<!DOCTYPE html>
<html lang="de">

<head>
	<title>Simons Basic – Eine notwendige Erweiterung für den Commodore 64 – Teil 1</title>
	<meta charset="UTF-8">
	<link rel="stylesheet" href="../style.css">
	<meta name="author" content="Hans Lorenz Schneider">
	<meta name="64er.issue" content="4/84">
	<meta name="64er.pages" content="40-44">
	<meta name="64er.head1" content="Software">
	<meta name="64er.toc_title" content="Simons Basic macht das Programmieren leicht">
	<meta name="64er.toc_category" content="Software">
	<meta name="64er.index_title" content="Simons Basic (Teil 1)">
	<meta name="64er.index_category" content="Software-Test|Erweiterung">
	<meta name="64er.id" content="simons_basic">
</head>

<body>
	<article>
		<h1>Simons Basic – Eine notwendige Erweiterung für den Commodore 64 – Teil 1</h1>

		<p class="intro">Erfahrene Commodore-Programmierer werden mir sicherlich zustimmen: Die ausgezeichneten Commodore-Editiermöglichkeiten verhalten sich für den Programmierer umgekehrt proportional zu den Basic-Versionen. Dies ist auch bei dem Commodore 64 nicht anders. Obwohl der C 64 über eine hochauflösende Grafik verfügt, bietet das Standard-Basic hier keine Unterstützung. Für häufige Programmierarbeiten sind Basic-Erweiterungen — insbesondere für den Grafikteil und die Sprites — eine notwendige Hilfe. Eine solche Erweiterung ist Simons Basic für den Commodore 64.</p>

		<p>Simons Basic bietet sehr viele wichtige Befehle. Bild 1 zeigt eine Übersicht über alle Befehle und eine Kurzbeschreibung ihrer Bedeutung. Diese Übersicht kann auch als Handzettel für diejenigen dienen, die schon mit Simons Basic arbeiten.</p>

		<p>Simons Basic enthält viele dringend notwendige Befehle, aber auch Befehle, die wohl nur in sehr seltenen Fällen benutzt werden. Auf jeden Fall ist Simons Basic für den geübten Programmierer eine wertvolle Unterstützung. Besonders hervorzuheben sind hier die Befehle, die in Bild 1 unter Programmierhilfen zusammengestellt sind, die in dieser oder ähnlicher Form auch schon von anderen Programmier-Kits her bekannt sein dürften. Weiterhin einige Befehle zur Verarbeitung von Zeichenreihen wie zum Beispiel INST. Für Programmierer, die auch andere Programmiersprachen wie PL/1 oder Pascal kennen, dürften besonders die neuen Strukturbefehle und die ERROR-Befehle interessant sein.</p>

		<figure>
			<table>
				<tbody>
					<tr>
						<th colspan="2" class="separator">Programmierhilfen</th>
					</tr>
					<tr>
						<td>AUTO</td>
						<td>Zeilennummernvergabe bei Programmeditierung</td>
					</tr>
					<tr>
						<td>COLD</td>
						<td>Kaltstart, ersetzt aus-/einschalten</td>
					</tr>
					<tr>
						<td>DELAY</td>
						<td>Listgeschwindigkeit einstellen</td>
					</tr>
					<tr>
						<td>DISAPA</td>
						<td>Anweisung schützen</td>
					</tr>
					<tr>
						<td>DISPLAY</td>
						<td>Belegung der Funktionstasten anzeigen</td>
					</tr>
					<tr>
						<td>DUMP</td>
						<td>Variablen mit Werten anzeigen</td>
					</tr>
					<tr>
						<td>FIND</td>
						<td>Basic-Befehle oder Zeichenreihen im Programm suchen</td>
					</tr>
					<tr>
						<td>KEY</td>
						<td>Funktionstasten mit Basicbefehl belegen</td>
					</tr>
					<tr>
						<td>MERGE</td>
						<td>anderes Programm in bestehendes einkopieren</td>
					</tr>
					<tr>
						<td>OLD</td>
						<td>NEW-Befehl aufheben</td>
					</tr>
					<tr>
						<td>OPTION</td>
						<td>Simons Basicbefehle hervorheben</td>
					</tr>
					<tr>
						<td>PAGE</td>
						<td>seitenweise Listenausgabe</td>
					</tr>
					<tr>
						<td>RENUMBER</td>
						<td>Zeilen umnumerieren (ohne Zeilenangaben bei GOTO und GOSUB)</td>
					</tr>
					<tr>
						<td>SECURE</td>
						<td>Programmzeile schützen</td>
					</tr>
					<tr>
						<td>TRACE/RETRACE</td>
						<td>aktuelle Zeilennummer, die im Programm durchlaufen wird, anzeigen und wieder aufheben</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Struktur-Befehle und ERROR-Befehle</th>
					</tr>
					<tr>
						<td>CALL</td>
						<td>Sprung zu einer mit PROC definierten Routine (ähnlich GOTO)</td>
					</tr>
					<tr>
						<td>END PROC</td>
						<td>Ende einer Routine, ähnlich RETURN</td>
					</tr>
					<tr>
						<td>EXEC</td>
						<td>Unterprogrammaufruf für Routinen die mit PROC und END PROC definiert wurden</td>
					</tr>
					<tr>
						<td>GLOBAL</td>
						<td>ursprünglichen Variablenwert wieder zuweisen</td>
					</tr>
					<tr>
						<td>IF...THEN...ELSE</td>
						<td>Bedingte Anweisung mit doppelter Anwendungsmöglichkeit</td>
					</tr>
					<tr>
						<td>LOCAL</td>
						<td>Block bedingte Variablen</td>
					</tr>
					<tr>
						<td>LOOP...EXIT IF...END LOOP</td>
						<td>Schleifendurchlauf mit bedingtem Abbruch</td>
					</tr>
					<tr>
						<td>NO ERROR</td>
						<td>Fehlermeldung unterdrücken</td>
					</tr>
					<tr>
						<td>ON ERROR</td>
						<td>Sprungverteile für Fehlermeldungen</td>
					</tr>
					<tr>
						<td>PROC</td>
						<td>Sprungadresse (symbolisch)</td>
					</tr>
					<tr>
						<td>RCOMP...ELSE</td>
						<td>Bedingte Anweisung, wobei die Bedingung von der letzten IF-Abfrage übernommen wird</td>
					</tr>
					<tr>
						<td>REPEAT...UNTIL</td>
						<td>ähnlich FOR...NEXT für bedingte Schleifen</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Grafik-Befehle</th>
					</tr>
					<tr>
						<td>ANGL</td>
						<td>Radius zeichnen</td>
					</tr>
					<tr>
						<td>ARC</td>
						<td>Segment zeichnen</td>
					</tr>
					<tr>
						<td>BLOCK</td>
						<td>farbig ausgefülltes Rechteck ausgeben</td>
					</tr>
					<tr>
						<td>CHAR</td>
						<td>Zeichen in Grafik-Bildschirm</td>
					</tr>
					<tr>
						<td>CIRCLE</td>
						<td>Ellipse (Sonderfall: Kreis) ausgeben</td>
					</tr>
					<tr>
						<td>CSET</td>
						<td>Zeichensatz umschalten</td>
					</tr>
					<tr>
						<td>DRAW</td>
						<td>Figur zeichnen</td>
					</tr>
					<tr>
						<td>HICOL</td>
						<td>Nach LOW COL zum zurücksetzen auf die drei Farben, die mit MULTI definiert werden</td>
					</tr>
					<tr>
						<td>HIRES</td>
						<td>hochauflösende Grafik (mit Wahl der Vordergrund- und Hintergrundfarbe) einschalten</td>
					</tr>
					<tr>
						<td>LINE</td>
						<td>Linie zeichnen</td>
					</tr>
					<tr>
						<td>LOW COL</td>
						<td>drei weitere Farben zum Multi-Color-Modus zuschalten</td>
					</tr>
					<tr>
						<td>MULTI</td>
						<td>Multi-Color-Modus mit drei Zeichenfarben bestimmen</td>
					</tr>
					<tr>
						<td>PAUTT</td>
						<td>Fläche mit Farbe füllen</td>
					</tr>
					<tr>
						<td>PLOT</td>
						<td>Punkt ausgeben</td>
					</tr>
					<tr>
						<td>REC</td>
						<td>Rechteck zeichnen</td>
					</tr>
					<tr>
						<td>ROT</td>
						<td>Figur drehen</td>
					</tr>
					<tr>
						<td>TEST</td>
						<td>Punkt vorhanden?</td>
					</tr>
					<tr>
						<td>TEXT</td>
						<td>Text in Grafik-Bildschirm</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Sprite-Befehle</th>
					</tr>
					<tr>
						<td>(KLAMMERAFFE)</td>
						<td>Form eines Sprites definieren</td>
					</tr>
					<tr>
						<td>CHECK</td>
						<td>Kollision abfragen</td>
					</tr>
					<tr>
						<td>CMOB</td>
						<td>Farben für Multi-Color-Sprite festlegen</td>
					</tr>
					<tr>
						<td>DESIGN</td>
						<td>Speicherzuteilung für Sprite</td>
					</tr>
					<tr>
						<td>DETECT</td>
						<td>Kollision vorbereiten</td>
					</tr>
					<tr>
						<td>MMOB</td>
						<td>Sprite darstellen oder bewegen</td>
					</tr>
					<tr>
						<td>MOB OFF</td>
						<td>Sprite ausschalten</td>
					</tr>
					<tr>
						<td>MOB SET</td>
						<td>Eigenschaften eines Sprite festlegen</td>
					</tr>
					<tr>
						<td>RLOCMOB</td>
						<td>Sprite bewegen</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Musik-Befehle</th>
					</tr>
					<tr>
						<td>ENVELOPE</td>
						<td>Hüllkurve einstellen</td>
					</tr>
					<tr>
						<td>MUSIC</td>
						<td>Noten festlegen</td>
					</tr>
					<tr>
						<td>PLAY</td>
						<td>Musikwiedergabe</td>
					</tr>
					<tr>
						<td>VOL</td>
						<td>Lautstärke einstellen</td>
					</tr>
					<tr>
						<td>WAVE</td>
						<td>Wellenform einstellen</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Befehle für Zeichenreihen</th>
					</tr>
					<tr>
						<td>AT</td>
						<td>Zeichenreihe auf Bildschirm positionieren</td>
					</tr>
					<tr>
						<td>CENTRE</td>
						<td>Ausgabe einer Zeichenreihe in der Mitte einer Bildschirmzeile</td>
					</tr>
					<tr>
						<td>CHAR</td>
						<td>Zeichen in Grafik-Bildschirm</td>
					</tr>
					<tr>
						<td>DUP</td>
						<td>Zeichenreihe vervielfachen</td>
					</tr>
					<tr>
						<td>INSERT</td>
						<td>Zeichenreihe in andere einfügen</td>
					</tr>
					<tr>
						<td>INST</td>
						<td>Zeichenreihe mit einer anderen überschreiben</td>
					</tr>
					<tr>
						<td>PLACE</td>
						<td>Zeichenreihe in Zeichenreihe suchen</td>
					</tr>
					<tr>
						<td>TEXT</td>
						<td>Text in Grafik-Bildschirm</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Befehl für Zahlen</th>
					</tr>
					<tr>
						<td>$</td>
						<td>Umwandlung Hexadezimal in Dezimal</td>
					</tr>
					<tr>
						<td>%</td>
						<td>Umwandlung Binär in Dezimal</td>
					</tr>
					<tr>
						<td>DIV</td>
						<td>Division ohne Rest</td>
					</tr>
					<tr>
						<td>EXOR</td>
						<td>bitweise Verknüpfung von Zahlen mit EXKLUSIV ODER</td>
					</tr>
					<tr>
						<td>FRAC</td>
						<td>Nachkommastellen einer Dezimalzahl</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Bildschirmsteuerung</th>
					</tr>
					<tr>
						<td>BFLASH</td>
						<td>Farbwechsel Bildschirmrahmen einschalten</td>
					</tr>
					<tr>
						<td>BFLASH O</td>
						<td>Farbwechsel Bildschirmrahmen ausschalten</td>
					</tr>
					<tr>
						<td>COPY</td>
						<td>Hardcopy einer hochauflösenden Grafik</td>
					</tr>
					<tr>
						<td>DOWN</td>
						<td>Bildschirmbereich nach unten rollen</td>
					</tr>
					<tr>
						<td>FCHR</td>
						<td>Bildschirmbereich mit Zeichen füllen</td>
					</tr>
					<tr>
						<td>FCOL</td>
						<td>Zeichenfarbe in Bildschirmbereich bestimmen</td>
					</tr>
					<tr>
						<td>FLASH</td>
						<td>Blinken einer Bildschirmfarbe einschalten</td>
					</tr>
					<tr>
						<td>FILL</td>
						<td>Bildschirmbereich mit Farbe und Zeichen füllen</td>
					</tr>
					<tr>
						<td>HRDCPY</td>
						<td>Hardcopy eines normalen Bildschirmes</td>
					</tr>
					<tr>
						<td>INV</td>
						<td>Bildschirmbereich invertieren</td>
					</tr>
					<tr>
						<td>LEFT</td>
						<td>Bildschirmbereich nach links rollen</td>
					</tr>
					<tr>
						<td>MOVE</td>
						<td>Bildschirmbereich duplizieren</td>
					</tr>
					<tr>
						<td>OFF</td>
						<td>Blinken einer Bildschirmfarbe ausschalten</td>
					</tr>
					<tr>
						<td>RIGHT</td>
						<td>Bildschirmbereich nach rechts rollen</td>
					</tr>
					<tr>
						<td>SCRLD</td>
						<td>Bildschirm (der mit SCRSV gespeichert wurde) laden</td>
					</tr>
					<tr>
						<td>SCRSV</td>
						<td>Bildschirm (Normal-Modus) speichern</td>
					</tr>
					<tr>
						<td>UP</td>
						<td>Bildschirmbereich nach oben rollen</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Befehle für Light-Pen, Joystick und Paddle</th>
					</tr>
					<tr>
						<td>JOY</td>
						<td>Funktion des Joystick bestimmen</td>
					</tr>
					<tr>
						<td>PENX</td>
						<td>X-Koordinate des Light-Pen</td>
					</tr>
					<tr>
						<td>PENY</td>
						<td>Y-Koordinate des Light-Pen</td>
					</tr>
					<tr>
						<td>POT</td>
						<td>Widerstand Paddle feststellen (Potentiometer)</td>
					</tr>
					<tr>
						<th colspan="2" class="separator">Sonstige Befehle</th>
					</tr>
					<tr>
						<td>(KLAMMERAFFE)</td>
						<td>neues Zeichen definieren</td>
					</tr>
					<tr>
						<td>DESIGN</td>
						<td>neu zu erstellendes Zeichen festlegen</td>
					</tr>
					<tr>
						<td>DIR</td>
						<td>Inhaltsverzeichnis einer Diskette ganz oder teilweise (Jokerzeichen) anzeigen</td>
					</tr>
					<tr>
						<td>DISC</td>
						<td>Diskbefehl ausführen</td>
					</tr>
					<tr>
						<td>FETCH</td>
						<td>Kontrollierte Eingabe</td>
					</tr>
					<tr>
						<td>INKEY</td>
						<td>Abfrage auf gedrückte Funktionstaste</td>
					</tr>
					<tr>
						<td>LIN</td>
						<td>aktuelle Zeile des Cursors anzeigen</td>
					</tr>
					<tr>
						<td>MEM</td>
						<td>Zeichensatz von ROM-Bereich in RAM-Bereich verlegen</td>
					</tr>
					<tr>
						<td>PAUSE</td>
						<td>Pause im Programm (ersetzt »leere« FOR...NEXT-Schleife)</td>
					</tr>
					<tr>
						<td>RESET</td>
						<td>Zeiger auf beliebige DATA-Zeile setzen</td>
					</tr>
				</tbody>
			</table>
			<figcaption>Bild 1. Diese Befehle bietet Simons Basic</figcaption>
		</figure>

		<p>Um die speziellen Möglichkeiten des Commodore 64 wie die hochauflösende Grafik, die Definition von Sprites und den Sound-Generator zu benutzen, sind natürlich die entsprechenden Befehle notwendige Voraussetzung, wenn Programmieren nicht in Byte-Fummelei ausarten soll.</p>

		<p>Zu den Befehlen, die wohl nur dann angewendet werden, wenn ein Programmierer auch alle Register des Computer sehen will, gehören neben einigen Befehlen aus den anderen Bereichen bestimmt auch alle Befehle der Bildschirmsteuerung.</p>

		<p>Alles in allem kann man jedoch sagen: Der zusätzliche Befehlsvorrat von Simons Basic läßt fast keine Wünsche offen.</p>

		<p>Gehen wir im folgenden kurz auf die verschiedenen Befehle und ihre Anwendungsmöglichkeiten ein:</p>

		<h2>Programmierhilfen</h2>

		<h3>AUTO</h3>

		<p>Dieser Befehl ist von anderen Kits bestimmt schon hinlänglich bekannt. Er ermöglicht die zeilenweise Programmeditierung, ohne jeweils eine neue Zeilennummer miteintippen zu müssen. Dies erspart hauptsächlich beim fließenden Eintippen eines Programms die Überlegung: Welches ist denn jetzt die nächste Zeile?</p>

		<h3>COLD</h3>

		<p>Dieser Befehl ersetzt das Ein- und Ausschalten des Computers, wenn ein Kaltstart durchgeführt werden soll. Intern werden im Computer immer Zeiger verwaltet, die auf den Anfang des Programms, den Anfang der Variablenbereiche und so weiter zeigen. Der Befehl COLD bewirkt nichts anderes als das Rücksetzen dieser Zeiger in den Ausgangszustand.</p>

		<h3>DELAY</h3>

		<p>Mit dem Befehl DELAY kann die Listgeschwindigkeit eingestellt werden. Daß hier 256 Möglichkeiten zur Verfügung stehen, ist mehr als ein Programmierer benötigt. Prinzipiell wird sich jeder aus den Möglichkeiten ein oder zwei Geschwindigkeiten aussuchen, die seiner Lesegeschwindigkeit am Bildschirm entsprechen.</p>

		<h3>DISAPA</h3>

		<p>In Verbindung mit dem Befehl SECURE ist der Befehl DISAPA ein hinreichend wirkungsvolles Mittel, um sein Programm gegen unbefugtes Auflisten zu schützen. Im Prinzip wäre es möglich, das gesamte Programm mit diesem Befehl zu schützen, jedoch macht man sich selbst die Arbeit der Softwarepflege damit nur schwieriger. Sinnvoll wäre es, diesen Befehl in einem kurzen Programmstück zu verwenden, welches einige andere Sicherungsmethoden enthält.</p>

		<h3>DISPLAY</h3>

		<p>Eine reine Informationsanweisung, die aber sehr wichtig ist, da es sonst sehr schwierig wäre, die aktuelle Belegung der Funktionstasten festzustellen.</p>

		<h3>DUMP</h3>

		<p>Der Vorteil eines Interpreters liegt zu einem großen Teil darin, daß während eines Programmlaufes das Programm abgebrochen werden kann und die Variablen abgefragt werden können. Dies erleichtert das Austesten erheblich gegenüber Compilerversionen. Nun ist es recht mühsam, immer nach einem BREAK im Programm einen PRINT-Befehl für alle — oder auch nur die benötigten — Variablen einzugeben, wenn mehrere sogenannte BREAK-POINTS gesetzt sind. Diese Arbeit erleichtert der DUMP-Befehl.</p>

		<h3>FIND</h3>

		<p>Ähnlich dem DUMP-Befehl erleichtert der FIND-Befehl das Testen sowie das Dokumentieren von Programmen. Besonders bei langen Listings ist es sehr mühsam, das gesamte Programm nach einer bestimmten Variablen zu durchsuchen. Da in Basic auch im Prinzip alle Variablen global sind, dürften — außer temporären Variablen — den Variablen nicht mehrfache Bedeutungen zugewiesen werden. Mit dem FIND-Befehl ist es unter anderem möglich zu prüfen, ob eine Variable schon im Programm vorhanden ist oder nicht.</p>

		<h3>KEY</h3>

		<p>Da der Commodore 64 Funktionstasten anbietet, ist es auch sinnvoll, diese mit häufig verwendeten Basic-Befehlen (zum Beispiel LIST) zu belegen.</p>

		<h3>MERGE</h3>

		<p>Der MERGE-Befehl ermöglicht zwar das Einkopieren von anderen Programmen in ein Programm, das sich im Hauptspeicher befindet, jedoch läßt dieser Befehl einige Möglichkeiten vermissen. Zum Beispiel ist das Laden von bestimmten Programmteilen eines Programms von Diskette nicht möglich. Dies ist besonders dann ein Nachteil, wenn aus anderen Programmen nur bestimmte Unterprogramme übernommen werden sollen.</p>

		<h3>OLD</h3>

		<p>Ab und zu kann es vorkommen, daß versehentlich ein NEW-Befehl eingegeben wurde, und man feststellt, daß das Programm vorher nicht abgespeichert war beziehungsweise die Kontrollampe an dem Floppy Disk-Laufwerk blinkt. Da durch den NEW-Befehl nur Zeiger intern umbesetzt werden, ist eigentlich noch nicht alles verloren. Aber es ist doch sehr mühsam, das Programmende des Programms und die Werte für den Beginn der Variablentabelle und so weiter ausfindig zu machen. Dies erspart einem der OLD-Befehl.</p>

		<h3>OPTION</h3>

		<p>Eine Anwendungsmöglichkeit für diesen Befehl, der alle Befehle von Simons-Basic hervorhebt, ist direkt nicht ersichtlich. Nützlich ist er vielleicht, wenn ein Programm in normales Basic umgeschrieben werden soll. Aber wenn jemand ein Programm, das mit Simons Basic erstellt wurde, erhält, und dies umschreiben will, weil ihm die Programmierunterstützung nicht zur Verfügung steht, der könnte diesen Befehl gebrauchen. Aber der hat ja kein Simons Basic. Und wer gibt schon seine Programme weiter mit einer Liste: Hier sind die Befehle, die geändert werden müssen?</p>

		<h3>PAGE</h3>

		<p>Da der Bildschirm des Commodore 64 nur 40 Zeichen je Zeile hat und das Auslisten der Programme sehr schnell geht, verschwinden Programmstücke nach oben aus dem Bildschirm heraus schneller, als man eventuell die STOP-Taste gefunden hat. Dies kann man einerseits mit der Benutzung der CTRL-Taste beeinflussen, andererseits mit dem weiter vorn beschriebenen DELAY-Befehl. Komfortabel ist es natürlich, wenn man vor Beginn einer jeden Programmiersitzung den Befehl Page verwendet, womit ein seitenweises Blättern in Vorwärtsrichtung erzielt werden kann.</p>

		<h3>RENUMBER</h3>

		<p>Wo fast jedes auf dem Commodore 64 erstelltes Programm dynamisch wächst, wird mal hier eine Zeile eingefügt, mal wird dort eine Zeile herausgenommen. Um dieses ganze Zeilennummern-Wirrwarr in den Griff zu bekommen ist natürlich der RENUMBER-Befehl sehr nützlich. Leider wirkt sich der RENUM-BER-Befehl nicht auf solche Zeilennummern aus, die hinter GOTO und GOSUB stehen. In mühsamer Kleinarbeit artet es dann aus, wenn Sie anschließend alle Sprungadressen bei GOTO/GOSUB-Befehl von Hand ändern müssen.</p>

		<h3>SECURE</h3>

		<p>Dieser Befehl bewirkt nur das eigentliche Schützen, der durch den Befehl DISAPA gekennzeichneten Befehle.</p>

		<h3>TRACE/RETRACE</h3>

		<p>Zum Testen von Programmen — besonders bei sogenannten Endlos-Schleifen — leistet der TRACE-Befehl, mit dem die aktuelle Zeilennummer eines laufenden Programmes angezeigt wird, sehr nützliche Hilfe.</p>

		<h2>Strukturbefehle und ERROR-Befehle</h2>

		<p>Diese Befehle lassen sich als Einzelbefehle nicht ausreichend erklären, da sie eine gewisse Blockstruktur voraussetzen, so daß wir diese im Zusammenhang besprechen wollen.</p>

		<h3>Schleifen/bedingte Schleifen/bedingte Anweisungen</h3>

		<p>Der erste Bereich der Strukturbefehle widmet sich den Schleifen und bedingten Anweisungen. Da das normale Basic nur IF..THEN-Befehle zuläßt, ist es eine wesentliche Vereinfachung, wenn diese Befehle auch einen ELSE-Teil erhalten. Dadurch können aufwendige Konstruktionen mit GOTO-Befehl vermieden werden, wie Bild 2 zeigt. Bild 3 zeigt die Bedingungen bei einem IF-Statement, die sehr komplex sein können, so daß es sinnvoll ist, diese Bedingung in einem weiteren Befehl ohne erneute Eingabe wieder prüfen zu können. Dies kann mit dem Befehl RCOMP...ELSE, da nicht wie in anderen Programmiersprachen eine blockweise Bearbeitung in verschiedenen Zeilen der THEN-/ELSE-Teile erfolgen kann, substituiert werden.</p>

		<figure>
			<pre>
100 REM OHNE IF...THEN...ELSE
110 IF A=B THEN C=D : GOTO 130
120 E=F
130 REM FORTSETZUNG
140 :
150 :
160 :
170 REM MIT IF...THEN...ELSE
180 IF A=B THEN C=D ELSE E=F
190 REM FORTSETZUNG
			</pre>
			<figcaption>Bild 2. Ein Beispiel für IF...THEN...ELSE</figcaption>
		</figure>
		<figure>
			<pre>
90 REM OHNE RCOMP...ELSE
100 IF A=B AND X=Y OR F&lt;G AND H&gt;J AND NOT Y=R THEN PRINT "SEHR LANGER TEXT";
110 IF A=B AND X=Y OR F&lt;G AND H&gt;J AND NOT Y=R THEN PRINT "DER NICHT IN EINE";
120 IF A=B AND X=Y OR F&lt;G AND H&gt;J AND NOT Y=R THEN PRINT "ZEILE PASST. !!!!";
130 IF A=B AND X=Y OR F&lt;G AND H&gt;J AND NOT Y=R THEN GOTO 150
140 PRINT"NOCH EIN TEXT"
150 REM FORTSETZUNG
160 :
170 :
180 :
190 REM MIT RCOMP...ELSE
200 IF A=B AND X=Y OR F&lt;G AND H&gt;J AND NOT Y=R THEN PRINT "SEHR LANGER TEXT";
210 RCOMP PRINT"DER NICHT IN EINE ZEILE PASST !!!!!" ELSE PRINT"NOCH EIN TEXT
220 REM FORTSETZUNG
			</pre>
			<figcaption>Bild 3. Beispiel für RCOMP...ELSE</figcaption>
		</figure>

		<p>Eine weitere Verbesserung ist die Programmierung von Schleifen mit Bedingungsteilen. Das Beispiel im Handbuch ist relativ ungünstig gewählt, da dieses Beispiel durch eine einfache FOR...NEXT-Schleife ersetzt werden kann. Bild 4 zeigt einen sinnvollen Einsatz für den Befehl REPEAT...UNTIL. Dabei wird die Schleife abgebrochen, wenn eine Bedingung erfüllt ist, die nicht in einer FOR...NEXT-Schleife einprogrammiert werden kann. Sicherlich ist es auch bei einfachen FOR......NEXT-Schleifen möglich, diese Schleifen mit einer IF-Abfrage zu verlassen, jedoch wird das Programm durch die neuen Befehle viel übersichtlicher. Ähnliches leistet auch der Befehl LOOP...EXIT IF...END LOOP.</p>

		<figure>
			<pre>
100 REM VERGLEICH ZWEIER ZAHLEN ALS ABBRUCHKRITERIUM
110 REPEAT
120 ZN = ZA / 3
130 UNTIL ABS(ZN-ZA) &lt;0.0000001
			</pre>
			<figcaption>Bild 4. So wird REPEAT...UNTIL eingesetzt.</figcaption>
		</figure>

		<h3>Prozeduren</h3>

		<p>Sehr schön handhaben läßt sich die Verwendung von Unterprogrammen als Prozeduren mit Simons Basic. Wie in blockorientierten Sprachen existiert auch ein Befehl PROC, der praktisch die Marke eines Unterprogrammes ist. Das Unterprogramm (in diesem Fall spricht man von Prozedur) wird auch nicht mit RETURN beendet, sondern mit END PROC. Der Aufruf kann mit CALL oder mit EXEC erfolgen, wobei CALL einem GO-TO entspricht (eine unübliche Art des Aufrufs einer Prozedur, da Prozeduren normal unabhängig von ihrer Lage im Programm ausgeführt werden) und EXEC einem GOSUB.</p>

		<p>Wenn auch keine Blockvariablen im ursprünglichen Sinne zugelassen sind, kann man jedoch mit dem Befehl LOCAL Variableninhalte retten und später mit dem Befehl GLOBAL wieder auf diese Werte zurückgreifen. Dies erleichtert insbesondere die Programmierung großer komplexer Programme mit vielen Prozeduren.</p>

		<h3>Fehlerbehandlung</h3>

		<p>Die beiden Befehle ON ERROR und NO ERROR erlauben eine relativ komfortable Fehlerbehandlung. Die normale Fehlerbehandlung (Programmabbruch mit Anzeige des Fehlers) ist in den meisten Fällen nicht sehr benutzerfreundlich, da die Fehler per Programm abgefangen und durch eine entsprechende Benutzermitteilung eventuell auch behoben werden könnten. Mit dem Befehl ON ERROR ist eine solche komfortable Fehlerbehandlung in Abhängigkeit des aufgetretenen Fehlers (Liste im Handbuch enthalten) möglich. Lediglich eine Unterdrückung der Fehlermeldungen ist durch den Befehl NO ERROR möglich.</p>

		<p>In der nächsten Ausgabe werden wir uns mit den Grafik-, Sprite- und Musik-Befehlen von Simons Basic sowie mit den Befehlen für Zeichenreihen, Zahlen, Light-Pen, Joystick, Paddle und der Bildschirmsteuerung beschäftigen.</p>

		<address class="author">(H.L. Schneider)</address>

	</article>

</body>

</html>
