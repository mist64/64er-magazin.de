<!DOCTYPE html>
<html lang="de">

<head>
    <title>80-Zeichen-Grafik für den C 128</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Thomas Rumbach, Dieter Winkler, ev">
    <meta name="64er.issue" content="12/85">
    <meta name="64er.pages" content="78-82">
    <meta name="64er.head1" content="Grafik">
    <meta name="64er.head2" content="128er">
    <meta name="64er.toc_title" content="<b>Super-Grafik für C128: Basic-Befehle für doppelte Auflösung</b>">
    <meta name="64er.toc_category" content="Listings zum Abtippen">
    <meta name="64er.index_title" content="80-Zeichen-Grafik für den C 128">
    <meta name="64er.index_category" content="Listings zum Abtippen|Tips & Tricks">
    <meta name="64er.id" content="80_zeichen">
</head>

<body>
    <article>
        <h1>80-Zeichen-Grafik für den C 128</h1>
        <p class="intro">Auf dieses Grafikpaket für eine 640 x 200 Punkte-Auflösung auf dem 80‑Zeichen‑Bildschirm haben C 128-Besitzer gewartet! Alle Grafikbefehle des Basic 7.0 stehen damit für den neuen Modus zur Verfügung.</p>

        <p>Der neue Basic-Interpreter des Commodore 128 enthält 26 Befehle, mit deren Hilfe man einfach und schnell auch komplizierte Grafik-Programme erstellen kann. Leider unterstützen diese Befehle nur die Programmierung des VIC-Chips mit der schon vom C 64 her bekannten Auflösung. Der zusätzlich eingebaute 80-Zeichen-Chip »VDC« wird nur zum Aufbau eines 80-Zeichen-Text-Bildschirms genutzt. Wer auch diesen Bildschirm für grafische Darstellungen nutzen will, der muß seine eigenen Routinen schreiben. Doch gibt es — wie der vorliegende Artikel zeigt — eine recht einfache Lösung für dieses Problem. Das abgedruckte Basic-Programm (Listing 1) baut ein Maschinenprogramm für den »User-RAM-Bereich« von $1300 bis $1bff auf. Nach dem Initialisieren dieses Maschinenprogramms mit »SYS DEC (”1303”)« stehen die Befehle GRAPHIC, BOX, CIRCLE, DRAW und PAINT auch für den VDC-Chip zur Verfügung. Die Befehle LOCATE, SCALE und SCNCLR und die Funktionen RCLR, RDOT und RGT können ohne Einschränkung im 640 x 200-Grafik-Modus benutzt wer-den. Beide Bildschirme können gleichzeitig im HiRes-Modus arbeiten, beim Aufruf eines Grafikbefehls prüft der Interpreter selbständig, welcher Video-Chip gerade angesprochen ist.</p>

        <h3>So programmiert man den VDC</h3>

        <p>Der 8563-Video-Chip ist ein erweiterter »Abkömmling« des viel verwendeten 6845-CTR-Controllers. Er verfügt (im C 128) über einen 16 KByte Bildschirmspeicher und ist nur über zwei Register unter den Adressen 54784 ($d600) und 54785 ($d601) mit den anderen Bausteinen des Computers verbunden. Alle Register und der gesamte Video-RAM-Bereich müssen über diese beiden Adressen angesprochen werden. Das »Einblenden« des Video-RAMs in den Adreßbereich der CPU ist nicht vorgesehen. Will man einen Wert in eines der 36 Register des 8563 übertragen, so muß man zunächst die Nummer des anzusprechenden Registers in die Speicherstelle 54784 und dann den zu übertragenden Wert in die Speicherstelle 54785 schreiben. Genauso geht es beim Lesen eines Registerinhaltes: »POKE 54784, Registernummer: PRINT PEEK (54785):REM Registerinhalt«.</p>

        <h3>Die HiRes-Grafikregister</h3>

        <p>Für die Grafikprogrammierung sind von den 36 Registern des VDC vor allem die Register 18, 19, 31, 25 und 26 interessant. Der Inhalt von Register 26 bestimmt (im Grafik-Modus!) Vorder- und Hintergrundfarbe. Über Bit 0 bis 3 kann man 16 verschiedene Hintergrundfarben, über Bit 4 bis 7 16 verschiedene Vordergrundfarben anwählen. Ein Beispiel: die Befehlsfolge »POKE 54784,26: POKE 54785, (3*16+2)« bewirkt, daß im HiRes-Modus eine rote Zeichenfarbe auf weißem</p>

        <p>Grund erscheint. Im Textmodus wird mit diesem Befehl nur die Hintergrundfarbe verändert. Register 25 ist ein mehrfach belegtes Register. Über die Bits 0 bis 3 kann man den Bildschirm um maximal 16 Pixel horizontal nach links verschieben. Mit Bit 4 kann man zwischen einfacher (0) und doppelter (1) Pixelgröße wählen. Mit den Bits 5 bis 7 kann man zwischen den drei Betriebsarten Text (Bit 6=1), Semigrafik (Bit 5=1) und Grafik (Bit 7 = 1) wählen. Für uns ist hier nur interessant, daß man durch Beschreiben von Register 25 mit dem Wert 128 den HiRes-Modus wählen und durch Beschreiben des Registers mit dem Wert 64 wieder in den Text-Modus zurückkehren kann. Alle anderen Bits sind standardmäßig mit Null besetzt.</p>

        <h3>Organisation des Grafik-Bildschirms</h3>

        <p>Fürjedes Pixel (Grafikpunkt) wird ein Bit benötigt. Das macht acht Pixel pro Byte oder 80 Bytes für eine waagrechte Bildzeile bei einer horizontalen Auflösung von 640 Pixel. In vertikaler Richtung erreicht der VDC 200 Zeilen Auflösung, das heißt insgesamt werden 80 x 200 = 16 000 Byte-Video-RAM von einem Bild belegt. Ein Farb-RAM ist nicht vorgesehen. Der VDC kann hochauflösende Grafik nur in einer einzigen Farbe darstellen, ein entscheidender Nachteil des VDC gegenüber dem VIC. Auch in der Adressierung der einzelnen Pixel unterscheiden sich VDC und VIC. Ein Byte beim VDC beschreibt acht nebenanderliegene Pixel, während ein Byte beim VIC acht untereinanderliegende Pixel kontrolliert. Anders ausgedrückt: Das Pixel mit den Koordinaten 7,0 wird von Bit 0 (!) der ersten Bildschirmspeicherstelle repräsentiert, das Pixel 0,7 von der (7 x 80=) 560sten Speicherstelle. Daraus ergibt sich die folgende Formel zur Berechnung der Bildschirmspeicheradresse für ein gegebenes Koordinatenpaar X,Y:<br>
            ADR= Yx80 + INT (X/8)<br>
            Und zur Berechnung des Bitwertes innerhalb dieser Speicherstelle erhält man (genauso wie beim VIC):<br>
            BIT= 2↑ (7-(»LOW-Byte von x«AND7))<br>
            Eine Routine »Punkt setzen« könnte man dann formulieren als:<br>
            ADR = (»Inhalt von ADR«) OR BIT</p>

        <h3>Komfortable Zeichenbefehle</h3>

        <p>Bis hierhin wurde recht ausführlich besprochen, wie man den Grafikschirm einschaltet und Punkte setzt. Nun wird sofort der Wunsch wach, Linien, Kreise oder andere Figuren zu zeichnen. Dazu sind schon recht anspruchsvolle Berechnungen nötig. Doch alle Rechenroutinen sind im Basic-ROM des C 128 enthalten. Allen Routinen ist gemeinsam, daß sie im Unterprogramm »Punkt setzen« münden. Die ROM-Routine dafür kann nur Punkte für den VIC-Bildschirm berechnen. Die oben beschriebene Routine bewirkt das gleiche für den VDC-Chip. Der Gedanke liegt nun nahe, in Routinen wie CIRCLE oder DRAW die Zeiger, die auf das Unterprogramm »Punkt setzen, löschen, testen« zeigen, auf das eigene »Punkt-setzen-Programm« zu »verbiegen«, das den VDC anspricht. Im ROM ist das zwar leider nicht möglich, und die meisten C 128-Benutzerwerden ihren neuen 128er nicht gleich mit neuen EPROMs versehen wollen, aber es geht ja auch viel einfacher: Man kopiert einfach die entscheidenden Programmteile ins RAM, paßt die besagten Zeiger an und teilt zuletzt noch dem Interpreter mit, daß er fortan beim Aufruf der Grafik-Befehle die neuen Routinen »anspringen« soll, wenn der 80-Zeichen-Bildschirm eingeschaltet ist. Die Lösung dieser Aufgabe ist das abgedruckte Basic-Programm (Listing 1). Es stellt alle Programmteile zusammen, die benötigt werden, um die Befehle GRAPHIC, BOX, CIRCLE, DRAW und PAINTauch für den VDC wirksam werden zu lassen. Alle Befehle für den 640 x 200-Punkte-Bildschirm sind nur im Programm-Modus ausführbar. Das ist deshalb so eingerichtet, weil der 80-Zeichen-Bildschirm im HiRes-Modus zwangsläufig zerstört wird (siehe oben). Die Befehle könnten im Direkt-Modus also gar nicht vom Bildschirm geholt und interpretiert werden. Man erhielte lediglich »Dreckflecken« auf dem HiRes-Bild. Probieren Sie einfach einmal im Direktmodus die Befehlsfolge »POKE 54784,25:POKE 54785,128« aus! Man kann sehr viel über die Funktionsweise des VDC im Textmodus lernen. RUN/STOP-RESTORE rückt die Register wieder zurecht.</p>

        <h3>Der neue GRAPHIC-Befehl</h3>

        <p>Der GRAPHIC-Befehl wurde um die Funktionen GRAPHIC 6,0 und GRAPHIC 6,1 erweitert. GRAPHIC 6 schaltet den 8563-HiRes-Modus ein. Folgt der »6« eine »1«, so wird der Bildschirm gelöscht, folgt eine »0« so bleibt der Bildschirm, wie er ist. Der Befehl GRAPHIC 6,1 ersetzt auch den in dieser Implementation nicht vorgesehenen Befehl SCNCLR 6.</p>

        <h3>Die Befehle BOX, CIRCLE, DRAW und PAINT</h3>

        <p>Diese Befehle funktionieren im 8563-Modus genauso wie es im Bedienungshandbuch für die VIC-Grafik beschrieben ist. Einzige Änderung: Die x-Koordinaten dürfen nun im Bereich von 0 bis 639 liegen. Auch die Implementierung dieser Befehle ist denkbar einfach: Nacheinander werden die Programmteile PAINT ($61a8 bis $62b6), BOX ($62b7 bis $6388), DRAW ($6797 bis $67d6) und CIRCLE ($668e bis $674c) in den RAM-Bereich ab $1672 kopiert (Basic-Programm Zeile 5 000 bis 5340). Darunter, in den RAM-Bereich, ab $1952 wird der Programmteil »Strecke zeichnen« aus ROM $9b30 bis $9c18 kopiert. Als nächstes werden die neuen Adressen für Unterprogrammaufrufe eingesetzt (WHILE-DO-Schleife). Es folgt schließlich der neue GRAPHIC-Befehl. Im Basic-Programm ist er in Form von DATA-Zeilen abgelegt. Ebenfalls in Form von DATA-Zeilen sind die schon besprochene Routine »setpoint« (RAM $1400 bis $1671) und die Erweiterung der Interpreterschleife im Basic-Text enthalten.</p>

        <h3>Die Interpreterschleife</h3>

        <p>Wie teilen wir dem Interpreter mit, daß er beim Aufruf der Grafikbefehle nun nicht mehr zu den ROM- sondern zu unseren neuen RAM-Routinen springen soll? Beim Starten eines Programms holt sich der Interpreter—genauso wie beim C 64 — die Adresse, die in den Speicherstellen $308 und $309 abgelegt ist. Er arbeitet dann das Programm ab, das bei dieser Adresse beginnt. Setzt man in die Speicherstelle $308/09 nun die Adresse des eigenen Programms ein, dann beginnt der Interpreter nach dem Starten eines Programms mit RUN seine Arbeit bei der neuen Adresse. Eben dieses »Verbiegen« des Interpretervektors bewirkt der Befehl SYS DEC (”1303”). Und noch eine wichtige Kleinigkeit enthält die Initialisierungsroutine: die ins RAM kopierten Programmteile enthalten zahlreiche Unterprogrammsprünge (JSR) in ROM-Routinen. Der Prozessor kann diese Sprünge nur richtig ausführen, wenn ihm der RAM-Speicherbereich, in dem unser Programm liegt, und die angesprochenen ROM-Adressen als ein zusammenhängender 64-KByte-Block erscheinen. Für die Zusammenstellung solcher gemeinsamer Bereiche ist die MMU zuständig (siehe Bedienungshandbuch Anhang B). Die Initialisierungsroutine sorgt dafür, daß die MMU im Bereich von $0 bis $1fff immer die RAMs einschaltet, auf der auch unser Programm liegt. Anders ausgedrückt: Auch wenn man über den BANK-Befehl die ROM-Bank 15 ausgewählt hat, nach dem Durchlaufen unserer Initialisierungsroutine liest die CPU die Adressen zwischen $0 und $1fff immer aus dem RAM-Bereich in Bank 0 aus. Und da taucht nun gleich eine neue Schwierigkeit auf. Wenn die CPU — egal welche Bank ausgewählt wurde — im Bereich von $0 bis $1fff nur Bytes aus Bank 0 erreicht, dann können auch die auf Bank 1 in eben diesem Bereich abgelegten Variablen nicht mehr gelesen werden. Und umgekehrt, beim Anlegen neuer Variablen, würde unser Programm in Bank 0 überschrieben, weil der Interpreter nicht wissen kann, daß er, obwohl er in Bank 1 schreiben will, in Wirklichkeit doch in Bank 0 schreibt. Deshalb muß der Anfang des Variablenspeicherbereichs auf $2000 gesetzt werden. Das bedeutet den Verlust von 7 KByte Variablenspeicherbereich (mit »?FRE(1)« überprüfbar!); aber anders geht es leider nicht, wenn man ständiges, zeitraubendes Umschalten zwischen den Speicherbänken vermeiden will. Doch nun zur eigentlichen Interpreterschleife. Zunächst wird ein Zeichen aus dem Basic-Text geholt und geprüft, ob es um ein Token der in Frage kommenden Grafikbefehle handelt. Ist das nicht der Fall, so fährt das Programm einfach in der alten Interpreterschleife im ROM fort. Ist ein Grafik-Token gefunden, so testet das Programm als nächstes, ob der VIC oder ob der VDC aktiviert ist. Ist der VIC aktiv, so legt sich das Program die dem Token entsprechende ROM-Adresse zurecht (selbstveränderlicher Code hinter dem JSR von »JSR $0000«), arbeitet die normale ROM-Routine ab und kehrt in die Interpreterschleife zurück. Ist der VDC aktiv, so werden die den neuen Befehlen entsprechenden RAM-Adressen geholt.</p>

        <p>Der aufmerksame Leser wird sich wohl schon gefragt haben, warum die Grafik-Routinen gerade in den Bereich ab $1300 »gequetscht« wurden. Ein Grund dafür wurde gerade schon genannt: Die Routinen enthalten sehr viele Sprünge in ROM-Unterprogramme, die es erforderlich machen, daß die gesamten 48 KByte ROM-I/O ab $4000 eingeblendet sind. Will man umständliche und vor allem zeitraubende Bank-Umschaltungen (JSRFAR im Kernal $ff6e) vermeiden, so muß man das Programm in den RAM-Bereich unterhalb von $4000 legen. Es soll jedoch möglich sein, auf beiden Grafik-Bildschirmen gleichzeitig zu arbeiten. Dann verbietet es sich auch noch, den Bereich von $1c00 bis $4000 zu benutzen, da dort der Farb- und der Bildschirmspeicher für die VIC-HiRes-Grafik angeordnet sind. Bleibt der einzige Bereich der freie RAM-Bereich von $1300 bis $1bff.</p>

        <h3>Das »Kochrezept«</h3>

        <p>Wer bis hier aufmerksam gelesen hat, wird gleichsam als Belohnung eine Menge interessanter Details zur Programmierung seines C 128 erfahren haben. Aberauch ungeduldige Leser sollten spätestens hier einhalten, es folgt die Bedienungsanleitung für das Programm »Graphik-80«:</p>

        <p>1) Tippen Sie das Basic-Programm »Graphik 80« (Listing 1) sorgfältig ein! Für diese Arbeit sollten Sie sich Zeit nehmen, damit Ihnen das »DATA-Grab« am Ende des Programms nicht zur Falle wird.<br>
            2) Speichern Sie das Basic-Programm auf Diskette. Wenn Sie später Änderungen am Grafik-Paket vornehmen wollen, brauchen Sie es wieder.<br>
            3) Starten Sie das Programm mit »RUN«! Das Diskettenlauf-werk(1541 oder 1570/1571) muß beim Startdes Programms eingeschaltet und mit einer Diskette versehen sein.<br>
            4) Wenn keine Fehlermeldungen aufgetreten sind, und Ihnen auch keine Fehler beim Abschreiben der DATA-Zeilen unterlaufen sind, dann befindet sich jetzt das fertige »Graphik-80«-Paket unter dem Namen »graphik-80.m« auf Diskette und fertig initialisiert im Speicher. Mit Hilfe des kleinen Testprogramms (Listing 2), das noch mit abgedruckt ist, können Sie leicht überprüfen, ob alles richtig gelaufen ist. Von jetzt ab brauchen Sie nur noch als erste (!) Programmzeile »bload”graphik-80.m":sys dec(”1303”)« einzugeben, und das Grafik-Paket steht zur Verfügung.</p>

        <p>Und nun viel Freude beim »Malen«! Vielleicht vermissen Sie den Befehl CHAR im Grafik-Paket. Er wird von den Verfassern dieses Artikels gerade zusammengebaut und soll in einer späteren Ausgabe der 64’er erscheinen. Die dem C 128 mitgelieferte CHAR-Routine ist wirklich etwas zu simpel. Es können nur 40 oder 80 Zeichen in 25 Zeilen dargestellt werden, genauso wie auf dem Textbildschirm. Die in Vorbereitung befindliche Routine kann hingegen Buchstaben aufjedem beliebigen Pixel beginnen lassen. Indizes wie H20 und Exponenten wie x2 sind dann kein Problem mehr. Auch senkrecht schreiben, etwa zum Beschriften von Koordinatenachsen, wird dann möglich sein. Und schließlich wird noch ein Hardcopy-Programm für Epson- und ähnliche Drucker geliefert, damitSie Ihre Bilder auch in Händen halten können.</p>

        <address class="author">(Thomas Rumbach/Dieter Winkler/ev)</address>
    </article>
</body>

</html>