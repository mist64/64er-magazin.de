<!DOCTYPE html>
<html lang="de">

<head>
    <title>Entdeckungsreise durch den C128</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Heimo Ponnath, ev">
    <meta name="64er.issue" content="12/85">
    <meta name="64er.pages" content="42-43">
    <meta name="64er.head1" content="Tips">
    <meta name="64er.head2" content="128er">
    <meta name="64er.toc_title" content="Tips und Tricks">
    <meta name="64er.toc_category" content="128er-Sonderteil">
    <meta name="64er.index_title" content="Entdeckungsreise durch den C 128">
    <meta name="64er.index_category" content="Kurse|C 128">
    <meta name="64er.id" content="entdeckungsreise">
</head>

<body>
    <article>
        <h1>Entdeckungsreise durch den C128</h1>
        <p class="intro">Ein frischgebackener C 128-Besitzer befindet sich in einer ähnlichen Situation wie Livingstone auf seiner Forschungsreise in Afrika. Dies ist ein erster Bericht von der Erforschung des unbekannten Kontinents C 128.</p>

        <p>Da steht er nun vor mir: Der neue von Commodore, der C 128. Als alter C 64-Hase bin ich höchst erfreut über den gewaltigen Basic-Wortschatz, der mir nun zur Verfügung steht. Langsam bekommen meine Basic-Programme die vielgelobte »Struktur« mit ELSE und BEGIN und DO etc. Allerdings bin ich vom C 64 allerhand Luxus schon gewohnt. Der Not gehorchend haben sich im Laufe der Zeit nämlich einige nette Erweiterungen angesammelt, die so zur Gewohnheit geworden sind, daß sie mir jetzt fehlen. Auch das feine Basic 7.0 hat seine Lücken!</p>

        <p>Als Assembler-Freak, dem nun sogar noch ein eingebauter Monitor zur Verfügung steht, machte ich mich also auf eine Forschungsreise durch die Firmware (integrierte Software im C 128) des Neuen. Das ist ein Weg durch »terra incognita«, denn noch hat niemand ein komplettes ROM-Listing veröffentlicht. Auch das umfangreiche Handbuch weist in der Liste der erweiterten Zeropage allerhand weiße Flecken auf.</p>

        <p>In unregelmäßiger Reihenfolge erhalten Sie Zwischenberichte von Entdeckungen, die diese Forschungsreise erbracht hat. Dies ist der erste davon.</p>

        <h3>Simulieren eines PRINT AT</h3>

        <p>Der neue SYS-Befehl im 128er-Modus erlaubt die Übergabe der Registerinhalte an aufgerufene Routinen:
            <code>SYS adresse,A,X,Y,S</code>
            Dabei ist
        </p>

        <p class="noindent">A = Akkumulator, X = X-Register, Y = Y-Register, S = Prozessorstatusregister</p>

        <p>An der Adresse 65520 in Bank 15 befindet sich eine Routine, die den Cursor an die Stelle setzt, die durch das X-Register (Zeile) und das Y-Register (Spalte) vorgegeben wird. Deshalb kann ein PRINT AT durch die Befehlssequenz simuliert werden: BANK15:SYS 65520,,Zeile,Spalte:PRINT A$</p>

        <p>A$ wird beispielsweise in die 10. Zeile ab der fünften Spalte gedruckt, wenn man schreibt:
            <code>BANK15:SYS 65520,,10,5:PRINT A$</code>
        </p>

        <h3>Welche Bank haben wir?</h3>

        <p>Sollten Sie auch zu denen gehören, die die Umschaltung zwischen den Banks des C 128 interessant finden, dann wird es Ihnen vermutlich auch so ergangen sein wie mir, daß Sie nämlich irgendwann nicht mehr so genau wissen, in welcher Bank Sie nun gerade operieren und erstaunt sind, daß beispielsweise ein POKE nicht das erwünschte Ergebnis bringt, weil die falsche Bank eingeschaltet war. Da stolperte ich über eine Adresse in der erweiterten Zeropage, in der offenbar immer die gerade aktuelle Bank gespeichert ist. Durch »PRINT PEEK(981)« behalten Sie immer den so wichtigen Überblick.</p>

        <h3>Ausgabe von Fehlermeldungen</h3>

        <p>Vermutlich ist diese Methode von Basic aus weit weniger interessant als in Assembler-Programmen: Durch »BANK15:SYS 19775,,X« (die zwei Kommas gehören da wirklich hin!) erzwingt man die Ausgabe der Fehlermeldung mit der Nummer X.</p>

        <p>In Assembler lädt man die Fehlernummer in das X-Register und springt dann die Ausgaberoutine bei $4D3F an:
            <code>LDX #$17
                JMP $4D3F
            </code>
            erzwingt einen »STRING TOO LONG ERROR« und führt den Computer in den READY-Status. Allerdings sollte man auch hier noch auf die richtige Speicherkonfiguration achten: Die Basic-ROMs müssen eingeschaltet sein.
        </p>

        <h3>Eingabelängen</h3>

        <p>Ist es Ihnen schon aufgefallen — im Handbuch bin ich noch nicht darüber gestolpert —, daß man im 128er-Modus jetzt Programmzeilen bis zu vier Bildschirmzeilen (auf dem 40-Zeichen-Schirm) lang machen darf?</p>

        <p>Auch INPUT-Eingaben bis zu vier Bildschirmzeilen sind möglich, wer hätte das gedacht?</p>

        <h3>Eine OLD-Routine</h3>

        <p>Versehentlich gelöschte Basic-Programme wieder LIST- und lauffähig zu machen durch einen OLD-Befehl, das sieht unser Basic 7.0 nicht vor. Dabei passiert es gerade bei den ersten Versuchen am C 128 so leicht, daß man in die falsche Bank rutscht und dann den Computer durch ein kleines POKE‑Kommando scheintot macht. Da gibt es dann den Retter aus der Not: Den RESET-Knopf, dessen Betätigung aber das Basic-Programm unauffindbar macht. Da hilft nur eine OLD-Routine.</p>

        <p>Auch beim C 128 wird nur der erste Zeilenlinker durch zwei Nullen überschrieben. Es gilt also, diesen zu restaurieren. Außerdem muß der Interpreter erfahren, wo das Ende des Programms zu finden ist. Hier geht das nicht mehr durch den Zeiger, der den Beginn der Variablen andeutet — die liegen jetzt in der Bank 1 —, sondern dazu existiert ein neuer Zeiger. Hier eine Zusammenstellung der für OLD wichtigen Vektoren:</p>

        <table class="plain">
            <tr>
                <td>$2D/$2E</td>
                <td>45/46</td>
                <td>Basic-Programmstart</td>
            </tr>
            <tr>
                <td>$1210/1</td>
                <td>4624/5</td>
                <td>Basic-Programmende</td>
            </tr>
        </table>

        <p>Das im folgenden abgedruckte <a href="#fehlerteufelchen" class="fehlerteufelchen_link">Programm OLD</a> sucht zuerst den Anfang der zweiten Programmzeile. Sollte das Programm durch allerlei Manipulationen schon so zerstört sein, daß diese Suche erfolglos bleibt, wird ein »STRING TOO LONG ERROR« ausgegeben. Andernfalls restauriert OLD den ersten Zeilenlinker und durchsucht dann den Textspeicher, bis die drei Nullen gefunden werden, die ein Programmende markieren. Die Endadresse wird nun noch in den Endevektor 1210/1 geschrieben und unser Mißgeschick ist repariert.</p>

        <h3>Programm OLD</h3>

        <p>OLD ist hier genauso abgedruckt, wie Sie es mittels des Monitors eingeben können. Drücken Sie zuerst die F8-Taste (dann schaltet sich der Monitor ein) und geben Sie dann ein:
            <code>A 0E000 LDA $2D ((RETURN))</code>
        </p>

        <p>Die nächste Adresse erscheint nun automatisch und Sie brauchen nun nur noch die weiteren Befehlssequenzen abzuschreiben. OLD ist willkürlich nach $E000 gelegt worden. Falls Sie das Programm lieber an anderer Stelle hätten, können Sie es mit dem T-Befehl des Monitors auch schnell verschieben. Sollten Sie es beispielsweise lieber bei $D000 liegen haben, dann verwenden Sie:
            <code>T E000 E051 D000</code>
        </p>

        <p>Durch SYS 57344 (im Fall, daß Sie es bei $E000 belassen) starten sie unser OLD und das Basic-Programm ist wieder auferstanden.</p>

        <h3>Speicher begrenzen</h3>

        <p>Ein Nebenprodukt der Arbeit an der OLD-Routine war das Auffinden eines weiteren Vektors, der die Obergrenze des Basic-Textes in der Bank 0 festlegt. Dadurch ist es auch beim C 128 möglich, Assemblerprogramme vor dem Überschreiben durch Basic-Text zu schützen. Eine Rolle kann das dann spielen, wenn ein sehr langes Grafikprogramm Gefahr läuft, in die Maschinenprogramm-Speicherbereiche zu gelangen. Der Vektor ist $1212/3 (4626/7 in dezimal).</p>

        <p>Durch BANK0 : POKE4626,0 : POKE4627,224 können wir beispielsweise unser OLD-Programm schützen.</p>

        <p>Dies sind meine ersten Funde auf der Forschungsreise durch den unbekannten Kontinent C 128. Es spricht vieles dafür, daß — nach dem Auffinden der OLD-Routine — auch ein MERGE in greifbarer Nähe liegt. Schließen Sie sich an, vielleicht finden Sie es?</p>

        <address class="author">(Heimo Ponnath/ev)</address>

        <figure>
            <pre>MONITOR
    PC  SR AC XR YR SP
; FB000 00 00 00 00 F8

. 0E000  A5 2D    LDA $2D
. 0E002  18       CLC
. 0E003  69 04    ADC #$04
. 0E005  85 24    STA $24
. 0E007  A5 2E    LDA $2E
. 0E009  69 00    ADC #$00
. 0E00B  85 25    STA $25
. 0E00D  A0 00    LDY #$00
. 0E00F  B1 24    LDA ($24),Y
. 0E011  F0 08    BEQ $E01B
. 0E013  C8       INY
. 0E014  C0 A0    CPY #$A0
. 0E016  D0 F7    BNE $E00F
. 0E018  4C 3F 4D JMP $4D3F
. 0E01B  C8       INY
. 0E01C  98       TYA
. 0E01D  A0 00    LDY #$00
. 0E01F  18       CLC
. 0E020  65 24    ADC $24
. 0E022  91 2D    STA ($2D),Y
. 0E024  85 24    STA $24
. 0E026  90 02    BCC $E02A
. 0E028  E6 25    INC $25
. 0E02A  A5 25    LDA $25
. 0E02C  C8       INY
. 0E02D  91 2D    STA ($2D),Y
. 0E02F  88       DEY
. 0E030  B1 24    LDA ($24),Y
. 0E032  AA       TAX
. 0E033  C8       INY
. 0E034  B1 24    LDA ($24),Y
. 0E036  F0 07    BEQ $E03F
. 0E038  85 25    STA $25
. 0E03A  86 24    STX $24
. 0E03C  38       SEC
. 0E03D  B0 F0    BCS $E02F
. 0E03F  A5 24    LDA $24
. 0E041  18       CLC
. 0E042  69 02    ADC #$02
. 0E044  8D 10 12 STA $1210
. 0E047  90 07    BCC $E050
. 0E049  E6 25    INC $25
. 0E04B  A5 25    LDA $25
. 0E04D  8D 11 12 STA $1211
. 0E050  60       RTS</pre>
            <figcaption>Programm OLD. Ein NEW oder RESET versehentlich gelöschtes Basic-Programm wird mit diesem Maschinenprogramm wieder einsatzfähig.</figcaption>
        </figure>
        <div class="binary_download" data-filename="old fuer c 128.prg" data-name="OLD für C 128"></div>

        <aside class="fehlerteufelchen" id="fehlerteufelchen">
            <h2>Fehlerteufelchen</h2>

            <p>In der dort beschriebenen »OLD«-Routine wurde vergessen, einen Vektor zu restaurieren. Damit die Routine fehlerfrei arbeitet, ist der »BCC«-Befehl in der Speicherstelle $0E047 abzuändern. Statt nach $0E050 muß nach $0E04B verzweigt werden.</p>

            <!-- 64'er 3/1986 -->
        </aside>
    </article>
</body>

</html>