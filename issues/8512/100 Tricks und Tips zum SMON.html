<!DOCTYPE html>
<html lang="de">

<head>
    <title>Tricks und Tips zum SMON</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Dietrich Weineck, ah">
    <meta name="64er.issue" content="12/85">
    <meta name="64er.pages" content="100-105">
    <meta name="64er.head1" content="Tips und Tricks">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="Tips zum SMON">
    <meta name="64er.toc_category" content="Tips und Tricks">
    <meta name="64er.index_title" content="Tips & Tricks zum SMON (inkl. Diskmonitor)">
    <meta name="64er.index_category" content="Listings zum Abtippen|Anwendungen">
    <meta name="64er.id" content="smon">
</head>

<body>
    <article>
        <h1>Tricks und Tips zum SMON</h1>
        <p class="intro">Neben einer kompletten Befehlsübersicht und allen erforderlichen Einsprungadressen stellen wir Ihnen einen komfortablen Disketten-Monitor und einen Disassembler vor, der auch illegale Opcodes disassembliert.</p>

        <p>SMON, der Maschinensprachemonitor, liegt nun seit Ausgabe 4/85 vollständig vor. Damals hatten wir um Kritik und Anregungen gebeten, und das Echo war größer als wir gehofft beziehungsweise befürchtet hatten. Daher wollen wir heute die Fragen beantworten, die am häufigsten gestellt wurden. Außerdem erhalten Sie eine Befehlsübersicht, die nunmehr auch den Diskmonitor mit einschließt, und wichtige Tabellen für die Arbeit mit SMON.</p>

        <p>Daß wir inzwischen nicht ganz untätig waren, das zeigen die beiden kleinen Erweiterungen, die Sie ebenfalls in diesem Artikel finden, sozusagen als Treuebonus.</p>

        <p>Tatsächlich hatten wir keine Vorstellung von dem, was über uns hereinbrechen sollte. Es gab Tage, an denen das Telefon nicht stillstehen wollte, und wenn wir uns gegen 23.30 Uhr manchmal mit verschlafener Stimme meldeten, dann nur deshalb, weil der erste Anrufer bereits gegen 7.30 Uhr Auskunft haben wollte.</p>

        <p>Natürlich haben wir uns einen Teil der Suppe selbst eingebrockt, schließlich war das Fehlerteufelchen durch die ganze Serie hindurch unser treuester Begleiter.</p>

        <p>Gefreut hat uns natürlich, wieviel positive Resonanz SMON bei den Lesern der 64’er gefunden hat, und das Lob und die Zustimmung haben uns für viel Mühe und Ärger entschädigt. (Die originellste Danksagung erhielten wir in Form eines gewaltigen Freßpakets — der Leser ist im Hauptberuf Metzger, ein Beispiel, das Schule machen sollte&hellip;) Genug der Vorrede, hinein ins Vergnügen. Beginnen wir mit den Korrekturen:</p>

        <p>Bereits im zweiten Teil (Ausgabe 12/84) haben wir einen Fehler in der Druckerroutine korrigiert; diese Korrektur scheint aber nicht durchgedrungen zu sein. Der Fehler führt dazu, daß der jeweils letzte Befehl in einem Absatz nicht mit ausgedruckt wird. Sollten Sie Probleme mit dem Drucker haben, listen Sie folgende Zeilen mit
            <code>M C56C C57B</code>
        </p>

        <p>Sie sollten folgende Ausgabe erhalten:
            <code>:C56C 09 C9 30 F0 05 C9 21 D0
                :C574 1 1 EA 20 94 C4 20 51 03
            </code>
        </p>

        <p>Wenn das bei Ihnen anders aussieht, müssen Sie Ihre Version durch Überschreiben ändern und danach neu speichern. Die Druckerroutine läuft mit allen uns bekannten Druckern, die an Geräteadresse 4 über den seriellen Bus oder Interface betrieben werden. Leider haben wir keine Erfahrung mit Druckern, die über RS232 und Geräteadresse 2 angesteuert werden.</p>

        <p>Ebenfalls schon korrigiert ist ein Fehler im Diskmonitor, der dazu führt, daß beim Einlesen eines Sektors das letzte Byte unterschlagen wird, beim Zurückschreiben aber ein (zufälliges) 256. Byte mitgeschickt wird. Wenn Sie es noch nicht korrigiert haben, geben Sie
            <code>0 CED8 CEDC EA</code>
            ein, damit werden zwei überflüssige Befehle mit NOPs überschrieben.
        </p>

        <p>Einen weiteren und hoffentlich den letzten Programmfehler hat ein aufmerksamer Leser aus Hamburg gefunden. Der Trance-Befehl (TW) hat die unangenehme Eigenschaft, bei jedem Aufruf die Prozessorflags, also das Statusregister, nach eigenem Gutdünken zu verändern. Auch hier haben wir des Guten zuviel getan und ein paar überflüssige Befehle programmiert. Abhilfe schafft<br>
            <code>0 CD59 CD5E EA</code>
        </p>

        <p>Die weitaus größere Zahl der Anfragen bezog sich aber nicht auf Fehler, sondern auf die Bedienung von SMON. Viele Leser wollten sich mit unserer geschmackvollen Farbgebung nicht zufrieden geben, anderen paßte es nicht, daß sie bei jedem Abspeichern erst auf Kassettenbetrieb umstellen mußten. SMON setzt nämlich bei jedem BRK alle diese Einstellungen mit konstanter Boshaftigkeit auf die von uns voreingestellten Werte. Dauerhafte Abhilfe schafft deshalb nur eine Änderung der Break-Routine, die wir hier disassembliert und kommentiert darstellen wollen. Geben Sie
            <code>D C214 C22E</code>
            ein. Sie erhalten
        </p>

        <table class="plain right2">
            <tr><td>C214</td><td>CLD</td><td></td><td>; löscht eventuellen Dezimalmodus</td></tr>
            <tr><td>C215</td><td>LDA</td><td>#08</td><td>; das ist die Gerätenummer der Floppy</td></tr>
            <tr><td>C217</td><td>STA</td><td>02B0</td><td></td></tr>
            <tr><td>C21A</td><td>LDA</td><td>#04</td><td>; das ist die Gerätenummer des Druckers</td></tr>
            <tr><td>C21C</td><td>STA</td><td>02AF</td><td></td></tr>
            <tr><td>C21F</td><td>LDA</td><td>#06</td><td>; Farbe für</td></tr>
            <tr><td>C221</td><td>STA</td><td>D020</td><td>; Rahmen und</td></tr>
            <tr><td>C224</td><td>STA</td><td>D021</td><td>; Hintergrund</td></tr>
            <tr><td>C227</td><td>LDA</td><td>#03</td><td>; Farbe für</td></tr>
            <tr><td>0229</td><td>STA</td><td>0286</td><td>; Zeichendarstellung</td></tr>
            <tr><td>C22C</td><td>LDX</td><td>#05</td><td>; jetzt werden 6 Werte</td></tr>
            <tr><td>C22E</td><td>PLA</td><td></td><td>; vom Stack geholt, nämlich die Register</td></tr>
        </table>


        <p>Sie können die Werte mit Ihren Lieblingsfarben, Ihrem Lieblingsdrucker etc. überschreiben und dann ein für allemal auf Ihrem Lieblingsgerätabspeichern.</p>

        <p>Weitergehende Änderungen einzelner Routinen lassen sich nachträglich kaum in das bereits abgetippte Programm einbauen. Die von Markt &amp; Technik vertriebene fertige Version von SMON enthält allerdings eine Reihe wichtiger Verbesserungen. So bricht der Vergleichsbefehl nicht mehr bei der ersten Nichtübereinstimmung ab, Änderungen mit dem »K-Befehl« sind inzwischen unkritisch, der Drucker läuft bei allen Befehlen (auch FIND), der Diskmonitor kann alle Diskettenkommandos ausgeben und so weiter. Besonderer Dank gebührt hier Herrn Hans Örtel für seine nicht endenwollende geduldige Kritik, die letztlich zu weiteren Verbesserungen geführt hat. Sollten Sie übrigens zu den glücklichen Besitzern der M&amp;T-Version gehören und nicht die oben dargestellten Fehler im Diskmonitor und Trace-Modus haben, können Sie diese folgendermaßen beheben:</p>

        <p>Suchen Sie nach dem Fehler im Diskmonitor mit
            <code>F A6 90 D0 06, C000 D000</code>
            Wenn Sie fündig werden, ist der Fehler vorhanden und Sie müssen ab der angezeigten Adresse 4 Byte mit NOPs ($EA) überschreiben. Genauso können Sie den Fehler im Trace mit
            <code>F 08 68 8D AA 02</code>
            finden. Nur müssen Sie diesmal 5 Byte ab der gefundenen Adresse mit NOPs überschreiben.
        </p>

        <p>Insgesamt gab es einige Schwierigkeiten mit den FIND-Funktionen. Dies ist die einzige Stelle, an der SMON die Einhaltung einer genauen Schreibweise fordert. Während er sonst Komma und Leerzeichen geflissentlich überliest, reagiert er hier recht penibel. Wie Sie wissen, besteht jeder FIND-Befehl aus zwei Buchstaben, der erste ist immer ein »F«. Der zweite ist »A« für absolute Adressen, »Z« für Zeropage-Adressen, »R« für relative Sprünge und »I« für Immediate-Adressierung. Das zweite Zeichen kann aber auch ein Leerzeichen sein, nämlich bei der Suche nach einzelnen Hexbytes. Und dieses Leerzeichen darf auf gar keinen Fall fehlen.</p>

        <p>Nach dem Befehl selbst steht, wonach gesucht werden soll, also eine Adresse oder Bytefolge. Diese muß unmittelbar ohne Leerzeichen hinter dem Befehl stehen und mit einem Komma abgeschlossen werden; dann kann die Angabe des zu untersuchenden Bereichs folgen. Wenn sie unterbleibt, wird der gesamte Speicher durchsucht. Bei der Bereichsangabe ist SMON wieder tolerant, Komma und Leerzeichen darf, muß aber nicht sein.</p>

        <p>TODO TABLE</p>

        <p>Ein paar Beispiele:</p>

        <table class="plain">
            <tr><td>FA D020, C000 D000</td><td>Falsch: Space zwischen FA und D020</td></tr>
            <tr><td>FAD020 C000 D000</td><td>Falsch: Kein Komma nach D020</td></tr>
            <tr><td>FAD020, C000 D000</td><td>Richtig</td></tr>
            <tr><td>F08 68, C000 D000</td><td>Falsch: Space nach F fehlt</td></tr>
            <tr><td>F 0868, C000 D000</td><td>Falsch: Space zwischen den Bytes fehlt</td></tr>
            <tr><td>F 08 68 C000 D000</td><td>Falsch: Kein Komma nach der Bytefolge</td></tr>
            <tr><td>F 08 68, C000, D000</td><td>Richtig</td></tr>
        </table>

        <h2>Noch einmal: SMON verschieben</h2>

        <p>Viele Schwierigkeiten gab es beim Verschieben von SMON in einen anderen Speicherbereich. Immerhin waren die nötigen Routinen einschließlich Fehlerteufelchen auch auf drei Ausgaben verteilt. Da konnte man schon mal das eine oder andere übersehen. Deshalb hier noch einmal alles auf einen Blick. Wie gehabt, gehen wirals Beispiel davon aus, daß SMON in den Bereich von $9000 bis $A000 verschoben werden soll. Natürlich geht das für jeden anderen Bereich genauso.</p>

        <ol>
            <li>Wir verschieben zuerst das ganze Programm ohne Umrechnen in den neuen Bereich:
                <code>W C000 CFFA 9000</code>
            </li>
            <li>Nun lassen wir alle absoluten (3-Byte-)Befehle umrechnen. Die Tabellen am Anfang von SMON bleiben verschont:
                <code>V C000 CFFA 9000 920B 9FD2</code>
            </li>
            <li>Als nächstes ändern wir die High-Bytes der Befehlsadresse. Geben Sie
                <code>»M 902B 906B«</code>
                ein und ändern Sie in jedem zweiten Byte das »C« durch Überschreiben in »9«. Vergessen Sie nicht, am Ende jeder Zeile »RETURN« zu drücken, damit Ihre Änderung auch übernommen wird.
            </li>
            <li>Nun sind die Befehle mit Immediate-Adressierung an der Reihe. Sie müssen so geändert werden, daß sie sich auf den neuen Bereich $9&hellip; beziehen. Suchen Sie sie mit
                <code>FIC*,9000 9FFA</code>
                heraus. Sie erhalten
                <table class="plain">
                    <tr><td>9005</td><td>LDA</td><td>#C2</td><td>ändern</td></tr>
                    <tr><td>9124</td><td>CPX</td><td>#00</td><td>nicht ändern</td></tr>
                    <tr><td>9386</td><td>LDY</td><td>#C0</td><td>ändern</td></tr>
                    <tr><td>9441</td><td>CMP</td><td>#C0</td><td>nicht ändern</td></tr>
                    <tr><td>987F</td><td>LDX</td><td>#C3</td><td>nicht ändern</td></tr>
                    <tr><td>988D</td><td>LDX</td><td>#C1</td><td>nicht ändern</td></tr>
                    <tr><td>9992</td><td>LDA</td><td>#C1</td><td>nicht ändern</td></tr>
                    <tr><td>9C2C</td><td>LDA</td><td>#CC</td><td>ändern</td></tr>
                    <tr><td>9C5B</td><td>LDA</td><td>#C2</td><td>ändern</td></tr>
                    <tr><td>9CF4</td><td>LDA</td><td>#CC</td><td>ändern</td></tr>
                    <tr><td>9DA1</td><td>LDX</td><td>#CC</td><td>ändern</td></tr>
                    <tr><td>9E03</td><td>LDA</td><td>#CC</td><td>ändern</td></tr>
                    <tr><td>9E6C</td><td>CMP</td><td>#00</td><td>nicht ändern</td></tr>
                    <tr><td>9F71</td><td>LDY</td><td>#CF</td><td>ändern</td></tr>
                </table>
                <p>Sie sehen, es gibt keine Regel, welche Befehle zu ändern sind und welche nicht. Aus diesem Grunde müssen Sie diese Änderungen »von Hand« vornehmen.</p>
            </li>
            <li>Die Adressen im Diskmonitor müssen ebenfalls umgestellt werden. Dazu geben Sie bitte ein:
                <code>M 9FD8 9FE4</code>
                und ändern Sie jedes zweite Byte wie unter Punkt 3 beschrieben.
            </li>
        </ol>

        <p>Vergessen Sie bitte auf keinen Fall, Ihre neue(n) Version(en) unter neuem Namen zu speichern. Sie lassen sich dann mit LOAD "Name",8,1 von Diskette laden und mit dem entsprechenden SYS (zum Beispiel 36864 bei SMON $9000) starten. Denken Sie auch daran, nach dem Laden und vor dem SYS ein NEW einzugeben, sonst beschwert sich der B-Befehl mit einem OUT OF MEMORY ERROR.</p>

        <h2>SMON lüftet Geheimnisse</h2>

        <p>Zwei Erweiterungen haben wir Ihnen zu Beginn angekündigt, die SMON noch leistungsfähiger machen sollen. Dabei handelt es sich einmal um eine Erweiterung des Disassemblers, mit dem nun auch die »illegalen« Opcodes des 6502 disassembliert werden, zum anderen, um neue Funktionen beim Diskmonitor, mit denen Sie in den Innereien Ihrer Floppy herumstöbern können. Nun ist der Speicherplatz bis auf 5 Byte ausgeschöpft, und die 4-KByte-Grenze soll auf keinen Fall überschritten werden. Wir haben daher andere Funktionen herausgenommen, und zwar für die Disassembler-Erweiterung den Diskmonitor und für die Diskmonitor-Erweiterung den Trace-Modus. Beide Erweiterungen sind also nicht gleichzeitig einsetzbar; überhaupt ist es sinnvoll, eigene Versionen für spezielle Anwendungen zusammenzustellen, eine »normale«, eine Spezial-Disk-Version und eine für verschärftes Disassemblieren.</p>

        <p>Beginnen wir mit dem letzten: Wie Sie wissen, erscheinen beim Disassemblieren immer drei Sternchen, wenn SMON auf ein Byte trifft, das keinen gültigen 6510-Opcode darstellt. Nun wissen Sie aber vielleicht auch, daß es über den offiziellen Befehlssatz hinaus noch einige Befehle gibt, die der Hersteller des Prozessors zwar nicht dokumentiert hat, die aber nichtsdestotrotz funktionieren und in einigen Programmen auch ausgenutzt werden. (Die 64’er hat in Ausgabe 3/85 darüber berichtet.) Es wäre natürlich schön, wenn SMON auch diese »illegalen« Opcodes anzeigen könnte. Unsere Erweiterung macht’s möglich.</p>

        <p>Wir haben Mnemonics für eine Reihe dieser Befehle eingesetzt und lassen diese von SMON mit einem vorangestellten »*« ausgeben. Übrig bleiben noch zehn Befehle, deren Wirkung aber so komplex ist, daß sie sich beim besten Willen nicht mit einem Mnemonic abkürzen lassen. Sie fallen auch aus der Logik der Prozessorstruktur heraus. Im einzelnen handelt es sich um die Opcodes 0B, 2B, 4B, 6B, 8B, 9C, 9E, AB, CB und EB. Bei diesen Befehlen haben wir keine gemeinsame Struktur entdecken können. Nähere Informationen enthält der oben genannte Artikel. Die neuen Mnemonics haben folgende Bedeutung:</p>

        <table class="plain">
            <tr><td>LAX</td><td>Load Akku and X<br>entspricht LDA und LDX.</td></tr>
            <tr><td>DCP</td><td>Decrement and ComPare<br>entspricht DEC und CMP.</td></tr>
            <tr><td>ISC</td><td>Increment and SubtraCt<br>entspricht INC und SBC.</td></tr>
            <tr><td>RLA</td><td>Rotate Left and Akku<br>entspricht ROL und AND</td></tr>
            <tr><td>RRA</td><td>Rotate Right an Add with carry<br>entspricht ROR und ADC.</td></tr>
            <tr><td>SLO</td><td>Shift Left OR Akku<br>entspricht ASL und ORA.</td></tr>
            <tr><td>SRE</td><td>Shift Right and EOR Akku<br>entspricht LSR und EOR.</td></tr>
            <tr><td>SAX</td><td>Store Akku AND X<br>führt eine UND-Verknüpfung zwischen Akku und X-Register durch und speichert das Ergebnis in der angegebenen Adresse ab.</td></tr>
            <tr><td>CRA</td><td>CRAsh<br>führt zum »Absturz« des Prozessors.</td></tr>
            <tr><td>NOP</td><td>NO Operation<br>entspricht dem bekannten NOP, jedoch kann dieser Befehl auch 2 oder 3 Byte lang sein. Dies wird durch die angegebene Adresse deutlich, die in diesem Fall natürlich keinerlei Bedeutung hat.</td></tr>
        </table>

        <p>Über den Sinn dieser Befehle läßt sich sicher streiten; allerdings kommen sie bisweilen in Programmen vor, meist um das Lesen dieser Programme unmöglich zu machen, also als Programmschutz. Von derVerwendung dieser Befehle in eigenen Programmen raten wir auf jeden Fall ab. Erstens wird kein Hersteller garantieren, daß die »illegalen« tatsächlich mit jedem 6510-Prozessor funktionieren, zweitens gibt es keine Funktion, die nicht auch mit den »normalen« Befehlen ebenso gut erreicht werden könnte. Und als Programmschutz taugen die »illegalen« spätestens mit derVeröffentlichung dieses Artikels ja auch nichts mehr. Aus diesem Grund haben wir bewußt auf eine Erweiterung des Assemblers in dieser Richtung verzichtet. Sie können also keine normalen Opcodes durch Überschreiben in »illegale« ändern, wohl aber umgekehrt. Es bleibt lediglich die Eingabe als Einzelbyte, was aber hoffentlich zu umständlich ist.</p>

        <h2>Komfortabler Disketten-Monitor für SMON</h2>

        <p>Jetzt folgt unser zweiter Leckerbissen in Form eines kleinen aber ungemein wertvollen Zusatzprogrammes für den SMON. Es handelt sich dabei um eine Erweiterung des Disketten-Monitors, mit dem jeder auf einen Schlag die Arbeit von Stunden zunichte machen kann. Geben Sie das Programm wie beschrieben ein, starten Sie SMON wie gewohnt und springen mit »Z« in den Disketten-Monitor. Von hieraus erreichen Sie mit »F« (wie Floppy) die neuen Befehle. Wir haben absichtlich diesen umständlichen Weg gewählt, denn Fehler in diesem Modus wirken noch dramatischer als sonst. Mit diesem Werkzeug haben Sie unmittelbaren Zugriff auf die Eingeweide der Floppy. Jetzt können Sie die folgenden Befehle mit einer Übungsdiskette (!!!) in aller Ruhe durcharbeiten.</p>

        <table class="plain">
            <tr><td class="center"><strong>M</strong></td><td>Memory-Dump des Disketten-Monitors</td></tr>
            <tr><td colspan="2">Beispiel: M (ohne weitere Eingabe) listet den Bereich des Floppy-RAM von $OOOO-$OOFF. (Es erscheint zunächst die erste Zeile, weitere Ausgabe mit der SPACE-Taste.)<p>In diesem Bereich befinden sich unter anderem die Jobspeicher ($00-$04) für die fünf Puffer 0-4, sowie die wichtigsten Variablen des DOS.</p></td></tr>
            <tr><td><strong>M 07</strong></td><td>Memory-Dump ab $0700</td></tr>
            <tr><td colspan="2"><p>Die BAM der Diskette wird nach dem Initialisieren in Puffer 4 ($0700 im Floppy-RAM) eingelesen. Schauen Sie sich also mit»M07« die aktuelle BAM an. Sie könnten jetzt durch einfaches Überschreiben den Inhalt der BAM ändern. (Der Doppelpunkt vor der Zeile wirkt als »hidden command«). Dann schauen Sie sich Ihre Änderung mit »M 07« wieder an. Sie sehen, daß inzwischen der Inhalt des Floppy-RAM geändert wurde. Wenn Sie nun den Jobcode »90« (=Schreibbefehl an den Floppy-Controller) in Speicherstelle $04 bringen, würde die geänderte (falsche!) BAM auf Diskette zurückgeschrieben werden!! Es gibt also genug Möglichkeiten, wie oben angedeutet, die Disketten zu »versauen«.</p></td></tr>
        </table>

        <p>Für das Ausprobieren noch einige wichtige Speicherstellen und Jobcodes:</p>

        <table class="plain">
            <tr><td>$80</td><td>Lesen</td></tr>
            <tr><td>$90</td><td>Schreiben</td></tr>
            <tr><td>$C0</td><td>»Anschlagen« des Kopfes</td></tr>
            <tr><td>$D0</td><td>Maschinenprogramme im Puffer ausführen</td></tr>
            <tr><td>$E0</td><td>Programm im Puffer ausführen mit Hochfahren des Laufwerks</td></tr>
            <tr><td></td><td></td></tr>
        </table>

        <p>Speicherstellen im Floppy-RAM:</p>

        <table class="plain">
            <tr><td>$06/$07</td><td>ist Spur- und Sektornummer für den Befehl in Puffer 0</td></tr>
            <tr><td>$08/$09</td><td>für Puffer 1</td></tr>
            <tr><td>$0A/$0B</td><td>für Puffer 2</td></tr>
            <tr><td>$0C/$0D</td><td>für Puffer 3</td></tr>
            <tr><td>$0E/$0F</td><td>für Puffer 4</td></tr>
        </table>

        <p>Jedem Puffer sind zwei Speicherstellen zugeordnet, eine für den Jobcode ($0000 bis $0004) und eine für Spur und Sektor. Wenn Sie also in Puffer 0 (in $0300 gelegen) einen bestimmten Block einlesen wollen, geben Sie folgende Befehle ein:</p>

        <p>»M« liest die Zeropage der Floppy ein - so sehen dann zum Beispiel die ersten Zeilen aus:
            <code>:0000 01 01 01 FF 03 04 01 34
                :0008 23 02 04 50 01 03 0A 11
            </code>
        </p>

        <p>Gehen Sie mit dem Cursor in die erste Zeile und schreiben Sie »80« in die erste Speicherstelle (anstelle der ersten 01). In Speicherstelle $06/$07 (die letzten beiden in der ersten Reihe) die Spur- und die Sektornummer, die gelesen werden soll, zum Beispiel 12 01. Sie sehen dann
            <code>:0000 80 01 01 FF 03 04 12 01
                :0008 unverändert
            </code>
        </p>

        <p>Drücken Sie die RETURN-Taste, mit »M 03« kann jetzt der eingelesene Block (hier der erste Directory-Block) angesehen werden. Änderungen können durch einfaches Überschreiben vorgenommen werden. Dauerhaft wird Ihre Änderung erst durch Zurückschreiben (nach Spur $12 und Sektor $01) mit dem Jobcode »90« in der ersten Speicherstelle. Nach Änderung der beiden für Puffer 0 zuständigen Adressen ($06/$07) auch an jede beliebige andere Stelle. Das ist wörtlich zu nehmen. Denn wir befinden uns hier »unterhalb« der Controllerebene, die unter anderem für die Prüfung auf Einhaltung der zulässigen Spur und Sektorgrenzen verantwortlich ist. Es erfolgt also keine Fehlermeldung, wenn Sie versuchen sollten, mit Ihrer Floppy bis in die des Nachbarn zu schreiben (zum Beispiel mit der Spur 152).</p>

        <p>Entsprechende Lese- und Schreibübungen können mit den anderen Puffern durchgeführt werden. Denken Sie daran, erst ist die Spur- beziehungsweise Sektornummer für den entsprechenden Puffer (in der zweiten Zeile!) einzugeben, bevor Sie in Zeile 1 den Jobcode mit einem »RETURN« übergeben. Denn mit Druck auf die RETURN-Taste wird Ihr Befehl ausgeführt. Und noch eins: Quälen Sie bitte dabei Ihren Schreibkopf nicht mehr als unbedingt erforderlich, sonst könnte er sich mechanisch verklemmen und nur noch mit einem Eingriff in die Floppymechanik wieder »befreit« werden.</p>

        <p>Falls Sie die Ausgaben 1/85 (Seite 151) und 3/85 (Seite 103 bis 135) der 64’er besitzen, können Sie sich dort über andere Speicherstellen der Floppy und die weitere Anwendung der Jobcodes informieren.</p>

        <p>Der Befehl @ ohne weitere Angaben fragt den Fehlerkanal ab, ansonsten dient er zur Befehlsübermittlung an die Floppy.</p>

        <table class="plain">
            <tr><td>Beispiel:</td><td>@</td><td>Fehlerkanal</td></tr>
            <tr><td></td><td>@I</td><td>Initialisierungsbefehl oder</td></tr>
            <tr><td></td><td>@S:name</td><td>Befehl zum Scratchen</td></tr>
            <tr><td></td><td></td><td>und so weiter.</td></tr>
        </table>

        <p>Bedingt durch die verschiedenen Versionen, springt dieser Befehl manchmal in den »normalen« Disketten-Monitor zurück, erkennbar an dem »*« am Zeilenanfang. Sie müssen dann wieder ein »F« eingeben.</p>

        <p>Mit X gelangt man wieder in den Disketten-Monitor.</p>

        <p>Zum Abschluß ein sehr hilfreicher Befehl namens »V«, der es erlaubt, Speicherbereiche aus dem Computer in den Laufwerkspuffer zu verschieben. Folgende einfache Syntax gilt dabei: <strong>V von nach</strong></p>

        <p>Um zum Beispiel ein Maschinenprogramm von $6000 in den Puffer 1 zu bekommen, geben Sie folgendes ein:
            <strong><code>V 6000 0400</code></strong>
        </p>

        <p>Dabei wird immer eine ganze Seite, also 256 Byte, übertragen. Was das Programm dort soll, fragen Sie? Führen Sie es doch einfach aus (Jobcode $D0 in Speicherstelle $01 schreiben); oder schreiben Sie es mit dem Jobcode »90« in einen beliebigen Sektor der Diskette.</p>

        <p>Wenn Sie dann Ihre Floppy so richtig durcheinander gebracht haben, und nichts läuft mehr, brauchen Sie nicht zu verzweifeln. Außer einem eventuell festhängenden Lesekopf passiert der Floppy nichts, nur Ihren Disketten.</p>

        <p>Tippen Sie die beiden Erweiterungsprogramme (Listing 1 und 2 beziehungsweise bei der M&amp;T-Version Listing 3 und 4) mit dem MSE-Programm ab und speichern Sie die fertigen Programme. Die Programme für die M&amp;T-Version haben sinnigerweise ein M&amp;T im Namen.</p>

        <p>Laden und starten Sie dann Ihren SMON $C000. Geben Sie ein: L"NDISASS"</p>

        <p>Damit werden die neuen Befehle automatisch über den bisherigen Disketten-Monitor geladen. Sie müssen nun aber noch aktiviert werden. Geben Sie dazu G CF0D ein.</p>

        <h2>Hinweise zum Abtippen</h2>

        <p>SMON meldet sich sofort mit seiner Registeranzeige wieder. Sie sollten nun diese Version unbedingt abspeichern, zum Beispiel mit S"SMON NDISASS" C000 CF3D</p>

        <p>Wenn Sie nun das Programm »ILLEGAL-CODE« (Listing 5) laden und mit D 4000 disassemblieren, sehen Sie die »illegalen« Opcodes schön geordnet nacheinander.</p>

        <p>Um die neuen Befehle des Disketten-Monitors in SMON einzubinden, gehen Sie ganz ähnlich vor. Nach dem Abtippen und Speichern des Programms »FLOPPYMON« muß natürlich SMON C000 geladen und gestartet werden. Anschließend</p>

        <ul class="plain">
            <li>geben Sie ein: L"FLOPPYMON"</li>
            <li>und aktivieren es mit G CDD8 (64’er-Version)</li>
            <li>beziehungsweise G CDB6 (M&amp;T-Version)</li>
        </ul>

        <p>Zum Abspeichern geben Sie S"SMON-FLOPPY" C000 CFFF ein. Das gilt für beide Versionen.</p>

        <address class="author">(Dietrich Weineck/ah)</address>

        <figure>
            <p>Bei allen Ausgabe-Befehlen ist gleichzeitig die Ausgabe auf einem Drucker möglich. Dazu werden die Befehle geSHIFTet eingegeben.</p>

            <table class="plain">
                <tr><td><strong>A</strong></td><td><strong>4000</strong> (Assembler)<br>symbolischer Assembler (Verarbeitung von Label möglich) Startadresse $4000</td></tr>
                <tr><td><strong>B</strong></td><td><strong>4000 4200</strong> (Basic-Data)<br>erzeugt Basic-DATA-Zeilen aus Maschinenprogramm im Bereich von $4000 bis $41FF</td></tr>
                <tr><td><strong>C</strong></td><td><strong>4010 4200 4013 4000 4200</strong> (Convert)<br>in ein Programm, das von $4000 bis $4200 im Speicher steht, soll bei 4010 ein 3-Byte-Befehl eingefügt werden. Dazu wird das Programm ab $4010 bis 4200 auf die neue Adresse $4013 verschoben. Alle absoluten Adressen, die innerhalb des Programmbereichs ($4000 bis $4200) stehen, werden umgerechnet, so daß die Sprungziele stimmen.</td></tr>
                <tr><td><strong>D</strong></td><td>4<strong>000 (4100)</strong> (Disassembler)<br>disassembliert den Bereich von $4000 (bis $4100) mit Ausgabe der Hex-Werte. Änderungen sind durch Überschreiben der Befehle möglich.</td></tr>
                <tr><td><strong>F</strong></td><td>(Find)<br>findet Zeichenketten (F), absolute Adressen (FA), relative Sprünge (FR), Tabellen (FT), Zeropageadressen (FZ) und Immediate-Befehle (FI)</td></tr>
                <tr><td><strong>G</strong></td><td><strong>(4000)</strong> (Go)<br>startet ein Maschinenprogramm, das bei $4000 im Speicher beginnt</td></tr>
                <tr><td><strong>I</strong></td><td><strong>01</strong> (I/O-Gerät)<br>stellt die Gerätenummer für Floppy (08 oder 09) oder Datasette (01) ein</td></tr>
                <tr><td><strong>K</strong></td><td><strong>A000 (A500)</strong> (Kontrolle)<br>zum schnellen Durchsuchen des Bereichs von $A000 (bis $A500) nach ASCII-Zeichen (32 Byte pro Zeile). Änderungen sind durch Überschreiben der ASCII-Zeichen möglich.</td></tr>
                <tr><td><strong>L</strong></td><td><strong>(4000)</strong> (Load)<br>lädt ein Maschinenprogramm an die richtige oder eine angegebene Adresse ($4000)</td></tr>
                <tr><td><strong>M</strong></td><td><strong>4000 (4400)</strong> (Memory-Dump)<br>gibt den Inhalt des Speichers von $4000 (bis $43FF) in Hex-Byte und ASCII-Code aus. Änderungen sind durch Überschreiben der Hex-Zahlen möglich.</td></tr>
                <tr><td><strong>0</strong></td><td><strong>4000 4500 AA</strong> (Occupy)<br>füllt den Speicherbereich von $4000 bis $4500 mit vorgegebenem Byte ($AA) aus</td></tr>
                <tr><td><strong>P</strong></td><td><strong>05</strong> (Printer)<br>setzt Geräteadresse 5 für Drucker</td></tr>
                <tr><td><strong>R</strong></td><td>(Register)<br>zeigt die Registerinhalte und Flags an. Änderungen sind durch Überschreiben möglich.</td></tr>
                <tr><td><strong>S</strong></td><td><strong>»Test« 4000 5000</strong> (Save)<br>speichert ein Programm von $4000 bis $4FFF unter dem Namen »Test« ab.</td></tr>
                <tr><td><strong>TW</strong></td><td><strong>(4000)</strong> (Trace Walk)<br>führt auf Tastendruck den jeweils nächsten Maschinenbefehl aus und zeigt die Registerinhalte an. Subroutinen können in Echtzeit durchlaufen werden (»J«). Wird keine Startadresse eingegeben, beginnt >TW« bei der letzten mit »R« angezeigten Adresse.</td></tr>
                <tr><td><strong>TB</strong></td><td><strong>4010 05</strong> (Trace Break)<br>setzt einen Haltepunkt für den Schnellschrittmodus bei $4010. Der Schnellschrittmodus wird unterbrochen, nachdem $4010 zum fünften Mal erreicht worden ist.</td></tr>
                <tr><td><strong>TQ</strong></td><td><strong>4000</strong> (Trace quick)<br>Schnellschrittmodus, springt beim Erreichen eines Haltepunktes in den Einzelschrittmodus.</td></tr>
                <tr><td><strong>TS</strong></td><td><strong>4000 4020</strong> (Trace stop)<br>arbeitet ein Programm ab $4000 in Echtzeit ab und springt beim Erreichen von $4020 in die Registeranzeige. Von dort aus kann (nach eventueller Änderung der Register) mit »G« oder »TW« fortgefahren werden. »TS« arbeitet nur im RAM-Speicher.</td></tr>
                <tr><td><strong>V</strong></td><td><strong>6000 6200 4000 4100 4200</strong> (Verschieben)<br>ändert in einem Programm von $4100 bis $41FF alle absoluten Adressen, die sich auf den Bereich von $6000 bis $6200 beziehen, auf einen neuen Bereich, der bei $4000 beginnt.</td></tr>
                <tr><td><strong>W</strong></td><td><strong>4000 4300 5000</strong> (Write)<br>verschiebt den Speicherinhalt von $4000 bis $42FF nach $5000 ohne Umrechnung der Adressen (zum Beispiel Tabellen)</td></tr>
                <tr><td><strong>X</strong></td><td>(Exit)<br>springt aus dem Monitor-Programm ins Basic zurück</td></tr>
                <tr><td><strong>#</strong></td><td><strong>49152</strong><br>Dezimalzahl umrechnen</td></tr>
                <tr><td><strong>$</strong></td><td><strong>002B</strong><br>4stellige Hex-Zahl umrechnen</td></tr>
                <tr><td><strong>%</strong></td><td><strong>01101010</strong><br>8stellige Binärzahl umrechnen</td></tr>
                <tr><td><strong>?</strong></td><td><strong>0344 + 5234</strong><br>Addition oder Subtraktion zweier 4stelliger Hex-Zahlen</td></tr>
                <tr><td><strong>=</strong></td><td><strong>4000 5000</strong> (Vergleich)<br>vergleicht den Speicherinhalt ab $4000 mit dem ab $5000</td></tr>
                <tr><td><strong>Z</strong></td><td>(Diskmonitor)<br>ruft den Diskmonitor auf. Dieser verfügt über folgende Befehle:</td></tr>
                <tr><td><strong>R</strong></td><td><strong>(12 01)</strong> (Read)<br>liest Track $12, Sektor $01 von der Diskette in einen Puffer im Speicher. Fehlt die Angabe von Track und Sektor, wird der logisch (!) nächste Sektor gelesen.</td></tr>
                <tr><td><strong>W</strong></td><td><strong>(12 01)</strong> (Write)<br>schreibt den Puffer im Speicher nach Track $12, Sektor $01 auf die Diskette. Ohne Angabe von Track und Sektor werden die letzten Eingaben von »R« benutzt.</td></tr>
                <tr><td><strong>M</strong></td><td>(Memory-Dump)<br>zeigt den Pufferinhalt als Hexdump (wie normales »M«), Weitere Ausgabe mit CBM-Taste, Abbruch mit STOP. Werte können durch Überschreiben geändert werden.</td></tr>
                <tr><td><strong>X</strong></td><td>(Exit)<br>springt in SMON zurück</td></tr>
                <tr><td><strong>F</strong></td><td>(weitere Disketten-Befehle initialisieren)<br>
                    sind die Befehle initialisiert, gilt:
                    <table class="plain">
                        <tr><td><strong>M</strong></td><td>(07)<br>Memory-Dump (Floppy-RAM/ROM)</td></tr>
                        <tr><td><strong>V</strong></td><td>6000 0400<br>Verschieben eines 256-Byte-Blocks von $6000 in den Laufwerkspuffer 1 beziehungsweise in das Floppy-RAM</td></tr>
                        <tr><td>@</td><td>normale Disketten-Befehle senden</td></tr>
                        <tr><td><strong>X</strong></td><td>zurück zum normalen Disketten-Monitor</td></tr>
                    </table>
                </td></tr>
            </table>
            <figcaption>Befehlsübersicht zum SMON</figcaption>
        </figure>
    </article>
</body>

</html>