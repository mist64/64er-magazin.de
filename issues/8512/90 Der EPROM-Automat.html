<!DOCTYPE html>
<html lang="de">

<head>
    <title>Der EPROM-Automat</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Dirk Gazic, aw">
    <meta name="64er.issue" content="12/85">
    <meta name="64er.pages" content="90,92-94,99">
    <meta name="64er.head1" content="Tips und Tricks">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_category" content="Tips und Tricks">
    <meta name="64er.index_title" content="Der Eprom-Automat (wie man Module macht)">
    <meta name="64er.index_category" content="Listings zum Abtippen|Tips & Tricks">
    <meta name="64er.id" content="module">
</head>

<body>
    <article>
        <h1>Der EPROM-Automat</h1>
        <p class="intro">Was steckt hinter der Datenspeicherung auf EPROMs? Wir zeigen Ihnen, wie man seine eigenen Module aus Basic-Programmen herstellt.</p>

        <p>Zur Programmierung von EPROMs sind drei Dinge notwendig: Ein Computer, ein EPROM-Programmiergerät, und das Wissen, in welcher Form Programme auf EPROMs gespeichert sein müssen. Dieser Artikel zeigt Ihnen, wie man eigene Programme so modifiziert, daß sie auf ein EPROM gespeichert und anschließend von dort auch ausgeführt werden können. In den folgenden Zeilen soll schrittweise erarbeitet werden, was dabei zu beachten ist. Sie sollen in die Lage versetzt werden, das Programm Auto-Eprom (Listing 1) zu verstehen und gegebenenfalls an Ihre eigenen Bedürfnisse anzupassen.</p>

        <p>Was ist eigentlich ein EPROM? Nun, zunächst ist ein EPROM nichts anderes als ein Datenspeicher, der sich beschreiben, lesen und auch wieder löschen läßt. Wenn man einmal von dem etwas komplizierten Schreib- und Löschvorgang absieht, unterscheidet sich ein EPROM nur in einem für den C 64-Programmierer wichtigen Punkt von anderen Speichern wie beispielsweise den Disketten oder der Datenkassette. Es handelt sich hierbei um die Tatsache, daß ein auf EPROM gespeichertes Programm in der Regel die Anfangsadresse $8000 (dezimal 32768) hat. Wie kann man aber den Computer überlisten und ein Basic-Programm, das ja normalerweise ab $0801 (dezimal 2049) liegt, sofort nach dem Einschalten des Computers ohne weitere Befehle startet? Dafür gibt es prinzipiell zwei Lösungen. Die erste Möglichkeit besteht darin, den Basic-Start mit den Befehlen »POKE 44,128:Poke 32768,0:NEW« nach $8000 zu verschieben und ein Basic-Programm in diesem Speicherbereich laufenzulassen.</p>

        <p class="noindent">Diese Methode hat jedoch den entscheidenden Nachteil, daß dann für Programm und Variablen nur noch magere 8 KByte zur Verfügung stehen. Die zweite wesentlich elegantere Möglichkeit besteht darin, das auf EPROM gebrannte Basic-Programm nach dem Einschalten des Computers in den normalen Speicherbereich für Basic-Programme ab $0801 (dezimal 2049) zu verschieben. Es wird dann vom C 64 genauso behandelt, als ob es von einem externen Datenspeicher, wie dem Diskettenlaufwerk, geladen worden wäre. Ein automatisches Starten des Programms soll dabei natürlich nicht vergessen werden. Es versteht sich beinahe von selbst, daß diese Anforderungen nur in Maschinensprache zu realisieren sihd. Wir wollen nun gemeinsam ein entsprechendes Programm erarbeiten. Dazu ist zunächst die Betriebssystem-Routine zu betrachten, die beim Einschalten des C 64 beziehungsweise nach einem Reset durchlaufen wird (Listing 2). Für uns besonders interessant ist das Unterprogramm, das in der Speicherzelle $FCE7 beginnt. Dieses Unterprogramm prüft, ob ab Adresse $8005 die Zeichenfolge »CBM80« steht. Sollte dies der Fall sein, wird in der nächsten Zeile die Adresse angesprungen, die in $8000 und $8001 gespeichert ist. Das bedeutet für das Verschiebeprogramm, dafür zu sorgen, daß ab $8000 die Startadresse des Programms steht und ab $8005 die Zeichenfolge »CBM80« zu finden ist. Damit haben wir schon einmal das erste Problem gelöst, da nun beim Einschalten das Verschiebeprogramm angesprungen wird. Das nächste Problem ist die Durchführung der Reset-Routine. Das ist deshalb erforderlich, da sich der Computer nach dem Einschalten in einem völlig undefinierten Zustand befindet. Würde in diesem Zustand die Kontrolle an den Basic-Interpreter übergeben (was wir nach dem Verschieben des Basic-Programms ja vorhaben), wäre ein Systemabsturz die unweigerliche Folge. Das Verschiebeprogramm führt deshalb als nächstes dieselbe Initialisierungs-Routine durch, die das Betriebssystem des C 64 sonst automatisch ausführt. Anschließend gilt es dann, das Basic-Programm wieder an den Basic-Start nach $0801 zu verschieben. Dazu stellt der Basic-Interpreter bereits eine bestens geeignete Routine zur Verfügung. Diese Routine erwartet die Anfangsadresse des zu verschiebenden Bereichs in den Speicherzellen $5F/$60 (dezimal 95/96) in der Form Low-/High-Byte, die Endadresse in den Speicherzellen $5A/$5B (dezimal 90/91) und die Endadresse des Bereichs in den verschoben werden soll in $58/$59 (dezimal 88/89).</p>

        <p>Schließlich gibt es noch zwei Speicherstellen in der Zeropage, die unsere Beachtung verdienen. Es sind die Zellen $2D/$2E (dezimal 45/46). Hier schaut der Interpreter später nach, wo das Basic-Programm aufhört, um nicht mit Variablenzuweisungen das Basic-Programm zu überschreiben. Beim Laden von der Diskette oder Kassette werden diese Speicherstellen automatisch auf die richtigen Werte gesetzt, in unserem Fall fällt diese Aufgabe dem Verschiebeprogramm zu. Nachdem wir die Blockverschieberoutine durchgeführt haben, könnte man bereits durch Sprung auf den Basic-Warmstart die Programm-Kontrolle an den Basic-Interpreter übergeben. Das Basic-Programm ist bereits list- und lauffähig. Es muß aber noch manuell mit RUN gestartet werden. Um auch dies dem Computer zu überlassen, brauchen wir vor dem Sprung auf den Basic-Warmstart lediglich noch den ASCII-Code für RUN und RETURN in den Tastaturpuffer schreiben und dem Interpreter mitteilen, daß im Tastaturpuffer ein zu verarbeitender Befehl steht. Der Tastaturpuffer beginnt bei $0277 (dezimal 631) und die Anzahl der Zeichen, die im Tastaturpuffer stehen, werden dem Computer über die Speicherstelle $00C6 (dezimal 198) mitgeteilt. Wenn der C 64 nun in den Direktmodus schaltet, verhält er sich genauso, als wenn Sie über die Tastatur »RUN« eingeben und die RETURN-Taste betätigt hätten. Damit ist das Verschiebeprogramm auch schon fertig. Bevor wir uns nun mit dem Problem beschäftigen, wie ein selbstgeschriebenes Basic-Programm zum Brennen auf EPROM in den Speicherbereich ab $805C (hinter das Verschiebeprogramm) kopiert wird, schauen Sie sich bitte zunächst das dokumentierte Listing des Verschiebeprogramms an (Listing 3). Bei den Werten in den Adressen $8045/$8049/$804D und $8053 handelt es sich um Platzhalter. Diese Werte werden später entsprechend der Länge des Basic-Programms verändert. Jetzt braucht man das eigentliche Programm nur noch an das Ende des Verschiebeprogrammes ab $805C zu kopieren, die Platzhalter im Verschiebeprogramm durch die richtigen Werte ersetzen und den EPROMmer anwerfen.</p>

        <p>Bei eingestecktem EPROM wird dann das Basic-Programm direkt nach dem Einschalten des Computers oder nach einem Reset automatisch gestartet. Nun wäre es aber sehr mühsam, jedes Programm, das gebrannt werden soll, mit einem Monitor nach $805C zu verschieben. Genau diese Arbeit nimmt Ihnen das Programm »EPROM-Automat« (Listing 1) ab.</p>

        <p>In diesem Programm finden Sie auch das eben entwickelte Maschinenprogramm in den DATA-Zeilen 2970 bis 3010 wieder. Die Bedienungsanleitung zu »EPROM-Automat« finden Sie in Bild 1. Betrachten wir uns die Zeilen 2650 bis 5010, die der eigentliche Hauptteil dieses Programms sind, etwas genauer. In diesen Zeilen wird das oben entwickelte Maschinenprogramm in den Speicherbereich ab $8000 geschrieben und dahinter das zu bearbeitende Basic-Programm kopiert. Nachdem man den Namen des zu bearbeitenden Programms eingegeben hat, wird in Zeile 2730 ein Lesekanal geöffnet. Danach werden die ersten beiden Byte dieser Programmdatei von der Diskette gelesen. Sie geben in der Form Low-/High-Byte die Startadresse des gespeicherten Programms an. Sollte die Startadresse nicht $0801 sein, springt das Programm sofort ins Menü zurück. Natürlich ist es theoretisch möglich, auch reine Maschinenprogramme, die an einer beliebigen Adresse beginnen und mit SYS (Startadresse) gestartet werden, mit dem EPROM-Automat zu bearbeiten. Dazu sind folgende Änderungen notwendig: Das Verschiebeprogramm muß so modifiziert werden, daß es nicht mehr mit RUN gestartet wird, sondern die Startadresse direkt mit JMP (Startadresse) angesprungen wird. Die Endadresse darf nicht mehr mit dem festen Offset 30811 (Zeile 2920) berechnet werden, sondern muß in Abhängigkeit von der Anfangsadresse des Programms ermittelt werden. Wenden wir uns der Zeile 2810 zu. In dieser Zeile wird das Maschinenprogramm in den richtigen Speicherbereich verschoben. Im Anschluß daran wird Byte für Byte das Basic-Programm dahintergeschrieben. Dabei wird immer wieder in Abhängigkeit vom Zähler »I« geprüft, ob das Programmende nicht über $A000 (dezimal 40960) hinausgeht. In diesem Fall käme man nämlich nicht mehr mit einem 8-KByte-EPROM aus. Wollen Sie jedoch auch 16-KByte-EPROMs brennen, müssen Sie außer dem Vergleichswert in Zeile 2850 auch noch das Verschiebeprogramm dahingehend modifizieren, daß es beim Kopieren des Basic-Programms den ROM-Bereich ab $A000 abschaltet, um den darunterliegenden RAM-Bereich lesen zu können. Weiterhin wäre es dann erforderlich, die PEEK-Funktion des C 64 dahingehend zu erweitern, daß sie in der Lage ist, auch den vom ROM überlagerten RAM-Bereich ab $A000 zu lesen.</p>

        <p class="noindent">Wollen Sie dagegen 4-KByte-EPROMs benutzen, müssen Sie lediglich den Wert in Zeile 2&thinsp;850 von 40960 in 36864 ($9000) ändern oder selbst darauf achten, daß das Programm, das Sie bearbeiten wollen, nicht länger als 4 KByte ist. Wenn das Programmende erreicht ist, wird der Programmkanal in Zeile 2&thinsp;890 wieder geschlossen und die Werte für die Speicherstellen $8046/$804A und $804E/$8054 werden berechnet. Sie erinnern sich, dort stehen bisher nur Platzhalter, die noch durch die richtigen Werte für den zu verschiebenden Ursprungs- und Zielbereich ersetzt werden müssen. Die Berechnung der Endadresse des Ursprungsbereiches ist relativ einfach. Dazu muß man lediglich den Zähler »I«, der ja mit dem Programmende im Speicher übereinstimmt, in Low- und High-Byte zerlegen. Aber auch die Berechnung der Endadresse des Zielbereichs ist nicht viel schwieriger. Dazu braucht man von »I« lediglich die Differenz zwischen der jetzigen Anfangsadresse ($805C) und der normalen Anfangsadresse ($0801) subtrahieren. Nun steht Ihr Basic-Programm brennfertig ab $8000 im Speicher. Nachdem Sie es auf EPROM gebrannt haben, bleibt noch ein kleines Problem. Beim Einschieben einer Modulplatine in den Expansion-Port des C 64 stehen für den Basic-Programmierer nur noch 30719 Byte zur Verfügung. Sollte Ihr Programm mit großen Variablenfeldern arbeiten, werden Sie die restlichen 8 KByte vielleicht auch noch benötigen. Sofern die Garantiezeit bei Ihrem Computer abgelaufen ist, öffnen Sie ihn einfach und bringen einen einfachen Ein-/Aus-Schalter an, der, wie in Bild 2 dargestellt, verdrahtet wird. Mit diesem Schalter können Sie dann bei Bedarf die Leitung EXROM, die bei eingesteckter Modulplatine normalerweise auf Masse liegt, freigeben und haben dann wieder den vollen Speicherbereich zur Verfügung. Noch ein Tip für diejenigen, die keinen EPROMmer besitzen. Auch sie können den EPROM-Automat sehr effektvoll einsetzen, da die präparierten Programme nach einem Reset automatisch wieder starten. In Ihrem Basic-Programm muß lediglich die Zeile: POKE 55,0:POKE 56,128:CLR enthalten sein.</p>

        <figure>
            <img src="90-2.png" alt="">
            <figcaption>Bild 2. Mit einem kleinen Trick lassen sich auch Module abschalten, das Bild wurde mit HI-EDDI erstellt.</figcaption>
        </figure>

        <address class="author">(Dirk Gazic/aw)</address>

        <figure>
            <p><strong>Bedienungsanleitung für das Programm EPROM-Automat:</strong></p>

            <ol>
                <li>Folgende Anforderungen muß das zu bearbeitende Programm erfüllen:
                    <ol type="a">
                        <li>Es muß mindestens eine Basic-Zeile enthalten.</li>
                        <li>Es darf nicht länger als 8 KByte (32 Blöcke auf der Diskette) sein.</li>
                    </ol>
                </li>
                <li><strong>Menü</strong>
                    <p>Nach dem Programmstart meldet sich der EPROM-Automat mit einem Menü. Sie können nun mit Hilfe der Cursorsteuertasten die einzelnen Optionen anwählen. Die jeweils angewählte Option wird dabei hervorgehoben. Durch Druck auf die RETURN-Taste wählen Sie dann den entsprechenden Programmteil aus. Sie haben im Hauptmenü zusätzlich die Möglichkeit, die eingestellten Bildschirmfarben zu verändern (F1 = Rahmen, F2 = Hintergrund, F3 = Schrift).</p>
                </li>
                <li><strong>Programme bearbeiten</strong>
                    <p>Geben Sie bitte den Namen des Programms ein, das Sie bearbeiten wollen. Fehlermeldungen werden gegebenenfalls in der unteren Statuszeile ausgegeben.</p>
                </li>
                <li><strong>Speicherinhalt sichern</strong>
                    <p>Dient zum Abspeichern von bearbeiteten Programmen auf Diskette. Sobald Sie diese Option angewählt haben, wird überprüft, ob Sie bereits ein Programm bearbeitet und dieses noch nicht gespeichert haben. Andernfalls werden Sie aufgefordert, einen Programmnamen anzugeben. Wenn Sie möchten, können Sie auch den vorgegebenen Namen übernehmen. Anschließend werden Sie gebeten, die Startadresse, ab der das Programm später geladen wird, einzugeben. Sollte die Steuersoftware für Ihren Eprommer bei $8000 liegen, so können Sie zum Beispiel »6« statt »8« eingeben.</p>
                </li>
                <li><strong>Directory zeigen</strong>
                    <p>Dieser Menüpunkt zeigt das Inhaltsverzeichnis der eingelegten Diskette. Dieser Vorgang kann jederzeit mit F1 abgebrochen werden. Die Funktionstaste F3 hält die Auflistung so lange an, bis eine beliebige Taste gedrückt wird.</p>
                </li>
                <li><strong>Programm beenden</strong>
                    <p>Diese Option beendet nach positiver Beantwortung der Sicherheitsabfrage, die Arbeit mit EPROM-Automat. Das zuletzt bearbeitete Programm bleibt dabei im weiterhin geschützten Speicherbereich ab $8000 erhalten und kann sofort auf ein EPROM gebrannt werden.</p>
                </li>
            </ol>

            <figcaption>Bild 1. Bedienungsanleitung zum Programm »EPROM-Automat«</figcaption>
        </figure>

        <figure>
            <pre data-filename="eprom-automat" data-name="EPROM-Automat"></pre>
            <figcaption>Listing 1. EPROM-Automat — ein komfortables Programm zur Modulherstellung. Bitte beachten Sie die Eingabehinweise auf Seite 54.</figcaption>
        </figure>
        <figure>
            <pre>FCE2 LDX &amp;FF
FCE4 SEI
FCE5 TXS
FCE6 CLD
FCE7 JSR FD02   prüft auf ROM in $8000
FCEA BNE FCEF   Sprung wenn kein Autostart-Modul
FCEC JMP (8000) Sprung auf Modul-Start
FCEF STX D016   Ab hier folgt der eigentliche Reset
FCF2 JSR FDA3
FCF5 JSR FD50
FCF8 JSR FD15
FCFB JSR FF5B
FCFE CLI
FCFF JMP (A000) Sprung zum BASIC Kaltstart</pre>
            <figcaption>Listing 2. Diese Betriebssystem-Routine prüft, ob ein Modul eingesteckt ist.</figcaption>
        </figure>

        <figure>
            <table class="plain">
                <tbody>
                    <tr>
                        <td>8000</td>
                        <td>.byte 09</td>
                        <td>Startadresse des Verschiebeprogramms (Lowbyte)</td>
                    </tr>
                    <tr>
                        <td>8001</td>
                        <td>.byte 80</td>
                        <td>Startadresse des Verschiebeprogramms (Highbyte)</td>
                    </tr>
                    <tr>
                        <td>8002</td>
                        <td>.byte 09</td>
                        <td>Neuer NMI-Vektor (Lowbyte)</td>
                    </tr>
                    <tr>
                        <td>8003</td>
                        <td>.byte 80</td>
                        <td>Neuer NMI-Vektor (Highbyte)</td>
                    </tr>
                    <tr>
                        <td>8004</td>
                        <td>.byte C3</td>
                        <td>''C''</td>
                    </tr>
                    <tr>
                        <td>8005</td>
                        <td>.byte C2</td>
                        <td>''B''</td>
                    </tr>
                    <tr>
                        <td>8006</td>
                        <td>.byte CD</td>
                        <td>''M''</td>
                    </tr>
                    <tr>
                        <td>8007</td>
                        <td>.byte 38</td>
                        <td>''8''</td>
                    </tr>
                    <tr>
                        <td>8008</td>
                        <td>.byte 30</td>
                        <td>''0''</td>
                    </tr>
                    <tr>
                        <td>8009</td>
                        <td>SEI</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>800A</td>
                        <td>STX D016</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>800D</td>
                        <td>JSR FDA3</td>
                        <td>Interrupt vorbereiten</td>
                    </tr>
                    <tr>
                        <td>8010</td>
                        <td>JSR FD50</td>
                        <td>Arbeitsspeicher initialisieren</td>
                    </tr>
                    <tr>
                        <td>8013</td>
                        <td>JSR FD15</td>
                        <td>Hardware und I/O Vektoren setzen</td>
                    </tr>
                    <tr>
                        <td>8016</td>
                        <td>JSR FF5B</td>
                        <td>Video-Reset</td>
                    </tr>
                    <tr>
                        <td>8019</td>
                        <td>CLI</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>801A</td>
                        <td>JSR E453</td>
                        <td>Basic-Vektoren laden</td>
                    </tr>
                    <tr>
                        <td>801D</td>
                        <td>JSR E3BF</td>
                        <td>RAM für Basic initialisieren</td>
                    </tr>
                    <tr>
                        <td>8020</td>
                        <td>JSR 803D</td>
                        <td>Basic-Programm verschieben</td>
                    </tr>
                    <tr>
                        <td>8023</td>
                        <td>LDX #FB</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>8025</td>
                        <td>TXS</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>8026</td>
                        <td>LDA #52</td>
                        <td>Code für »r«</td>
                    </tr>
                    <tr>
                        <td>8028</td>
                        <td>STA 0277</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>802B</td>
                        <td>LDA #D5</td>
                        <td>Code für »U«</td>
                    </tr>
                    <tr>
                        <td>802D</td>
                        <td>STA 0278</td>
                        <td></td>
                    </tr>
                    <!-- New rows from the second image -->
                    <tr>
                        <td>8030</td>
                        <td>LDA #0D</td>
                        <td>Code für RETURN</td>
                    </tr>
                    <tr>
                        <td>8032</td>
                        <td>STA 0279</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>8035</td>
                        <td>LDA #03</td>
                        <td>3 Zeichen im Tastaturpuffer</td>
                    </tr>
                    <tr>
                        <td>8037</td>
                        <td>STA 00C6</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>803A</td>
                        <td>JMP E386</td>
                        <td>Sprung zum Basic-Warmstart</td>
                    </tr>
                    <tr>
                        <td>803D</td>
                        <td>LDA #5C</td>
                        <td>Anfangsadresse des zu verschiebenden Bereiches (Lowbyte)</td>
                    </tr>
                    <tr>
                        <td>803F</td>
                        <td>STA 005F</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>8041</td>
                        <td>LDA #80</td>
                        <td>Anfangsadresse des zu verschiebenden Bereiches (Highbyte)</td>
                    </tr>
                    <tr>
                        <td>8043</td>
                        <td>STA 0060</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>8045</td>
                        <td>LDA #6E</td>
                        <td>Endadresse des zu verschiebenden Bereiches (Lowbyte)</td>
                    </tr>
                    <tr>
                        <td>8047</td>
                        <td>STA 005A</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>8049</td>
                        <td>LDA #80</td>
                        <td>Endadresse des zu verschiebenden Bereiches (Highbyte)</td>
                    </tr>
                    <tr>
                        <td>804B</td>
                        <td>STA 005B</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>804D</td>
                        <td>LDA #14</td>
                        <td>Endadresse des Zielbereiches (Lowbyte)</td>
                    </tr>
                    <tr>
                        <td>804F</td>
                        <td>STA 0058</td>
                        <td></td>

                    </tr>
                    <tr>
                        <td>8051</td>
                        <td>STA 002D</td>
                        <td>Basic-Ende setzen (Lowbyte)</td>
                    </tr>
                    <tr>
                        <td>8053</td>
                        <td>LDA #08</td>
                        <td>Endadresse des Zielbereiches (Highbyte)</td>
                    </tr>
                    <tr>
                        <td>8055</td>
                        <td>STA 0059</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>8057</td>
                        <td>STA 002E</td>
                        <td>Basic-Ende setzen (Highbyte)</td>
                    </tr>
                    <tr>
                        <td>8059</td>
                        <td>JMP A3BF</td>
                        <td>Sprung zur Blockverschiebroutine</td>
                    </tr>
                </tbody>
            </table>

            <figcaption>Listing 3. Dieses Programm muß vor jedem Basic-Programm im EPROM stehen</figcaption>
        </figure>
    </article>
</body>

</html>
