<!DOCTYPE html>
<html lang="de">

<head>
    <title>Komfortable Befehlserweiterung</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Bernd Stuke, ev">
    <meta name="64er.issue" content="Sonderheft 5/85">
    <meta name="64er.pages" content="10-15">
    <meta name="64er.head1" content="Basic-Erweiterungen">
    <meta name="64er.toc_category" content="Basic-Erweiterungen">
    <meta name="64er.toc_title" content="Komfortable Befehlserweiterung<br>42 neue Basic-Befehle erleichtern das Programmieren.">
    <meta name="64er.id" content="basic-ex">
</head>

<body>
    <article>
        <h1>Komfortable Befehlserweiterung</h1>
        <p class="intro">»Basic-Expansion« ist ein universelles Programm, das den Befehlssatz des C 64 um 42 neue Kommandos erweitert, die das Arbeiten mit Floppy und Grafik enorm vereinfachen.</p>

        <p>Das Besondere an dieser Erweiterung ist zudem, daß sie sich »unter« dem Basic-ROM befindet. Trotz der Länge von 6625 Byte des Maschinenprogramms werden nur 260 Byte des freien Basic-RAM benötigt.</p>

        <p>Nachdem das Programm (siehe Listing) mit »SYS 40700« gestartet wurde, erscheint nach kurzer Zeit die Einschaltmeldung von »Basic-Expansion«. 42 neue Befehle (siehe Tabelle) können von nun an ganz normal verwendet werden.</p>

        <p><strong>Hier die neuen Befehle im Überblick:</strong><br>
            Bei der Beschreibung gelten folgende Symbole:<br>
            <strong>ga</strong>: Geräteadresse<br>
            <strong>lfn</strong>: logische Filenummer<br>
            <strong>fa</strong>: Farbe (1 bis 16, 1=schwarz, 2=weiß, 3=rot, etc.); der Farbcode entspricht genau der Anordnung auf der Tastatur (CRTL 1 = schwarz, CRTL 2 = weiß etc.)<br>
            <strong>PLOT x,y,fa</strong>: Punkt mit den Koordinaten (x,y) und der Farbe fa setzen (nur im Grafikmodus)<br>
            <strong>LINE a, b, x, y, fa</strong>: Linie von Punkt (a,b) bis Punkt (x,y) in der Farbe fa zeichnen<br>
            <strong>SETARC Startwinkel, Endwinkel, Schrittweite, Mittelpunkt x, Mittelpunkt y, Radius in x-Richtung, Radius in y-Richtung, Farbe fa</strong>: Diese Routine zeichnet einen Kreisbogen (im Bogenmaß) um einen Mittelpunkt.<br>
            <strong>Beispiel</strong>: »SETARC 0,2*3.14,0.1,200,100,100,3«zeichnet einen vollen Kreis um den Mittelpunkt (100,100) mit dem Radius 100 in roter Farbe.
        </p>

        <p>Diese Zeichenroutine kann jedoch nicht nur Punkte setzen, sondern auch wieder löschen. Dazu setzt man fa einfach auf Null.<br>
            Beispielsweise löscht»PLOT 100,100,0«den Punkt(100,100), weil der Farbcode gleich Null ist. Das giltauch für LINE und SETARC.<br>
            <strong>GRAPHICS</strong> schaltet die hochauflösende Grafik ein (320x200 Punkte).<br>
            <strong>NORM</strong> ist der Gegenbefehl zu GRAPHICS und schaltet wieder zurück in den Textmodus.<br>
            <strong>GCLEAR</strong> löscht eine hochauflösende Grafik.<br>
            <strong>GCOL r, h</strong> setzt die Farbe r als Rahmenfarbe und h als Hintergrundfarbe für die hochauflösende Grafik.<br>
            <strong>GSAVE "PRG-NAME", ga</strong> speichert die hochauflösende Grafik auf Kassette oder Diskette.<br>
            <strong>GLOAD "PRG-NAME", ga</strong> lädt eine hochauflösende Grafik von Diskette oder Kassette. GSAVE und GLOAD speichern, beziehungsweise laden auch den Farbspeicher der hochauflösenden Grafik.<br>
            <strong>COLOUR r, h</strong> arbeitet im Textmodus und setzt die Farben für Rahmen &reg; und Hintergrund (h).<br>
            <strong>HBLOCK l, fa</strong> zeichnet im Textmodus einen horizontalen Balken der Länge I in der Farbe fa ab der aktuellen Cursorposition und setzt den Cursor eine Zeile tiefer. L darf nur Werte zwischen 0 und 319 annehmen.<br>
            <strong>VBLOCK l, fa</strong> arbeitet wie HBLOCK, nur in vertikaler Richtung. Zugelassen sind Werte zwischen 0 und 199.<br>
            <strong>CURSCOL fa</strong> ändert die Cursorfarbe, das heißt man kann so die Schrittfarbe wählen.<br>
            <strong>SCROLL r, uz, oz</strong> scrollt den Bildschirm zwischen den Zeilen uz und oz in der Richtung, die der Parameter r angibt. Dabei bedeutet: 0 nach rechts; 1 nach oben; 2 nach links und 3 nach unten, uz ist die untere und oz die obere Zeile, die beide im Bereich zwischen 0 und 24 liegen.<br>
            <strong>DOKE a, b</strong> bedeutet ein »Doppelbyte-POKE«, das heißt, a und b sind 2-Byte-Zahlen. In die Speicherstelle a wird das Low-Byte von b gePOKEt, entsprechend wird der Speicherstelle a+1 das High-Byte von b zugewiesen.<br>
            <strong>SIZE</strong> gibt die Speicherplatzbelegung aus: gesamter Basic-Speicher, Programm, Variablen, Arrays, Strings, freier Basic-Speicher.<br>
            <strong>RESTORE n</strong> setzt den DATA-Zeiger auf die Zeile n oder auf die nächste darauffolgende Zeile, n muß dabei eine Zeilennummer sein. Der normale RESTORE-Befehl funktioniert natürlich auch noch.<br>
            <strong>ON&hellip;RESTORE a, b, c, d..</strong> läuft ähnlich ab wie ON..GOTO. Je nach dem Ergebnis des Ausdrucks nach dem ON-Befehl wird der DATA-Zeiger auf die Zeile a, b, c,.. positioniert.<br>
            <strong>MERGE "PRG-NAME", ga</strong> hängt ein Basic-Programm von Diskette oder Kassette mit Geräteadresse ga an ein im Speicher befindliches Basic-Programm an und sortiert die Basic-Zeilen nach ihren Zeilennummern.<br>
            <strong>GEN "String"</strong> arbeitet nur im Programm-Modus. Dieser Befehl erzeugt eine neue Basic-Zeile in einem Basic-Programm. Der String muß am Anfang eine Zeilennummer und danach den Basic-Text enthalten. Zum Beispiel erzeugt der Befehl GEN "10 DATA 1,2,3" die Basic-Zeile »10 DATA 1,2,3« im Programm. Nach der Erzeugung fährt das Programm mit der auf den GEN-Befehl folgenden Basic-Zeile fort. Der Computer springt nach dem GEN-Befehl immer in die nächste Zeile, so daß Basic-Befehle in derselben Zeile nach dem GEN-Befehl i nicht ausgeführt werden. Zu beachten ist aber, daß alle Variablenwerte gelöscht werden und daß der String nur 80 Zeichen umfassen darf. Und noch ein Hinweis: Enthält der String nur eine Zeilennummer, so wird die entsprechende Basic-Zeile gelöscht. In keinem Falle sollte der GEN-Befehl in einem Unterprogramm verwendet werden, da er den Basic-Stack manipuliert.<br>
            <strong>DUMP</strong> listet alle verwendeten Variablen tabellarisch auf. Lediglich die Arrays werden dabei nicht berücksichtigt.<br>
            <strong>ARRAY</strong> gibt sämtliche Arrays mit Werten aus. Die Ausgabe kann durch einmaligen Druck der SHIFTTaste angehalten werden. Dann wartet das Programm so lange, bis die Commodore-Taste gedrückt wird. Dies gewährleistet, daß der Benutzer alle Arraywerte genauestens ablesen kann.<br>
            <strong>RENUM z, s</strong> numeriert ein Basic-Programm neu. RENUM ändert neben den Zeilennummern die Adressen bei GOTO, GOSUB, THEN, RESTORE, RUN sowie bei sämtlichen ON..GOTO, ON..GOSUB oder ON..RESTORE-Ausdrücken. Z gibt die erste neue Zeilennummer, s die Schrittweite an. RENUM berücksichtigt ebenfalls, ob möglicherweise zu große Zeilennummern erreicht werden. Bevor die Zeilennummern verändert werden, wird geprüft, ob die zu erzeugenden Zeilennummern auch im Bereich 0 bis 64000 liegen, andernfalls wird eine Fehlermeldung ausgegeben. Die Schrittweite 0 wird auch nicht akzeptiert. RENUM kann im Programm-Modus verwendet werden. Dabei werden alle Variablenwerte gelöscht. Wie beim GEN-Befehl springt der Computer nach dem RENUM-Befehl automatisch in die nächste Basic-Zeile. Der RENUM-Befehl kann zwei Fehlermeldungen ausgeben: »US-ERROR IN xx« bedeutet, daß im Programm eine Sprungadresse nicht vorhanden war. »US« steht für »UNDEFINED STATEMENT«. Der RENUM-Befehl unterbricht jetzt aber nicht einfach, sondern er ersetzt die nicht-definierte Sprungadresse durch die Adresse derjenigen Basic-Zeile, die als nächste auf die nicht-definierte folgen würde. Die zweite Fehlermeldung lautet: »SN-ERROR IN xx«, welche anzeigt, daß bei einer Sprungadresse eine zu große Zahl angegeben wurde. Hier verfährt der Befehl so, daß statt der fehlerhaften Adresse die Adresse der ersten Basic-Zeile im Programm eingesetzt wird. Dadurch wird verhindert, daß ein Programm durch die falsche Adresse möglicherweise abstürzt. Die Zeilennummern xx in den Fehlermeldungen gibt natürlich die neue Adresse der Zeile an, in der ein Fehler auftrat.<br>
            <strong>OLD</strong> ist der Gegenbefehl zu NEW. So können durch NEW oder Reset gelöschte Programme wieder »zurückgeholt« werden.<br>
            <strong>CURSOR s,z(,"Drucktext")</strong> ist der Positionierbefehl für den Cursor. S gibt die Spalte (0 bis 39) und z die Zeile (0 bis 24) der gewünschten Position an. Es existieren zwei CURSOR-Varianten:<br>
            CURSOR s, z setzt nur den Cursor.<br>
            CURSOR s, z , "String" dagegen positioniert den Cursor auf die Position (s,z) und druckt an diese Stelle den Text »String«. Wird also hinter der Zeilenangabe noch ein Komma gesetzt, so wird praktisch wie beim PRINT-Befehl fortgefahren.
        </p>

        <p>Die nächsten Befehle beziehen sich nur auf das 1541-Floppy-Laufwerk. gn ist hierbei die Geräteadresse der Diskettenstation.<br>
            <strong>DIRgn</strong> listet das Directory der Diskette auf dem Bildschirm, ohne ein im Speicher befindliches Programm zu löschen. Der Benutzer kann während des Auflistens mit der gedrückten SHIFT-Taste das Listen so lange verzögern, bis die SHIFTTaste wieder entriegelt wird. Die Commodore-Taste unterbricht das Auflisten des Inhaltsverzeichnisses ebenfalls, nur wird damit das Listen einfach abgeschlossen und der Computer verarbeitet den nächsten Befehl.<br>
            <strong>RECORD#,lfn,rn(,bp)</strong> ist der Positionierbefehl für relative Dateien. Ifn bezeichnet die Filenummer des geöffneten relativen Files, rn stellt die Recordnummer (1-65535) und bp eventuell die Position innerhalb dieses Records (1-254) dar. Ohne Angabe von bp wird immer der Wert 1 angenommen.<br>
            <strong>DISC "Befehl", gn</strong> übermittelt dem 1541-Laufwerk DOS-Befehle wie zum Beispiel<br>
            DISC "I0", gn
        </p>

        <p>Hier wird die Diskette in der Floppy-Station mit der Geräteadresse gn initialisiert. Mit DISC können alle DOS-Befehle, die an den Befehlskanal gehen, übertragen werden. Die Befehle müssen aber innerhalb der Anführungsstriche stehen.<br>
            <strong>DISCGET# lfn,Variable$ (,Länge I)</strong> ist ein erweiterter INPUT #-Befehl. Ifn bezeichnet die logische Filenummer; danach muß eine Stringvariable angegeben werden. Diese Routine liest nun bis zum nächsten RETURN-Code Zeichen ein und speichert sie unter der Stringvariablen ab. Dabei können bis zu 255 Zeichen eingelesen werden. Wird zusätzlich noch eine Länge I mit angegeben, so liest der Befehl genau I Zeichen ein, so daß die Stringlänge der Variablen vorbestimmt wird. Dies erweist sich beispielsweise beim Einlesen von Records aus relativen Dateien als sehr nützlich, denn hier kann der Parameter I die Länge des Records darstellen.<br>
            <strong>PROTECT "File-Name", gn</strong> schützt ein File auf der Diskette gegen den SCRATCH-Befehl. Files, die so geschützt sind, werden im Directory gesondert gekennzeichnet. Mit dem SCRATCH-Befehl können diese Files nicht mehr gelöscht werden.<br>
            <strong>FREE &ldquo;File-Name&rdquo;, gn</strong> ist der Gegenbefehl zum PROTECT-Befehl. Hiermit werden geschützte Files auf der Diskette wieder freigegeben und können nun mit SCRATCH gelöscht werden. Für PROTECT und FREE gibt es auch die Möglichkeit, den Namen des Files mit dem Jokerzeichen &ldquo; * &rdquo; abzukürzen.<br>
            <strong>DOSTYPE &ldquo;Stringzeichen &rdquo;, gn</strong> verändert das DOS-Flag der Floppy-Station. Das Zeichen »A« kennzeichnet das DOS der VC 1541. Wird jetzt DOSTYPE &ldquo;B&rdquo;, gn eingegeben, so hat der Benutzer das DOS-Flag verändert. Dies aber bedeutet, daß man nichts mehr auf die Diskette schreiben kann. Bei jedem Schreibbefehl wird geprüft, ob auch das »richtige« DOS-Flag vorhanden ist (DOS»A«), Trifft dies nicht zu, so kann eine Diskette nicht mehr beschrieben werden. Durch »DOSTYPE <strong>&ldquo;A&rdquo;,gn</strong>« erzeugt man wieder das richtige DOS-Flag, so daß die Diskette wieder beschrieben werden kann. Insofern bedeutet der DOSTYPE-Befehl eine Art Schreibschutz der Diskette. Anzumerken ist noch, daß die Routine immer nur das erste Zeichen im Stringausdruck berücksichtigt.<br>
            @: Dieser Befehl dient demjenigen, der mit dieser Basic-Erweiterung noch nicht zufrieden ist, als zusätzlicher Erweiterungsbefehl. Der @-Befehl bewirkt normalerweise nichts. Der Zeiger in der Sprungtabelle der Basic-Befehle ist auf ein RETURN (RTS) positioniert. Der Benutzer kann nun ein Maschinenprogramm mit dem Klammeraffen aufrufen. Dazu muß er die Werte in der Sprungtabelle für den @-Befehl ändern. Der Sprungvektor liegt in den Speicherstellen 40221 und 40222 (dezimal). Normalerweise steht dort der Vektor 40804, weil in der Speicherstelle 40805 ein RTS-Code enthalten ist. Der Sprungvektor kann vom Benutzer verändert werden (durch die POKE- oder DOKE-Befehle), indem der Vektor auf die Einsprungadresse gesetzt wird. Wenn ein Programmierer beispielsweise einen neuen Befehl als Maschinenprogramm ab Adresse 828 (Kassettenpuffer) angelegt hat, so POKEt er das Low-Byte von (828—1) in 40221 ein und speichert das High-Byte von (828—1) in 40222 ab. Nun kann die neue Routine mit @ angesprochen werden. Durch Zuweisung des ursprünglichen Wertes von (40805—1) in die Speicherstellen der Sprungtabelle wird der neue Befehl wieder aufgehoben.<br>
            <strong>Soweit die neuen Befehle. Nun kommen wir zu den neuen Funktionen der Erweiterung:</strong><br>
            <strong>RAM (xx)</strong> gibt den Inhalt der RAM-Speicherstelle xx an und ähnelt dadurch sehr der PEEK-Funktion. Doch die RAM-Funktion liest die Werte immer aus dem RAM aus. Zusätzlich wird im Bereich $D000 bis $DFFF (hexadezimal) der Charaktergenerator ausgelesen, so daß die Werte für die Zeichen aus dem Charakter-ROM aufgelistet werden können.<br>
            <strong>CVAL (&ldquo;String &rdquo;)</strong> ähnelt der VAL-Funktion, kann jedoch auch Rechnungen auswerten. So ergibt »CVAL(&ldquo;5*6+3&rdquo;)« als Beispiel den Wert 33, wogegen »VAL(&ldquo;5*6+3&rdquo;)« gleich 5 ist. CVAL verarbeitet alle Funktionen, jedoch darf der String nicht länger als 80 Zeichen sein.<br>
            <strong>ROUND(x,y)</strong> rundet eine Zahl x auf y Nachkommastellen. Somit kann man eine Fließkommazahl auf eine ganze Zahl runden, wenn y=0 ist.<br>
            <strong>&amp;(xxxx)</strong> wandelt die dezimale Zahl xxxx (oder einen numerischen Integer-Ausdruck) in den entsprechenden hexadezimalen String, welcher zwei oder vier Zeichen umfaßt, je nachdem ob der Wert xxxx kleiner oder größer als 256 ist. Der Ausdruck xxxx muß eine positive Zwei-Byte-Zahl darstellen. Beispiel: »PRINT &amp;(15)« ergibt »OF«.<br>
            <strong>!(&ldquo;yyyy&rdquo;)</strong> ist das Gegenstück zur &amp;-Funktion. Sie wandelt einen hexadezimalen String in die entsprechende dezimale, positive Zwei-Byte-Zahl. Der String muß zwei oder viör Zeichen umfassen, je nachdem ob der Hex-Wert kleiner oder größer als &ldquo;FF&rdquo; ist.<br>
            <strong>TEST(x,y)</strong> fragt ab, ob in der hochauflösenden Grafik der Punkt mit den Koordinaten (x,y) gesetzt ist. Trifft dies zu, so erhält man das Ergebnis -1, sonst ergibt sich der Wert 0.<br>
            <strong>INSTR(1. String, 2. String)</strong> oder <strong>INSTR(1. String, 2. String, a)</strong> untersucht, ob der zweite String im ersten String enthalten ist und gibt die Position an, ab der der zweite String gefunden wird. Ist der zweite String nicht im ersten String enthalten, so wird eine Null ausgedruckt. Der Parameter a, der zusätzlich mit angegeben werden kann, gibt die Position im ersten String an, ab der getestet werden soll, ob der zweite String ein Teil des ersten ist. Wird a nicht mit angegeben, so wird er automatisch auf 1. gesetzt, das heißt es wird ab der ersten Position im ersten String untersucht.<br>
            <strong>DS$(ga)</strong> liest den Fehlerkanal der Floppy-Station aus, wobei ga die Geräteadresse angibt.<br>
            <strong>DS(ga)</strong> ermittelt nur die Nummer der Fehlermeldung der Floppy-Station mit der Geräteadresse ga.<br>
            <strong>HEADBYT (&ldquo;File-Name&rdquo;, ga, n)</strong> bezieht sich auf das n-te Byte im Eintrag eines Files im Inhaltsverzeichnis. Die Geräteadresse ist ga. Der String »File-Name« stellt den Namen des Files dar. Jeder Eintrag eines Files enthält 30 Byte mit wichtigsten Informationen über Länge des Files, File-Typ etc. Diese Bytes können nun einzeln mit der HEADBYT-Funktion ausgelesen werden. Beispielsweise stellt Byte 0 im Eintrag eines Files den File-Typ dar. Mit der HEADBYT-Funktion kann der Benutzer den File-Typ auslesen, wobei n=0 sein muß. Bei einer relativen Datei befindet sich im 21. Byte des Eintrags die Recordlänge, so daß mit HEADBYT die Recordlänge schnell festgestellt werden kann (bei n=21). Zu beachten ist, daß der Parameter n nur im Bereich 0 bis 29 liegen darf. Welche Bedeutung nun die einzelnen Bytes im Eintrag eines Files haben, läßt sich anhand des Bedienungshandbuches für die 1541 feststellen. Wichtig ist auch noch, daß bei der Angabe des File-Namens mit dem Jokerzeichen »*« gearbeitet werden kann. DEEK(xxxx) stellt ein Doppelbyte-PEEK dar. DEEK (xxxx) ist die Gegenfunktion zu DOKE. Es werden die Inhalte der Speicherstellen xxxx und xxxx+1 als positive Zwei-Byte-Zahl dargestellt. xxxx muß die Adresse des Low-Bytes markieren; das Ergebnis ist eine Zahl zwischen 0 und 65535. Die DEEK-Funktion liest immer aus dem RAM aus. In den Bereichen des Basic-lnterpreter-ROMs und dem Betriebssystem-ROMs wird ebenfalls immer das RAM ausgelesen. Das ROM kann nur mit PEEK ausgelesen werden. DEEK unterscheidet sich von der RAM-Funktion nur im Bereich $D000 bis $DFFF. Hier hat DEEK keinen Zugriff auf den Charaktergenerator.
        </p>

        <p>Soweit sind nun alle neuen Befehle und Funktionen beschrieben worden. Eines sollte man jedoch unbedingt beachten: Bei der Benutzung des THEN-Befehls muß darauf geachtet werden, daß nach dem THEN ein Doppelpunkt»:«folgt, um danach die neuen Basic-Befehle benutzen zu können. Wird der Doppelpunkt weggelassen, so gibt der Computer »SYNTAX ERROR« aus, wenn nach THEN ein neuer Basic-Befehl verwendet wird.<br>
            <strong>Hinweise zur Eingabe:</strong>
        </p>

        <p>Geben Sie das Programm mit dem MSE ein (siehe Seite 8). Geladen wird es dann mit »LOAD".. &ldquo;,8,1«. Danach geben Sie bitte NEW ein. Der Start erfolgt mit »SYS 40700«.</p>

        <p>Sollte während der Benutzung der Erweiterung ein RESET ausgelöst werden, so erscheint wieder das gewohnte Bild des Basic V2, was jedoch nicht heißt, daß die Basic-Erweiterung gelöscht worden ist. Die Erweiterung ist nicht gegen RESETs des Computers geschützt. Um das zu erreichen, hätte der gesamte Bereich von hexadezimal $8000 bis $A000 vor Überschreiben geschützt werden müssen, was aber einem Basic-Speicherverlust von 8 KByte gleichkäme. Doch eben dieser Speicherverlust sollte vermieden werden. Dem Benutzer sollte noch möglichst viel Speicherplatz für Basic-Programme und Daten zur Verfügung stehen. Doch wenn der Benutzer nach einem RESET sofort »SYS 40700« eingibt, so ist die Basic-Erweiterung wieder aktiviert, wenn nicht schwerwiegende Programmfehler einen Teil der Erweiterung verändert haben.</p>

        <address class="author">(Bernd Stuke/ev)</address>

        <figure>
            PLOT<br>
            LINE<br>
            SETARC<br>
            GRAPHICS<br>
            NORM<br>
            GCLEAR<br>
            GCOL<br>
            COLOUR<br>
            GLOAD<br>
            GSAVE<br>
            HBLOCK<br>
            VBLOCK<br>
            CURSCOL<br>
            SCROLL<br>
            DOKE<br>
            SIZE<br>
            MERGE<br>
            GEN<br>
            DUMP<br>
            ARRAY<br>
            RENUM<br>
            OLD<br>
            DOSTYPE<br>
            DIR<br>
            RECORD #<br>
            DISCGET #<br>
            DISC<br>
            PROTECT<br>
            FREE<br>
            CURSOR<br>
            @ (KLAMMERAFFE)<br>
            RAM<br>
            CVAL<br>
            ROUND<br>
            ! (AUSRUFZEICHEN)<br>
            & (UND-ZEICHEN)<br>
            TEST<br>
            INSTR<br>
            DS$<br>
            DS<br>
            HEADBYT<br>
            DEEK<br>
            RESTORE<br>
            ON RESTORE<br>
            <figcaption>Tabelle 1. Liste aller neuen Befehle und Funktionen</figcaption>
        </figure>

        <figure>
            <pre data-filename="basic-ex_mse.prg" data-name="Basic-Expansion" data-mse=mse1></pre>
            <figcaption>Listing »Basic-Expansion«. Bitte mit dem MSE eingeben. Beachten Sie die Eingabehinweise auf Seite 8.</figcaption>
        </figure>
        <div class="binary_download" data-filename="basic-ex_mse.prg" data-name="XXXXXXXXXXXXXXX"></div>
    </article>
</body>

</html>
