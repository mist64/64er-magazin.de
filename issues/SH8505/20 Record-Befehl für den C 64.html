<!DOCTYPE html>
<html lang="de">

<head>
    <title>Record-Befehl für den C 64</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Bernward Bretthauer, rg">
    <meta name="64er.issue" content="Sonderheft 5/85">
    <meta name="64er.pages" content="20-21">
    <meta name="64er.head1" content="Basic-Erweiterungen">
    <meta name="64er.toc_category" content="Basic-Erweiterungen">
    <meta name="64er.toc_title" content="Record-Befehl für den C 64<br>Ein kleines Maschinenprogramm, das den RECORD-Befehl implementiert.">
    <meta name="64er.id" content="record-bef">
</head>

<body>
    <article>
        <h1>Record-Befehl für den C 64</h1>
        <p class="intro">Dieses Programm erleichtet Ihnen den Umgang mit relativen Files.</p>

        <p>Bei relativen Files kann auf jeden Satz des Files direkt zugegriffen werden, ohne die vorherigen Sätze lesen zu müssen. Außerdem kann ein eröffnetes File nach Belieben beschrieben und gelesen werden, es ist also zum Beispiel möglich, Satz 12 zu beschreiben, auch wenn bereits höhere Sätze existieren. Ein relatives File wird durch folgenden OPEN-Befehl eingerichtet:</p>

        <p>OPEN lfn,ga,sa,”filename,l,”+chr$(sl). Dabei bedeutet:<br>
            <strong>lfn</strong> = logische Filenummer.<br>
            <strong>ga</strong> = Geräteadresse (normalerweise 8)<br>
            <strong>sa</strong> = Sekundäradresse (mindestens 2, höchstens 14)<br>
            <strong>sl</strong> = maximale Satzlänge des relativen Files (mindestens 1, höchstens 254). Diese Angabe ist entscheidend für den späteren Diskettenplatzverbrauch des Files, da auch Sätze, die nicht mit voller Satzlänge beschrieben werden, den gesamten durch sl reservierten Platz verbrauchen. Ist ein relatives File erst einmal eingerichtet, so kann die Satzlänge nicht mehr verändert werden. Es genügt dann der folgende OPEN-Befehl:<br>
            OPEN lfn,ga,sa,”filename”
        </p>

        <p>Selbstverständlich muß ein relatives File auch mit CLOSE lfn geschlossen werden. Auf die einzelnen Sätze eines relativen Files wird normal mit PRINT #lfn, INPUT#lfn oder GET#lfn zugegriffen, allerdings muß vor jedem Zugriff auf den gewünschten Satz positioniert werden. Dies übernimmt die vorliegende Basic-Erweiterung.</p>

        <p>Durch <strong>RECORD#lfn,sn,(,p)</strong> wird auf den Satz mit der Nummer sn positioniert, wird zusätzlich noch p angegeben, so wird innerhalb des Satzes das p-te Zeichen angewählt. Der neue Befehl muß von THEN durch einen Doppelpunkt abgetrennt werden. Es können folgende Basic-Fehlermeldungen auftreten:<br>
            ?SYNTAX ERROR: Schreibfehler im Befehl oder die Erweiterung war nicht eingeschaltet.<br>
            ?ILLEGAL QUANTITY ERROR: Ein Argument lag außerhalb des erlaubten Bereichs.<br>
            ?FILE NOT OPEN ERROR: Das File mit der logischen Filenummer lfn war nicht eröffnet.<br>
            ?ILLEGAL DEVICE NUMBER ERROR: Dem File mit der Nummer lfn ist ein Gerät mit einer Adresse kleiner als 8 oder größer als 15 zugeordnet.<br>
            Es können außerdem folgende Floppy-Fehlermeldungen auftreten (Sie müssen durch den Fehlerkanal ausgelesen werden):<br>
            50,RECORD NOT PRESENT: Der Satz, auf den positioniert wurde, existiert nicht. Diese Meldung kann ignoriert werden, wenn der Satz beschrieben werden soll, denn durch das Beschreiben wird er eingerichtet. (Und alle nicht existierende Sätze mit kleinerer Nummer ebenfalls.) Aus Geschwindigkeitsgründen empfiehlt es sich, bei der Einrichtung eines Files den höchsten Satz zuerst zu beschreiben.<br>
            51,OVERFLOW IN RECORD: Die maximale Satzlänge sl wurde beim Schreiben überschritten. Zu beachten ist, daß das Carriage Return am Ende des Satzes mitzählt.<br>
            52,FILE TOO LARGE: Die Diskette ist voll, der letzte Schreibzugriff kann nicht durchgeführt werden.</p>

        <h3>Aufbau des Programms</h3>

        <p>Der Basic-Interpreter besitzt einen Zeiger (Adresse $0308, im Listing »decod« genannt), der auf die Routine zur Befehlsinterpretation zeigt. Dieser Vektor wird nach dem Aufruf der Erweiterung zuerst gemerkt und danach auf eine eigene Routine zur Befehlsinterpretation gesetzt. Vor dem Merken wird noch geprüft, ob der Vektor schon auf die eigene Routine zeigt. Damit wird verhindert, daß der Computer bei einem versehentlichen Doppelaufruf abstürzt. Die eigene Routine rettet zunächst den Zeiger, der auf das augenblickliche Zeichen im Basic-Text zeigt, und ruft dann die CHRGET-Routine (Befehlscodierung siehe Bild 1, Symboltabelle Bild 2) auf. Diese Routine holt das nächste Zeichen aus dem Basic-Text. Sie überliest automatisch Leerzeichen. Wenn das Ende einer Zeile oder ein Doppelpunkt erreicht wird, so wird die Z-Flag des Prozessors gesetzt. Ein Problem ergibtsich dadurch, daß in »RECORD#« der Simons Basic-Befehl »REC« vorkommt. Er wird bei Verwendung von Simons Basic also in eine interne Darstellung beginnend mit $64 umgewandelt. Das Programm testet daher, ob $64 vorliegt und verzweigt bei positiver Antwort. In beiden Fällen wird nun getestet, ob der Befehl »RECORD#«vorliegt. Unter dem Namen tab 1 (beziehungsweise tab 2 für Simons Basic) steht (rückwärts) die interne Darstellung des Befehls »RECORD«. Dabei ist zu beachten, daß »OR« wiederum nicht im ASCII-Code abgelegt ist, sondern als Token. Wird nur eine Abweichung gefunden, so wird der gemerkte CHRGET-Zeiger zurückgeholt und zur normalen Interpreterroutine gesprungen, anderenfalls tritt eine eigene Routine in Funktion (sie beginnt beim Label OK). Sie holt die Satznummer und, wenn angegeben, die Position im Satz aus dem Basic-Text und sendet die Informationen an die Floppy über die Sekundäradresse 15 (Kommandokanal). Die Floppy erwartet die Werte in folgender Form: »p« als Zeichen, das positioniert werden soll; die Sekundäradresse, mit der das relative File eröffnet wurde; die Satznummer in der Reihenfolge niederwertiges — höherwertiges Byte und, falls angegeben, die Position im Satz. Es werden folgende Routinen des Interpreters und des Betriebssystems verwendet:</p>

        <table class="plain">
            <tr>
                <td><strong>getbyt</strong></td>
                <td>Holt einen beliebigen Ausdruck in das x-Register.</td>
            </tr>
            <tr>
                <td><strong>search</strong></td>
                <td>Sucht nach der logischen Filenummer in x.</td>
            </tr>
            <tr>
                <td><strong>parset</strong></td>
                <td>Holt logische Filenummer, Geräteadresse und Sekundäradresse in die Speicherzellen $b8,$ba und $b9</td>
            </tr>
            <tr>
                <td><strong>listen</strong></td>
                <td>Teilt dem angesprochenen Gerät mit, daß es Daten empfangen soll.</td>
            </tr>
            <tr>
                <td><strong>seclis</strong></td>
                <td>Sendet die Sekundäradresse zum angesprochenen Gerät.</td>
            </tr>
            <tr>
                <td><strong>iecout</strong></td>
                <td>Sendet den Wert im Akkumulator zum angesprochenen Gerät.</td>
            </tr>
            <tr>
                <td><strong>chkcom</strong></td>
                <td>Prüft auf Komma im Basic-Text.</td>
            </tr>
            <tr>
                <td><strong>getrec</strong></td>
                <td>Holt einen numerischen Ausdruck in den Fließkomma-Akkumulator.</td>
            </tr>
            <tr>
                <td><strong>fac16</strong></td>
                <td>Wandelt den Wert im Fließkomma-Akkumulator in eine 16-Bit-Zahl und speichert sie in $14 und $15.</td>
            </tr>
            <tr>
                <td><strong>comget</strong></td>
                <td>= chkcom + getbyte.</td>
            </tr>
            <tr>
                <td><strong>unlist</strong></td>
                <td>Beendet die Übertragung an die Floppy.</td>
            </tr>
        </table>

        <p>Das Programm wurde mit dem Assembler »ASSI« übersetzt, eine Übernahme auf andere Assembler dürfte nicht schwierig sein. Der Basic-Lader (Listing 1, Source-Code: Listing 2) legt das Programm ab der Adresse 49152 ($C000) ab, schaltet die Erweiterung ein und löscht sich dann selbst, er muß also vorher auf Diskette abgespeichert werden. Die Erweiterung wird durch SYS49152 ein- und durch SYS49155 ausgeschaltet. STOP/RESTORE schaltet die Erweiterung nicht ab.</p>

        <address class="author">(Bernward Bretthauer/rg)</address>

        <figure>
            * = 49152
            <table class="plain">
                <tr>
                    <td>chrget</td>
                    <td>= $73</td>
                    <td>; holt nächstes Zeichen</td>
                </tr>
                <tr>
                    <td>chrgot</td>
                    <td>= $79</td>
                    <td>; holt letztes Zeichen</td>
                </tr>
                <tr>
                    <td>chrvek</td>
                    <td>= $7a</td>
                    <td>; Chrgetzeiger</td>
                </tr>
                <tr>
                    <td>decod</td>
                    <td>= $0308</td>
                    <td>; Vektor für Befehlsdec.</td>
                </tr>
                <tr>
                    <td>error</td>
                    <td>= $4a37</td>
                    <td>; Fehlermeldung ausgeben</td>
                </tr>
                <tr>
                    <td>schleife</td>
                    <td>= $a7ae</td>
                    <td>; Interpreterschleife</td>
                </tr>
                <tr>
                    <td>getrec</td>
                    <td>= $b083</td>
                    <td>; Recordnummer holen</td>
                </tr>
                <tr>
                    <td>chkcom</td>
                    <td>= $aefd</td>
                    <td>; prüft auf Komma</td>
                </tr>
                <tr>
                    <td>getbyt</td>
                    <td>= $b79b</td>
                    <td>; holt Byte in x</td>
                </tr>
                <tr>
                    <td>comget</td>
                    <td>= $b711</td>
                    <td>; chkcom + getbyt</td>
                </tr>
                <tr>
                    <td>fac16</td>
                    <td>= $b77c</td>
                    <td>; FAC nach 16-Bit wandeln</td>
                </tr>
                <tr>
                    <td>search</td>
                    <td>= $f30f</td>
                    <td>; sucht logische Filenr.</td>
                </tr>
                <tr>
                    <td>parset</td>
                    <td>= $f30c</td>
                    <td>; setzt Fileparameter</td>
                </tr>
                <tr>
                    <td>listen</td>
                    <td>= $ffb1</td>
                    <td>; LISTEN senden</td>
                </tr>
                <tr>
                    <td>seclis</td>
                    <td>= $ff93</td>
                    <td>; Sekundärad. nach LISTEN</td>
                </tr>
                <tr>
                    <td>iecou t</td>
                    <td>= $ffa8</td>
                    <td>; Ausgabe auf IEC-bus</td>
                </tr>
                <tr>
                    <td>unlist</td>
                    <td>= $ffae</td>
                    <td>; UNLISTEN senden</td>
                </tr>
                <tr>
                    <td>integ</td>
                    <td>= $14</td>
                    <td>; Integer Wert</td>
                </tr>
                <tr>
                    <td>filenr</td>
                    <td>= $b8</td>
                    <td>; logische Filenummer</td>
                </tr>
                <tr>
                    <td>secadr</td>
                    <td>= $b9</td>
                    <td>; Sekundäradresse</td>
                </tr>
                <tr>
                    <td>ga</td>
                    <td>= $ba</td>
                    <td>; Gerätenummer</td>
                </tr>
            </table>

            <figcaption>Bild 1. Befehlscodierung</figcaption>
        </figure>

        <figure>
            <table>
                <tr>
                    <td>0073</td>
                    <td>chrget</td>
                </tr>
                <tr>
                    <td>0079</td>
                    <td>chrgot</td>
                </tr>
                <tr>
                    <td>007a</td>
                    <td>chrvek</td>
                </tr>
                <tr>
                    <td>0308</td>
                    <td>decod</td>
                </tr>
                <tr>
                    <td>a437</td>
                    <td>error</td>
                </tr>
                <tr>
                    <td>a7ae</td>
                    <td>schleife</td>
                </tr>
                <tr>
                    <td>ad8a</td>
                    <td>getrec</td>
                </tr>
                <tr>
                    <td>aefd</td>
                    <td>chkcom</td>
                </tr>
                <tr>
                    <td>b79e</td>
                    <td>getbyt</td>
                </tr>
                <tr>
                    <td>b7f1</td>
                    <td>comget</td>
                </tr>
                <tr>
                    <td>b7f7</td>
                    <td>fac16</td>
                </tr>
                <tr>
                    <td>f30f</td>
                    <td>search</td>
                </tr>
                <tr>
                    <td>f31f</td>
                    <td>parset</td>
                </tr>

                <tr>
                    <td>ffb1</td>
                    <td>listen</td>
                </tr>
                <tr>
                    <td>ff93</td>
                    <td>seclis</td>
                </tr>
                <tr>
                    <td>ffa8</td>
                    <td>iecout</td>
                </tr>
                <tr>
                    <td>ffae</td>
                    <td>unlist</td>
                </tr>
                <tr>
                    <td>0014</td>
                    <td>integ</td>
                </tr>
                <tr>
                    <td>00b8</td>
                    <td>filenr</td>
                </tr>
                <tr>
                    <td>00b9</td>
                    <td>secadr</td>
                </tr>
                <tr>
                    <td>00ba</td>
                    <td>ga</td>
                </tr>
                <tr>
                    <td>c019</td>
                    <td>endoff</td>
                </tr>
                <tr>
                    <td>c01a</td>
                    <td>vekt</td>
                </tr>
                <tr>
                    <td>c01c</td>
                    <td>flag</td>
                </tr>
                <tr>
                    <td>c01d</td>
                    <td>on</td>
                </tr>
                <tr>
                    <td>c02c</td>
                    <td>l1</td>
                </tr>

                <tr>
                    <td>c036</td>
                    <td>l2</td>
                </tr>
                <tr>
                    <td>c041</td>
                    <td>tab1</td>
                </tr>
                <tr>
                    <td>c047</td>
                    <td>tab2</td>
                </tr>
                <tr>
                    <td>c04b</td>
                    <td>record</td>
                </tr>
                <tr>
                    <td>c05a</td>
                    <td>13</td>
                </tr>
                <tr>
                    <td>c067</td>
                    <td>simon</td>
                </tr>
                <tr>
                    <td>c06c</td>
                    <td>13s</td>
                </tr>
                <tr>
                    <td>c079</td>
                    <td>out</td>
                </tr>
                <tr>
                    <td>c082</td>
                    <td>ok</td>
                </tr>
                <tr>
                    <td>c091</td>
                    <td>14</td>
                </tr>
                <tr>
                    <td>c09f</td>
                    <td>illdev</td>
                </tr>
                <tr>
                    <td>c0a4</td>
                    <td>15</td>
                </tr>
                <tr>
                    <td>c0da</td>
                    <td>ende</td>
                </tr>
            </table>
            <figcaption>Bild 2. Symbol-Tabelle</figcaption>
        </figure>

        <figure>
            <pre data-filename="record-bef." data-name="Record-Befehle"></pre>
            <figcaption>Listing 1. Basic-Lader »Record-Befehle«. Bitte beachten Sie die Eingabehinweise auf Seite 6.</figcaption>
        </figure>

        <figure>
            <pre>     * = 49152 ;Startadresse

       jmp on       ;zum Einbinden       c000 4c 1d c0

;******* Erweiterung abschalten *******
       lda flag     ;schon abgeschaltet? c003 ad 1c c0
       beq endoff                        c006 f0 11
       lda vekt     ;Vektor wieder her-  c008 ad 1a c0
       sta decod    ;stellen             c00b 8d 08 03
       lda vekt+1                        c00e ad 1b c0
       sta decod+1                       c011 8d 09 03
       lda #0       ;Flag fuer Abge-     c014 a9 00
       sta flag     ;schaltet setzen     c016 8d 1c c0
endoff rts                               c019 60
vekt   .word $a7e4                       c01a e4 a7
flag   .byte $00                         c01c 00

;******* Erweiterung einschalten ******
on     lda #$ff     ;Flag fuer Einge-    c01d a9 ff
       sta flag     ;schaltet setzen     c01f 8d 1c c0
       lda decod                         c022 ad 08 03
       cmp #&lt;record                      c025 c9 4b
       beq l1                            c027 f0 03
       sta vekt                          c029 8d 1a c0
l1     lda decod+1                       c02c ad 09 03
       cmp #>record                      c02f c9 c0
       beq l2                            c031 f0 03
       sta vekt+1                        c033 8d 1b c0
l2     lda #&lt;record                      c036 a9 4b
       sta decod                         c038 8d 08 03
       lda #>record                      c03b a9 c0
       sta decod+1                       c03d 8d 09 03

       rts                               c040 60
;****** Interpreterdarstellung von ****
;****** RECORD#                    ****
tab1   .byte $23,$44,$b0,$43,$45,$52     c041 23 44 b0 43 45 52
tab2   .byte $23,$44,$b0,$08             c047 23 44 b0 08

;****** Test auf RECORD#           ****
record
       lda chrvek      ;Chrgetzeiger     c04b a5 7a
       pha             ;retten           c04d 48
       lda chrvek+1                      c04e a5 7b
       pha                               c050 48
       jsr chrget                        c051 20 73 00
       cmp #$64        ;Simon´s Basic    c054 c9 64
       beq simon       ;TOKEN            c056 f0 0f
       ldy #6                            c058 a0 06
l3     cmp tab1-1,y                      c05a d9 40 c0
       bne out                           c05d d0 1a
       jsr chrget                        c05f 20 73 00
       dey                               c062 88
       bne l3                            c063 d0 f5
       beq ok                            c065 f0 1b
simon  jsr chrget                        c067 20 73 00
       ldy #4                            c06a a0 04
l3s    cmp tab2-1,y                      c06c d9 46 c0
       bne out                           c06f d0 08
       jsr chrget                        c071 20 73 00
       dey                               c074 88
       bne l3s                           c075 d0 f5
       beq ok                            c077 f0 09
;****** Weiter mit normalem Basic  ****
out    pla                               c079 68
       sta chrvek+1                      c07a 85 7b
       pla                               c07c 68
       sta chrvek                        c07d 85 7a
       jmp (vekt)                        c07f 6c 1a c0
;****** eigentlicher RECORD#-Befehl ***
ok     pla         ;Zeiger von Stack     c082 68
       pla                               c083 68
       jsr getbyt  ;holt Byte nach x     c084 20 9e b7
       jsr search  ;sucht log. Filenr.   c087 20 0f f3
       beq l4      ;gefunden             c08a f0 05
       ldx #3      ;file not open        c08c a2 03
       jmp error   ;ausgeben             c08e 4c 37 a4
l4     jsr parset  ;Fileparameter setzen c091 20 1a f0
       lda secadr  ;Sekundaeradresse     c094 a5 b9
       and #$0f                          c096 29 0f
       pha         ; = Kanalnummer       c098 48
       lda ga                            c099 a5 ba
       cmp #16                           c09b c9 10
       bcc l5      ;ga &lt; 16              c09d 90 05
illdev ldx #9      ;illegal device nr.   c09f a2 09
       jmp error                         c0a1 4c 37 a4
l5     cmp #8                            c0a4 c9 08
       bcc illdev  ;ga &lt; 8               c0a6 90 f7
       jsr listen                        c0a8 20 b1 ff
       lda #$6f    ;15 and $60           c0ab a9 6f
       sta secadr                        c0ad 85 b9
       jsr seclis                        c0af 20 93 ff
       lda #'p     ;positionieren        c0b2 a9 50
       jsr iecout  ;senden               c0b4 20 a8 ff
       jsr chkcom                        c0b7 20 fd ae
       jsr getrec  ;Recordnummer holen   c0ba 20 44 b9
       jsr fac16   ;FAC nach 16-Bit      c0bd 20 f7 b7
       pla         ;Kanalnummer          c0c0 68
       jsr iecout                        c0c1 20 a8 ff
       lda integ   ;Recordnr. lo         c0c4 a5 14
       jsr iecout                        c0c6 20 a8 ff
       lda integ+1 ;Recordnr. hi         c0c9 a5 15
       jsr iecout                        c0cb 20 a8 ff
       jsr chrgot  ;letztes Zeichen      c0ce 20 79 00
       beq ende    ;kein dritter Param.? c0d1 f0 07
       jsr comget  ;Komma und Parameter  c0d3 20 7d b7
       txa                               c0d6 8a
       jsr iecout  ;Position in Record   c0d7 20 a8 ff
ende   jsr unlist                        c0da 20 ae a7
       jmp schleife;zur Interpreterschl. c0dd 4c ae a7</pre>
            <figcaption>Listing 2. Source-Code von »Record-Befehl«</figcaption>
        </figure>
    </article>
</body>

</html>
