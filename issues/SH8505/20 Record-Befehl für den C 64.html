<!DOCTYPE html>
<html lang="de">

<head>
    <title>Record-Befehl für den C 64</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Bernward Bretthauer, rg">
    <meta name="64er.issue" content="Sonderheft 5/85">
    <meta name="64er.pages" content="20-21">
    <meta name="64er.toc_category" content="Basic-Erweiterungen">
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="record-bef">
</head>

<body>
    <article>
        <h1>Record-Befehl für den C 64</h1>
        <p class="intro">Dieses Programm erleichtet Ihnen den Umgang mit relativen Files.</p>

        <p>Bei relativen Files kann auf jeden Satz des Files direkt zugegriffen werden, ohne die vorherigen Sätze lesen zu müssen. Außerdem kann ein eröffnetes File nach Belieben beschrieben und gelesen werden, es ist also zum Beispiel möglich, Satz 12 zu beschreiben, auch wenn bereits höhere Sätze existieren. Ein relatives File wird durch folgenden OPEN-Befehl eingerichtet:</p>

        <p>OPEN lfn,ga,sa,”filename,l,”+chr$(sl). Dabei bedeutet:<br>
            <strong>lfn</strong> = logische Filenummer.<br>
            <strong>ga</strong> = Geräteadresse (normalerweise 8)<br>
            <strong>sa</strong> = Sekundäradresse (mindestens 2, höchstens 14)<br>
            <strong>sl</strong> = maximale Satzlänge des relativen Files (mindestens 1, höchstens 254). Diese Angabe ist entscheidend für den späteren Diskettenplatzverbrauch des Files, da auch Sätze, die nicht mit voller Satzlänge beschrieben werden, den gesamten durch sl reservierten Platz verbrauchen. Ist ein relatives File erst einmal eingerichtet, so kann die Satzlänge nicht mehr verändert werden. Es genügt dann der folgende OPEN-Befehl:<br>
            OPEN lfn,ga,sa,”filename”
        </p>

        <p>Selbstverständlich muß ein relatives File auch mit CLOSE lfn geschlossen werden. Auf die einzelnen Sätze eines relativen Files wird normal mit PRINT #lfn, INPUT#lfn oder GET#lfn zugegriffen, allerdings muß vor jedem Zugriff auf den gewünschten Satz positioniert werden. Dies übernimmt die vorliegende Basic-Erweiterung.</p>

        <p>Durch <strong>RECORD#lfn,sn,(,p)</strong> wird auf den Satz mit der Nummer sn positioniert, wird zusätzlich noch p angegeben, so wird innerhalb des Satzes das p-te Zeichen angewählt. Der neue Befehl muß von THEN durch einen Doppelpunkt abgetrennt werden. Es können folgende Basic-Fehlermeldungen auftreten:<br>
            ?SYNTAX ERROR: Schreibfehler im Befehl oder die Erweiterung war nicht eingeschaltet.<br>
            ?ILLEGAL QUANTITY ERROR: Ein Argument lag außerhalb des erlaubten Bereichs.<br>
            ?FILE NOT OPEN ERROR: Das File mit der logischen Filenummer lfn war nicht eröffnet.<br>
            ?ILLEGAL DEVICE NUMBER ERROR: Dem File mit der Nummer lfn ist ein Gerät mit einer Adresse kleiner als 8 oder größer als 15 zugeordnet.<br>
            Es können außerdem folgende Floppy-Fehlermeldungen auftreten (Sie müssen durch den Fehlerkanal ausgelesen werden):<br>
            50,RECORD NOT PRESENT: Der Satz, auf den positioniert wurde, existiert nicht. Diese Meldung kann ignoriert werden, wenn der Satz beschrieben werden soll, denn durch das Beschreiben wird er eingerichtet. (Und alle nicht existierende Sätze mit kleinerer Nummer ebenfalls.) Aus Geschwindigkeitsgründen empfiehlt es sich, bei der Einrichtung eines Files den höchsten Satz zuerst zu beschreiben.<br>
            51,OVERFLOW IN RECORD: Die maximale Satzlänge sl wurde beim Schreiben überschritten. Zu beachten ist, daß das Carriage Return am Ende des Satzes mitzählt.<br>
            52,FILE TOO LARGE: Die Diskette ist voll, der letzte Schreibzugriff kann nicht durchgeführt werden.</p>

        <h3>Aufbau des Programms</h3>

        <p>Der Basic-Interpreter besitzt einen Zeiger (Adresse $0308, im Listing »decod« genannt), derauf die Routine zur Befehlsinterpretation zeigt. Dieser Vektor wird nach dem Aufruf der Erweiterung zuerst gemerkt und danach auf eine eigene Routine zur Befehlsinterpretation gesetzt. Vor dem Merken wird noch geprüft, ob der Vektor schon auf die eigene Routine zeigt. Damit wird verhindert, daß der Computer bei einem versehentlichen Doppelaufruf abstürzt. Die eigene Routine rettet zunächst den Zeiger, der auf das augenblickliche Zeichen im Basic-Text zeigt, und ruft dann die CHRGET-Routine (Befehlscodierung siehe Bild 1, Symboltabelle Bild 2) auf. Diese Routine holt das nächste Zeichen aus dem Basic-Text. Sie überliest automatisch Leerzeichen. Wenn das Ende einer Zeile oder ein Doppelpunkt erreicht wird, so wird die Z-Flag des Prozessors gesetzt. Ein Problem ergibtsich dadurch, daß in »RECORD#« der Simons Basic-Befehl »REC« vorkommt. Er wird bei Verwendung von Simons Basic also in eine interne Darstellung beginnend mit $64 umgewandelt. Das Programm testet daher, ob $64 vorliegt und verzweigt bei positiver Antwort. In beiden Fällen wird nun getestet, ob der Befehl »RECORD#«vorliegt. Unter dem Namen tab 1 (beziehungsweise tab 2 für Simons Basic) steht (rückwärts) die interne Darstellung des Befehls »RECORD«. Dabei ist zu beachten, daß »OR« wiederum nicht im ASCII-Code abgelegt ist, sondern als Token. Wird nur eine Abweichung gefunden, so wird der gemerkte CHRGET-Zeiger zurückgeholt und zur normalen Interpreterroutine gesprungen, anderenfalls tritt eine eigene Routine in Funktion (sie beginnt beim Label OK). Sie holt die Satznummer und, wenn angegeben, die Position im Satz aus dem Basic-Text und sendet die Informationen an die Floppy über die Sekundäradresse 15 (Kommandokanal). Die Floppy erwartet die Werte in folgender Form: »p« als Zeichen, das positioniert werden soll; die Sekundäradresse, mit der das relative File eröffnet wurde; die Satznummer in der Reihenfolge niederwertiges — höherwertiges Byte und, falls angegeben, die Position im Satz. Es werden folgende Routinen des Interpreters und des Betriebssystems verwendet:</p>

        <p>TODO TABLE</p>

        <p>getbyt : Holt einen beliebigen Ausdruck in das x-Register.<br>
            search : Sucht nach der logischen Filenummer in x.<br>
            parset : Holt logische Filenummer, Geräteadresse und Sekundäradresse in die Speicherzellen $b8,$ba und $b9<br>
            listen : Teilt dem angesprochenen Gerät mit, daß es Daten empfangen soll.<br>
            seclis : Sendet die Sekundäradresse zum angesprochenen Gerät.<br>
            iecout : Sendet den Wert im Akkumulator zum angesprochenen Gerät.<br>
            chkcom : Prüft auf Komma im Basic-Text.<br>
            getrec : Holt einen numerischen Ausdruck in den Fließkomma-Akkumulator.<br>
            fac16 : Wandelt den Wert im Fließkomma-Akkumulator in eine 16-Bit-Zahl und speichert sie in $14 und $15.<br>
            comget : =chkcom + getbyte.<br>
            unlist : Beendet die Übertragung an die Floppy.</p>

        <p>Das Programm wurde mit dem Assembler »ASSI« übersetzt, eine Übernahme auf andere Assembler dürfte nicht schwierig sein. Der Basic-Lader (Listing 1, Source-Code: Listing 2) legt das Programm ab der Adresse 49152 ($C000) ab, schaltet die Erweiterung ein und löscht sich dann selbst, er muß also vorher auf Diskette abgespeichert werden. Die Erweiterung wird durch SYS49152 ein- und durch SYS49155 ausgeschaltet. STOP/RESTORE schaltet die Erweiterung nicht ab.</p>

        <address class="author">(Bernward Bretthauer/rg)</address>

        <figure>
            * = 49152
            <table class="plain">
                <tr>
                    <td>chrget</td>
                    <td>= $73</td>
                    <td>; holt nächstes Zeichen</td>
                </tr>
                <tr>
                    <td>chrgot</td>
                    <td>= $79</td>
                    <td>; holt letztes Zeichen</td>
                </tr>
                <tr>
                    <td>chrvek</td>
                    <td>= $7a</td>
                    <td>; Chrgetzeiger</td>
                </tr>
                <tr>
                    <td>decod</td>
                    <td>= $0308</td>
                    <td>; Vektor für Befehlsdec.</td>
                </tr>
                <tr>
                    <td>error</td>
                    <td>= $4a37</td>
                    <td>; Fehlermeldung ausgeben</td>
                </tr>
                <tr>
                    <td>schleife</td>
                    <td>= $a7ae</td>
                    <td>; Interpreterschleife</td>
                </tr>
                <tr>
                    <td>getrec</td>
                    <td>= $b083</td>
                    <td>; Recordnummer holen</td>
                </tr>
                <tr>
                    <td>chkcom</td>
                    <td>= $aefd</td>
                    <td>; prüft auf Komma</td>
                </tr>
                <tr>
                    <td>getbyt</td>
                    <td>= $b79b</td>
                    <td>; holt Byte in x</td>
                </tr>
                <tr>
                    <td>comget</td>
                    <td>= $b711</td>
                    <td>; chkcom + getbyt</td>
                </tr>
                <tr>
                    <td>fac16</td>
                    <td>= $b77c</td>
                    <td>; FAC nach 16-Bit wandeln</td>
                </tr>
                <tr>
                    <td>search</td>
                    <td>= $f30f</td>
                    <td>; sucht logische Filenr.</td>
                </tr>
                <tr>
                    <td>parset</td>
                    <td>= $f30c</td>
                    <td>; setzt Fileparameter</td>
                </tr>
                <tr>
                    <td>listen</td>
                    <td>= $ffb1</td>
                    <td>; LISTEN senden</td>
                </tr>
                <tr>
                    <td>seclis</td>
                    <td>= $ff93</td>
                    <td>; Sekundärad. nach LISTEN</td>
                </tr>
                <tr>
                    <td>iecou t</td>
                    <td>= $ffa8</td>
                    <td>; Ausgabe auf IEC-bus</td>
                </tr>
                <tr>
                    <td>unlist</td>
                    <td>= $ffae</td>
                    <td>; UNLISTEN senden</td>
                </tr>
                <tr>
                    <td>integ</td>
                    <td>= $14</td>
                    <td>; Integer Wert</td>
                </tr>
                <tr>
                    <td>filenr</td>
                    <td>= $b8</td>
                    <td>; logische Filenummer</td>
                </tr>
                <tr>
                    <td>secadr</td>
                    <td>= $b9</td>
                    <td>; Sekundäradresse</td>
                </tr>
                <tr>
                    <td>ga</td>
                    <td>= $ba</td>
                    <td>; Gerätenummer</td>
                </tr>
            </table>

            <figcaption>Bild 1. Befehlscodierung</figcaption>
        </figure>

        <figure>
            <table>
                <tr>
                    <td>0073</td>
                    <td>chrget</td>
                </tr>
                <tr>
                    <td>0079</td>
                    <td>chrgot</td>
                </tr>
                <tr>
                    <td>007a</td>
                    <td>chrvek</td>
                </tr>
                <tr>
                    <td>0308</td>
                    <td>decod</td>
                </tr>
                <tr>
                    <td>a437</td>
                    <td>error</td>
                </tr>
                <tr>
                    <td>a7ae</td>
                    <td>schleife</td>
                </tr>
                <tr>
                    <td>ad8a</td>
                    <td>getrec</td>
                </tr>
                <tr>
                    <td>aefd</td>
                    <td>chkcom</td>
                </tr>
                <tr>
                    <td>b79e</td>
                    <td>getbyt</td>
                </tr>
                <tr>
                    <td>b7f1</td>
                    <td>comget</td>
                </tr>
                <tr>
                    <td>b7f7</td>
                    <td>fac16</td>
                </tr>
                <tr>
                    <td>f30f</td>
                    <td>search</td>
                </tr>
                <tr>
                    <td>f31f</td>
                    <td>parset</td>
                </tr>

                <tr>
                    <td>ffb1</td>
                    <td>listen</td>
                </tr>
                <tr>
                    <td>ff93</td>
                    <td>seclis</td>
                </tr>
                <tr>
                    <td>ffa8</td>
                    <td>iecout</td>
                </tr>
                <tr>
                    <td>ffae</td>
                    <td>unlist</td>
                </tr>
                <tr>
                    <td>0014</td>
                    <td>integ</td>
                </tr>
                <tr>
                    <td>00b8</td>
                    <td>filenr</td>
                </tr>
                <tr>
                    <td>00b9</td>
                    <td>secadr</td>
                </tr>
                <tr>
                    <td>00ba</td>
                    <td>ga</td>
                </tr>
                <tr>
                    <td>c019</td>
                    <td>endoff</td>
                </tr>
                <tr>
                    <td>c01a</td>
                    <td>vekt</td>
                </tr>
                <tr>
                    <td>c01c</td>
                    <td>flag</td>
                </tr>
                <tr>
                    <td>c01d</td>
                    <td>on</td>
                </tr>
                <tr>
                    <td>c02c</td>
                    <td>l1</td>
                </tr>

                <tr>
                    <td>c036</td>
                    <td>l2</td>
                </tr>
                <tr>
                    <td>c041</td>
                    <td>tab1</td>
                </tr>
                <tr>
                    <td>c047</td>
                    <td>tab2</td>
                </tr>
                <tr>
                    <td>c04b</td>
                    <td>record</td>
                </tr>
                <tr>
                    <td>c05a</td>
                    <td>13</td>
                </tr>
                <tr>
                    <td>c067</td>
                    <td>simon</td>
                </tr>
                <tr>
                    <td>c06c</td>
                    <td>13s</td>
                </tr>
                <tr>
                    <td>c079</td>
                    <td>out</td>
                </tr>
                <tr>
                    <td>c082</td>
                    <td>ok</td>
                </tr>
                <tr>
                    <td>c091</td>
                    <td>14</td>
                </tr>
                <tr>
                    <td>c09f</td>
                    <td>illdev</td>
                </tr>
                <tr>
                    <td>c0a4</td>
                    <td>15</td>
                </tr>
                <tr>
                    <td>c0da</td>
                    <td>ende</td>
                </tr>
            </table>
            <figcaption>Bild 2. Symbol-Tabelle</figcaption>
        </figure>

        <figure>
            <pre data-filename="record-bef." data-name="Record-Befehle"></pre>
            <figcaption>Listing 1. Basic-Lader »Record-Befehle«. Bitte beachten Sie die Eingabehinweise auf Seite 6.</figcaption>
        </figure>

        <figure>
            TODO
            <figcaption>Listing 2. Source-Code von »Record-Befehl«</figcaption>
        </figure>
    </article>
</body>

</html>
