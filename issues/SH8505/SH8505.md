# Programme, die jeder braucht

Interessante Informationen und hervorragende Listings zu ausgesuchten Themen finden Sie in unserer 64’er Sonderheftreihe. In diesem Sonderheft haben wir bislang noch nicht veröffentlichte Listings und Tips & Tricks zu den Themen
- Datasette,
- Floppy
- Basic-Erweiterungen
- Programmier-Hilfen
zusammengetragen. Ob Anfängeroder Profi — für jeden ist etwas dabei.

Zwei Speichermedien sind es, die der C 64-Besitzer in erster Linie einsetzt: die Datasette und die Floppy 1541. Die Datasette trifft man hauptsächlich dort an, wo entweder die Finanzlage nicht allzu rosig aussieht, oder wo jemand erst einmal in die Computerwelt hineinschnuppern will. »Aufrüsten« ist ja immer noch möglich. Aber Berichte von Händlern und Umfragen zeigen es ganz deutlich: der Vormarsch der Floppy ist nicht zu bremsen. Und das mit Recht.

### Schnelle Datasette

Datasetten-Benutzer haben oft Schwierigkeiten, Kassetten von Freunden oder Bekannten zu laden. Vielfach liegt es an einem verstellten Tonkopf. Wir geben Ihnen wertvolle Tips, wie man fremde Kassetten trotzdem nutzen kann. Das Laden und Speichern von Programmen ist bei der Datasette ein langwieriges Unternehmen. Mit unserem Quick-Tape wird sie auf einmal schneller als die Floppy.

### Floppy- und Anwendungslistings

Unwahrscheinlich vielseitig ist der Komplex »Floppy«, für den wir einiges an Hilfsprogrammen und wertvollen Anwendungen anbieten. Eine schnelle Formatierroutine und ein sehr schnelles Kopierprogramm sind ebenso gefragt wie einige Programme zur Manipulation des Directorys. Greifen Sie in das DOS der Floppy ein mit dem Floppy-Monitor! Vergessen Sie die manchmal sehr umständliche Bedienung des Floppy-Lauf-werks! Arbeiten Sie mit »Disk-Master«! Eine komplette Dateiverwaltung, mit der unter anderem eigene Masken erstellt werden können, wird Sie begeistern!

### Basic-Erweiterungen

Wir haben einige sehr interessante Basic-Erweiterungen für Sie herausgesucht, die alles bieten, was Sie sich vorstellen können. SindSie ein Liebhaberderstrukturierten Programmierung? Dann ist »aufpoliertes Basic« das Richtige für Sie. Sogar Programmierer von Spielen dürfen sich auf eine spezielle Basic-Erweiterung für Spiele freuen. Und mit »Disc-Basic« bekommen Sie das Floppy-Laufwerk erst richtig in den Griff.

### Tips und Tricks-Listings

Tips und Tricks sind immer wieder begehrt und kommen selbstverständlich nicht zu kurz. Darunter sind einige echte Leckerbissen, zum Beispiel die Cross-Reference-List, die Ihre Basic-Programme durchleuchtet. Komplettin Maschinencode geschrieben und deshalb sagenhaft schnell. Für Neugierige ist der Sourcecode gleich mit abgedruckt.

Alles in allem erhalten Sie in diesem Sonderheft rund 45 Listings, die es in sich haben. Alle Programme wurden mit Prüfsummen versehen, um Ihnen das Eintippen zu erleichtern. Sie finden dazu zwei Programme, den Checksummer 64 V3 (auf Seite 6 für Basic-Programme) und den MSE (für Maschinensprache-Listings auf Seite 8). Damit können Sie alle anderen Programme sicher und bequem abtippen.

### Listing-Service auf Kassette und Diskette

Wer keine Zeit oder keine Lust hat, alle Programme selbst in mühevoller Kleinarbeit abzuschreiben, kann wieder auf den bewährten Leserservice zurückgreifen.

Alle Listings befinden sich auf

- Diskette mit der Bestellnummer L6 85 S5D. Die Diskette kostet 29,90 Mark.
- Kassette mit der Bestellnummer L6 85 S5K. Die Kassette kostet 19,90 Mark.

Bitte verwenden Sie für Ihre Bestellung die beigefügte Postscheck-Zahlkarte zur Überweisung des Rechnungsbetrags. Sie erleichtern uns die Auftragsabwicklung und Sie sparen sich die 3 Mark Versandkosten!

# Checksummer 64 — Neu

Der Checksummer 64 V3 überprüft jede Basic-Zeile direkt nach der Eingabe, erkennt Fehleingaben und auch Vertauschungen von Zahlen und Ziffern, und erspart deshalbeine aufwendige Fehlersuche.

Der Checksummer 64 V3 ist ein kleines Maschinenprogramm, das Sie sofort unterrichtet, ob Sie die jeweilige Programmzeile korrekt eingegeben haben.

So gehen Sie vor:

1.	Programm abtippen und speichern.
2.	Starten mit RUN
3.	Nach kurzer Zeit sehen Sie am Bildschirm:<br>CHECKSUMMER 64, CHECKSUMMER AKTIVIERT, AUSSCHALTEN MIT POKE 1,55, ANSCHALTEN MIT POKE 1,53, READY.
4.	Anschalten des Checksummer 64V3 mit POKE 1,53.
5.	Test: Geben Sie in einer freien Zeile ein: »1 REM« und drücken die RETURN-Taste. Am Bildschirm oben links sollten Siedie Prüfsumme <63> sehen.
6.	Geben Sie ein Listing aus unserem Heft ein. Nach jeder Zeile wird die Zahl, die im Listing in Klammern < > steht, in den Bildschirm eingeblendet. Stimmen die Zahlen nicht überein, so liegtvermutlich ein Eingabefehlervor. Die Zahl in den Klammern, und auch die Klammern selbst, dürfen beim Abtippen nicht mit eingegeben werden!
7.	Dieser neue Checksummer 64V3 bemerkt, im Gegensatz zu den bisherigen, auch Vertauschungen von Zahlen und Buchstaben.
8.	Unsere Basic-Listings enthalten keine Steuerzeichen mehr. Diese werden ersetzt durch Klartext und stehen zwischen geschweiften Klammern. Deshalb sind weder die Klammern noch was dazwischen steht, abzutippen, sondern die in Tabelle 1 aufgeführten Tasten zu drücken. Auf Ihrem Bildschirm erhalten Sie dann wieder die entsprechenden Grafikzeichen (siehe Bild 1 und 2).
9.	Alle Grafikzeichen werden ebenfalls ersetzt durch unterstrichene oder überstrichene Großbuchstaben. Unterstrichene Buchstaben bedeuten, daß Sie die SHIFT-Taste und den angegebenen Buchstaben drücken müssen, überstrichene jedoch die Commodore-Taste mit dem Buchstaben. Auch hier erhalten Sie am Bildschirm das entsprechende Grafikzeichen und nicht etwa das im Listing erkennbare Zeichen (siehe Bild 1 und 2).

## Checksummer VC 20 V3

Der Checksummer VC 20 V3 ist im Prinzip genauso aufgebaut wie der Checksummer 64. Da beim VC 20 jedoch nicht die Möglichkeit besteht, das ROM softwaremäßig zu modifizieren, mußte ein anderer Weg als beim Commodore 64 gewählt werden, um die Checksumme zu generieren.

In ihrer Funktionsweise unterscheiden sich der Checksummer VC 20 und der Checksummer 64 nicht. Es gelten folgende Sonderregelungen bei der Benutzung des Checksummer VC 20:

- Da der Basic-Bereich nicht belegt werden soll, ist das Programm im Kassettenpuffer abgelegt.
- Angeschaltet wird der Checksummer VC 20 mit »SYS 955«.
- Abschaltung des Checksummer VC 20 wird mit »SYS 58459« vollzogen.

Achtung: Nehmen Sie keine Kassetten-Operationen vor, wenn der Checksummer VC 20 eingeschaltet ist. Da das Betriebssystem den Kassettenpuffer mit Daten belegt, kann der Checksummer VC 20 überschrieben werden, was zur Folge hat, daß sich der Computer bei aktiviertem Checksummer VC 20 »aufhängt«. Wollen Sie deshalb ein Programm auf (von) Kassette abspeichern (laden), so müssen Sie erst den Checksummer VC 20 abschalten (SYS 58459).

Daraufhin kann der Kassettenpuffer mit Daten überschrieben werden, ohne daß der Computer »aussteigt«.

Als Sicherung wird bei der Initialisierung geprüft, ob das zuletzt angesprochene Peripherie-Gerät der Kassettenrecorder war. Ist das der Fall, so werden die Betriebssystemroutinen LOAD und SAVE für die Benutzung gesperrt. Der Rechner meldet bei Aufruf einer dieser beiden Routinen READY, ohne weitere Aktionen durchzuführen. Diese Sicherung kann man nach der Tipparbeit aufheben, wenn man den Checksummer VC 20 mit SYS 58459 abschaltet. Dadurch wird der Kassettenpuffer für andere Daten freigemacht. Weiterhin wird dann durch gleichzeitiges Drücken der Tasten »Run-Stop & Restore« erreicht, daß die Betriebssystemroutinen LOAD und SAVE wieder eingerichtet werden.

- Bei Benutzung einer Diskettenstation brauchen Sie nicht darauf zu achten, daß bei LOAD beziehungsweise SAVE der
C 64/VC 20 Checksummer VC 20 überschrieben wird, da der Kassettenpuffer für die Diskettenstation normalerweise nicht genutzt wird. Deshalb können Sie die beiden Routinen weiterhin normal nutzen, sofern der Rechner bei der Initialisierung des Checksummer VC 20 feststellt, daß das zuletzt angesprochene Peripherie-Gerät nicht der Kassettenrecorder war.
- Bedingt durch den anderen Aufbau des Checksummer VC 20 wird anders als beim Checksummer 64 nach der LOAD-Routine keine Checksumme ausgegeben.
- Wird eine Zeile gelöscht, also eine Zahl zwischen 0 und 65999 eingegeben, und danach Return gedrückt, so wird eine Checksumme ausgegeben, die aber keine Bedeutung hat.

Sie können die Programme auch weiterhin ohne den Checksummer eintippen.

(F. Lonczewski/gk)

**Hinweis: {13 SPACE} bedeutet 13mal die Leertaste drücken**

TODO ASIDE

CTRL steht für Control-Taste, so bedeutet [CTRL-A], daß Sie die	
Control-Taste und die Taste »A« drücken müssen. Im folgenden steht:	
{DOWN}	Taste neben rechtem Shift, Cursor unten
{UP}	Shift-Taste & Taste neben rechtem Shift; Cursor hoch
{CLR}	Shift-Taste & 2. Taste ganz rechts oben
{INST}	Shift-Taste & Taste ganz rechts oben
{HOME}	2. Taste von ganz rechts oben
{DEL}	Taste ganz rechts oben
{RIGHT}	Taste ganz rechts unten
{LEFT}	Shift-Taste & Taste unten rechts
{SPACE}	Leertaste
{F1}	grauer Tastenblock rechts
{F3}	grauer Tastenblock rechts
{F5} .	grauer Tastenblock rechts
{F7}	grauer Tastenblock rechts
{F2}	grauer Tastenblock rechts & Shift
{F4}	grauer Tastenblock rechts & Shift
{F6}	grauer Tastenblock rechts & Shift
{F8}	grauer Tastenblock rechts & Shift
{RETURN}	Shift-Taste & Return
{BLACK}	Control-Taste & 1
{WHITE}	Control-Taste & 2
{RED}	Control-Taste & 3
{CYAN}	Control-Taste & 4
{PURPLE}	Control-Taste & 5
{GREEN}	Control-Taste & 6
{BLUE}	Control-Taste & 7
{YELLOW}	Control-Taste & 8
{RVSON}	Control-Taste & 9
{RVOFF}	Control-Taste & 0
{ORANGE}	Commodore-Taste & 1
{BROWN}	Commodore-Taste & 2
{LIG.RED}	Commodore-Taste & 3
{GREY 1}	Commodore-Taste & 4
{GREY 2}	Commodore-Taste & 5
{LIG.GREEN}	Commodore-Taste & 6
{LIG.BLUE}	Commodore-Taste & 7
{GREY 3}	Commodore-Taste & 8

Wenn Sie sich erst einmal an die in Klartext geschriebenen Steuerzeichen gewöhnt haben, werden Sie den Vorteil dieser Schreibweise erkennen. Der zu dem jeweiligen Steuerzeichen gehörende Klartext ist so verfaßt, daß Sie leicht die Taste beziehungsweise die Tastenkombination finden, die Sie drücken müssen.

Die Steuerbefehle im Klartext	

## MSE - Abtippen sicher und leicht gemacht

> Ähnlich wie der »Checksummer« ist auch der MSE ein Hilfsmittel bei der Eingabe von Listings, diesmal jedoch bei reinen Maschinensprache-Programmen.

Im Gegensatz zum »Checksummer« aber ist die Eingabe nicht ohne den MSE möglich. Der MSE verringert die Tipparbeit um ein Drittel und schließt Fehleingaben vollkommen aus. Außerdem können Sie die Werte blind eingeben, ohne andauernd auf den Bildschirm schauen zu müssen. Dies wird durch akustische Meldungen realisiert.

MSE ist ein Maschinenspracheditor, mit dem ein Vertippen ausgeschlossen ist. Eine abgetippte Zeile wird nur angenommen, wenn sie richtig ist. Eine Checksumme am Ende jeder Zeile prüft, ob die richtigen Werte in der richtigen Zeile an der richtigen Stelle stehen. Wenn nicht, ertönt ein Warnsignal, und man beseitigt den Fehler.

War die Zeile korrekt, erklingt ein Gong, und die nächste Zeilennummer wird ausgegeben. Damit ist also auch »blindes« Eintippen möglich; Sie können sich voll auf den Text konzentrieren.

### So arbeitet man mit MSE

Laden und starten Sie MSE. Zuerst wird der Programmname und die Start- und Endadresse erfragt. Diese Angaben entnehmen Sie dem Kopf des jeweiligen abgedruckten Listings. MSE meldet sich dann mit der Zeilennummer der ersten Zeile. Wenn Sie die Zeile richtig eingegeben haben, erscheint die nächste Zeilennummer und so weiter bis zum Ende. Zum Schluß wird das fertige Programm mit »CTRL-S« auf Diskette oder Kassette abgespeichert. Dazu sind keine weiteren Angaben mehr erforderlich. Das Programm kann dann ganz normal wieder geladen und gestartet werden. Wenn Sie nicht alles auf einmal tippen wollen, können Sie jederzeit unterbrechen und den eingetippten Teil mit »CTRL-S« abspeichern. Wollen Sie weiterarbeiten, laden und starten Sie MSE wieder.

Geben Sie auf die Frage nach der Startadresse aber jetzt »L« ein, um Ihr Teilprogramm zu laden. Jetzt können Sie mit »CTRL-N« die Adresse eingeben, an der Sie weitertippen müssen. Wenn Sie sich nicht gemerkt haben, wie weit Sie gekommen sind, geben Sie nach dem Laden »CTRL-M« ein.

Auf die Frage nach der Startadresse antworten Sie mit der Anfangsadresse, die links in der Kopfzeile auf dem Bildschirm steht. Nun wird Ihr Programm aufgelistet. Mit »SPACE« wird das Listen fortgesetzt, mit »STOP« abgebrochen. Das Ende Ihres Programmteils erkennen Sie sehr einfach daran, daß nur noch der Wert »AA« in der Zeile steht. Die Adresse dieser Zeile müssen Sie anschließend mit »CTRL-N« eingeben. Das Programm ist nur mit »STOP/RESTORE« zu verlassen. Speichern Sie aber vorher unbedingt immer Ihren Text ab.

### Hinweise zum Abtippen

Vor dem Abtippen oder späteren Wiederladen des MSE-Laders müssen Sie unbedingt folgende Zeile eingeben:
**POKE 43,1: POKE 44,32: POKE 8192,0: NEW**

Starten Sie das Programm mit RUN. Fehlerhafte Zeilen werden angezeigt und müssen korrigiert werden, bis der Lader zum »READY« durchläuft. Jetzt müssen Sie das fertige MSE-Programm abspeichern. Dazu brauchen Sie nur »RETURN« zu drücken, weil die erforderlichen Angaben schon auf dem Bildschirm stehen. (Kassettenbesitzer müssen in Zeile 343 die letzte Zahl in »1« abändern.) Ab jetzt können Sie »MSE V1.0« direkt, also ohne den DATA-Lader, benutzen. MSE V1.0 wird ganz normal mit »,8« geladen (keine POKEs notwendig).

(N. Mann / D. Weineck / gk)

TODO ASIDE

MSE-Befehle:
DEL löscht die letzte Eingabe.
CTRL-S speichert das eingetippte Programm ab.
CTRL-L lädt ein Programm. Start- und Endadresse werden automatisch ermittelt.
CTRL-M listet den Speicherinhalt. Abbruch mit STOP-Taste, weiter mit Leertaste.
CTRL-N erlaubt die Eingabe einer neuen Adresse zum Weitertippen.
CTRL-P gibt ein MSE-Listing auf dem Drucker aus.

# Komfortable Befehlserweiterung

> »Basic-Expansion« ist ein universelles Programm, das den Befehlssatz des C 64 um 42 neue Kommandos erweitert, die das Arbeiten mit Floppy und Grafik enorm vereinfachen.

Das Besondere an dieser Erweiterung ist zudem, daß sie sich »unter« dem Basic-ROM befindet. Trotz der Länge von 6625 Byte des Maschinenprogramms werden nur 260 Byte des freien Basic-RAM benötigt.

Nachdem das Programm (siehe Listing) mit »SYS 40700« gestartet wurde, erscheint nach kurzer Zeit die Einschaltmeldung von »Basic-Expansion«. 42 neue Befehle (siehe Tabelle) können von nun an ganz normal verwendet werden.

**Hier die neuen Befehle im Überblick:**
Bei der Beschreibung gelten folgende Symbole:
**ga**: Geräteadresse
**lfn**: logische Filenummer
**fa**: Farbe (1 bis 16, 1=schwarz, 2=weiß, 3=rot, etc.); der Farbcode entspricht genau der Anordnung auf der Tastatur (CRTL 1 = schwarz, CRTL 2 = weiß etc.)
**PLOT x,y,fa**: Punkt mit den Koordinaten (x,y) und der Farbe fa setzen (nur im Grafikmodus)
**LINE a, b, x, y, fa**: Linie von Punkt (a,b) bis Punkt (x,y) in der Farbe fa zeichnen
**SETARC Startwinkel, Endwinkel, Schrittweite, Mittelpunkt x, Mittelpunkt y, Radius in x-Richtung, Radius in y-Richtung, Farbe fa**: Diese Routine zeichnet einen Kreisbogen (im Bogenmaß) um einen Mittelpunkt.
**Beispiel**: »SETARC 0,2*3.14,0.1,200,100,100,3«zeichnet einen vollen Kreis um den Mittelpunkt (100,100) mit dem Radius 100 in roter Farbe.

Diese Zeichenroutine kann jedoch nicht nur Punkte setzen, sondern auch wieder löschen. Dazu setzt man fa einfach auf Null.
Beispielsweise löscht»PLOT 100,100,0«den Punkt(100,100), weil der Farbcode gleich Null ist. Das giltauch für LINE und SETARC.
**GRAPHICS** schaltet die hochauflösende Grafik ein (320x200 Punkte).
**NORM** ist der Gegenbefehl zu GRAPHICS und schaltet wieder zurück in den Textmodus.
**GCLEAR** löscht eine hochauflösende Grafik.
**GCOL r, h** setzt die Farbe r als Rahmenfarbe und h als Hintergrundfarbe für die hochauflösende Grafik.
**GSAVE "PRG-NAME ", ga** speichert die hochauflösende Grafik auf Kassette oder Diskette.
**GLOAD "PRG-NAME", ga** lädt eine hochauflösende Grafik von Diskette oder Kassette. GSAVE und GLOAD speichern, beziehungsweise laden auch den Farbspeicher der hochauflösenden Grafik.
**COLOUR r, h** arbeitet im Textmodus und setzt die Farben für Rahmen (r) und Hintergrund (h).
**HBLOCK l, fa** zeichnet im Textmodus einen horizontalen Balken der Länge I in der Farbe fa ab der aktuellen Cursorposition und setzt den Cursor eine Zeile tiefer. L darf nur Werte zwischen 0 und 319 annehmen.
**VBLOCK l, fa** arbeitet wie HBLOCK, nur in vertikaler Richtung. Zugelassen sind Werte zwischen 0 und 199.
**CURSCOL fa** ändert die Cursorfarbe, das heißt man kann so die Schrittfarbe wählen.
**SCROLL r, uz, oz** scrollt den Bildschirm zwischen den Zeilen uz und oz in der Richtung, die der Parameter r angibt. Dabei bedeutet: 0 nach rechts; 1 nach oben; 2 nach links und 3 nach unten, uz ist die untere und oz die obere Zeile, die beide im Bereich zwischen 0 und 24 liegen.
**DOKE a, b** bedeutet ein »Doppelbyte-POKE«, das heißt, a und b sind 2-Byte-Zahlen. In die Speicherstelle a wird das Low-Byte von b gePOKEt, entsprechend wird der Speicherstelle a+1 das High-Byte von b zugewiesen.
**SIZE** gibt die Speicherplatzbelegung aus: gesamter Basic-Speicher, Programm, Variablen, Arrays, Strings, freier Basic-Speicher.
**RESTORE n** setzt den DATA-Zeiger auf die Zeile n oder auf die nächste darauffolgende Zeile, n muß dabei eine Zeilennummer sein. Der normale RESTORE-Befehl funktioniert natürlich auch noch.
**ON...RESTORE a, b, c, d..** läuft ähnlich ab wie ON..GOTO. Je nach dem Ergebnis des Ausdrucks nach dem ON-Befehl wird der DATA-Zeiger auf die Zeile a, b, c,.. positioniert.
**MERGE "PRG-NAME", ga** hängt ein Basic-Programm von Diskette oder Kassette mit Geräteadresse ga an ein im Speicher befindliches Basic-Programm an und sortiert die Basic-Zeilen nach ihren Zeilennummern.
**GEN "String"** arbeitet nur im Programm-Modus. Dieser Befehl erzeugt eine neue Basic-Zeile in einem Basic-Programm. Der String muß am Anfang eine Zeilennummer und danach den Basic-Text enthalten. Zum Beispiel erzeugt der Befehl GEN "10 DATA 1,2,3" die Basic-Zeile »10 DATA 1,2,3« im Programm. Nach der Erzeugung fährt das Programm mit der auf den GEN-Befehl folgenden Basic-Zeile fort. Der Computer springt nach dem GEN-Befehl immer in die nächste Zeile, so daß Basic-Befehle in derselben Zeile nach dem GEN-Befehl i nicht ausgeführt werden. Zu beachten ist aber, daß alle Varia-tolenwerte gelöscht werden und daß der String nur 80 Zeichen umfassen darf. Und noch ein Hinweis: Enthält der String nur eine Zeilennummer, so wird die entsprechende Basic-Zeile gelöscht. In keinem Falle sollte der GEN-Befehl in einem Unterprogramm verwendet werden, da er den Basic-Stack manipuliert.
**DUMP** listet alle verwendeten Variablen tabellarisch auf. Lediglich die Arrays werden dabei nicht berücksichtigt.
**ARRAY** gibt sämtliche Arrays mit Werten aus. Die Ausgabe kann durch einmaligen Druck der SHIFTTaste angehalten werden. Dann wartet das Programm so lange, bis die Commodore-Taste gedrückt wird. Dies gewährleistet, daß der Benutzer alle Arraywerte genauestens ablesen kann.
**RENUM z, s** numeriert ein Basic-Programm neu. RENUM ändert neben den Zeilennummern die Adressen bei GOTO, GOSUB, THEN, RESTORE, RUN sowie bei sämtlichen ON..GOTO, ON..GOSUB oder ON..RESTORE-Ausdrücken. Z gibt die erste neue Zeilennummer, s die Schrittweite an. RENUM berücksichtigt ebenfalls, ob möglicherweise zu große Zeilennummern erreicht werden. Bevor die Zeilennummern verändert werden, wird geprüft, ob die zu erzeugenden Zeilennummern auch im Bereich 0 bis 64000 liegen, andernfalls wird eine Fehlermeldung ausgegeben. Die Schrittweite 0 wird auch nicht akzeptiert. RENUM kann im Programm-Modus verwendet werden. Dabei werden alle Variablenwerte gelöscht. Wie beim GEN-Befehl springt der Computer nach dem RENUM-Befehl automatisch in die nächste Basic-Zeile. Der RENUM-Befehl kann zwei Fehlermeldungen ausgeben: »US-ERROR IN xx« bedeutet, daß im Programm eine Sprungadresse nichtvor-handen war. »US« steht für '»UNDEFINED STATEMENT«. Der RENUM-Befehl unterbrichtjetztaber nicht einfach, sondern er ersetzt die nicht-definierte Sprungadresse durch die Adresse derjenigen Basic-Zeile, die als nächste auf die nicht-definierte folgen würde. Die zweite Fehlermeldung lautet: »SN-ERROR IN xx«, welche anzeigt, daß bei einer Sprungadresse eine zu große Zahl angegeben wurde. Hier verfährt der Befehl so, daß statt der fehlerhaften Adresse die Adresse der ersten Basic-Zeile im Programm eingesetzt wird. Dadurch wird verhindert, daß ein Programm durch die falsche Adresse möglicherweise abstürzt. Die Zeilennummern xx in den Fehlermeldungen gibt natürlich die neue Adresse der Zeile an, in der ein Fehler auftrat.
**OLD** ist der Gegenbefehl zu NEW. So können durch NEW oder Reset gelöschte Programme wieder »zurückgeholt« werden.
**CURSOR s,z(,"Drucktext")** ist der Positionierbefehl für den Cursor. S gibt die Spalte (0 bis 39) und z die Zeile (0 bis 24) der gewünschten Position an. Es existieren zwei CURSOR-Varianten:
CURSOR s, z setzt nur den Cursor.
CURSOR s, z , "String " dagegen positioniert den Cursor auf die Position (s,z) und druckt an diese Stelle den Text »String«. Wird also hinter der Zeilenangabe noch ein Komma gesetzt, so wird praktisch wie beim PRINT-Befehl fortgefahren.

Die nächsten Befehle beziehen sich nur auf das 1541-Floppy-Laufwerk. gn ist hierbei die Geräteadresse der Diskettenstation.
**DIRgn** listet das Directory der Diskette auf dem Bildschirm, ohne ein im Speicher befindliches Programm zu löschen. Der Benutzer kann während des Auflistens mit der gedrückten SHIFT-Taste das Listen so lange verzögern, bis die SHIFTTaste wieder entriegelt wird. Die Commodore-Taste unterbricht das Auflisten des Inhaltsverzeichnisses ebenfalls, nur wird damit das Listen einfach abgeschlossen und der Computer verarbeitet den nächsten Befehl.
**RECORD#,lfn,rn(,bp)** ist der Positionierbefehl für relative Dateien. Ifn bezeichnet die Filenummer des geöffneten relativen Files, rn stellt die Recordnummer (1-65535) und bp eventuell die Position innerhalb dieses Records (1-254) dar. Ohne Angabe von bp wird immer der Wert 1 angenommen.
**DISC "Befehl", gn** übermittelt dem 1541-Laufwerk DOS-Befehle wie zum Beispiel
DISC "I0", gn

Hier wird die Diskette in der Floppy-Station mit der Geräteadresse gn initialisiert. Mit DISC können alle DOS-Befehle, die an den Befehlskanal gehen, übertragen werden. Die Befehle müssen aber innerhalb der Anführungsstriche stehen.
**DISCGET# lfn,Variable$ (,Länge I)** ist ein erweiterter INPUT #-Befehl. Ifn bezeichnet die logische Filenummer; danach muß eine Stringvariable angegeben werden. Diese Routine liest nun bis zum nächsten RETURN-Code Zeichen ein und speichert sie unter der Stringvariablen ab. Dabei können bis zu 255 Zeichen eingelesen werden. Wird zusätzlich noch eine Länge I mit angegeben, so liest der Befehl genau I Zeichen ein, so daß die Stringlänge der Variablen vorbestimmt wird. Dies erweist sich beispielsweise beim Einlesen von Records aus relativen Dateien als sehr nützlich, denn hier kann der Parameter I die Länge des Records darstellen.
**PROTECT "File-Name", gn** schützt ein File auf der Diskette gegen den SCRATCH-Befehl. Files, die so geschützt sind, werden im Directory gesondert gekennzeichnet. Mit dem SCRATCH-Befehl können diese Files nicht mehr gelöscht werden.
**FREE "File-Name", gn** ist der Gegenbefehl zum PROTECT-Befehl. Hiermit werden geschützte Files auf der Diskette wieder freigegeben und können nun mit SCRATCH gelöscht werden. Für PROTECT und FREE gibt es auch die Möglichkeit, den Namen des Files mit dem Jokerzeichen " * " abzukürzen.
**DOSTYPE "Stringzeichen ", gn** verändert das DOS-Flag der Floppy-Station. Das Zeichen »A« kennzeichnet das DOS der VC 1541. Wird jetzt DOSTYPE "B", gn eingegeben, so hat der Benutzer das DOS-Flag verändert. Dies aber bedeutet, daß man nichts mehr auf die Diskette schreiben kann. Bei jedem Schreibbefehl wird geprüft, ob auch das »richtige« DOS-Flag vorhanden ist (DOS»A«), Trifft dies nicht zu, so kann eine Diskette nicht mehr beschrieben werden. Durch »DOSTYPE **"A",gn**« erzeugt man wieder das richtige DOS-Flag, so daß die Diskette wieder beschrieben werden kann. Insofern bedeutet der DOSTYPE-Befehl eine Art Schreibschutz der Diskette. Anzumerken ist noch, daß die Routine immer nur das erste Zeichen im Stringausdruck berücksichtigt.
@: Dieser Befehl dient demjenigen, der mit dieser Basic-Erweiterung noch nicht zufrieden ist, als zusätzlicher Erweiterungsbefehl. Der @-Befehl bewirkt normalerweise nichts. Der Zeiger in der Sprungtabelle der Basic-Befehle ist auf ein RETURN (RTS) positioniert. Der Benutzer kann nun ein Maschinenprogramm mit dem Klammeraffen aufrufen. Dazu muß er die Werte in der Sprungtabelle für den @-Befehl ändern. Der Sprungvektor liegt in den Speicherstellen 40221 und 40222 (dezimal). Normalerweise steht dort der Vektor 40804, weil in der Speicherstelle 40805 ein RTS-Code enthalten ist. Der Sprungvektor kann vom Benutzer verändert werden (durch die POKE- oder DOKE-Befehle), indem der Vektor auf die Einsprungadresse gesetzt wird. Wenn ein Programmierer beispielsweise einen neuen Befehl als Maschinenprogramm ab Adresse 828 (Kassettenpuffer) angelegt hat, so POKEt er das Low-Byte von (828—1) in 40221 ein und speichert das High-Byte von (828—1) in 40222 ab. Nun kann die neue Routine mit @ angesprochen werden. Durch Zuweisung des ursprünglichen Wertes von (40805—1) in die Speicherstellen der Sprungtabelle wird der neue Befehl wieder aufgehoben.
**Soweit die neuen Befehle. Nun kommen wir zu den neuen Funktionen der Erweiterung:**
**RAM (xx)** gibt den Inhalt der RAM-Speicherstelle xx an und ähnelt dadurch sehr der PEEK-Funktion. Doch die RAM-Funktion liest die Werte immer aus dem RAM aus. Zusätzlich wird im Bereich $D000 bis $DFFF (hexadezimal) der Charaktergenerator ausgelesen, so daß die Werte für die Zeichen aus dem Charakter-ROM aufgelistet werden können.
**CVAL ("String ")** ähnelt der VAL-Funktion, kann jedoch auch Rechnungen auswerten. So ergibt »CVAL("5*6+3")« als Beispiel den Wert 33, wogegen »VAL("5*6+3")« gleich 5 ist. CVAL verarbeitet alle Funktionen, jedoch darf der String nicht länger als 80 Zeichen sein.
**ROUND(x,y)** rundet eine Zahl x auf y Nachkommastellen. Somit kann man eine Fließkommazahl auf eine ganze Zahl runden, wenn y=0 ist.
**&(xxxx)** wandelt die dezimale Zahl xxxx (oder einen numerischen lnteger-Ausdruck) in den entsprechenden hexadezimalen String, welcher zwei oder vier Zeichen umfaßt, je nachdem ob der Wert xxxx kleiner oder größer als 256 ist. Der Ausdruck xxxx muß eine positive Zwei-Byte-Zahl darstellen. Beispiel: »PRINT &(15)« ergibt »OF«.
**!("yyyy")** ist das Gegenstück zur &-Funktion. Sie wandelt einen hexadezimalen String in die entsprechende dezimale, positive Zwei-Byte-Zahl. Der String muß zwei oder viör Zeichen umfassen, je nachdem ob der Hex-Wert kleiner oder größer als "FF" ist.
**TEST(x,y)** fragt ab, ob in der hochauflösenden Grafik der Punkt mit den Koordinaten (x,y) gesetzt ist. Trifft dies zu, so erhält man das Ergebnis -1, sonst ergibt sich der Wert 0.
**INSTR(1. String, 2. String)** oder **INSTR(1. String, 2. String, a)** untersucht, ob der zweite String im ersten String enthalten ist und gibt die Position an, ab der der zweite String gefunden wird. Ist der zweite String nicht im ersten String enthalten, so wird eine Null ausgedruckt. Der Parameter a, der zusätzlich mit angegeben werden kann, gibt die Position im ersten String an, ab der getestet werden soll, ob der zweite String ein Teil des ersten ist. Wird a nicht mit angegeben, so wird er automatisch auf 1. gesetzt, das heißt es wird ab der ersten Position im ersten String untersucht.
**DS$(ga)** liest den Fehlerkanal der Floppy-Station aus, wobei ga die Geräteadresse angibt.
**DS(ga)** ermittelt nur die Nummer der Fehlermeldung der Floppy-Station mit der Geräteadresse ga.
**HEADBYT ("File-Name", ga, n)** bezieht sich auf das n-te Byte im Eintrag eines Files im Inhaltsverzeichnis. Die Geräteadresse ist ga. Der String »File-Name« stellt den Namen des Files dar. Jeder Eintrag eines Files enthält 30 Byte mit wichtigsten Informationen über Länge des Files, File-Typ etc. Diese Bytes können nun einzeln mit der HEADBYT-Funktion ausgelesen werden. Beispielsweise stellt Byte 0 im Eintrag eines Files den File-Typ dar. Mit der HEADBYT-Funktion kann der Benutzer den File-Typ auslesen, wobei n=0 sein muß. Bei einer relativen Datei befindet sich im 21. Byte des Eintrags die Recordlänge, so daß mit HEADBYT die Recordlänge schnell festgestellt werden kann (bei n=21). Zu beachten ist, daß der Parameter n nur im Bereich 0 bis 29 liegen darf. Welche Bedeutung nun die einzelnen Bytes im Eintrag eines Files haben, läßt sich anhand des Bedienungshandbuches für die 1541 feststellen. Wichtig ist auch noch, daß bei der Angabe des File-Namens mit dem Jokerzeichen »*« gearbeitet werden kann. DEEK(xxxx) stellt ein Doppelbyte-PEEK dar. DEEK (xxxx) ist die Gegenfunktion zu DOKE. Es werden die Inhalte der Speicherstellen xxxx und xxxx+1 als positive Zwei-Byte-Zahl dargestellt. xxxx muß die Adresse des Low-Bytes markieren; das Ergebnis ist eine Zahl zwischen 0 und 65535. Die DEEK-Funktion liest immer aus dem RAM aus. In den Bereichen des Basic-lnterpreter-ROMs und dem Betriebssystem-ROMs wird ebenfalls immer das RAM ausgelesen. Das ROM kann nur mit PEEK ausgelesen werden. DEEK unterscheidet sich von der RAM-Funktion nur im Bereich $D000 bis $DFFF. Hier hat DEEK keinen Zugriff auf den Charaktergenerator.

Soweit sind nun alle neuen Befehle und Funktionen beschrieben worden. Eines sollte man jedoch unbedingt beachten: Bei der Benutzung des THEN-Befehls muß darauf geachtet werden, daß nach dem THEN ein Doppelpunkt»:«folgt, um danach die neuen Basic-Befehle benutzen zu können. Wird der Doppelpunkt weggelassen, so gibt der Computer »SYNTAX ERROR« aus, wenn nach THEN ein neuer Basic-Befehl verwendet wird.
**Hinweise zur Eingabe:**

Geben Sie das Programm mit dem MSE ein (siehe Seite 8). Geladen wird es dann mit »LOAD".. ",8,1«. Danach geben Sie bitte NEW ein. Der Start erfolgt mit »SYS 40700«.

Sollte während der Benutzung der Erweiterung ein RESET ausgelöst werden, so erscheint wieder das gewohnte Bild des Basic V2, was jedoch nicht heißt, daß die Basic-Erweiterung gelöscht worden ist. Die Erweiterung ist nicht gegen RESETs des Computers geschützt. Um das zu erreichen, hätte der gesamte Bereich von hexadezimal $8000 bis $A000 vor Überschreiben geschützt werden müssen, was aber einem Basic-Speicherverlust von 8 KByte gleichkäme. Doch eben dieser Speicherverlust sollte vermieden werden. Dem Benutzer sollte noch möglichst viel Speicherplatz für Basic-Programme und Daten zur Verfügung stehen. Doch wenn der Benutzer nach einem RESET sofort »SYS 40700« eingibt, so ist die Basic-Erweiterung wieder aktiviert, wenn nicht schwerwiegende Programmfehler einen Teil der Erweiterung verändert haben.

(Bernd Stuke/ev)

# Disk-Basic – programmieren Sie Ihre eigene Datenverwaltung!

> Disk-Basic ergänzt das magere Basic V 2.0 um einige Befehle zum komfortablen Programmieren von sequentiellen und relativen Dateien.

Disk-Basic ist entstanden, um beispielsweise eine leistungsfähige Dateiverwaltung miteinfachen Befehlen zu programmieren. Das ist natürlich nur eines der denkbaren Anwendungsgebiete von Disk-Basic, denn sein umfangreicher Befehlsvorrat erleichtert generell das Arbeiten mit dem 1541-Floppy-Laufwerk. Disk-Basic hatdasZiel, nichtmehrmitspektakulären Kommandokombinationen die Laufwerke zum Arbeiten zu animieren, sondern mit Klartextbefehlen. Damit trägt es dem Prinzip einer Hochsprache wie Basic, komfortabel Daten zu verarbeiten, Rechnung.

Nach dem fehlerfreien Eingeben (verwenden Sie bitte den MSE) und Abspeichern des Programms (siehe Listing) kann Disk-Basic mit SYS 49152 gestartet werden. Die Befehlssyntax aller neuen Befehle richtet sich nach der altbewährten Methode: Sonderzeichenerkennung — Befehlsidentifizierung — Ausführung. Bevor nun die Wirkung der einzelnen Befehle erläutert wird, noch einige andere allgemeine Hinweise.

- Da, zumindest in Deutschland, das englische Pfund-Zeichen relativ wenig verwendet wird, wurde es als Einleitungszeichen für die neuen Befehle gewählt.
- Beim Start oder bei der Initialisierung werden zwei Kommandokanäle geöffnet:
OPEN 15,8,15 und OPEN 16,9,15

Es ist dabei ohne Belang, ob die Floppy-Laufwerke eingeschaltet sind oder nicht. Da der Befehl RUN alle Kanäle schließt, muß am Programmanfang immer mit INIT initialisiert werden. Der Grund für diese Forderung ist, daß während des Arbeitens mit relativen Dateien an den Zuständen der Kanäle nichts verändert werden darf.

- Um auch bei den Sekundäradressen Ordnung zu schaffen, wird beim Öffnen einer Datei die Sekundäradresse gleich der Kanalnummer gesetzt (zum Beispiel OPEN 2,8,2). Aus diesem Grund darf die Kanalnummer nur zwischen 2 und 14 liegen.
- Das zweite Floppy-Laufwerk (nicht unbedingt notwendig) sollte die Geräteadresse 9 haben. Ist es bereits fest auf eine höhere Nummer eingestellt, muß das Programm geringfügig verändertwerden. Ansonsten stehtzurVeränderung derGerä-teadresse ein gesonderter Befehl zur Verfügung.

Die 38 Befehle des Disk-Basic unterteilen sich in zwei Gruppen:

Die eigentlichen DOS-Befehle und allerlei Hilfsbefehle, zum Beispiel zur Aufbereitung von Datensätzen.

Folgendes zur Erklärung:

Steht »dr« in Klammern, so bedeutet das, daß die Geräte-Nummer weggelassen werden kann. Dabei wird angenommen, daß es sich um Gerät 8, das Floppy-Laufwerk handelt.

”...” bedeutet, daß weitere Parameterkombinationen angehängt werden können.

### Befehle für die Laufwerksbedienung

£CATALOG (.’’Parameter”) (,dr)
Ausgabe des Directorys. Als Parameter sind Standardjoker (siehe 1541-Handbuch Seite 11) einsetzbar.
£COLLECT (,dr)

»Aufräumen« führt eine Disk-Garbage-Collection durch (entspricht dem Validate.
£COPY,”neufile=altfile,...” (,dr)
Kopieren von Files
£CLALL

schließt alle Kanäle und öffnet die Kommandokanäle sofort wieder
£OPEN,fn,”filename,x,y”
öffnet Kanal fn.

TODO

x = s sequential
p	program
u	user
y = w	write
r	read
a	append
m Lesen einer nicht gechlossenen Datei

fn muß zwischen 2 und 14 liegen
£ERROR,dr,ds (,ds$) (,tr) (,se)
dr muß angegeben werden. Fehlerkanal wird gelesen £FORMAT,”diskname,id” (,dr) formatieren einer Disk
£RENAME,”neuname=altname” (,dr)
umbenennen von Dateien
£SCRATCH,”filename,...” (,dr)
löschen von Dateien
£CHANGE,neue nr, alte nr
Die Gerätenummer des »alten« Floppy-Laufwerks wird umgeändert.
£INIT (,dr)
Das betreffende Laufwerk wird initialisiert
£CHAIN,”Programmname” (,dr)
Aneinanderhängen von Programmen mit Variablenschutz; darf nur bei fertig entwickelten Programmen verwendet werden, da das Programm im Speicher nach Ende oder Abbruch nicht mehr ordnungsgemäß zu listen und zu starten ist. £SYSTEM,”Programmname” (,dr) die Erweiterung wird gespeichert
£FETCH,fn,az,er$,...
vom File fn werden az Zeichen in er$ eingelesen
£TRANS, Sendedatei-Nr., Empfangsdatei-Nr.
beide Dateien müssen geöffnet sein. Die Daten können zwischen allen Peripheriegeräten ausgetauscht werden.
£RANDOM,fn,”Name”,le,az (,dr)
fn = Kanalnummer
le = Länge eines Records
az = die Anzahl derfreigemachten Records (record az wird mit CHR$(255) beschrieben)
£CLEAR
löscht den Datenpuffer für relative Dateien
£PUT,fn,rn,az (,dr)
schreibt az Byte des Puffers in den Record rn
£GET,fn,rn,az (,dr)
liest az Byte des Records rn in den Puffer
£WRITE,pos,x$,az,...
schreibt az Zeichen des Strings x$ ab pos (Position) in den Puffer.
Ist der String zu kurz, wird mit CHR$(O) aufgefüllt.
£READ,Pos,az,x$... liestab Pos (Position) az: Zeichen des Puffers in x$

### Andere Befehle:

£COMRa,a$,...
wandelt die Zahl a (integer oder real) in den äquivalenten String. Real 5 Zeichen, Integer 2 Zeichen.
£RECOMP,a$,a,...
Umkehrung von COMP
£BEEP
Ausgabe eines Signaltones
£CSET,x,y
Cursorpositionierung
x = Zeile, y = Spalte
£CREAD,x,y
Cursorabfrage
gibt aktuelle Cursorposition aus (x = Zeile, y = Spalte)
£RESTORE, Ausdruck
Positioniert den Lesezeiger für Daten auf Zeile »Ausdruck«
£INSTR$,a$,b$,Pos,erg,...
durchsucht a$ ab Pos nach b$. Ist erg = 0, dann nicht vorhanden
£STORE,adresse,”XXYYXXYYXXYY...” ...
speichert Hexbytes ab Adresse (ideal für Sprites)
£STR$,”XXYYXXYYXXYY”,a$...
wandelt Hexbytes in ASCII-Zeichen und speichert sie in a$
£STRING,a Zeichen,er$ ...
erzeugt einen a Zeichen langen String aus
£COLOUR,f1,f2
verändert die Bildschirmfarben
£GOTO,Ausdruck
GOTO wird »berechenbar«
£HEX,z,h$...
wandelt z in h$ (hexadezmalzahl) um
£DEZ,h$,z...
wandelt h$ (hexadezimal) in z (dezimal) um
£LINPUT,a$
Übernimmt eine ganze Zeile mit allen Zeichen
£SYS,adresse,akku,xreg,yreg...
SYS mit Parameterübergabe der 6510-Register
akku = Akkumulator
xveg = X-Register
yveg = y-Register
£QUIT
verlassen des Interpreters

(Harald Großauer/aw)

# Record-Befehl für den C 64

> Dieses Programm erleichtet Ihnen den Umgang mit relativen Files.

Bei relativen Files kann auf jeden Satz des Files direkt zugegriffen werden, ohne die vorherigen Sätze lesen zu müssen. Außerdem kann ein eröffnetes File nach Belieben beschrieben und gelesen werden, es ist also zum Beispiel möglich, Satz 12 zu beschreiben, auch wenn bereits höhere Sätze existieren. Ein relatives File wird durch folgenden OPEN-Befehl eingerichtet:

OPEN lfn,ga,sa,”filename,l,”+chr$(sl). Dabei bedeutet:
**lfn** = logische Filenummer.
**ga** = Geräteadresse (normalerweise 8)
**sa** = Sekundäradresse (mindestens 2, höchstens 14)
**sl** = maximale Satzlänge des relativen Files (mindestens 1, höchstens 254). Diese Angabe ist entscheidend für den späteren Diskettenplatzverbrauch des Files, da auch Sätze, die nicht mit voller Satzlänge beschrieben werden, den gesamten durch sl reservierten Platz verbrauchen. Ist ein relatives File erst einmal eingerichtet, so kann die Satzlänge nicht mehr verändert werden. Es genügt dann der folgende OPEN-Befehl:
OPEN lfn,ga,sa,”filename”

Selbstverständlich muß ein relatives File auch mit CLOSE lfn geschlossen werden. Auf die einzelnen Sätze eines relativen Files wird normal mit PRINT #lfn, INPUT#lfn oder GET#lfn zugegriffen, allerdings muß vor jedem Zugriff auf den gewünschten Satz positioniert werden. Dies übernimmt die vorliegende Basic-Erweiterung.

Durch **RECORD#lfn,sn,(,p)** wird auf den Satz mit der Nummer sn positioniert, wird zusätzlich noch p angegeben, so wird innerhalb des Satzes das p-te Zeichen angewählt. Der neue Befehl muß von THEN durch einen Doppelpunkt abgetrennt werden. Es können folgende Basic-Fehlermeldungen auftreten:
?SYNTAX ERROR: Schreibfehler im Befehl oder die Erweiterung war nicht eingeschaltet.
?ILLEGAL QUANTITY ERROR: Ein Argument lag außerhalb des erlaubten Bereichs.
?FILE NOT OPEN ERROR: Das File mit der logischen Filenummer lfn war nicht eröffnet.
?ILLEGAL DEVICE NUMBER ERROR: Dem File mit der Nummer lfn ist ein Gerät mit einer Adresse kleiner als 8 oder größer als 15 zugeordnet.
Es können außerdem folgende Floppy-Fehlermeldungen auftreten (Sie müssen durch den Fehlerkanal ausgelesen werden):
50,RECORD NOT PRESENT: Der Satz, auf den positioniert wurde, existiert nicht. Diese Meldung kann ignoriert werden, wenn der Satz beschrieben werden soll, denn durch das Beschreiben wird er eingerichtet. (Und alle nicht existierende Sätze mit kleinerer Nummer ebenfalls.) Aus Geschwindigkeitsgründen empfiehlt es sich, bei der Einrichtung eines Files den höchsten Satz zuerst zu beschreiben.
51,OVERFLOW IN RECORD: Die maximale Satzlänge sl wurde beim Schreiben überschritten. Zu beachten ist, daß das Carriage Return am Ende des Satzes mitzählt.
52,FILE TOO LARGE: Die Diskette ist voll, der letzte Schreibzugriff kann nicht durchgeführt werden.

### Aufbau des Programms

Der Basic-Interpreter besitzt einen Zeiger (Adresse $0308, im Listing »decod« genannt), derauf die Routine zur Befehlsinterpretation zeigt. Dieser Vektor wird nach dem Aufruf der Erweiterung zuerst gemerkt und danach auf eine eigene Routine zur Befehlsinterpretation gesetzt. Vor dem Merken wird noch geprüft, ob der Vektor schon auf die eigene Routine zeigt. Damit wird verhindert, daß der Computer bei einem versehentlichen Doppelaufruf abstürzt. Die eigene Routine rettet zunächst den Zeiger, der auf das augenblickliche Zeichen im Basic-Text zeigt, und ruft dann die CHRGET-Routine (Befehlscodierung siehe Bild 1, Symboltabelle Bild 2) auf. Diese Routine holt das nächste Zeichen aus dem Basic-Text. Sie überliest automatisch Leerzeichen. Wenn das Ende einer Zeile oder ein Doppelpunkt erreicht wird, so wird die Z-Flag des Prozessors gesetzt. Ein Problem ergibtsich dadurch, daß in »RECORD#« der Simons Basic-Befehl »REC« vorkommt. Er wird bei Verwendung von Simons Basic also in eine interne Darstellung beginnend mit $64 umgewandelt. Das Programm testet daher, ob $64 vorliegt und verzweigt bei positiver Antwort. In beiden Fällen wird nun getestet, ob der Befehl »RECORD#«vorliegt. Unter dem Namen tab 1 (beziehungsweise tab 2 für Simons Basic) steht (rückwärts) die interne Darstellung des Befehls »RECORD«. Dabei ist zu beachten, daß »OR« wiederum nicht im ASCII-Code abgelegt ist, sondern als Token. Wird nur eine Abweichung gefunden, so wird der gemerkte CHRGET-Zeiger zurückgeholt und zur normalen Interpreterroutine gesprungen, anderenfalls tritt eine eigene Routine in Funktion (sie beginnt beim Label OK). Sie holt die Satznummer und, wenn angegeben, die Position im Satz aus dem Basic-Text und sendet die Informationen an die Floppy über die Sekundäradresse 15 (Kommandokanal). Die Floppy erwartet die Werte in folgender Form: »p« als Zeichen, das positioniert werden soll; die Sekundäradresse, mit der das relative File eröffnet wurde; die Satznummer in der Reihenfolge niederwertiges — höherwertiges Byte und, falls angegeben, die Position im Satz. Es werden folgende Routinen des Interpreters und des Betriebssystems verwendet:

TODO TABLE

getbyt : Holt einen beliebigen Ausdruck in das x-Register.
search : Sucht nach der logischen Filenummer in x.
parset : Holt logische Filenummer, Geräteadresse und Sekundäradresse in die Speicherzellen $b8,$ba und $b9
listen : Teilt dem angesprochenen Gerät mit, daß es Daten empfangen soll.
seclis : Sendet die Sekundäradresse zum angesprochenen Gerät.
iecout : Sendet den Wert im Akkumulator zum angesprochenen Gerät.
chkcom : Prüft auf Komma im Basic-Text.
getrec : Holt einen numerischen Ausdruck in den Fließkomma-Akkumulator.
fac16 : Wandelt den Wert im Fließkomma-Akkumulator in eine 16-Bit-Zahl und speichert sie in $14 und $15.
comget : =chkcom + getbyte.
unlist : Beendet die Übertragung an die Floppy.

Das Programm wurde mit dem Assembler »ASSI« übersetzt, eine Übernahme auf andere Assembler dürfte nicht schwierig sein. Der Basic-Lader (Listing 1, Source-Code: Listing 2) legt das Programm ab der Adresse 49152 ($C000) ab, schaltet die Erweiterung ein und löscht sich dann selbst, er muß also vorher auf Diskette abgespeichert werden. Die Erweiterung wird durch SYS49152 ein- und durch SYS49155 ausgeschaltet. STOP/RESTORE schaltet die Erweiterung nicht ab.

(Bernward Bretthauer/rg)

# Aufpoliertes Basic

> 39 zusätzliche und leistungsfähige Befehle stellt dieses Programm dem Programmierer zur Verfügung.

Das Programm (siehe Listing) belegt nur 8 KByte des Basic-RAMs. Der Restbedarf an Arbeitsspeicher wurde mit den Bereichen $C000 bis $CFFF und $E000 bis $FFFF abgedeckt.

Der zusätzliche Interpreter arbeitet nach demselben Prinzip wie der Commodore-Interpreter, das heißtjeder Befehl belegt nur genau 1 Byte. Die Erweiterung ist so geschrieben, daß Verzögerungen der Befehlserkennung kaum auftreten.

Das Programm wird mit SYS 64738 oder einem RESET-Schalter gestartet.

Die Basic-Erweiterung kann noch durch eigene Befehle ergänzt werden. Dazu hängt man die neuen Befehlsnamen an das Ende derTabelle, die bei $800A beginnt. Die Adresse der neuen Befehle wird an das Ende der Tabelle gehängt, die bei $8275 beginnt. Hierbei muß der Wert »Adresse — 1« angegeben werden. Beispiel: Für eine Routine ab $9E00 muß die Adresse $9DFF (im Lo-Byte/Hi-Byte-Format) angegeben werden. Bei den Befehlen ist darauf zu achten, daß das letzte Zeichen geSHIFTet angegeben wird (MSB gesetzt), damit der Computer weiß, wo das Befehlswortendet. Alle Befehle lassen sich abkürzen, da sie in 1-Byte-Tokens umgesetzt werden.

Zusätzliche Befehle kann man risikolos von $9875 unmittelbar nach dem JMP $984F-Befehl bis $9FFF (Basic-RAM-Ende) hinzufügen.

(Markus Feldmann/rg)

### Hinweise:

Wird während des Listens die SHIFTTaste gedrückt, so hält der Computer so lange damit an, wie diese gedrückt bleibt; wird jedoch die »Commodore-Taste« gedrückt, so wird sehr langsam gelistet (auch nur solange die Taste gedrückt bleibt).

Wenn der C 64 sich längere Zeit (einige Sekunden) mit der Grafik beschäftigt (Abspeichern, Laden von Grafiken) sollte man ihn auf keinen Fall mit RUN/STOP-RESTORE abbrechen, da es sonst zum System-Absturz kommen kann (das Kernal-ROM ist während des Zeichnens, und der Basic-Interpreter

während des Abspeicherns und Einladens von Grafiken abgeschaltet)!

Die Erweiterung ist darauf ausgelegt, auf ein EPROM gebrannt zu werden. Dieses ist daher ein recht einfacher Vorgang. Ist die Erweiterung nur als Programm vorhanden, läßtsie sich durch »POKE32776,0:COLD« abschalten.

Wichtig: Sollen die neuen Basic-Befehle nach »IF...THEN« benutzt werden, so müssen sie mit einem Doppelpunkt vom »THEN« getrennt werden. (Beispiel: IF A=0 THEN:PLOT X,Y)

TODO ASIDE/TABLE

# PRINT USING mit der USR-Funktion

> Haben Sie sich auch schon über die unformatierte Zahlenausgabe Ihres C 64 geärgert? Dann nehmen Sie in Zukunft die folgende USR-Funktion, um für Ihren C 64 ein PRINT USING zu erhalten.

Wie allgemein bekannt und vielfach bemängelt, bietet das Commodore-Basic keinen PRINT USING-Befehl. Doch gerade bei kommerziellen Problemen kann auf eine Druckaufbereitung von Zahlen nicht verzichtet werden. Eine Rechnung, in der nicht einmal die Dezimalpunkte untereinander stehen, ist eben unübersichtlich und keine Reklame. Für die Druckaufbereitung gibt es verschiedene Lösungen.

Die beste Lösung ist ein Maschinenprogramm. Interessierte Maschinenprogrammierer finden den Quellcode zu dieser Routine in Listing 1. Doch zunächst stellt sich die Frage, wie ein Maschinenprogramm für die Druckaufbereitung aufgerufen werden soll. Offensichtlich ist die USR-Funktion am geeignetsten, da sie sowohl in einer PRINT- als auch in einer PRINT#- oder einer LET-Anweisung verwendet werden kann. Der Aufruf der Funktion erfolgt durch USR(X),L,NK. Dabei ist X die Zahl, die aufbereitet werden soll, L die Gesamtfeldlänge der aufbereiteten Zahl einschließlich Vorzeichen und Dezimalkomma und NK die Anzahl der darzustellenden Nachkommastellen. Die USR-Funktion wandelt zunächst die Zahl X in einen ASCII-String um und berechnet die Stringlänge und die Anzahl der Nachkommastellen. Wenn bei der Wandlung von X der Interpreter die Exponentialform wählt, dann wird die Exponen-tialdarstellung zunächst in die Fließkommadarstellung umgewandelt. Danach werden die Nachkommastellen aufbereitet. Fehlende Nachkommastellen werden durch angehängte Nullen ergänzt. Müssen Nachkommastellen abgeschnitten werden, dann*wird die Zahl gerundet, wenn die erste abgeschnittene Dezimalstelle größer oder gleich 5 ist. Wenn die Anzahl der gewünschten Nachkommastellen null ist, dann wird die Zahl als ganze Zahl (Integer) ohne Dezimalkomma aufbereitet. Wegen der kaufmännischen Anwendung wird der Dezimalpunkt durch ein Dezimalkomma ersetzt. Nach der Aufbereitung der Nachkommastellen wird durch Voranstellen von Leerzeichen der String auf die erforderliche Länge gebracht. Ist der String nach der Aufbereitung der Nachkommastellen schon länger als gewünscht, dann wird er nicht mehr verändert, sondern in voller Länge ausgegeben, um einen Datenverlust zu verhindern.

Das hier vorgestellte Maschinenprogramm verwendet nur relative Sprünge — außer bei den Aufrufen der Betriebssystemroutinen. Daher kann sich jeder Anwender das Programm ohne Änderungen in den Speicherbereich laden, der ihm am geeignetsten erscheint. Als Stringpuffer wird der Bereich ab $100 benutzt. DashatzurFolge, daß die GETSTR-Routinedie-sen String nicht in den Stringbereich kopiert. Der Stringbereich wird also nicht unnötig belastet. Eine Wertzuweisung A$=USR(X),L,NK ist dadurch aber auch nicht möglich, da die nächste Stringfunktion den Bereich ab $100 wieder überschreibt. Wenn druckaufbereitete Werte einer Variablen zugewiesen werden sollen, dann muß die Anweisung A$= " " +USR(X),L,NK oder A$=(USR(X),L,NK)+" " lauten, da dann das Ergebnis der Stringverknüpfung in den Stringbereich kopiert wird und der Variablen A$ dauerhaft zugewiesen ist.

Vor dem ersten Aufruf der USR-Funktion muß jetzt noch in Adresse 785 (Low-Byte) und 786 (High-Byte) die Startadresse der USR-Funktion hinterlegt werden. Listing 2 zeigt das Basic-Ladeprogramm für die USR-Funktion. Die Ladeadresse können Sie selbst bestimmen. Das Ladeprogramm setzt die Startadresse der USR-Funktion in den Speicherstellen 785 und 786 entsprechend. Zur Verdeutlichung der Anwendung der USR-Funktion enthält das Ladeprogramm verschiedene Druckaufbereitungen der Zahl r. Das Ergebnis des Beispiels ist in Bild 1 wiedergegeben.

(Dr. Michael Irskens/ah)

# Game-Basic

> Mit dieser Befehlserweiterung lassen sich mit wenig Aufwand sehr effektvolle Spiele schreiben. Es wird dabei der Umgang mit Sprites und Sonderzeichen und die Bildschirmverwaltung (Scrolling) unterstützt.

Da ich einen Großteil meiner eigenen Programme in Basic schreibe und mir dabei die nicht sehr komfortable »POKE«-erei auf die Nerven geht, habe ich nun eine Basic-Erweiterung geschrieben die, wie ich meine, diese Vorgänge um Einiges erleichtert.

Eingabe des Programms
1)	Das Programm »Game-Basic-C000« mitdem MSE-V 1.0 eingeben (siehe Listing 1) und speichern.
2)	Programm mit »SYS 49152« starten. Das Programm kopiert sich nun selbständig an den Basic-Start ab $0800.
3)	Das Programm nun mit SAVE ”GAME-BASIC”,8 (oder bei Kassette: ,1)speichern.

Das Game-Basic kann nun ganz normal geladen und mit »RUN« gestartet werden.

## Die Speicherbelegung

Alle wichtigen Adressen (Bildschirm, Farbspeicher, Sprites, SID, Timer etc.) bleiben unverändert. Der Bereich $0800-$OFFF ist für 32 Sprites reserviert, die dort abgelegt werden. Die Erweiterungselbstliegtim Bereich $1000-$17B0. Der Bereich $17B1-$1FFF bleibtfrei und kann füreigene Maschinenprogramme genutzt werden. Ab der Adresse $2000 bis $27FF liegt ein frei definierbarer Zeichensatz. Ab $2800 beginnt der Basic-Speicher(!). Dieser dehnt sich wie gewohnt bis zurAdresse $9FFF. Das RAM im Bereich $A000-$CFFF und von $E000-$FFFF bleibtfrei und kann für eigene Zwecke verwendet werden.

## Die Befehle

Der Befehl »RESET« bewirkt einen Neustart der Basic-Erweiterung, wobei ein vorhandenes Basic-Programm nicht gelöscht wird.

Da es gerade bei Basic-Erweiterungen leicht vorkommen kann, daß man einzelne Befehle vergißt und nicht immer eine Anleitung zur Hand hat, habe ich den Befehl HELP mit eingebaut. Er listet alle zusätzlichen Kommandos auf.

Auf HiRes-Befehle habe ich grundsätzlich verzichtet, da meine Erweiterung ja hauptsächlich für die Verwendung im Spiele-Bereich vorgesehen ist. Normalerweise ist es nicht üblich, ein Spielprogramm in HiRes-Grafik zu erstellen (außer Lo-derunner und ein paar anderen), sondern mit Hilfe von Sonderzeichen. Außerdem wäre das Programm dann um einiges länger. (Es genügen schon zwei KByte, wenn man sie abtippen muß.)

Alle reinen Basic-Programme laufen natürlich auch mit der Erweiterung. Will man die Erweiterung trotzdem abschalten, ohne den Computer ausschalten zu müssen, so kann man das mittels des Befehls »BASIC« tun. Die Erweiterung kann dann mit SYS 4096 wieder aktiviert werden, falls sie nicht aus irgendeinem Grund überschrieben wurde.

Wer hat sich nicht auch schon über das lästige POKE 53281,xx:POKE 53280,xx:POKE 646,xx... geärgert? Mit dem Befehl »COLOR« lassen sich Bild-, Rahmen- und Zeichenfarbe ganz einfach einstellen. Zum Beispiel blauer Rahmen, weißer Hintergrund und grüne Schrift: COLOR6,1,5

## Steuerzeichen entfallen

Damit wären wir auch schon bei den Befehlen, die den Bildschirm betreffen. Der Befehl »SCROFF« schaltet den Bildschirm aus; zum Beispiel während vom Programm ein Bild aufgebaut wird. Mit »SCRON« wird er wieder eingeschaltet. Die komplizierte »POKE«-erei im VIC hat nun ein Ende.

Mit »PAINT« wird der Farbspeicher für den Bildschirm mit der angegebenen Farbe gefüllt. Ein beschriebener Bildschirm kann natürlichauch nachträglich umgefärbt werden. Man kann damit ganz hübsche Effekte erzielen.

»REVERS« invertiert den Bildschirminhalt.

Auch die lästigen Steuerzeichen entfallen mit der Erweiterung bis auf RVSON und RVSOFF. (Aber auch die kann man durch POKE 199,1 beziehungsweise POKE 199,0 umgehen.) Der Bildschirm wird nicht mehr mit PRINTCHR$(147),sondern einfach mit »CLS« gelöscht.

Mit dem Befehl »CLEAR« kann man sogar einzelne Zeilen beziehungsweise Zeilenblöcke löschen. Zum Beispiel »CLEAR 12,24« löscht den Bildschirm ab der 13. Zeile (die erste Zeile ist Zeile 0).

Das Editieren von Programmen wird mit meiner Erweiterung fast nicht unterstützt, da die Aufgabe der Expansion ja darin liegen soll, Spielprogramme in Basic schneller ablaufen zu lassen. Mit dem Befehl »TAB« kann man zumindest die Übersicht in einem Listing etwas erhöhen. Es wird jeder Befehl in eine eigene Zeile geschrieben, was, die Übersicht betreffend, auch nicht zu verachten ist. Bevor man dann eine Zeile wieder ändern will, muß unbedingt durch einen erneuten >TAB«-Befehl diese Darstellung wieder abgeschaltet werden.

Die Befehle INC und DEC, also Inkrement (Erhöhen) und Dekrement (Erniedrigen) sind eine Abwandlung des POKE-Befehls. Es wird nicht wie bei POKE eine Zahl in eine Adresse geschrieben, sondern eine in einer Adresse vorhandene Zahl um den angegebenen Wert erhöht beziehungsweise erniedrigt.

Sollte ein Programm für eine Sekunde anhalten, mußte man bisher eine umständliche Zeitschleife verwenden (FOR T = 1 TO 1000: NEXT). Diese wird nun durch den Befehl PAUSE ersetzt. 1 Sekunde Wartezeit = PAUSE 500.

## Zeichensatz verändern

Jedes professionelle Spiel kommt nicht ohne Sonderzeichen aus. Daher war es von vornherein klar, daß meine Erweiterung Befehle zur Erstellung eines eigenen Zeichensatzes enthalten sollte. Dabei ist die Darstellungsweise in Form von DATA-Zeichen die übersichtlichste. Ich habe dazu den Befehl »CODE« gewählt (siehe Beispiel »0« im folgenden Text).

In meiner Erweiterung gibt es den Befehl COPY: Er kopiert den Zeichensatz ins RAM, wo er dann mittels CREATE und CODE verändert werden kann. Mit CREATE wird das zu verändernde Zeichen festgelegt. Wir wollen zum Beispiel aus dem 0 einen Umlaut Ö machen. So schreiben wir folgendes: CREATE 1,15.

Die 1 bewirkt, daß wir ein Zeichen (0 wäre für Sprites) verändern und die 15 ist der POKE-Code für den Buchstaben 0. Der Befehl CODE bestimmt nun das Bitmuster für das mit CREATE ausgewählte Zeichen. Unser Ö würde nun im Programm so aussehen:

TODO

10	CREATE	1 ,1 5	oder	10	CREATE	1 ,15
20	CODE	. 11 . . 11.	20	CODE	.11 . . 11.
30	CODE		30	CODE	. . 1 1 1 1 . .
40	CODE	. .1111 ..	40	CODE	
50	CODE	.11 . .11.	50	FORI = 1TO4	
60	CODE	. 11 . . 11.	60	CODE	.11 . .11.
70	CODE	.11 . .11.	70	NEXT I	
80	CODE	.11 . .11.	80	CODE	. . 1 1 1 1 ..
90	CODE	. . 1111 ..			

Es würde auch schon folgendes genügen, da die restlichen Bitmuster mit dem 0 übereinstimmen:

10 CREATE 1 , 1 5
20 CODE .11 . . 11.
30 CODE ............
40 CODE . . 1 1 1 1 ..

Der Zeichensatz kann natürlich auch durch die altbewährte POKE-Methode verändert werden, da er jetzt »mitten« im RAM-Bereich liegt (ab $2000 dez. 8192).

Auch der Multicolor-Modus wird in meiner Erweiterung sowohl für Zeichen als auch für Sprites voll unterstützt:

Aktiviert wird dieser mit dem Befehl MULTI 1 beziehungsweise ausgeschaltet mit MULTI 0. Die Multicolor-Zusatzfarben (zwei an der Zahl) bestimmt man ebenfalls mit MULTI.

»MULTI 2, 5, 2, 6, 7« bedeutet zum Beispiel, daß ab jetzt Zeichen in den Farben Grün (5) und Rot (2), Sprites in den Farben Blau (6) und Gelb (7) dargestellt werden. MULTI 2,... bedeutet: Multicolor-Modus mit den folgenden Farben einschalten. Bei den Bitmustern ändern sichjetztallerdings die Codes: 1 = Zusatzfarbe 1,2 == Zusatzfarbe 2, 3 = normale Zusatzfarbe, . = leer

Die bunte Version unseres Ö sähe nun so aus:

TODO

CODE .	. 1 1 . . 11	
CODE .	.11 . .11	entspricht grün
CODE .		
CODE .	.222222	
CODE .	.22..22	
CODE .	.22..22	entspricht rot
CODE .	.33..33	
CODE .	.333333	entspricht aktueller Zeichenfarbe

Es ist darauf zu achten, daß die Zahlen der CODEs immer paarweise angegeben werden (Multicolor). Bei der Erstellung von Sprites wird genauso vorgegangen, bis auf folgende Änderungen:
1)	»CREATE 0, Spriteblock (32-63)«. Statt dem Zeichensatz wird der gewählte Block angegeben (32-63). Die 0 teilt dem Computer mit, daß ein Sprite und kein Zeichen verändert beziehungsweise erstellt werden soll.
2)	Das Bitmuster beim CODE-Befehl hat jetzt 24 Stellen anstatt acht bei Zeichen.

## Bildschirmverwaltung

Der Befehl SET ist ein erweiterter PRINT-Befehl. Der Unterschied zum PRINT-Befehl liegt darin, daß die Steuerzeichen entfallen (wie anfangs erwähnt).

Zum Beispiel SET 18,12,1,”TEXT”

Dieser Befehl schreibt das Wort TEXT in die zwölfte Zeile ab der 18. Spalte in weißen Zeichen. Mit dem normalen PRINT-Befehl würde man dazu eine Unmenge Steuerzeichen benötigen; außerdem ist der SET-Befehl schneller.

Der Befehl SCROLL verschiebt beziehungsweise verändert beliebige Bildschirmbereiche. Eine genauere Erklärung möchte ich an dieser Stelle unterlassen, da man die Möglichkeiten durch eigene Versuche am besten sehen kann.

Die restlichen sechs der insgesamt 26 Befehle meiner Erweiterung unterstützen ausschließlich den Umgang mit Sprites. Mit SON wird ein Sprite ein- beziehungsweise mit SOFF wieder ausgeschaltet.

SSET positioniert ein Sprite an eine beliebige Stelle im (oder außerhalb vom) Bildschirm. Das achte Bit im VIC-Register 16 für die Sprite X-Position braucht dabei nicht beachtet zu werden. Mit SPRITE wird ein Sprite definiert. Folgende Parameter werden hier angegeben:

Spritenummer, Block (Aussehen des Sprites — 32-63), Y-Expanded (ja oder nein), X-Expanded üa oder nein), vor oder hinter Bildschirmzeichen, Multicolor (ja oder nein), Grundfarbe.

Ein ganz spezieller Befehl ist SRUN. Mit SRUN kann ein beliebiges Sprite (oder auch mehrere) in eine von acht möglichen Richtungen bewegt werden. Das Programm wird dadurch aber nicht aufgehalten, da die Sprites vom Interrupt gesteuert wer-

den. Dadurch ist es zum Beispiel möglich, daß ein Sprite, während es bewegt wird, seine Gestalt verändern oder sogar das Programm gelistet werden kann. Man kann sich so zum Beispiel ein Sprite in Bewegung ansehen, während man es editiert. Aber auch hier sind natürlich eigenen Versuchen keine Grenzen gesetzt. Der letzte Befehl SSTOP ist der Gegensatz zu SRUN, das heißt er stoppt die mit SRUN gestarteten Sprites. Die Positionen der Sprites können wie bisher mit dem normalen PEEK ausgelesen werden.

Eine Befehlsübersicht gibt Tabelle 1. Das Beispielprogramm (Listing 2) zeigt, wie man innerhalb von Spielen diese neuen Befehle einsetzt. Bitte zur Eingabe von Listing 2 nicht den Checksummer verwenden, da dieser nicht mit Basic-Erwei-terungen zusammenarbeitet.

(Ronald Mayer/tr)

TODO ASIDE

## Alle neuen Befehle auf einen Blick

**RESET** Neustart der Erweiterung; bereits vorhandene Basic-Programme werden nicht gelöscht.
**HELP** Auflistung aller Befehle von Game-Basic.
**BASIC** Abschalten der Erweiterung; auch hier werden Programme nicht gelöscht
**COLOR rf,hf,zf** Rahmen- {rf), Hintergrund- (hf) und Zeichenfarbe (zf) setzen.
**REVERS** Invertiert den gesamten Bildschirminhalt.
**PAINT f** Färbt Bildschirminhalt mit Farbe f.
**CLS** Bildschirm löschen.
**SCROFF** Bildschirm ausschalten.
**SCRON** Bildschirm wieder einschalten.
**CLEAR an,en** Bildschirm wird von Zeile an bis Zeile en gelöscht.
**COPY** Zeichensatz ins RAM kopieren.
**TAB** Formatierten LIST-Modus ein- beziehungsweise ausschalten.
**PAUSE t** Das Programm wird t*0,002 Sekunden lang angehalten. INC ad,eh Addiert eh zum Inhalt der Adresse ad.
**DEC ad,eh** Subtrahiert eh vom Inhalt der Adresse ad.
**SET s,z,f,”text”** Schreibt »text« in die Zeile z, Spalte s mit der Farbe f.
**SCROLL az,ez,s,z,f,r** Scrollt Bildschirmbereich von Anfangszeile az bis Endzeile ez in Richtung r (O=nach rechts, 1-nach links). Dabei werden Zeichen mit dem Code z in der Farbe f nachgescrollt.
**SON s** Schaltet Sprite Nummer s ein.
**SOFF s** Schaltet Sprite Nummer s aus.
**SPRITE s,bl,ye,xe,pr,mc,f**
Bestimmt Sprite Nummer s:
bl = Block (32-64)
ye = doppelte Höhe (O=nein, 1=ja)
xe = doppelte Breite (O=nein, 1=ja)
pr = Priorität vor (=0) oder hinter (=1) Bildschirmzeichen
mc = Multicolor an (=1) oder aus (=0)
f = Farbe des Sprites
**SSET s,x,y** Setzt Sprite Nummer s an Position x (0-511!), y (0-255).
**SRUN s,ri** Sprite s bewegt sich in angegebene Richtung:
0	7	6	5	4	3	2	1
**SSTOP s** Sprite s hält wieder an.
**MULTI c,z1,z2,s1,s2** Multicolor-Mode ein- und ausschalten: c = 0 = Multicolor für Zeichen an
1	= Multicolor für Zeichen aus
2	= Angabe von Zusatzfarben
Bei Verwendung von 0 oder 1 brauchen die Zusatzfarben nicht mit angegeben werden.
z1 = Zusatzfarbe 1 für Zeichen
z2 = Zusatzfarbe 2 für Zeichen
s1	= Zusatzfarbe 1 für Sprites
s2	= Zusatzfarbe 2 für Sprites
**CREATE m,b1** Erstellen eines neuen Zeichens/Sprites:
m = Mode (O=Sprite, 1=Zeichen)
b1 = Spriteblock oder Zeichencode
**CODE bits** Nur in Zusammenhang mit dem CREATE-Befehl.
Bei Sprites 24 Bits, bei Zeichen 8 Bits.
.	= Hintergrundfarbe.
1	= Farbedes Zeichens/Sprites (bei Multicolor-Mode Zusatzfarbe 1) 2 = Zusatzfarbe 2
3	= Farbe des Zeichens/Sprites bei Multicolor-Mode

# Disk-Basic 64

> Disk-Basic 64 ist eine besonders leistungsfähige diskettenorientierte Ba-sic-Erweiterung, die mit fast 50 neuen Befehlen das Arbeiten mit dem Diskettenlaufwerk enorm erleichtert.

Wer kennt sie nicht, die unzähligen OPENs und PRINTs, die notwendig sind, wenn man Befehle an das 1541-Laufwerk senden will. Auch beim Laden und Speichern ist das normale Commodore-Basic nicht gerade komfortabel. Abhilfe schafft die Basic-Erweiterung »Disk-Basic 64«. Sie enthält unteranderem fast alle diskettenorientierten Befehle des Basic 4.0 von Commodore, das der C 128 ebenfalls kennt. Viele Funktionen die sich bisher nur mit Spezialprogrammen oder einem Diskmonitor realisieren ließen, werden nun auf einen Basic-Befehl hin ausgeführt und sind somit auch programmierbar.

Zur Eingabe von »Disk-Basic 64« verwenden Sie bitte den MSE. Nach dem Speichern kann die Basic-Erweiterung dann jederzeit mit »LOAD " DISK-BASIC ",8« geladen und mit »RUN« gestartet werden. Danach steht »Disk-Basic 64« im Speicherbereich von $9200 bis $9DFF. Dieser Bereich wird für Basic automatisch gesperrt, so daß nur noch 35327 Bytes, also 3584 Bytes weniger, für Basic-Programme zurVerfügung stehen. Der $C-Bereich bleibt für eigene Maschinenprogramme oder einen Monitor frei.

Doch jetzt zur Beschreibung der neuen Befehle:

### DLOAD"name"

Das Programm »name« wird von der Diskette an den Basic-Anfang geladen. Entspricht»LOAD"name",8«.

### DSAVE"name"

Das momentan im Speicher befindliche Basic-Programm wird auf der Diskette gespeichert. Entspricht »SAVE" name ",8«.

### DVERFIY"name"

Das momentan im Speicher befindliche Basic-Programm wird mit dem auf Diskette gespeicherten Programm »name« verglichen. Entspricht »VERIFY "name ",8«.

### REPLACE"name"

Ersetzt das Programm »name« auf der Diskette durch das im Speicher befindliche. Entspricht dem Basic-Befehl »SAVE" @:name",8«

### SCRATCH"name"

Das File »name« wird gelöscht. Im Namen dürfen auch die Jokerzeichen »?« und »*« verwendet werden. Es werden dann sämtliche Files, die dem Namen entsprechen, gelöscht. Entspricht dem Floppy-Befehl »S:«.

### RENAME "altname" TO "neuname"

Das File mit dem Namen »altname« wird in »neuname« umbenannt. Entspricht dem Floppy-Befehl »R:«.

### COPY"altfile"TO"neufile"

Das File »altfile« wird auf dieselbe Diskette als »neufile« kopiert. So können Sicherheitskopien von Files hergestellt werden. Mit diesem Befehl kann nicht von einer Diskette auf eine andere kopiert werden. Entspricht dem Floppy-Befehl »C:«.

### HEADER"name,id"

Die im Laufwerk befindliche Diskette wird mit dem Namen »name« und der ID »id« formatiert. Wird »,id« weggelassen, so wird die Diskette nur gelöscht. Entspricht dem Floppy-Befehl »N:«

### COLLECT

Die Diskette wird aufgeräumt, das heißt, daß alle Blöcke, die nicht von Files belegt sind, freigegeben werden und sämtliche nicht ordnungsgemäß geschlossenen Files gelöscht werden. Entspricht dem Floppy-Befehl »V«.

### INIT

Die Diskette wird initialisiert. Entspricht dem Floppy-Befehl »I«.

### CHECK

Der Fehlerkanal des Laufwerks wird auf dem Bildschirm ausgegeben (siehe auch DS$).

### CATALOG

Das vollständige Directory wird auf dem Bildschirm ausgegeben. Dabei verlangsamt die CTRL-Taste den Ausdruck, die Commodore-Taste hält die Ausgabe an und die Stop-Taste beendet den Befehl.

### DIR"$:auswahl"

Die dem Ausdruck entsprechenden Teile des Directory werden auf dem Bildschirm ausgegeben. »DIR"$:*=P"« druckt beispielsweise nur die Programme, »DIR"$:?=R"« alle einbuchstabigen, relativen Files. Ansonsten gelten die Kontrollmöglichkeiten von CATALOG.

### BSAVE"name",start,ende+l

Mit diesem Befehl kann der Speicherbereich von start bis ende auf Diskette gespeichert werden. Dies können Maschinenprogramme, Grafikbilder oder sonstiges sein.

### BLOAD"name" <,adr >

Das File »name« wird an die angegebene Speicheradresse geladen. Wird keine Adresse angegeben, so wird das File an die Adresse geladen, an der es beim Speichern stand. Da keine Basic-Vektoren verändert werden, tritt kein »OUT OF MEMORY ERROR« mehr auf, wenn in den $C-Bereich geladen wurde. Ebenso wird bei einem BLOAD in einem Basic-Programm das Programm nicht neu gestartet, wie bei LOAD, sondern direkt hinter dem BLOAD fortgesetzt.

### CHAIN"name" <,zn >

Das Basic-Programm »name« wird geladen und bei der Zeilennummer zn gestartet. Fehlt die Zeilennummer, so wird bei der ersten Zeile gestartet. Wird eine nicht existierende Zeilennummer angegeben, so gibt der Computer einen »UNDEF’D STATEMENT ERROR«aus. Achtung! Bei CHAIN gehen die Inhalte der Variablen wie bei LOAD verloren! Dies muß man beachten, wenn man CHAIN zum Nachladen von Programmteilen in Basic-Programmen einsetzen will.

### PASS"kommando"

Mit diesem Befehl lassen sich Kommandos an das Laufwerk senden, die nicht direkt von Disk-Basic unterstützt werden, so zum Beispiel die »U«- oder »B«-Kommandos.

### DPOKE adresse,wert

Dieser Befehl entspricht dem normalen POKE mit der Ausnahme, daß der Wert in der Adresse des Laufwerk-RAMs gespeichert wird. Er ist nur im Adressenbereich von 0 bis 2047 sinnvoll.

### DPEEK(adresse)

Diese Funktion entspricht dem PEEK. Der Inhalt einer Speicherstelle des Laufwerkes kann mit »?DPEEK(adresse)« ausgedruckt oder mit »variable = DPEEK(adresse)« in eine Variable übergeben werden.

### DSYS(adresse)

Mit diesem Befehl können Maschinenprogramme im Laufwerk gestartet werden. Entspricht dem Basic-Befehl SYS. Ein Beispiel: DSYS (60064) löst in dem angeschlossenen Floppy-Laufwerk einen Reset aus.

### NAME"nome"

Der 16 Zeichen lange Name einer Diskette wird umgeändert Hat der Stringname mehr als 16 Zeichen, wird ein »STRING TOO LONG ERROR« ausgegeben.

### ID"id"

Mit diesem Befehl kann die ld sowie das Formatkennzeichen in der ersten Zeile des Directory geändert werden. Der String »id« kann maximal 5 Buchstaben haben und überschreibt dann die ID, das Fbrmatkennzeichen (normalerweise »2A«) und das Leerzeichen zwischen den beiden. Achtung! Diese Änderungen beziehen sich nur auf das Directory. Die tatsächliche ID und Fbrmatkennzeichen werden nicht verändert.

### PROTECT < "name" >

Mit dem Befehl PROTECT wird eine ganze Diskette schreibgeschützt, indem das echte Fbrmatkennzeichen von »A« auf »X« geändert wird. Es sind dann keinerlei Schreibzugriffe mehr auf diese Diskette möglich.

Wird beim PROTECT-Befehl ein Name angegeben, so wird nur das File mit diesem Namen gegen Löschen und Überschreiben geschützt. Der Schreibschutz ist am Kleinerzeichen hinter dem Filetyp im Directory erkennbar. Es dürfen keine Joker im Namen angegeben werden.

### REPROTECT<"name">

Mit diesem Befehl lassen sich der Disketten- und File-Schreibschutz wieder rückgängig machen. Siehe PROTECT.

### CHANGE dev.alt TO dev.neu

Hiermit lassen sich softwaremäßig die Gerätenummern des 1541-Laufwerks verändern. So ändert »CHANGE 8 TO 9« die Gerätenummer des gerade eingeschalteten Laufwerkes auf 9. So lassen sich mehrere Laufwerke gleichzeitig betreiben.

### DEVICE dev

Mit diesem Befehl läßt sich einstellen, auf welche Gerätenummer sich die Befehle des Disk-Basics beziehen. Nach »DEVICE 9« werden sämtliche Befehle am Laufwerk unter der Gerätenummer 9 ausgeführt. Dieser Wert wird in der Speicherstelle 2 gespeichert.

### RESET d

Das Laufwerk mit der Gerätenummer d wird in den Einschaltzustand versetzt. Aus Sicherheitsgründen muß immer die Gerätenummer angegeben werden. Bitte warten Sie einige Sekunden bevor Sie dieses Laufwerk wieder ansprechen.

### MERGE"name"

Das Programm »name« wird von der Diskette geladen und an das im Speicher befindliche angehängt. Achten Sie darauf, daß das zweite Programm höhere Zeilennummern als das erste hat.

### CONCAT "altfilel" & "aMile2" TO "neufile"

Mit diesem Befehl können zwei sequentielle Files zu einem verkettet werden. Dies funktioniert nicht mit Programmen!

### DS$ und DS

In diesen beiden Variablen ist stets die aktuelle Fehlermeldung (DS$) beziehungsweise die aktuelle Fehlernummer (DS) des Laufwerkes. Sie dürfen deswegen nicht in Zuweisungen wie »DS$= "HALLO"« verwendet werden.

### DOPEN# lfn,"name",p1,p2

Mit DOPEN lassen sich alle Arten von Files auf dem Laufwerk eröffnen. Die Filenummer darf von 2 bis 255 gehen. Empfehlenswert sind Nummern von 2 bis 14, da die Sekundäradresse des Files immer gleich der Filenummer logisch »UND«-verknüpft mit 15 ist, also immer im Bereich von 0 bis 15 liegt. Für den Fileparameter p1 sind die Buchstaben »S«, »U«, »P« und »L« erlaubt. Die ersten drei stehen für sequentielle, User- und Programm-Files. Der Parameter p2 ist dann entweder »W« oder »R« für Schreiben oder Lesen.

Lautet der erste Parameter »L« so wird ein relatives File zum Schreib/Lese-Zugriff eröffnet. Die Länge eines Datensatzes (Record) wird direkt an das »L« angehängt. Der zweite Parameter entfällt. Ein Beispiel: »DOPEN 2, "name",L40« eröffnet ein relatives File mit der Record-Länge 40.

### DCLOSE<#lfn>

Dieser Befehl schließt das File mit der Nummer lfn. Wird keine Filenummer angegeben, werden alle geöffneten Files ordnungsgemäß geschlossen.

### APPEND#lfn/"name"

Ein sequentielles File wird zum Erweitern (Anhängen von Datensätzen) geöffnet. Die Sekundäradresse errechnet sich wie bei DOPEN.

### FETCH#lfn,len,xx$

Mit diesem Befehl werden aus dem File mit der Nummer lfn eine festgelegte Anzahl (len) von Zeichen in eine beliebige Stringvariable (xx$) übertragen. Die Vorteile gegenüber dem INPUT #-Befehl sind: Datensätze sind nicht mehr auf 88 Zeichen beschränkt, sondern dürfen bis zu 255 Zeichen haben. Es werden auch Kommata und Doppelpunkte übernommen. Der Befehl kann auch im Direktmodus eingesetzt werden.

### RECORD # lfn,rec < ,pos >

Mit diesem Befehl wird die Bearbeitung von relativen Dateien zum Kinderspiel. Der Zeiger auf die Datei mit der Filenummer lfn wird auf den Datensatz mit der Nummer rec positioniert. Zusätzlich kann noch die Position des Datei-Zeigers innerhalb dieses Datensatzes angegeben werden. Wird dieser Parameter weggelassen, wird immerauf das erste Zeichen positioniert. Dies entspricht der Befehlsfolge: »PRINT#15,"P";CHR$(lfn);CHR$(reclo);CHR$(rechi); CHR$(pos)«.

### LIST"name" <,start-ende >

Der LIST-Befehl wurde erweitert, so daß bei Angabe eines Namens das Listing im ASCII-Code als sequentielles File auf der Diskette abgelegt wird. Sollen nur Teile abgespeichert werden, so kann die normale LIST-Syntax für Bereichsmarkierungen angehängt werden. Basic-Programme können somit in Textverarbeitungsprogramme übernommen werden.

### ENTER"name"

Mit ENTER kann ein auf Diskette gelistetes Programm wieder in den Speicher übernommen werden. Die Zeichen, die gerade gelesen werden, werden zusätzlich auf dem Bildschirm ausgegeben. Eine Anwendungsmöglichkeit ist ein »echtes« MERGE, bei dem das zweite Programm nicht einfach angehängt, sondern die beiden entsprechend der Zeilennummern zusammengemischt werden. Achtung! Es dürfen keine doppelten Zeilennummern vorkommen!

### BLOCKS

Dies ist eine weitere Basic-Funktion. Mit ihr erhält man die Anzahl der freien Blöcke einer Diskette. Diese Funktion kann wahlweise in PRINT-Befehlen oder Wertzuweisungen verwendet werden.

### START("name")

Mit dieser Funktion läßt sich die Startadresse des Programms »name« ermitteln. Auch diese Funktion kann in PRINT-Befehlen und Wertzuweisungen verwendet werden. Ist dieses Programm nicht vorhanden, wird als Startadresse der Wert 51143 ermittelt.

### SIZE("name")

Mit dieser Funktion läßt sich die Länge eines Files in Blocks ermitteln. Hier gilt dasselbe wie bei den beiden anderen beschriebenen Funktionen.

### RESCUE"name",ft

Mit diesem Befehl kann ein soeben gelöschtes File wieder gerettet werden beziehungsweise der Filetyp eines Files geändert werden. Für den Parameter ft sind die Zahlen 1 bis 4 erlaubt. Sie bedeuten:
0 = DELeted
1 = SEQuential
2 = PRoGram
3 = USeR
4 = RELative

Der Filetyp im Directory wird angepaßt und anschließend ein VALIDATE ausgeführt, um die Blöcke dieses Files wieder zu belegen. Achtung! Wurde zwischen dem Löschen und dem Rettungsversuch auf die Diskette geschrieben (SAVE oder ähnliches), dann läßt sich mit hoher Wahrscheinlichkeit das gelöschte Programm nicht mehr retten!

### ENTRY$("name")

Mit dieser Funktion lassen sich die kompletten 30 Bytes eines Directory-Eintrags in einen String ablegen: »xx$= ENTRY$("name")«. Die Verwendung im PRINT-Befehl ist zwar möglich aber sinnlos. Achtung! An den 30 Byte langen Fileeintrag werden drei Bytes angehängt, die Spur, Sektor und Position des gelesenen Eintrages darstellen. Diese drei Bytes dürfen nicht verändert werden, da sonst beim Zurückschreiben mit WRITE das Directory zerstört wird!

### WRITE xx$

Mit diesem Befehl kann ein manipulierter Directory-Eintrag zurückgeschrieben werden. Zusammen mit der ENTRY$-Funktion läßt sich beispielsweise ein Directory-Sortierpro-gramm aufbauen. Siehe ENTRY$.

### DESTROY n

Der Track mit der Nummer n wird endgültig zerstört. Beim Zugriff auf diesen Track erhält man nur den 21 READ ERROR. Die Diskette kann nur noch durch komplettes Neuformatieren normalisiert werden. Nach der Ausführung dieses Befehls muß das Laufwerk kurz ausgeschaltet werden.

### QUIT

Mit QUIT wird Disk-Basic verlassen, ohne daß das im Speicher befindliche Basic-Programm gelöscht wird. Allerdings gehen die Variablen-Inhalte verloren.

### COMMANDS

Auf dieses Kommando hin werden alle zusätzlichen Befehle von Disk-Basic auf dem Bildschirm ausgegeben.

Noch einige kleine Anmerkungen: Anders als bei vielen Basic-Erweiterungen muß zwischen dem THEN-Befehl und einem Disk-Basic-Kommandp kein Doppelpunkt stehen! Bei allen Befehlen wird, ist das durch DEVICE festgelegte Laufwerk nicht angeschlossen, ein »DEVICE NOT PRESENT ER-ROR« gemeldet. Bei fehlendem Filenamen gibt es einen »MIS-SING FILENAME ERROR«.

(Alexander Frink/bs)

# COP — Hilfe für Datasette

> COP ist die Abkürzung für »Cassette Operations Program«. Es erleichtert den Umgang mit der eigenen Programmsammlung auf Kassetten.

COP ist ein Hilfsprogramm zur Verwaltung von Programmsammlungen. Mit ihm können Sie Programme auf einer Datasette leichter und schneller finden und bei Bedarf ein Inhaltsverzeichnis einer Kassettenseite ausdrucken.

COP besteht aus zwei Teilen: Einem Hauptprogramm, das auf einer separaten Kassette gespeichert werden kann, und den Datensätzen für die einzelnen Kassetten-Seiten, die zur einfacheren Handhabung am Anfang jeder Kassettenseite abgelegt werden sollten.

Nach dem Starten des Programms mit »RUN« erscheint ein Menü auf dem Bildschirm, dessen einzelne Punkte hier erklärt werden:

### 1)	Anfänge ermitteln

In diesem Programmpunkt können Sie die Programme einer Kassette katalogisieren. Zunächst geben Sie bitte den Namen und die Seite der Kassette ein. Danach wird nach den Titeln der einzelnen Programme gefragt. Hier können Sie auch persönliche Zusätze angeben wie zum Beispiel Zählerstand oder Fast-Tape, da der eingegebene Titel nicht mit dem Namen des Programms auf der Kassette übereinstimmen muß. Haben Sie alle Titel eingegeben, tippen Sie bitte ein »*« als Endekennzei-chen ein.

Nun wird die zu katalogisierende Kassette im zurückgespulten Zustand eingelegt und immer bis zumjeweiligen Programm vorgespult. Dann drücken Sie die STOP-Taste. Zu diesem Zweck sollte man sich vorher den Stand des Zählwertes der einzelnen Programme notiert haben. Dies geschieht fortgesetzt bis zum letzten Programm, dann wird wieder zum Eingangsmenü zurückgesprungen.

### 2)	Programm suchen

Nach der Anzeige des Kassettennamens und der Seite können die Programmnamen mit der Leertaste durchgeblättert werden. Hat man das zu suchende Programm gefunden, drückt man die Taste »RETURN«. Nun spult man die Kassette vor, der Computer stoppt den Spulvorgang automatisch kurz vor dem Programm. Drücken Sie nun »Stop« und »Play« an der Datasette, und das gewünschte Programm wird automatisch geladen. COP wird dabei gelöscht.

### 3)	Zeiten abspeichern

In diesem Programmteil werden alle erstellten Daten (Kassetten- und Programmnamen und Zeitzum Stoppen) in einem Datensatz gespeichert. Dies kann zum Beispiel am Anfang der zu bearbeitenden Kassette geschehen. Dann sollte man das erste Programm allerdings nicht direkt am Anfang des Bandes speichern, da es dann den Datensatz überschreibt oder umgekehrt. Am praktikabelsten hat sich ein Vorspulen bis zum Zählwerksstand »30« erwiesen, bevor man das erste Programm speichert.

### 4)	Zeiten laden

Hier werden die unter Punkt 3 abgespeicherten Datensätze wieder geladen.

### 5)	Verzeichnis ausdrucken

Zunächst erscheinen die ersten 14 der auf der Kassette befindlichen Programme auf dem Bildschirm. Mit der Leertaste kann zu den nächsten 14 weitergeblättert werden. Wurden alle Programme aufgelistet, kann man sich das komplette Verzeichnis auf dem Plotter 1520 ausgeben lassen. Eine Anpassung an andere Drucker dürfte überhaupt kein Problem sein, dakeinedruckerspezifischen Befehleverwendetwerden. Einzig und allein der OPEN-Befehl in Zeile 5160 muß entsprechend des vorhandenen Druckers geändert werden.

Noch einige Hinweise: Das Programm ist auf 30 Titel pro Kassette beschränkt, mehr sind auf einer Kassette kaum sinnvoll. >Turbo-Tape«-Benutzer müssen noch die Zeile 2200 ändern. Dort wird das Eintippen der Tastenkombination »SHIFT/LOAD« simuliert, um das angewählte Programm zu laden, was mit manchen »Turbo-Tape«-Versionen nicht funktioniert. Am allereinfachsten wird dort nur der END-Befehl eingesetzt und der LOAD-Befehl dann von Hand eingegeben.

Für diejenigen, die das Programm verändern wollen, hier noch eine Variablenliste:

(Hubertus Luhmann/bs)

### Variablenliste:

TODO TABLE

A$	Eingabe über GET
C$	Kassettennummer
CS$	Kassettenseite
PP$(Q)	laufende Programmtitel
Q	Zählervariable
P$/P1$	Play/Play löschen
F$/F1$	FFwd/FFwd löschen
S$/S1$	Stop/Stop löschen
R$/R1$	Record/Record löschen
Z$/Z1$	Rewind/Rewind löschen
PR$/PL$	Anzeige »Programm:«/PR$ löschen
Q1	Höchste Anzahl Programme
Q2	Höchste Anzahl Programme und Sternchen (Q2=Q1 + 1)
TI$(Q)	Zeitvariable
T1$(Q)	Zwischenspeicher der Zeitvariablen

# So stellt man die Datasette ein!

> Die Fehlermeldung »LOAD ERROR« weist meistens auf eine defekte Kassette oder einen dejustierten Tonkopf hin. Dieser läßt sich allerdings mit einem Schraubenzieher einstellen.

Wer mit seiner Datasette Programme eines anderen Data-setten-Besitzers laden will, der erlebt nach Eingabe des LOAD-Befehls oft die bizarrsten Dinge. Neben einem lapidaren »LOAD ERROR«, kann man andere Fehlermeldungen wie »OUT OF MEMORY ERROR« erhalten, aber auch Meldungen wie »FOUND A!.;$Y&«, (meist folgt dann innerhalb von Sekunden ein »LOAD ERROR«). Wenn es ganz schlimm kommt, stürzt der Computer auch noch ab und läßt sich nur mit einem Reset zu einem weiteren Ladeversuch bewegen, der dann allerdings ähnlich effektvoll endet.

Hier gibt es mehrere mögliche Fehlerursachen: die Kassette ist defekt, der Tonkopf ist verstellt oder die elektromagnetischen Störstrahlungen eines Fernsehers oder Monitors verhindern einen einwandfreien Betrieb. Das letzte Problem läßt sich lösen, wenn man die Datasette bis auf maximale Kabellänge vom Fernseher während dem Laden entfernt. Sollte die Kassette defekt sein, hilft nur eine Sicherheitskopie. Am häufigsten tritt allerdings der zweite Grund, ein dejustierter Tonkopf, auf. Im folgenden soll beschrieben werden, wie man seinen Tonkopf kurzzeitig auf ein anderes Programm einstellen kann. Eine komplette, einwandfreie Einstellung läßt sich allerdings nur mit einem kleineren Bastelaufwand erreichen. Wir werden im64’er, Ausgabe 10/85, eineSchaltungvorstellen, mitderdie Datasette auf jede Kassette optimal justiert werden kann. Will man aber nur ein Programm laden, das man aufgrund einer falschen Einstellung leider nicht laden kann, reicht das folgende Verfahren aus:

Versuchen Sie, das Programm zu laden. Sollte derComputer überhaupt nichts auf der Kassette finden (Bildschirm bleibt hellblau, Datasette stoppt nicht, keine »FOUND ...«-Meldung), dann sollten Sie vorerst lieber auf das Programm verzichten. Die Tonkopfeinstellung, mit der dieses Programm gespeichert wurde, und die ihrer Datasette unterscheiden sich dann so erheblich, daß es einerseits sehr lange dauert, den Tonkopf ohne Zusatzhardware einzustellen, Sie andererseits aber mindestens die gleiche Zeit brauchen, ihre eigene Tonkopfeinstellung wiederzufinden.

Sollte der Computer etwas auf dem Band finden, dann läßt sich die Dejustierung des Kopfes in drei Klassen einteilen: — Der Computer meldet sich mit »FOUND filename«, lädt einige Sekunden bis Minuten und meldet dann einen »LOAD ERROR«: Entweder ist der Tonkopf nur sehr leicht verstellt oder die Kassette ist defekt.

- Der Computer meldet sich mit »FOUND filename« und so-fort mit »LOAD ERROR« oder »OUT OF MEMORY ERROR« oder einer anderen Fehlermeldung: Der Tonkopf ist etwas mehr verstellt als im ersten Fall, allerdings immer noch nicht sehr.
- Der Computer meldet sich mit »FOUND irgendwas«, wobei »irgendwas« meist aus Grafikzeichen und Farbumschaltungen besteht, meldet sofort oder später einen Fehler oder stürzt irgendwann ab: Der Tonkopf ist mittelstark verstellt und dürfte sich ohne Zusatzhardware noch richten lassen.

Bei der Tonkopfeinstellung tut man sich erheblich leichter, wenn man die Datasette aufschraubt. Lösen Sie also den Stecker der Datasette vom Computer, nehmen Sie eine in der Datasette liegende Kassette heraus und lösen Sie die vier Schrauben an der Unterseite.

Nehmen Sie dann das Oberteil des Gehäuses ab. Ziemlich genau in der Mitte der Mechanik befindet sich der Tonkopf. Er ist mit zwei Schrauben an der Mechanik befestigt (siehe Bild). Mit der linken Schraube läßt sich die Einstellung des Tonkopfes vornehmen. Drehen Sie niemals an der rechten Schraube!

Bevor Sie nun wild an der linken Schraube herumkurbeln, sollten Sie sich diejetztige Position merken. Die Schraube hat einen langen und einen kurzen Schlitz. Merken Sie sich die Position des langen Schlitzes am besten wie die Zeiger einer Uhr. Steht der beispielsweise senkrecht, kann man das als zwölf Uhr interpretieren. Vergessen Sie diese Einstellung nicht, sonst müssen Sie nachher stundenlang herumprobieren, bis Sie Ihre eigenen Kassetten laden können.

Legen Sie nun die Kassette mit dem Programm, das Sie laden wollen, ein. Verdrehen Sie die linke Kopfschraube ein wenig (maximal um ein bis zwei »Stunden«). Es ist egal in welche Richtung Sie drehen, Sie sollten sie sich nur merken. Machen Sie wieder einen Ladeversuch. Es gibt jetzt drei Möglichkeiten:

- Es hat sich überhaupt nichts geändert: Verdrehen Sie die Schraube wieder um ein bis zwei »Stunden« in dieselbe Richtung und machen Sie einen erneuten Ladeversuch.
- Der Fehler ist, gemäß der oben gemachten Abstufungen, kleiner geworden: Verdrehen Sie die Schraube wieder um ein bis zwei »Stunden« in dieselbe Richtung und machen Sie einen erneuten Ladeversuch.
- Der Fehler ist, gemäß der oben gemachten Abstufung, größer geworden oder der Computer findet gar nichts mehr: Drehen Sie in die Ausgangsstellung zurück und probieren Sie es nochmal in der anderen Richtung.

Sollten Sie irgendwann das Programm fehlerfrei laden können: Herzlichen Glückwunsch! Drehen Sie nun die Schraube wieder in ihre Ausgangsstellung zurück und speichern Sie das Programm.

Ein letztes Mal sei hier auf die kleine Schaltung in Ausgabe 10/85 verwiesen, mit der sich jede Datasette exakt auf jede noch so verstellt aufgenommene Kassette in wenigen Minuten einstellen läßt.

(bs)

# Turbo Tape de Luxe

> Machen Sie Ihrer Datasette Beine: Mit diesem Programm wird sie sogar etwas schneller als das Floppy-Lauf-werk.

Datasettenbesitzer müssen eigentlich gemütliche Leute sein. Bis zu zwanzig Minuten kann es nämlich dauern, wenn man ein umfangreiches Programm laden will. Viele Leute haben deswegen schon schnelle Lade- und Speicherroutinen geschrieben, die die Datasette um Faktoren zwischen 5 und 15 beschleunigen. Am bekanntesten und verbreitetsten ist das Programm »Turbo Tape«.

Das hier abgedruckte Programm »Turbo Tape de Luxe« (siehe Listing) zeichnet sich vor anderen Schnelladesystemen durch folgende Punkte aus:

- Es ist kompatibel zu »Turbo Tape«, kann also mit »Turbo Tape« gespeicherte Programme lesen. Daraus folgt, daß der Kassettenbetrieb um den Faktor 10 (wie bei »Turbo Tape«) beschleunigt wurde. Das ist immerhin sogar etwas schneller als das Floppy-Laufwerk 1541 (ohne Hypra-Load).
- Es arbeitet nicht mit neuen Basic-Befehlen, sondern mit einem Eingabemenü, so daß keine Konflikte mit Basic-Erweite-rungen entstehen können.
- Das Basic-ROM kann während des Betriebs abgeschaltet werden, so daß auch Programme, die teilweise unter dem Basic-ROM liegen (lange Spiele und ähnliches), gespeichert werden können.
- Das Programm schütztsich selbstvordem Überladen durch andere Programme.
- Es können beliebige RAM-Bereiche gespeichert werden.
- Programme können codiert und decodiert werden, damit kein Unbefugter Zugriff auf die Programme hat.
- Mit Hilfe des SMON kann das Programm in beliebige Speicherbereiche geschoben und sogar in ein EPROM gebrannt werden.

Nach dem Abtippen mit dem MSE und Speichern des Programms, kann es mit »SYS 49152« gestartet werden. Vorher sollten Sie jedoch NEW eingeben. Das Hauptmenü erscheint dann sofort und wartet auf eine Eingabe. Mit der Taste »Q« kann man dieses Menü wieder verlassen und dann später mit dem Befehl »£T« wieder ins Menü zurückkehren. Damit dies funktioniert, wird allerdings ein Basic-Vektor verbogen, der von vielen Basic-Erweiterungen benutzt wird und somit eine Zusammenarbeit mit »Turbo Tape de Luxe« völlig unmöglich macht. Soll dieser Vektor nicht verbogen werden, muß »Turbo Tape de Luxe« mit »SYS 49164« gestartet werden. An den Menüfunktionen hat sich nichts geändert, allerdings kann nach dem Verlassen mit »Q« nicht mehr mit »£T« ins Menü zurückgesprungen werden, sondern nur mit dem angegebenen SYS-Befehl.

## Die Kommandos

Doch nun zur Erklärung der einzelnen Menü-Kommandos:

### L — Load

Nach dem Drücken derTaste »L« wird vom Benutzer die Eingabe des Namens des zu ladenden Programmes verlangt. Soll das nächstbeste Programm geladen werden, darf der Name weggelassen werden. Ebenso ist eine Angabe mit Abkürzung (Joker) (»*«) erlaubt (Beispiel: »TUR*«). Da bei fastjeder Programmoption ein Filename angegeben werden muß, wird im einzelnen nicht mehr darauf hingewiesen.

Nachdem das Programm gefunden wurde, werden Name und Adressen des Programmes angezeigt und auf einen Druck auf die Commodore-Taste gewartet. Wird diese Taste nicht gedrückt, wird nach zirka acht Sekunden der Ladevorgang fortgesetzt.

### P — Proload

Mit dieser Funktion können sowohl Basic-, wie auch Maschinensprache-Programme geladen und automatisch gestartet werden. Ist das eingeladene Programm ein Basic-Programm, wird der »RUN«-Befehl simuliert. Ist das geladene Programm hingegen ein Maschinen-Programm, wird es nach dem Laden an der Anfangsadresse gestartet. Dies funktioniert nicht bei allen Maschinen-Programmen!

### V — Verify

Mit Verify kann ein abgespeichertes Programm mit dem im Speicher befindlichen verglichen werden.

### S — Save

Speichert das im Speicher vorhandene Basic-Programm.

### A — Allsave

Speichert beliebige RAM-Bereiche ab. Die Start- und Endadresse müssen in hexadezimaler Form angegeben werden. Beim Laden wird das Programm wieder an diese Adressen zurückgeladen.

### O — Original

Speichert RAM-Bereiche so ab, daß sie später an andere Adressen geladen werden. Als erstes müssen Sie die Adressen angeben, an die das Programm später geladen werden soll. Danach geben Sie die Adressen an, an denen sich das Programmjetzt befindet. Zum Schluß folgt, wie bei allen Save-Befehlen, der Filename.

### R — Renew

Holt ein durch »NEW« oder einen Reset gelöschtes Basic-Programm wieder zurück.

### K — Kill

Zerstört »Turbo Tape de Luxe« und »biegt« die Vektoren wieder gerade. Zum Neuaufruf muß es erneut geladen werden.

### M — Monitor

Löscht den Bildschirm und startet einen Maschinensprache-Monitor, sofern dieser im Speicher vorhanden ist. Damit individuelle Monitore verwendet werden können, muß die Einsprungadresse in $C52C/$C52D angepaßt werden. Ist kein Monitor vorhanden, kann das Programm abstürzen!

### C — Code

Codiert einen Speicherbereich nach Adressenangabe. Das so codierte Programm kann gespeichert und später wieder geladen und decodiert werden.

### D — Decode

Decodiert einen bestimmten Speicherbereich.

Wer sich einen individuellen Code erstellen möchte, damit außer ihm niemand Zugriff auf die Programme hat, muß folgende zwei Speicherstellenpaare ändern:
CODE1 : C591 und C59C
CODE2 : C594 und C59A

In den beiden Speicherstellen eines Paares muß immer dasselbe Byte stehen!

### Q — Quit

Verläßt das »Turbo Tape de Luxe«-Menü und springt zurück in Basic.

### ± — Basic-ROM ein-/ausschalten

Im »Turbo Tape de Luxe«-Menü kann das Basic-ROM ($A000-$BFFF) abgeschaltet werden, um Programme, Grafikbilder und anderes im RAM unter dem ROM aus diesem Bereich speichern zu können. Der derzeitige Zustand des Basic-ROMs wird in dem Kästchen »BR« angezeigt.

Die abgedruckte Version von »Turbo Tape de Luxe« liegt im Speicherbereich von $C000 bis $C9B0. Sie kann mit dem SMON und seinem »C«-Befehl in beliebige Speicherbereiche geschoben werden, da alle verwendeten Sprungtabellen als BIT-Befehle getarnt sind. Genaueres zur Verwendung des »C«-Befehls beim SMON entnehmen Sie bitte der Anleitung zum SMON selbst (64’er, Ausgabe 11/84 bis 2/85).

Wer will, kann »Turbo Tape de Luxe« nach dem Verschieben sogar in ein EPROM brennen.

Sollte sich »Turbo Tape de Luxe« einmal mit »Load Memory Error« melden, dann haben Sie versucht, ein Programm zu laden, das »Turbo Tape de Luxe« teilweise überschrieben und gelöscht und somit einen sauberen Systemabsturz heraufbeschworen hätte. Diese Sicherheitsabfrage funktioniert auch in etwaigen verschobenen Versionen.

(J. Golombek/bs)

# Floppy-Fehler ohne Rätsel

Wer kennt ihn nicht, den bekannten Vierzeiler, mit dem der Fehlerkanal des Disketten-Laufwerks abgefragt wird? Mit diesem Programm zeigt der Computer automatisch an, welcher Fehler aufgetreten ist.

Das Eintippen jenes berühmten Vierzeilers ist zwar ein einfaches, aber zeitraubendes Verfahren:
10 OPEN15,8,15
20 INPUT # 15,A1,A2$,A3,A4
30 PRINTA1,A2$,A3,A4
40 END

Immerhin sind ungefähr 56 Tasten zu drücken. Meistens vergißt der Anwender außerdem die Zeilen wieder zu löschen. Eine Alternative besteht darin, das DOS 5.1 der Demodiskette zu laden. Doch stellte auch dies keine befriedigende Lösung dar. Es sind immer noch einige Tasten zu drücken. Eine bessere Lösung ist ein entsprechendes Maschinenprogramm (Listing). Der Fehlerkanal der Floppy wird selbständig vom Computer überwacht und bei Bedarf vollautomatisch eine Fehlermeldung ausgegeben.

Das Programm ist ganz in Maschinensprache geschrieben. Nach dem Betätigen einer beliebigen Taste werden Sie aufgefordert, die Startadresse einzugeben. Das Programm ist frei verschiebbar, die entsprechenden Änderungen werden vom Programm selbst durchgeführt. Zunächst werden Sie noch nichts bemerken, außer, daß sich der Computer mit einem READY wiedermeldet. Versuchen Sie aber nun einmal eine Fehlermeldung der Floppy zu erzeugen. Als Beispiel können Sie ein Programm von der Diskette laden, das es nicht gibt. Auf dem Bildschirm erhalten Sie sofort die entsprechende Fehlermeldung und die Aufforderung, eine Taste zu drücken. Die Funktionen des Computers sind um eine wichtige und nützliche Fähigkeit erweitert worden. Außerdem arbeitet das Programm innerhalb von Basic-Programmen ebenfalls zuverlässig. Bei einem Fehler wird ein Programm nicht unterbrochen. Als weitere Besonderheit ist zu erwähnen, daß das Programm auch mit anderen Hilfsprogrammen zusammenarbeitet. Sie können zum Beispiel Hypra-Load oder das DOS 5.1 weiterhin benutzen. Das Programm wird durch Drücken der Run-Stop/ Restore-Taste unterbrochen. Ein erneuter Start istjederzeit mit SYS (Startadresse) möglich.

### Funktionsweise des Programmes

Zuerst werden die IRQ-Vektoren geändert. DerComputerar-beitet dann bei jedem Interrupt das Programm ab. Dann findet eine Verzögerung statt, damit der Fehlerkanal nicht bei jedem Interrupt abgefragt wird. Danach wird geprüft, ob die Diskettenstation arbeitet und wenn ja, wird die Routine verlassen. Als nächstes wird der Fehlerkanal abgefragt und geprüft, ob ein Fehler vorliegt. Ist dies der Fall, dann wird die augenblickliche Cursorposition zwischengespeichert und der Computer merkt sich den Inhalt der oberen drei Zeilen. Diese Zeilen werden dann gelöscht, der Cursor abgeschaltet, eine neue Schriftfarbe gewählt und die Fehlermeldung in reverser Schrift ausgegeben.

Anschließend wird die Aufforderung, eine Taste zu drücken, aufden Bildschirm geschrieben. DerComputerwartetdann so lange, bis eine Taste gedrückt wird. Dann wird der ursprüngliche Bildschirminhalt wieder hergestellt, die alte Bildschirmfarbe ins Register gePOKEt und der Cursor auf den alten Platz gebracht. Das Programm benutzt insgesamt elf Unterroutinen des Betriebssystems. Die Farbe, in der die Fehlermeldung ausgegeben werden soll, ist durch den Befehl POKE Startadresse+123, Farbcode veränderbar. Dem Programmierer ist mit diesem Programm ein sehr gutes Hilfsmittel in die Hand gegeben.

(Georg Kramer/aw)

# Diskmaster — Beherrschen Sie das 1541-Laufwerk!

> Dieses Programm macht die Bedienung des Floppy-Laufwerks 1541 sicher und komfortabel. Alle Befehle, die man sich bislang mühsam aus dem Handbuch suchen mußte, stehen auf Knopfdruck parat. Außerdem gibt es die Möglichkeit, eine Reihe von kommerziellen Programmen mit eigenen Basic-Programmen zu kombinieren.

Das Programm Diskmaster (siehe Listing) ist ein Maschinensprache-Programm, das für den Commodore 64 geschrieben wurde, damitsich Floppy-geplagte Commodore-Besitzer nicht länger die Finger wund schreiben müssen, wenn sie zum Beispiel die Floppy initialisieren oder ein Programm laden wollen.

Diskmaster muß mit dem MSE eingegeben werden.

### Das Hauptmenü

Nachdem Diskmaster mit SYS 49152 gestartet wurde, meldet es sich mit dem Hauptmenü. Hier gibt es fünf Wahlmöglichkeiten:

1.	Programm laden
2.	Programm speichern
3.	Diskette verwalten
4.	Inhalt zeigen
5.	Zurück zu Basic

Man kann nun einen der Menüpunkte anwählen, indem man eine der Tasten 1 bis 5 tippt. Der angewählte Menüpunkt erscheint dann revers auf dem Bildschirm. Die Wahl wird nun durch Drücken der RETURN-Taste bestätigt.

### Programm laden

Das erste Untermenü bietet insgesamt vier Menüpunkte:

1.	laden
2.	laden und starten
3.	merge (zusammenfügen)
4.	zurück

Es gib hier nun vier verschiedene Möglichkeiten, ein Programm zu laden. Unter Menüpunkt 1 wird ein Programm genauso geladen, wie man das vom Basic her bereits kennt, allerdings geht es hier etwas komfortabler. Man gibt einfach den Namen des gewünschten Programms ein, schließt die Eingabe mit RETURN ab, und der C 64 lädt das Programm. Vom Hauptmenü aus kann man dann wieder in das Basic zurück und das Programm RUN neu starten.

Menüpunkt 1 bietet im Prinzip nichts Neues. Die Punkte 2 und 3 hingegen stellen eine Erweiterung der Bedienungsmöglichkeiten gegenüber dem Standard dar. Unter Punkt 3 wird das angegebene Programm an das bereits im Speicher befindliche Basic-Programm angehängt. Man kann also zwei (oder mehr) Programme miteinander verknüpfen und erspart sich so eine MengeSchreibarbeit. Hierbei istallerdingsunbedingtdar-auf zu achten, daß die Zeilennummern des zweiten Programms höher sind als die des ersten.

### Programm speichern

Der Menüpunkt 2 des Hauptmenüs ermöglicht das Speichern von Programmen, die sich im Basic-Speicherbereich befinden. Dazu wird einfach der Name des Programms eingegeben. Falls ein Programm gleichen Namens bereits existiert, wird eine entsprechende Fehlermeldung in der untersten Zeile des Bildschirms ausgegeben.

### Diskette verwalten

Alle Befehle, die der Floppy über den Kommando-Kanal übermittelt werden, können unter Menüpunkt 3 des Hauptmenüs übermittelt werden. Es erscheint folgendes Untermenü:

1.	Initialisieren
2.	Reorganisieren
3.	Name ändern
4.	File löschen
5.	File kopieren
6.	Name der Disk ändern
7.	Formatieren
8.	zurück

Wählt man Punkt 1 an, so wird die Floppy initialisiert.

Unter 2 wird ein Validate ausgeführt, das heißt, alle unbenutzten Blocks auf der Diskette freigegeben.

Mit Punkt 3 kann der Name eines Files geändert werden. Diskmaster fordert Sie hier auf, den alten und den neuen Namen des betreffenden Files einzugeben. Anschließend wird der Name geändert.

Menüpunkt 4 wird angewählt, wenn man ein File (Programm oder Datei) löschen möchte. Hier muß der Name des betreffenden Files eingegeben werden.

Unter Menüpunkt 5 können Files auf der Diskette kopiert werden. Auch hier müssen der Name des alten und des neuen Files angegeben werden.

Will man den Namen der Diskette ändern, so muß man den Menüpunkt 5 anwählen. Man kann dann den neuen Namen sowie die neue ID der Diskette eingeben.

Anschließend wird der Name geändert. Soll eine Diskette hingegen total gelöscht werden, ist Menüpunkt sieben an der Reihe. Auch hier werden Name und, wenn eine vollkommene Neuformatierung der Diskette verlangt wird, ID der Diskette eingegeben. Punkt acht führt Sie zurück ins Hauptmenü.

### Inhalt zeigen

Vom Hauptmenü aus kann der Inhalt der Diskette gezeigt werden. Dazu wird der Menüpunkt 4 gewählt. Es erscheint dann, nach kurzer Diskettenaktivität, ein kleines Fenster auf dem Bildschirm, in dem die erste »Seite« des Directorys ausgegeben wird. Die jeweils nächste Seite wird durch Drücken der Taste F3 aufgerufen. Mit F1 verläßt man diesen Menüpunkt wieder.

### Der Editor

Diskmaster bietet zur komfortablen Eingabe der Namen einen kleinen Eingabe-Editor. Dieser bietet die üblichen Funktionen des C 64 Basic-Editors, bis auf eine Änderung: DEL löscht den Buchstaben unter und hinter dem Cursor.

### Zeigen der Directory während der Eingabe

Das Directory kann nicht nur vom Hauptmenü aus angesehen werden, sondern auch immer dann, wenn eine Eingabe, zum Beispiel eines Filenamens, erfolgen soll. Dank dieser Funktion kann man sich zum Beispiel davon überzeugen, daß das Programm, das man laden möchte, auch wirklich existiert, ohne ins Hauptmenü gehen zu müssen. Will man das Directory ausrufen, so muß man F3 drücken. Mit F1 verläßt man das Directory wieder.

### Verlassen eines Menüpunktes

Jeder Menüpunkt kann verlassen werden, ohne daß er ausgeführt wird, in dem man F1 druckt. Es erscheint dann wieder das jeweilige Menü und es kann ein anderer Menüpunkt gewählt werden.

### Die Fehlermeldungen

Es erscheinen die üblichen Fehlermeldungen der Floppy, wenn durch einen Eingabefehler eine Fehlerbedingung entstanden sein sollte. Mit F1 wird die Fehlerroutine wieder verlassen.

### Verträglichkeit mit anderen Programmen

Diskmaster kann mit einer Reihe von bekannten Programmen benutzt werden, zum Beispiel Vizawrite. Diskmaster funktioniert, wenn man eine kleine Einschränkung macht, auch mit Hypra-Load. Man muß dann allerdings auf das Einlesen des Di-rectorys verzichten. Stellt sich das Directory als lebenswichtig heraus, so muß man mit POKE 1,55 das Hypra-Load inaktivieren. Als Alternative bietet sich außerdem an, das Directory als Basic-Programm zu laden.

### Einige technische Details

Diskmaster belegt den Speicherplatz von $C000 bis $D000. Außerdem wird der Speicherbereich von $D000 bis $FFFF zum Teil zur Zwischenspeicherung des Directorys benutzt. Daher kann kein Directory eingelesen werden, solange Hypra-Load aktiv ist. Ist Hypra-Load aktiviert, so erscheint nach dem Laden eines Programms die Warmstartmeldung der Floppy.

Das Directory wird bei Diskmaster auf eine etwas ungewöhnliche Art eingelesen: Diskmaster initialisiert zunächst die Diskette und prüft anschließend anhand des Namens und der ID, ob das Directory der betreffenden Diskette bereits eingelesen wurde. Wenn ja, so wird das Directory nicht erneut eingelesen. Das spart Zeit, besonders bei sehr vollen Disketten.

Selbstverständlich kann die Diskette vom Basic aus wie üblich benutzt werden.

(Volker Köhne/aw)

# Entstörung des 1541-Laufwerks

> Bisher war es fast unmöglich, den Monitor oder Fernseher in die unmittelbare Nähe des Diskettenlaufwerks zu stellen. Durch die elektromagnetischen Felder ist kaum noch ein störungsfreier Zugriff möglich. Abhilfe schafft eine selbstgebastelte Abschirmung.

Eine Computeranlage braucht schon ihren Platz: Computer, Monitor, Diskettenstation und Drucker benötigen schon fast den gesamten Arbeitstisch. Warum also nicht platzsparend das Floppy-Laufwerk unter den Fernseher oder zumindest näher an ihn heran stellen. Doch unterschreitet man einen gewissen Mindestabstand, führt jeder Zugriff auf eine Diskette nur noch zu Lesefehlern. In einem Monitor und Fernsehgerät wird mit sehr starken elektromagnetischen Feldern gearbeitet, die die ungenügend abgeschirmte 1541 bei geringem Abstand aus dem Takt bringen können. Wer wenig Platz hat, und das Laufwerk am oder unter dem Fernseher stehen haben möchte, der muß die Abschirmung entscheidend verbessern. Das ist aber sehr viel einfacher als es sich anhört. Sie brauchen noch nicht einmal Ihren Lötkolben anzuheizen, ein Schraubenzieher ist schon Werkzeug genug.

Sie schrauben einfach ihre Floppy auf und nehmen den Deckel ab, natürlich erst, nachdem Sie den Netzstecker gezogen haben! In den Deckel kleben Sie nun eine möglichst starke Metallfolie, also keine einfache Alu-Frischhaltefolie. Die Folie muß aus einem Stücksein. Achten Sie auch darauf, daß Sie nur die vorderen zwei Drittel des Deckels bekleben, so daß die Lüftungsschlitze hinten frei bleiben, sonst stirbt Ihr Laufwerk recht bald den Wärmetod.

Die Metallfolie muß nun noch leitend mit dem Laufwerk-Chassis verbunden werden, damit der gewünschte Abschirmeffekt eintritt. Zu diesem Zweck benötigen Sie eine Kontaktfeder, die Sie sich sehr einfach aus einem Blech nach unserer Vorlage (siehe Bild) basteln können. Diese Kontaktfeder kann bei Laufwerken mit kurzer Platine einfach an einem der beiden vorderen Befestigungswinkel festgeschraubt werden. Bei Laufwerken mit langer Platine stehen diese beiden Befestigungswinkel nicht mehr zur freien Verfügung. Isolieren Sie einfach die Unterseite der Kontaktfeder, damit keine Kurzschlüsse auf der Platine entstehen können. Dann darf die Kontaktfeder auf der Platine am Befestigungswinkel festgeschraubt werden. Wird der Deckel wieder aufgesetzt, sollte die Kontaktfeder gegen die Metallfolie drücken und somit die Verbindung herstellen.

Wer sein Laufwerk offen, das heißt ohne Deckel, betreibt, hat es sogar noch einfacher. Sie besorgen sich dann ein dünnes Metallblech im DIN-A3-Format, das Sie halbkreisförmig über das offene Laufwerk stülpen. An den unteren Befestigungswinkeln, die das Chassis im Gehäuse halten, müssen Sie nun einfach eine leitende Verbindung zwischen Blech und Chassis herstellen. Dies geht zum Beispiel durch Zwischenklemmen von zwei Pfennig-Stücken. Da das Blech nur seitlich, aber nicht nach vorne und hinten abschließt, ist eine mehr als ausreichende Kühlung gewährleistet.

Nach diesen kleinen Umbauten sollten Sie in der Lage sein, das Laufwerk ohne Schwierigkeiten in unmittelbarer Nähe von Fernseher oder Monitor zu betreiben.

(Uwe Gerlach/bs)

# Schnelles Formatieren mit der 1541

> Das 1541-Floppy-Laufwerk gehört nicht nur beim Laden, sondern auch beim Formatieren einer Diskette nicht gerade zu den schnellsten seiner Gattung. »Fast Format« ändert das.

Wer bislang mit einer Datasette gearbeitet hat, wird erstaunt feststellen, daß eine Diskette erst formatiert werden muß, bevor man etwas mit ihr anfangen kann. Zu allem Unglück dauert dieser Vorgang, bei dem die Diskette in Spuren und Sektoren eingeteilt wird, fast genau 80 Sekunden. Wenn man beispielsweise ein ganzes Paket (zehn Disketten) nacheinander formatieren möchte, sitzt man fast 15 Minuten vor dem Computer. Fast Format reduziert diesen Vorgang auf nur 11 Sekunden pro Diskette, oder, bei zehn Disketten, auf unter drei Minuten.

Das eigentliche Fast Format ist als Maschinenprogramm im $C000 Bereich abgespeichert (Listing 1). Die neue Formatier-Routine wird durch folgenden Befehl aufgerufen:
SYS49152,N$,I$,D

Dabei ist N$ der neue Diskettenname, l$ die genau zwei Zeichen lange ID und D die Geräteadresse des betreffenden Floppy-Laufwerks. Der Fast Format-Befehl kann genauso wie der normale Formatierbefehl (N:Name, ID) verwendet werden. Etwas einfacher geht es mit dem kleinen Basic-Unterpro-gramm (Listing 2). Es fragt alle Parameter ab und startet die Format-Routine. Bitte vergessen Sie nicht, vor dem Start des Programms eine neue Diskette einzulegen, denn sonst ist Ihr gerade eingegebenes Programm wieder verloren.

Eine kleine Einschränkung noch zum Schluß. In der Regel gibt es keine Probleme mit schnell formatierten Disketten, bei älteren und verstellten Laufwerken sind allerdings Fehler möglich. Verwenden Sie deshalb für ganz besonders wichtige Daten-Disketten den normalen Formatier-Befehl.

(Jan Kusch/aw)

# FMON 1541 — das Werkzeug für werdende Floppy-Spezialisten

> Zur Programmierung des 1541-Floppy-Laufwerks braucht man gutes Werkzeug. Mit dem FMON 1541 können Sie Programme für das Floppy-Laufwerk schreiben oder sich einfach ein wenig im Speicher umsehen.

FMON 1541 ist eine große Hilfe für alle, die Ihr 1541-Laufwerk programmieren wollen. Er erlaubt einfaches Assemblieren und Disassemblieren. Außerdem sind noch viele andere Sonderfunktionen eingebaut. In der folgenden Anleitung werden wir Ihnen die Funktionen und Befehle des FMON 1541 erläutern.

Tippen Sie zunächst den FMON 1541 (Listing 1) mit dem MSE ab und speichern Sie ihn. Nach dem Laden mit LOAD "FMON 154T,8,1 wird der Monitor mit SYS 32768 oder SYS 8 * 4096 gestartet. Folgende Befehle bietet Ihnen der FMON 1541:

**A** Direktassembler
Format :A aaaa bbb ccccc
Der Befehl bbb mit dem Operanden ccccc wird an die Adresse aaaa geschrieben (6502-Schreibweise). Alle Angaben erfolgen hexadezimal. Ein $ muß nicht vorgestellt werden. Bei der Art Immediate sind achtstellige Binärzahlen (% vorgestellt) und ASCII-Angaben (in ” (CHR$(34)) erlaubt. Beispiel: AND #%10101100 oder LDA #”A”, wobei der zweite Anführungsstrich weggelassen werden kann (LDA #”A). Bei Accu-Befehlen kann das nachfolgende A weggelassen werden. Einzelne Bytes können mit einem ».« eingegeben werden (.A9). Bei Branch-Befehlen wird die Zieladresse in Form einer zweistelligen Hexzahl angegeben. Und jetzt eine »Spezialität« des FMON 1541: Alle undefinierten Opcodes (vorgestelltim 64’er, Ausgabe 3/85) werden verarbeitet! (Tabelle 1)
**D** Disassemblieren von Speicherbereichen
Format: D aaaa, bbbb
Disassembliert den Speicherbereich aaaa bis bbbb. Wenn bbbb fehlt, wird ab der Adresse aaaa disassembliert. Wenn beide Adressen fehlen, dann wird ab 0300 disassembliert. Ändern von Bytes ist möglich. Fahren Sie an die Stelle und ändern Sie die oder das Byte und drücken »RETURN«.
**X** Exit
Springt ins Basic zurück
**Z** Exit II
Springt ins Basic zurück (wie RUN-STOP / RESTORE)
**G** GO
Format: G aaaa
Springt zur Speicheradresse aaaa. Das Programm muß mit RTS enden.
**M** Memory Dump
Format: M aaaa, bbbb
Gibt den Speicherbereich aaaa bis bbbb mitacht Byte pro Zeile und ASCII-Ausgabe aus. Wenn bbbb fehlt, wird wie beim D-Befehl gehandelt. Wenn aaaa fehlt, dann wird der Bereich $ 0300 bis 03FF gelistet. Ändern von Byte möglich.
\# Ändern der Floppyadresse.
zum Beispiel: #9. Alle Befehle wirken auf das Floppy-Laufwerk mit der Geräteadresse 9.
\> Ändern der Druckeradresse
zum Beispiel: >5
Das Floppy-Laufwerk ist auf acht und der Drucker auf vier voreingestellt.
@ Senden von Befehlen in den Befehls-Kanal
Format: @a: bbbbbb
Sendet den Befehl a mit dem Text bbbbbb an das Floppy-Laufwerk.
\* Liest Fehlerkanal aus.
**$** Listet Directory.
**C** Kaltstart des Floppy-Laufwerks. Alle Puffer werden gelöscht!.
**I** Initialisieren des Floppy-Laufwerks.
**R** Lesen eines Blocks.
Format: R tt ss
Liest den Track tt, Sector ss in Puffer Null ($0300 bis 03FF). Mit M kann er angezeigt und verändert werden.
**W** Schreiben eines Blocks auf Diskette ($0300 bis 03FF). Format: Wie bei Read.
Read und Write werden mit Jobbefehlen gehandhabt. Ein eventuell auftretender Fehler steht in Adresse $0000 (Fehlermeldungen siehe Tabelle 2). Meiden Sie ILLEGAL BLOCK OR SECTOR!
**J** Senden eines Jobbefehls für Puffer Null.
Format: J aa, bb cc
Der Jobbefehl aa wird mit den Parametern bb und cc in Speicheradresse $0000, 0006/0007 geschrieben.
**P** ASCII-Text an eine bestimmte Stelle schreiben.
Format: P aaaa, ttttttttt
Der Text ttttttttt wird an die Adresse aaaa und folgende gesetzt.
**S** Sichern von Speicherbereichen.
Format: S ’’ttttttttt“, aaaa, bbbb
Der Bereich aaaa bis bbbb wird in die sequentielle Datei ttttttttt zwischengespeichert. Da sequentielle Daten Puffer benutzen, wird der Speicherbereich aaaa bis bbbb erst in den Bereich ab $C000 im Computer zwischengespeichert, dann erst in die sequentielle Datei geschrieben. Dieses Verfahren dauert seine Zeit (der FMON ist nicht abgestürzt!). Wenn Sie Ihr Programm nach dem Speichern starten wollen, müssen Sie es erst mit »L« neu laden, da die Puffer benutzt werden.
**L** Laden von Speicherbereichen.
Format L ’’ttttttttt“
Das Programm ttttttttt wird in die Floppy geladen. Auch der L-Befehl braucht seine Zeit!
Sichern und laden Siekeine Speicherbereiche, die länger als 4 KByte sind (ist ja auch gar nicht notwendig).
**F** Füllen von Bereichen.
Format F aaaa, bbbb, cc
Der Bereich aaaa bis bbbb wird mit dem Byte cc vollgeschrieben.
**Q** Beschleunigen des Schreib-Lesekopfs (64’er Ausgabe 4/85).
Format: Q oder Qaa
Nur »Q« beschleunigt und »Qaa« schaltet wieder auf normal um, wobei aa ein beliebiges Zeichen sein kann.
**N** Druckt eine Datei.
Format: N ’’ttttttttt, X“
Druckt die Datei ttttttttt (Dateityp X).

(M. Köhler/P. Baumann/aw)

TODO TABLE

Absturzbefehle werden durch ABS gekennzeichnet
No operation (1 Byte) werden bis auf NOP mit NO1 gekennzeichnet
No operation (2 Byte) werden mit NO2 bezeichnet.
No operation (3 Byte) werden mit NO3 angezeigt.
Wenn man diese Befehle beim A-Befehl benutzt, wird der erste jeweils mögliche Befehl genommen (bei ABS: 02).
Besondere Schreibweisen:

TODO TABLE

ASL:ORA	ASO
ROL:AND	RAN
LSR:EOR	LSE
ROR:ADC	RAD
DEC:CMP	DEM
INC:SBC	INB

Ansonsten wird die übliche 6502-Schreibweise benutzt.
Hinter den Opcodes steht der Name des Befehls und danach die Adressierungsart: ZO = ZEROPAGE; ZOX = ZEROPAGE, X; ZOY = ZEROPAGE, Y; IMM = IMMEDIATE; INX = INDIRECT, X; INY = INDIRECT, Y; ABS = ABSOLUT; ABSX = ABSOLUT, X; ABSY = ABSOLUT, Y;

TODO TABLE

OB =ANN	(ZO)
2B =ANN	(ZO)
4B ==ANL	(IMM)
6B = DAR	(IMM)
83 =AXX	(INX)
87 =AXR	(ZO)
8B =TAN	(IMM)
8F =AAX	(ABS)
93 =AXY	(INY)
97 =AXI	(ZOX)
9B =AXS	(ABSY)
9C =YXA	(ABSX)
9E =XYA	(ABSY)
9F =AYY	(ABSY)
A3 =LDT	(INX)
A7 =LTA	(ZO)
AB =???	(Wirkung noch nicht ermittelt)
AF =LTX	(ABS)
B3 =LYT	(INY)
B7 =LAX	(ZOY)
BB =TSA	(ABSY)
BF =LYX	(ABSY)
CB =XAS	(IMM)
EB =SBC	(IMM (wie der normale Befehl SBC))

Tabelle 1. Eingabehinweise und besondere Schreibweisen des FMON 1541

TODO TABLE

Rückmeldungen in der Adresse 0000 bei R/W/J (Fehlermeldungen)
$01 = Fehlerfreie Durchführung (00, OK)
$02 = Blockheader nicht gefunden (20, Read Error)
$03 = Sync-Markierung nicht gefunden (21, Read Error)
$04 = Datenblock nicht gefunden (22, Read Error)
$05 = Datenprüfsumme ist falsch (23, Read Error)
$07 = Fehler nach einem Verify (25, Write Error)
$08 — Diskette ist schreibgeschützt (26, Write Protect on)
$09 = Prüfsumme im Header falsch (27, Read Error)
$0A = Datenblock auf Diskette zu lang (28, Write Error)
$0B — Falsche ID im Block Header (29, Disk ID Mismatch)
$0F = Keine Diskette im Laufwerk (74, Drive not Ready)
$10 = Fehler bei Decodierung (24, Read Error)

Tabelle 2. Die Fehlermeldungen in der Adresse 0000 werden mit dieser Tabelle entschlüsselt

# Directory-Editor mit Komfort

> Mit diesem Programm gestalten Sie das Disketten-Directory ganz nach Ihren Wünschen.

Mit dem Directory-Editor kann man das Inhaltsverzeichnis einer Diskette auf komfortable Art und Weise ändern. Das Programm ist lauffähig auf dem Commodore 64 sowie seinen »großen Brüdern«CBM 2001 bis8001. EserkenntComputer-und Floppy-Laufwerk-Typ und sollte ohne Schwierigkeiten auch an andere und zukünftige Commodore-Computer und -Floppy-Laufwerke anzupassen sein.

Das Programm wird mit RUN gestartet. Es dauert einige Sekunden, bis Computer- und Floppy-Laufwerk-Typ erkannt und die Variablen entsprechend gesetzt sind.

## Befehlsbeschreibung

Tabelle 1 zeigt eine Übersicht über alle Befehle des Directory-Editors. Die Befehle im einzelnen: Durch »A« oder »SPACE« (Leertaste) erhöht man eine zweiseitige Kurzanleitung mit einer Befehlsübersicht (weiter mit beliebiger Taste).

Mit »0« und »1« kann man bei einem angeschlossenen Doppelfloppy-Laufwerk zwischen den beiden Laufwerken wählen. Falls ein Doppelfloppy-Laufwerk angeschlossen ist, wird beim Start des Programms automatisch Laufwerk 1 gewählt, so daß sich folgende Laufwerksaufteilung anbietet: Laufwerk 0 mit Systemdiskette und Laufwerk 1 mit der zu bearbeitenden Diskette.

»L« dient zur Umschaltung zwischen Groß- und Kleinschreibung. Mit »X« kann das Programm jederzeit verlassen werden. Wird gerade eine Diskette bearbeitet, so wird zunächst automatisch der Befehl »E« ausgeführt.

Der eigentliche Editor wird mit »I« initialisiert. Die Aufforderung zum Einlegen der zu bearbeitenden Diskette bestätigt man mit einem beliebigen Tastendruck. Nun wird die eingelegte Diskette initialisiert und nachgeprüft, ob sie dem Format des Floppy-Laufwerks entspricht. Jetzt werden nacheinander Diskettenname und Identität (ID) angezeigt, die man durch einfaches Überschreiben ändern kann. Die ID darf übrigens bis zu fünf (bei CBM 2040/3040 vier) Zeichen lang sein. Mit der RETURN-Taste kommt man zum Inhaltsverzeichnis.

Das Programm zeigt jetzt den ersten Eintrag an. Im ersten Feld wird die Länge des Files in Blöcken angezeigt. Das zweite Feld enthält den Filenamen, der nach dem Drücken von »N« frei geändert werden kann.

Im dritten Feld werden drei Fileparameter angezeigt, die in dem Directory auf der Diskette alle in einem Byte untergebracht sind: Wenn ein Stern vor dem Filetyp angezeigt wird, so wurde das File nach dem Schreiben nicht geschlossen, was es normalerweise unmöglich macht, auf dieses File wieder zuzugreifen. Glücklicherweisegeschiehtdies recht selten, daso etwas nur durch Stromausfall, versehentliches Ziehen des Netzsteckers oder durch Unterbrechen eines Basic-Pro-gramms mitten im Schreibvorgang zustandekommen kann. Trotzdem ist es ärgerlich, wenn es einmal passiert. Mit dem Directory-Editor können solche Files wieder lesefähig gemacht werden, indem man »*« eingibt. Dabei wird die erste Spur/Sektor-Kennzeichnung ausgelesen und das File bis zum Ende verfolgt. Danach wird die errechnete Blockzahl in das Directory geschrieben und ein Validate der Diskette nach dem Programmlauf veranlaßt (ab Zeile 6000). Der Stern vor dem Filetyp verschwindet, das File ist wieder in Ordnung. Es kann wohl vorkommen, daß die letzten (maximal 254) Bytes verlorengehen, wenn diese bei dem Zwischenfall noch im Floppypuffer zwischengespeichert waren; dafür ist der Rest aber gerettet.

Als zweite Information in diesem dritten Feld wird der Filetyp ausgegeben. Dieser kann durch Drücken des Anfangsbuchstaben des gewünschten Filetyps geändert beziehungsweise das File mit »D« gelöscht werden. Auch gelöschte Files werden mit angegeben und können (leider nicht bei den Floppy-Laufwerken CBM 2040/3040 wegen der völligen Zerstörung der Block-Zeiger) wieder eingetragen werden. Bei der Benutzung ist aber Vorsicht geboten, denn wenn nach dem Löschen schon wiederauf die Diskette geschrieben wurde, können Teile des Files oder Programms zerstört sein. Werden nach einem Validate zu viele freie Blöcke ausgegeben, dann kann man nichts mehr retten und das File sollte wieder gelöscht und die Diskette mit dem Validate-Befehl nochmals überprüft werden.

Die dritte Information, die nur ab DOS-Version 2 vorhanden ist (also nicht für 2040/3040), ist der Löschschutz. Er wird durch »+« ein- und durch »—« wieder ausgeschaltet und schützt vor dem Scratch-Befehl. Der New-Befehl beachtet solch einen softwaremäßigen Schutz nicht, hier hilft nur der physikalische Löschschutz, das Ankleben einer Schreibschutzmarke. Der softwaremäßige Löschschutz wird mit »<« hinter dem Filetyp in der Directory angezeigt.

Die letzten beiden Felder der Zeile zeigen den Startsektor, also den Anfang des Files, auf der Diskette. Bei 2040/3040-Floppy-Laufwerken sieht man, daß mit »Scratch« gelöschte Files eine Null in der Anzeige der Spur anzeigen und somit nicht mehr reparabel sind.

Mit der RETURN-Taste, »-« oder »=« kann man den nächsten Eintrag in die Anzeige holen. Sucht man nur ein bestimmtes File, um etwas zu ändern, so kann man mit »B« gleich bis zum Ende des Directory-Blocks »vorspulen«. Dies hat den Vorteil, daß es schneller geht. Trotzdem kann man immer mit »t» oder »@« ein File zurückgehen, falls es in demselben Block liegt.

Wenn ein File wieder in die Directory zurückgeholt oder gelöscht wird, so muß die Diskette später zur korrekten Blockbelegung überprüft werden. Will man diesen Vorgang erzwingen, so kann man »V« drücken. Ob überprüft wird oder nicht, steht unten in der vorletzten Textzeile hinter »V«. Ein »+« bedeutet, daß erst später überprüft wird.

Mit »E« kann die Bearbeitung jederzeit unterbrochen und zum Ende gesprungen werden. Am Ende des Directory, beziehungsweise wenn »E« eingegeben wurde, wird — falls erforderlich durch Löschen, Wiedereintragen oderSchließen eines Files — die Diskette mit dem »Validate«-Befehl überprüft. Dies kann eine Minute dauern, falls sich viele Files auf der bearbeiteten Diskette in ungelöschtem Zustand befinden. Danach wird die Anzahl der benutzten und der freien Blöcke ausgegeben. In Klammern erscheint die Anzahl der freien Blöcke, die in dem Directory abgelegt sind. Kommt es zu Unterschieden, so sollte, wenn das Directory bis zum Ende durchgeblättert wurde, mit »Validate« überprüft werden. Wenn mit »E« oder »X« abgebrochen wurde, dann sind wahrscheinlich nicht alle belegten Blöcke mitgezählt worden und die Zahlen, die nicht in Klammern stehen, sind nicht relevant. Nach Anzeige der Blockzahlen ist das Programm bereit, eine neue Diskette zu bearbeiten.

## Eingebaute Geräteanpassung

Am Anfang des Programms wird in eine Unterroutine ab Zeile 7 500 gesprungen, die durch Vergleichen eines Bytes mit einer Tabelle herausfindet, in welchem Computer sich das Programm im Augenblick befindet, und danach alle systemspezifischen Adressen, die vom Hauptprogramm benötigt werden, in Variablen einliest. Dieses Vorgehen ermöglicht es, jeden Commodore-Computer, der mindestens einen 40 Zeichen breiten Bildschirm besitzt, zu benutzen, ohne das Programm vollständig verändern zu müssen. Außerdem können auch die großen Commodore CBM 600/700 oder die kleinen C 16/C 116 und der Plus/4 mit dem gleichen Programm laufen, wenn die Abfragen entsprechend erweitert werden. Zur eigenen Anpassung des Programms sind in Tabelle 2 die benötigten Systemadressen aufgeführt. Sie müssen in dieser Reihenfolge nach dem PEEK-Wert und dem Namen des Computers ab Zeile 7 560 in DATAs abgelegt werden.

Für alle Commodore-Computer gilt, daß mindestens 16 KByte RAM vorhanden sein müssen. Hiervon sollten 12 KByte zur freien Verfügung übrigbleiben, denn der Directory-Editor belegt 10 KByte und benötigt noch einmal 2 KByte für Variablen.

Auch die Floppy-Laufwerke besitzen unterschiedliche Eigenschaften und Eigenarten, die es nötig machen, den Geräte-Typ durch das Programm erkennen zu lassen, um ein zufriedenstellendes Arbeiten des Directory-Editors mit allen Laufwerken zu gewährleisten. Diese Routine (ab Zeile 7 000) wurde aus dem Programm »Disk Addr Change« der 1541-Test/ Demo-Diskette entnommen und für den Directory-Editor erweitert. Auch dieses Unterprogramm kann leicht an neue Floppy-Laufwerke angepaßt werden. Es werden mit »M-R« einzelne Bytes aus dem Floppy-ROM gelesen, die charakteristisch für bestimmte Floppy-Laufwerke sind. Anpassungen an alle gängigen Commodore-Floppy-Laufwerke sind eingebaut (2/4031, 1540/1, 2/3040, 4040, 8050, 8250, wobei CBM 4040/8050 entweder mit DOS 2.1/2.5 oder DOS 2.7 ausgestattet sind). Die Erweiterung auf neue Commodore-Laufwerke (zum Beispiel 1571 und SFD 1001/1002) ist natürlich möglich. In Tabelle 3 werden alle erforderlichen Variablen erklärt und am Beispiel der eingebauten Anpassung demonstriert. Tabelle 4 zeigt die Bedeutung wichtiger Variablen, die bei verschiedenen Laufwerks-Typen unterschiedlich sein kann.

## Die Unterroutinen

Der Programmablauf ist in Tabelle 5 erläutert. Einige interessante, auch für andere Programme verwendbare Unterroutinen sind enthalten. Das Unterprogramm ab Zeile 8000 stellt eine neue Eingabe-Routine dar, die die Möglichkeit bietet, die Cursorsteuerung sowie lnsert/Delete zu erlauben, und trotzdem aufzupassen, daß nicht über den Rand des Eingabefeldes hinausgefahren wird. Außerdem sind zwei Tasten etwas anders belegt: Die HOME-Taste setzt den Cursor auf den Anfang des Eingabe-Feldes und CLR löscht nur das Eingabe-Feld, so daß der Bildschirmaufbau nicht aus Versehen einmal zerstört werden kann. Zeile 8021 wurde nur speziell für den Directory-Editor eingebaut: sie füllt den Rest des Strings bis zur Maximallänge IL mit SHIFT-Leerzeichen auf. Das wird zum Löschen eines möglichen Reststrings in der Directory benötigt und kann bei eigener Anwendung der Eingabe-Routine gegebenenfalls weggelassen werden. Die Eingabe von SHIFT-RETURN bewirkt, daß der Rest ab der Cursor-Position gelöscht und die Eingabe wie bei RETURN beendet wird.

Die Routine ab Zeile 8040 scrollt einen beliebigen Bildschirmbereich von Zeile X1 bis X2 aufwärts, falls der Cursor in Zeile X2 steht. Dies geschieht durch »INPUT« vom Bildschirm und Ausgabe der eingegebenen Strings je eine Zeile höher.

Ab Zeile 8060 steht die Warteschleife bis zum Drücken einer Taste. Dabei wird der Cursor eingeschaltet und an eine vordefinierte Stelle auf den Bildschirm gesetzt. In PR$ ist das Promptzeichen enthalten. Wenn das Unterprogramm von Zeile 2000 her angesprungen wird, sieht man ein »>«. Aus einem anderen Unterprogramm heraus (zum Beispiel Anleitung) zeigt sich ein » < «. Daran erkennt man, in welchem Modus man sich gerade befindet. Die gedrückte Taste wird direkt daneben angezeigt.

Ab Zeile 8 070 befindet sich eine Routine, die einen Text inklusive aller Steuerzeichen ausdruckt. Auch ein sonst »unverdauliches« RETURN-Zeichen (CHR$(13)) wird mitgedruckt. Da Sie mit einem fehlerhaft arbeitendem Directory-Editor einigen Schaden anrichten können, sollten Sie erst nach dem sorgfältigen Austesten des Programms mit Disketten, von denen ein Doppel existiert, die Arbeit mit dem Directory-Editor beginnen.

(Dieter Temme/ev)

# Programmschutz durch Autostart und Paßwort

> Ein Programm, das nach dem Laden sofort gestartet wird und nicht mehr unterbrochen werden kann, ist eine Art Programmschutz. Richtig raffiniert wird es aber, wenn noch zusätzlich ein Paßwort nötig ist. »Autostart C 64 Plus« macht es Ihnen einfach, Ihre Programme so zu bearbeiten.

Das Programm »Autostart C 64 Plus« ist eine besonders komfortable und nützliche Art der Programmsicherung für den C 64 und ein Diskettenlaufwerk. Das Autostartprogramm lädt das zu bearbeitende Programm, das bis zu 230 Blöcke lang sein darf, in den Speicher des C 64, verschlüsselt es, fügt noch einige Modifizierungen ein und speichert es wieder ab. Der so eingefügte Programmschutz kann nur noch mit großem Aufwand rückgängig gemacht werden. Sicherlich kann jeder Programmschutz auch wieder entfernt werden, aber um dies so schwer wie möglich zu machen, soll hier nichts weiteres darüber verraten werden. Die Dauer des gesamten Bearbeitungsvorgangs richtet sich ganz nach der Länge des zu bearbeitenden Programms. Die Eingabe aller Parameter ist dabei komfortabel durch Menüpunkte und Abfragen realisiert worden. Ein so gespeichertes Programm startetsich nach dem Laden automatisch, wenn Sie das entsprechende Paßwort wissen.

Geben Sie zunächst das Programm Autostart C 64 Plus (siehe Listing) mit dem Checksummer ein. Nach dem Starten des Programms ist es notwendig, einige Parameter einzugeben, denn es wird zwischen Basic- und Maschinenprogrammen unterschieden. Bei Maschinenprogrammen benötigt Autostart C 64 Plus zusätzlich die Startadresse. Mit zwei weiteren Menüpunkten läßt sich jedes Programm gegen eine Unterbrechung durch RUN/STOP-RESTOREabsichern. Zuletztwirddasjewei-lige Paßwort eingegeben. Ein Paßwort ist eine Art Geheimzahl, das aber auch Buchstaben enthalten darf. Es darf bis zu 10 Zeichen lang sein. Falls kein Paßwort eingegeben wird, startet das bearbeitete Programm später ohne jegliche Abfrage. Bevor Autostart C 64 Plus nun mit der Modifizierung des Programms beginnt, wird nochmals nach der Richtigkeit aller Angaben gefragt.

Während dem Laden istjedes so modifizierte Programm gegen einen Reset geschützt. Dieser Schutz wird jedoch nach dem Laden abgeschaltet, da sonst ein Speicherplatzverlust von 8 KByte eintreten würde. Das bearbeitete Programm wird wie ein Maschinenprogramm mit LOAD »Name«,8,1 eingeladen. Danach erscheinen auf dem Bildschirm die normalen Betriebssystem-Meldungen—soweitnichtsUngewöhnliches. Nun muß man aber, und das ist der Trick, unaufgefordert das zuvor festgelegte Paßwort über die Tastatur eingeben (ohne anschließendes RETURN). Falls das Paßwort richtig war, blinkt der Bildschirm kurz auf und der Ladevorgang wird normal fortgesetzt. War das Paßwort aber falsch, so läuft das Diskettenlaufwerk ohnejede Fehlermeldung bis ans Ende ihrer Tage weiter. Falls Sie sich vertippt haben, ist es am einfachsten, eine Taste zu drücken, die nicht im Paßwort vorhanden ist, und dann nochmals das Paßwort einzugeben. Dadurch, daß keinerlei Fehler- oder Rückmeldungen ausgegeben werden, ist es für jemanden, der das Paßwort nicht kennt, fast unmöglich, Ihre Programme zu verwenden.

Ein Tip noch zum Schluß: Schreiben Sie sich Ihre Paßwörter auf, oder wenden Sie immer das gleiche Schema an (etwa jeder zweite Buchstabe des Programmnamens), denn sonst ist auch für Sie selbst der Zugang versperrt.

(Jan Kusch/aw)

# Zu zweit geht’s besser

> Dieses Programm für C 64, Floppy und Drucker beseitigt ein lästiges und papieraufwendiges Problem: Drucker, die keinen Randsteller haben, können zwei Directories nebeneinander ausgeben.

Nachdem eine Diskette eingelegt und eine Taste gedrückt wurde, lädt das Programm die Directory in den Speicher. Nun ist die zweite Directory an der Reihe. Sobald diese geladen ist, werden die Directories nebeneinander ausgedruckt. Hierbei wird nach und vor ihnen eine Leerzeile eingefügt, damit in einer Serie von Directories nicht alle aneinanderkleben. Nach dem Ausdrucken können weitere Disketteninhalte bearbeitet werden.

Vorsicht! Es werden keinerlei Druckereinstellungen vorgenommen. Also müssen alle Einstellungen vor dem Start des Programms vorgenommen werden (Zeilenabstand etc.). Die voreingestellte Sekundäradresse ist 0. Sie kann aber mit PO-KE 2144, neue Sekundäradresse auf einen beliebigen Wert gesetzt werden. Die Geräteadresse kann mit POKE 2142,5 zum Beispiel von 4 auf 5 gesetzt werden. (Übrigens: da das Programm am Basic-Anfang liegt und weil ihm ein SYS-Befehl vorgelagert ist, kann es mit LOAD »name«,8 (,1 bei Kassette) geladen und mit RUN gestartet werden.)

(Claus Brunzema/rg)

# ProDat — Dateiverwaltung mit Raffinessen

> Das Besondere an »ProDat« ist, daß man die Eingabemaske wie bei den teuren kommerziellen Programmen selbst definieren kann. Außerdem ist »ProDat« durch verschiedene Maschinenprogramme besonders schnell und einfach zu bedienen.

Wenn man das Listing vollständig und fehlerfrei eingetippt hat, darf man erst mal aufatmen. Elf KByte Basic sind schließlich kein Honiglecken. Im Bereich von $0334 (820) bis $03cf (1020) stehen verschiedene Maschinenprogramme. Da dies aber der Kassettenpuffer ist, läßt sich »ProDat« nicht ohne weiteres für Datasette verwenden.

Die Daten werden von Maschinenroutinen geladen und gespeichert. Auch das Kopieren der Bildschirmmaske deraktuel-len Datei in den Bildschirmspeicher geschieht in Maschinensprache. Da die INPUT-Routine des Betriebssystems geringfügig geändert wurde, bereitet bei der Maskenerstellung auch die Eingabe von Anführungszeichen, Doppelpunkten oder Kommata keinerlei Schwierigkeiten. Um bei der Verarbeitung der Daten der gefürchteten Garbage-Collection aus dem Weg zu gehen, wurde eine etwas geänderte Version des Stringver-tauschers von Boris Schneider aus der 64’er, Ausgabe 1/85 verwendet. FürInteressiertezeigtTabelle 1 einedokumentier-te Liste der wichtigsten im Programm verwendeten Variablen.

### Hinweise zum Abtippen:

Manche Zeilen haben Überlänge, das heißt, sie sind länger als die vom Basic-Interpreter erlaubten 80 Zeichen. Diese Zeilen können Sie nur mit den im Anhang D des Commodore-Handbuchs vermerkten Abkürzungen der Basic-Befehle eingeben. Das gilt zum Beispiel für die Zeile 360. Leerzeichen vor und nach den einzelnen Basic-Befehlen dienen nur der Übersichtlichkeit und können beim Eintippen ersatzlos weggelassen werden.

### Programmbeschreibung:
###Menü 1, Hauptmenü
**1**	— Aufruf Menü 2
**2**	— Neue Datei definieren

Zuerst muß die Eingabemaske definiert werden. Wie das aussehen kann, zeigt Bild 1. Sie können frei mit den Cursor-Tasten auf dem Bildschirm umherwandern und Ihr persönliches Eingabeformular erstellen. Dabei sind alle Tasten und Zeichen erlaubt. (VorsichtvorSHIFT-CLR!) Zahlen zum Beachten: Maximale Felderanzahl (in der Sprache der Dateiverwaltung wird jede Stelle in der Maske, an der Sie später eine Eingabe machen, als Feld bezeichnet): 1 500 pro Datei, 40 pro Datensatz (ein Datensatz ist eine mit Daten gefüllte Eingabemaske). Maximale Feldlänge: 80 Zeichen.

Wie das Beispiel Bild 1 zeigt, werden Felder mit Hochpfeilen markiert. Wird derabschließende Pfeil weggelassen, so nimmt das Programm hierfür die maximale Feldlänge von 80 Zeichen. Wird später bei der Eingabe der Schlußpfeil erreicht, so springt der Cursor automatisch zum nächsten Feld weiter. Die Pfeile selbst tauchen später nicht mit in der Eingabemaske auf (siehe Bild 2). Mit dem Pfeil nach links können Sie eine Datensatznummeranzeige programmieren. Das heißt, daß an dieser Stelle später die Nummer des Datensatzes innerhalb der Datei ausgedruckt wird. Weiterhin istwichtig, daß Sie die letzte Bildschirmzeile nichtverwenden dürfen. Ein Feld in dervorletzten Zeile darf also nur 40 Zeichen lang sein! Nachdem die Eingabemaske definiert ist, müssen noch die Druckparameter eingegeben werden (siehe nächster Menüpunkt).
**3**	— Druckparameter festlegen/ändern
Nun müssen Sie festlegen, welche Felder in welcher Reihenfolge später auf dem Drucker ausgedruckt werden sollen. Ein Feld wird mit der »eckigen Klammer auf« markiert (siehe Bild 3). Sie können natürlich auch erklärenden Text oder ähnliches ausdrucken lassen. Alles, was zwischen den »eckigen Klammern zu«steht, wird später im Breitschrift-Modus gedruckt. Durch Änderung der Zeilen 2 570 und 2 580 hat man auch andere Möglichkeiten, zum Beispiel Kursiv-Druck oder dergleichen. Es können maximal 60 Druckzeilen definiertwer-den. Zu beachten ist, daß ein angesprochenes Feld auch wirklich vorhanden ist, da dies nicht überprüft wird. Sie können ein Feld auch mehrmals ausgeben lassen, das liegt ganz bei Ihnen. Eine Druckzeile kann maximal 80 Zeichen fassen, wodurch beispielsweise auch kleinere Formbriefe möglich sind. 4 — Directory laden 5 — File löschen
**6**	— Validate
**7**	— Disk formatieren
**8**	— File umbenennen

Die Menüpunkte 4 bis 8 erklären sich von selbst, beziehungsweise sind im Floppy-Handbuch genauer erklärt.

### Menü 2, Datei verwalten
**1**	— Datei laden

Sollte eine erweiterte oder geänderte Datei noch im Speicher stehen, so wird sicherheitshalber erst gefragt, ob Sie nicht erst speichern möchten. Die vorhandene Datei wird sonst gelöscht.
**2**	— Datei pflegen/ändern/ergänzen

Nach Wahl dieses Punktes sind Sie zunächst im Anzeigemodus, der wie Bild 4 aussehen könnte. In diesem Modus sind einige Tasten mit Sonderfunktionen belegt. (Siehe Tabellen 2 und 3)
**3**	— Datei abspeichern
**4**	— Datei sortieren

Es besteht jetzt die Möglichkeit, entweder alphabetisch nach einem bestimmten Feld zu sortieren, oder man läßt sich bestimmte Daten heraussuchen, zum Beispiel alle Adressen eines bestimmten Postleitzahlbereichs. Die kann man auf dem Drucker ausgeben lassen, oder speichert sie gleich in einer neuen Datei ab.
**5**	— Alle angegebenen Felder der Datei können aufaddiert werden, zum Beispiel bei einer Haushaltsbuchhaltung alle Ausgaben für Essen, etc.
**6**	— Aufruf Menü 3

### Menü 3, Druckermenü

**1**	— Alle Datensätze mit den vorher definierten Druckparametern auf dem Drucker ausgeben.
**2**	— Gesamte Datei ausdrucken.
**3**	— Entspricht Punkt 1, aber nur in Verbindung mit der Sortierroutine.
**4**	— Entspricht Punkt 2, aber nur in Verbindung mit der Sortierroutine.

### Allgemeine Hinweise:

Sollte der Cursor einmal an einer Stelle stehenbleiben, und auch keine Taste mehr annehmen, so ist das kein Grund zur Panik. Der Computer braucht ab einer gewissen Datenmenge einfach Zeit, um das Eingegebene sinnvoll im Speicher unterzubringen. Wenn Sie »ProDat« als Textverarbeitungsprogramm verwenden wollen, so definieren Sie die Eingabefelder einfach über den gesamten Bildschirm und lassen die Datensatz-Nummeranzeige als zum Beispiel Seitennummer des Textes arbeiten.

(Wolfgang Hahn/tr)

# Schnell kopiert mit Hypra-Copy

> Hypra-Copy ist ein schnelles und komfortables Filecopy-Programm für den C 64. Das Kopieren wird um das Vierbis Fünffache beschleunigt.

Trotz deraufwendigen Lade- und Speicherroutinen ist es gelungen, das Programm insgesamt recht kurz zu halten; Hypra-Copy belegt, gespeichert auf der Diskette, nur ganze 15 Blöcke. Somit ist der verfügbare Arbeitsspeicher sehr groß: Hypra-Copy kann sich bis zu 30 Filenamen »merken«, und in einem Ladegang können maximal 232 Blöcke eingelesen werden. Hat man das Programm (siehe Listing) mit dem MSE abgetippt und gespeichert, kann es später ganz normal mit »LOAD ”HYPRA-COPY”,8« geladen und mit »RUN« gestartet werden.
Es erscheint dann das Hauptmenü:
**HYPRA-COPY**
:C: Copy Files
:S: Scratch Files
:D: Directory
:O: Order Disk

Die Bedienung ergibt sich damit eigentlich schon von selbst. Drückt man die Taste »O«, erscheint auf dem Bildschirm eine eckige Klammer mit einem blinkenden Cursor dahinter.

Nun kann man den Befehl eingeben, der zur Floppy geschickt werden soll. Reagiert die Floppy mit einer Fehlermeldung, so wird diese auf dem Bildschirm ausgegeben.

Bei Betätigung der Taste »D« erscheint das Directory. Der Ausdruck kann durch die CTRL-Taste angehalten werden. Durch Drücken der »S«-Taste gelangt man in den Scratch-Modus (löschen von Files). Um Verwechslungen mit dem Copy-Modus auszuschließen, wird erst einmal mit einer dicken, reversen Balkenüberschrift darauf aufmerksam gemacht, daß man sich tatsächlich im Scratch-Modus befindet. Danach erscheintdas Directory, jedoch erscheinthinterjedem Filenamen ein »(Y/N)«; relative Files sowie Files, deren Länge gleich 0 oder größer als 232 Blöcke ist, werden bei dieser Befragung übergangen, denn diese Routine wird auch beim Kopieren gebraucht und Files mit diesen Eigenschaften kann Hypra-Copy nicht kopieren.

Files, die sich Hypra-Copy merken soll, müssen mit »Y« markiert werden. Ist man versehentlich im Scratch-Modus gelandet, so kann man diesen Modus mit der STOP-Taste verlassen (ansonsten dient die STOP-Taste dazu, Hypra-Copy zu beenden; man kann es dann aber wieder mit »RUN« starten).

So werden nach und nach alle Files der Directory durchgegangen. Will man nur einige wenige Files am Anfang einer ellenlangen Directory löschen (oder kopieren), so braucht man die restlichen Files nicht mehr mit »N« zu bearbeiten, es genügt ein Druck auf die »t «Taste, und man gelangt zum Ende des Directory. Hier wird dann gefragt, ob man nun auch sicher ist, daß diese Files gelöscht werden sollen. Beantwortet man diese Frage mit »N«, gelangt man zurück in das Hauptmenü, andernfalls werden die markierten Files gelöscht.

Damit man weiß, wie weit das Programm mit dem Löschen ist, wird immer der Name des Files ausgegeben, das gerade gelöscht wird. Am Ende des Löschvorgangs gelangt man automatisch wieder in das Hauptmenü.

## Der Copy-Modus

So, nun zum Copy-Modus, in den man mit der »C«-Taste kommt. Zuerst werden wieder, genau wie beim Löschen, die Namen der zu kopierenden Files eingelesen.

Danach wird gefragt, ob man die Files einzeln oder gesammelt kopieren will und ob beim Speichern ein »VERIFY« durchgeführt werden soll. Verzichtet man auf dieses Verify, so wird etwas schneller kopiert. Um den Bedienungskomfort zu erhöhen, werden die Antworten auf diese Fragen, wie auch auf die »SURE?«-Frage (sure = Sind Sie sicher?) im Scratch-Modus und die »SAVE BUFFER AGAIN?«-Frage (Soll das gleiche noch einmal gespeichert werden?), nicht per GET ($ffe4), sondern per BASIN ($ffcf) eingelesen, wobei die wohl gebräuchlichere Antwort schon vorgegeben ist; man braucht also nur noch RETURN drücken; natürlich kann diese vorgegebene Antwort aber auch überschrieben werden.

Nun werden die Programme geladen. Ist die Summe der Blöcke der einzelnen Files kleiner als 233, können sogar alle auf einmal eingelesen werden; andernfalls wird ein erneuter Ladeanlauf nötig.

Sind die Files geladen, wird man aufgefordert, die Ziel-Disk einzulegen; außerdem wird noch die Anzahl der zu speichernden Blocks angegeben, und ein Untermenü erscheint.

Es besteht jetzt noch die Möglichkeit, diverse Directories anzusehen oder Befehle zur Floppy zu schicken.

Man kann also in aller Ruhe eine passende Diskette aussuchen. Ist man gewillt fortzufahren, so drückt man einfach die Funktionstaste F7, dann beginnt nämlich das Speichern. Anschließend wird man gefragt, ob man eben diese Files noch einmal auf eine andere Diskette schreiben will. Beantwortet man diese Frage mit »Y«, beginnt der komplette SAVE-Vorgang von neuem. Andernfalls wird normal fortgefahren und, wie schon erwähnt, können erneute Ladeanläufe erforderlich werden.

Wurden alle Files kopiert, so wird in das Hauptmenü zurückgekehrt.

Nun zur Fehlerbehandlung: Mit »Fehlern« sind nicht Fehler gemeint, die in der Programmstruktur von Hypra-Copy liegen, sondern Fehler, die von der Floppy signalisiert werden; sei es, daß man einen unkorrekten Befehl an die Floppy schickt, man beim Kopieren die falsche Diskette einlegt oder Write- oder Read-Errors auftreten.

## Erste Hilfe bei Fehlern

ln solchen oder ähnlichen Fällen besteht immer die Möglichkeit, den Vorgang, bei dem der Fehler aufgetreten ist, zu wiederholen beziehungsweise zu übergehen. Treten Fehler beim Öffnen eines Files auf, so kann man sogar nochmals Directories ansehen und Befehle an die Floppy schicken. War es nicht möglich, ein File korrekt zu laden und wurde es übergangen, so wird dies bei der Angabe der zu speichernden Blöcke, wie auch beim Speichern selbst, berücksichtigt. Können Files aus irgendeinem Grund nicht korrekt gespeichert werden, so kann man diese auch überspringen.

(Burkhard Graves/ev)

# Programme leichter laden

> Dieses Programm vereinfacht das Laden von Programmen durch direkte Auswahl aus dem Directory.

Programme werden häufig nach dem Listen des Directorys durch Voranstellen eines »LOAD« und Ergänzung durch ”,8:“ oder ”8,1“ geladen. Oftmals vergißt man dabei allerdings das Eintippen des Doppelpunktes oder man macht andere kleine Fehler, worauf sich der Computer mit einem »SYNTAX ER-ROR« meldet.

Mit »Directory-Lader« (Listing) kann das Directory einer Diskette nun so manipuliert werden, daß wahlweise ein »,8:« oder ein »,8,1« an den Filenamen angehängt wird. Das vereinfacht den Ladevorgang um einiges: Nur noch das Directory listen, mit dem Cursor in die gewünschte Zeile fahren, »LOAD« eingeben und schon geht’s los.

## So funktioniert der »Directory-Lader«

Jedes Programm auf einer Diskette ist in einem Directoryblock verzeichnet. Dort belegt der Name des Programmes 16 Byte. Ist der Name kürzer als 16 Byte, wird er durch ein »SHIFT Space« (CHR$ 160) ergänzt. Dadurch wird auch das Ende eines Namens vom DOS erkannt.

Beim Listen des Directorys werden nun alle 16 Byte des Namens auf dem Bildschirm angezeigt. Das zu lösende Problem besteht also darin, den gewünschten Zusatz ebenfalls hinter dem Programm anzuzeigen.

Dazu wird zuerst der erste Block des Directorys eingelesen. Der Bufferpointer wird auf den ersten Namen des Blocks gesetzt und der Name ausgelesen. Hierbei werden alle 16 Byte des Namens verwendet. Durch Betätigen entsprechender Tasten wird nun der Name wie folgt bearbeitet:
@ Löschen des Zusatzes
↑ Überspringen des Namens ohne Änderung
**M** Schreiben des Zusatzes»,8,1«
**B** Schreiben des Zusatzes »,8:«

Beim Schreiben des Zusatzes wird der Name des Programms von hinten durch den Zusatz ergänzt. Dabei werden Programmnamen, die längerals 11 Zeichen bei Maschinenprogrammen oder länger als 12 Zeichen bei Basic-Programmen sind, entsprechend verkürzt.

In dieser Weise werden sämtliche Namen eines Directory-Blocks bearbeitet.

Da der Bufferpointer jedesmal weitergesetzt wird, kann es vorkommen, daß auch bereits gelöschte Programme bearbeitet werden. Das hat jedoch keinen weiteren Einfluß.

Nach der Bearbeitung eines Blocks wird dieser zurückgeschrieben, und das Programm fährt mit dem nächsten Block fort.

Tabelle 1 zeigt die verwendeten Variablen, Tabelle 2 die einzelnen Routinen des Programms.

Während der Bearbeitung wird ständig der nächste zu bearbeitende Block angezeigt. Erscheinen die Werte 0 und 255, so ist der letzte Block erreicht. Man hatjetzt eine Diskette mit modifiziertem Directory und damit einfach zu ladenden Programmen vorliegen (Bild 1).

(Holger Weihe/ev)

# Disk-Füller

> Ab und zu passiert es, daß auf einer Diskette nur ein paar Blöcke fehlen. Mit dem Disk-Füller können in Notfällen bis zu 17 zusätzliche Blöcke auf der Diskette genutzt werden.

Das Problem ist wohl jedem bekannt, der eine gut sortierte Programmsammlung hat: alle thematisch gleichen Programme bis auf eines passen auf eine Diskettenseite. Und gerade dieses letzte Programm benötigt nur einige wenige Blöcke. Aber hier kann in Notfällen Abhilfe geschaffen werden. Auf der Spur 18, auf der sich unter anderem das Directory befindet, sind meist noch ein paar Blöcke frei, die das DOS der 1541 aber nicht zur Verfügung stellt. Mit dem Programm Disk-Füller können diese freien Blöcke ausgenutzt werden. Zu diesem Zweck werden Blöcke von schon auf der Diskette befindlichen Programmen auf die freien Blöcke der Spur 18 umkopiert und die Blockzeiger angepaßt. Die ursprünglichen Programmblöcke stehen dann zur freien Verfügung.

Das Programm ist weitgehend selbsterklärend, hier aber einige wichtige Hinweise: Nach dem Laden darf das Programm erst mit »RUN« gestartet werden, wenn die zu behandelnde Diskette im Laufwerk liegt. Außerdem dürfen nur Disketten behandelt werden, deren BAM einwandfrei in Ordnung ist. Im Zweifelsfalle sollte vorher ein Validate mit »OPEN 15,8,15,”V”« durchgeführt werden.

Hier ist die genaue Funktionsweise des Programms beschrieben:

Nach einer kurzen Erläuterung für den Benutzer werden in den Zeilen 1050 und 1060 (Listing) zwei Kanäle zum Laufwerk geöffnet. Gleichzeitig wird die eingelegte Diskette initialisiert. In Zeile 2000 werden drei Variablenfelder dimensioniert. Sie dienen zum Ablegen der Zeiger auf den jeweils nächsten Directoryblock sowie der Anzahl der Einträge in diesem Block. Mit Zeile 2010 beginnt dann eine Schleife, die alle Directory-Blöcke verfolgt, ihre Lage auf der Diskette in den dimensionierten Feldern speichert und ihre Anzahl in der Variablen B festhält. Ab Zeile 2500 wird die Anzahl der freien Einträge im letzten Directory-Block bestimmt. Dazu wird jeweils das Filetyp-Byte abgefragt. Hat es den Wert Null, ist dieser Eintrag noch frei. Sollte der Benutzer die Frage, ob der angezeigte Platz genügt, negativ beantworten, wird ein Block für weitere acht Einträge freigehalten.

Als nächstes wird überprüft, welche Blöcke der Spur 18 noch frei sind. Dazu werden die entsprechenden Bytes der BAM in den Computerspeicher geholt und analysiert (Zeile 3120 bis 3230).

In Zeile 4000 beginnt das Verschieben schon belegter Blöcke in die Spur 18. Dazu werden in einer großen Schleife (bis Zeile 4680) alle Directory-Einträge abgearbeitet. Dies geschieht folgendermaßen: Der Zeiger auf den ersten Block des ersten Eintrags wird in den Variablen AS und AT zwischengespeichert, der zugehörige Block eingelesen und der Zeiger auf den Fortsetzungsblock ebenfalls gespeichert. Dann wird ein freier Block der Spur 18 gesucht und der alte Zeiger auf diesen umgelenkt. Der Computer gibt nun eine Protokollzeile aus. Dieser Block wird nun als belegt und der alte als frei gekennzeichnet. Als letztes wird endlich der Inhalt des zu verschiebenden Blocks auf den Block der Spur 18 geschrieben. Sollte nach dem ersten Eintrag immer noch Platz auf der Spur 18 sein, fährt das Programm mit dem zweiten Eintrag fort, bis die Spur 18 komplett belegt ist.

(U. Gerlach/bs)

# Schreibschutz per Software
> Eleganter als das Hantieren mit Klebestreifen ist ein Disketten^chreib-schutz per Software: Hier ist ein Programm, das einen solchen Schreibschutz nicht nur anbringen, sondern ihn auch wieder entfernen kann.

Die Funktion dieses Programms basiert darauf, das Format-kennzeichen (»A«) auf der Diskette zu ändern (hier in »X«). Versucht man nun, Daten auf die Diskette zu schreiben, so reagiert das Floppy-Laufwerk mit der Fehlermeldung »CBM DOS V2.6 1541«. Das Lesen istjedoch weiterhin problemlos möglich. Damit erspart man sich die zuweilen umständliche Verwendung von Schreibschutz-Aufklebern auf der Diskette. Außerdem ist dieser softwaremäßig realisierte Schreibschutz um einiges sicherer, denn er kann nicht durch Leichtsinn oder Versehen entfernt werden.

Eine Schwierigkeit ergibt sich aber, wenn das neue Fbrmat-kennzeichen wieder in »A« geändert werden soll, um zum Beispiel noch ein Programm auf der Diskette zu speichern. Da ja jegliches Schreiben unmöglich ist, hat man selbst mit den Direktzugriffs-Befehlen keine Möglichkeit mehr, wieder ein »A« auf die Diskette zu bringen.

Hier liegt nun die eigentliche Neuheit dieses Programms. Mit einem Memory-Write-Befehl (Listing) wird in die Speicherstelle 257 ($0101) der Floppy der ASCII-Code von »A« (65) geschrieben. In dieser Speicherstelle wird bei jedem Initialisieren einer Diskette deren Fbrmatkennzeichen im ASCII-Fbrmat abgelegt. Ist nun dieser Inhalt gleich 65, so schreibt die Floppy wieder ohne Probleme auf die Diskette, und genau dies wird in dem Programm ausgenutzt.

Nun einige Bemerkungen zur Bedienung des Programms: Nach dem Starten mit »RUN« wird das Formatkennzeichen der Diskette eingelesen und ausgedruckt. Daraufhin gibt man das Format-Zeichen ein, das die Diskette erhalten soll. Drückt man nur RETURN, so wird das vorgegebene Zeichen übernommen und es kommt immer zu einer Änderung des Fbrmatkennzei-chens. Zum Schluß wird dann deraktuelle Zustand der Diskette angezeigt.

Achtung! Unmittelbar nach dem Programmlauf ist der Schreibschutz nicht aktiv, da in der Speicherstelle 257 noch immer 65 steht. Erst nach dem Initialisieren einer geschützten Diskette ist dieser Schutz auch wirksam. Auch gegen versehentliches Formatieren, bei dem ja alle Programme gelöscht werden, schütztdieses Programm nicht, da bei diesem Befehl logischerweise kein Formatkennzeichen gelesen wird.

In allen anderen Fällen ist der Schutzjedoch voll wirksam und macht Schreibschutz-Etiketten überflüssig.

(Manfred Lins/ev)

# Disk-Tester

> Mit diesem Programm lassen sich Disketten schneller, komfortabler und schonender auf defekte Sektoren untersuchen, als das mit dem entsprechenden Programm auf der Test/De-modiskette der Fall ist.

Das Programm ist insbesondere bei Verwendung älterer Disketten oder bei Nutzung der Disketten-Rückseite zu empfehlen. Es überprüft in knapp 10 Minuten die gesamte Diskette auf schadhafte Stellen und markiert die eventuell gefundenen unbrauchbaren Sektoren als belegt, so daß sie von der 1541 nicht mehr zur Datenspeicherung verwendet werden. So ist es möglich, auch teilweise beschädigte Disketten noch zur Datenspeicherung heranzuziehen, ohne daß es zu WRITE- oder READ-ERRORS kommt.

### Programmbeschreibung:

Nach dem Starten des Programms (siehe Listing) muß man entscheiden, ob man nur die vollen Blocks (durch Lesen) oder alle Blocks (durch Lesen und Beschreiben) testen will, oder ob man die schon bei vorherigen Tests als fehlerhaft erkannten Blocks nach einem VALIDATE wieder belegen will. Danach wird gefragt, ob der Befehl »VALIDATE« an die Floppy gesendet werden soll. Dies ist nur bei Disketten sinnvoll, auf denen die Daten öfters geändert werden und die keine relativen Dateien, ISAM-Dateien oder ähnliche, im Direktzugriff arbeitenden Speicherformate, enthalten. Bei Disketten mit den oben genannten Dateien, von denen man nicht sicher weiß, ob die beschriebenen Blöcke auch in der BAM (Block Availability Map, Sektorbelegungstabelle) als belegt gekennzeichnetsind, sollte die Option »Leere Blocks testen« auf keinen Fall angewandt werden, da sonst Daten verlorengehen können.

Es folgt nach kurzer Lese- und Decodierzeit die symbolische Belegung der Diskette auf dem Bildschirm, auf der die belegten Sektoren als »-« und die nicht belegten als »*« gekennzeichnet sind. Wie kommt es dazu? Nun, jede Spur belegt in der BAM (Spur 18, Block 0, Positionen 4-143) 4 Byte. Zuerst kommt die Anzahl der freien Blöcke auf der Spur, im Programm bezeichnet mit FR$. Dann kommt nacheinander die Belegung der Sektoren 7-0, 15-8 und 23-16. Ein 1-Bit kennzeichnet dabei einen freien Block, ein O-Bit einen besetzten. Dies wird nun in der Routine »Analysieren der BAM«aufgelöst und in B%(T,S) festgehalten, wobei T die Spur und S den Sektor enthält. Die darauffolgende Testroutine beschränkt sich jetzt nur darauf, die Spuren und Sektoren einzeln durchzuzählen und in Abhängigkeit von B%(T,S) und der Variable TS (0, wenn alle, 1, wenn nur volle Blocks getestet werden sollen) entweder den Block zu lesen, oder ihn mit dem einmal aufgefüllten Puffer zu beschreiben. Danach wird der Fehlerkanal auf die Fehlernummer abgefragt, da dies schneller geht, als immer die ganze Fehlermeldung zu holen. Tritt ein Fehler auf, so wird dieser angezeigt und auf dem Monitor als roter Punkt in der BAM markiert. Gleichzeitig wird die Variable FE erhöht. Tritt kein Fehlerauf, so wird die Kennzeichnung für den gerade getesteten Block auf dem Monitor gelöscht. Sind alle Blocks getestet, werden die eventuell vorhandenen defekten Blocks auf der Diskette belegt und in dem Format »Spur,chr$(13),Block,chr$(13)« in dem USR-File ».DISKFEHLER« gespeichert. Das erste Byte entspricht in diesem Fall der Anzahl aller gefundenen Fehler.

Die Routine »Kaputte Blocks belegen« hat nun nichts weiter zu tun, als dieses File zu lesen und die Blocks zu belegen.

## Änderungen für andere Computer

Für einen der »großen« CBMs muß die Zeile 135 und sämtliche POKEs in den Zeilen 150 und 470 gelöscht werden, da sie keine Farbdarstellungen besitzen. Die Zeile 140 muß so geändert werden:
140 BI=32768

Für einen VC 20 mit 40-Zeichen-Bildschirm müssen nur die farbgebenden POKEs in Zeile 150, die Strings in Zeile 135 und die Variablen in Zeile 140 angepaßt werden. Für die Besitzer eines VC 20 mit 22-Zeichen-Bildschirm sind größere Änderungen erforderlich, da die BAM nicht angezeigt werden kann und sie sich somit mit einer numerischen Darstellung des Testablaufs zufrieden geben müssen. Es werden die freien und die belegten Blocks sowie der zuletzt getestete Sektor angezeigt. Die Zeilen 140, 470 und 635 ff. müssen vollständig gelöscht werden. Folgende Zeilen müssen geändert werden:
355 PRINTL$T$" BESETZTE BLOCKS:" O$683-FR:-PRINTT$" FREIE BLOCKS": "O$FR;D$D$
450 INPUT#15,F:IFF<20GOT0480
480 PRINTG$" T: " T;Z$"S;Z$" "U

Zehn Minuten für das Überprüfen einer Diskette mögen zwar immer noch recht lang anmuten, wenn man jedoch bedenkt, wieviel Ärger (READ-ERROR, WRITE-ERROR) ein fehlerhafter Sektor verursachen kann, dann rentiert es sich bestimmt, diese Zeit zu investieren.

(Ulrich Langler/ev)

# Betriebssystem selbst gemacht

> Ein eigenes Betriebssystem zu schreiben, ist nicht jedermanns Sache. Aber warum soll man nicht das vorhandene für sich abändern?

Wie schön wäre es doch, sein eigenes, kleines Betriebssystem für den C 64 zu schreiben. Doch gewiß ist das nicht gerade jedermanns Sache. Daraus könnte sich schnell ein »Fulltime-Job« mit Beschäftigung bis ins hohe Rentenalter entwickeln. Es liegt viel näher, das vorhandene Betriebssystem einfach so lange abzuändern, bis ein eigenes, den Bedürfnissen angepaßtes Kernal entsteht. Beste Beispiele sind das Hypra-Kernal und Hypra-Perfekt (64’er, Ausgaben 12/84, 1/85 und 4/85). Bestimmt hat so mancher inzwischen schon eine kleine Kernal-Sammlung auf Diskette oder EPROM.

Ganz interessant wäre es dann, auf einfache Weise diese Systeme weiter abzuändern. Ihnen beispielsweise einen deutschen Basic-Interpreter zu verpassen, mit deutschen System-und Fehlermeldungen.

Gesagt, getan: Vorliegendes Programm erledigt dies alles. Es ist abgestimmt auf die Kernal-Version aus der 64’er-Ausgabe 1/85 sowie auf das Hypra-Perfekt-Kernal aus Ausgabe 4/85, arbeitet jedoch auch mit vielen anderen Betriebssystemen. Probieren geht hier über Studieren.

Im Gegensatz zu den oben genannten EPROM-Versionen, erzeugt dieses Programm ein lauf- und damit testfähiges Betriebssystem im freien RAM-Bereich unter dem Kernal-ROM ab $E000. Nichtjeder wird wohl gleich ein EPROM programmieren, sondern lieber zuerst etwas experimentieren wollen. Zuerst werden Basic und Kernal ins RAM kopiert (lnit-Routine ab 190). Erstdann kann geändert werden. Das Programm (siehe Listing) erlaubt auch (falls vorhanden) ein Betriebssystem von Diskette zu laden (Zeile 23, siehe Tabelle 1 und 2). Danach kann die Farbkombination beim Warm- und Kaltstart ausgetestet werden. Der SYS-Befehl in Zeile 201 löst einen Reset des Bildschirms innerhalb der geänderten Kernalroutine aus, so daß die Kombination sofort beurteilt werden kann. Erst nach Bestätigen verzweigt das Programm nach Zeile 213. Dort kann eine OLD-Routine aktiviert werden. Beginn ist ab Adresse 64608. Dies gilt es zu beachten, wenn ein Kernal abgeändert werden soll, das eventuell diesen Bereich benutzt. Es handelt sich dabei um einen Teil der normalerweise überschriebenen Kassettenroutinen des Betriebssystems. Hat man ein Betriebssystem geladen, das mit der OLD-Routine kollidiert, muß letztere verschoben werden.

Die genannten Hypra-Kernal sind diesbezüglich unkritisch. Beachtet werden muß lediglich, daß sich deren Adressen für Funktionstasten-Belegung unterscheiden. Soll OLD also auch auf Funktionstaste gelegt werden, fragt das Programm selbst nach der verwendeten Version (Zeile 218). Bei anderen Kernal-Versionen kommt es auf das berühmte Experiment an. Betriebssysteme ohne eine Belegung der Funktionstasten können selbstverständlich auch nicht den OLD-Befehl per Funktionstaste unterstützen. Es fehlen ganz einfach die nötigen Routinen (siehe Original Kernal V2.0)!

Hier bleibt ja immer noch der SYS-Befehl zum Aufruf von OLD, den man sich eben merken muß. Für ganz zerstreute Freaks ist die nachfolgende Routine am idealsten. OLD als gewöhnlicher Basic-Direktbefehl (also auch abkürzbar mit »O SHIFT L«): Zeile 224 sorgt für die entsprechende Programmierung. Da hier, wie nachher auch bei den Fehlermeldungen in deutscher Sprache, das Basic mitverändert wird, muß natürlich auch das Basic-ROM (beziehungsweise -RAM) abgespeichert werden. Wie, das wird zum Schluß erklärt.

Wurden alle Eingaben gemacht, startet das Programm die Initialisierungs-Routine, die Kernal und Basic mit deutschen System- und Fehlermeldungen versieht. Zu guter Letzt wird das neue Betriebssystem aktiviert (Zeile 133). Jetzt können ruhig mal alle Neuheiten durchgespielt werden. Gar nicht so einfach, alle Fehler-Meldungen zu »provozieren«.

Und dabei gibt es immer noch Programmierer, die sich bei Meldungen wie »Syntax Error« die Haare raufen. Aufjeden Fall: einen »Syntax Error« wird es für jene jetzt wohl kaum mehr geben.

Jetzt noch kurz zu den Änderungen gegenüber den EPROM-Versionen. Um ein EPROM zu brennen, muß das Programm in einem Bereich liegen, auf den das EPROM-Pro-grammiergerät zugreifen kann. Daher liegen die Hypra-Kernal ab $6 000 im Speicher. Die Adressen bleiben unkorrigiert, so daß als EPROM ein lauffähiges Betriebssystem im Originalbereich ab $E000 entsteht. Ausgetestet werden kann aber nur, wenn das Betriebssystem wieder an seinen Ursprung verschoben wird. Das kann am komfortabelsten mit einem Monitorprogramm durchgeführt werden.

Ohne Monitor muß mit einer Basic-PEEK/POKE-Schleife der Speicherbereich $6000 bis $7FFF auf die Adressen ab $E000 verschoben werden:
forx=24576to49151:fory=57344to65535
pokey,peek(x):nexty:nextx

Zuvor muß sichergestellt sein, daß das RAM unter dem ROM ab $E000 aktiviert wurde (wie durch die Routine ab Zeile 193). Am besten, man speichert sich diese Basic-Routine separat als Programm, da sie beim Einlesen eines Betriebssystems immer wieder benötigt wird. Aus Zeitgründen wäre eine solche Routine in Maschinen-Code auch nicht zu verachten.

Der verschobene Speicherbereich muß nun lediglich noch auf Disk abgespeichert werden. Ohne Monitor kann dazu zum Beispiel das kleine Programm im 64’er, Ausgabe 2/85, Seite 91 verwendet werden.

Mit einem Maschinensprache-Monitor geht’s einfacher:
Verschieben: .T6000,7FFF,E000-
Save Kernal: .S »K-Name«,08,E000,FFFF
Save Basic: .S »B-Name«,08,A000,BFFF

Beim SMON hat der Verschiebe-Befehl den Buchstaben »W«, und Komma, Minuszeichen und Geräteadresse entfallen.

Übrigens kann auch das ROM ins RAM mittels Monitor kopiert werden. Die Befehle dazu lauten
Kernal:TE000, FFFF, E000-Basic:TA000,BFFF,A000- (danach POKE 1,53).

Auf der Diskette hat man jetzt ein Betriebssystem, das nur mehr vom Programm nachgeladen zu werden braucht. Es kann aber auch schon vorher ein Betriebssystem im RAM aktiv sein. Das Bearbeitungsprogramm erkennt automatisch, ob das Original oder ein neues Kernal aktiv ist (Adresse 1 gleich 55 oder 53, Zeile 100/101)! Andernfalls wird immer das Original-Betriebssystem bearbeitet.

Grundsätzlich muß vor jedem Laden einer Kernal- oder Basic-Version von ROM auf RAM umgePOKEt werden.

Arbeiten mit dem neuen Betriebssystem:

1.	ROM auf RAM umPOKEn
2.	Zeropage-Adresse 1 mit POKE 1,53 umschalten
3.	Kernal laden mit »LOAD ”Name”,8,1«
4.	Basic laden mit »LOAD ”Name”,8,1«

Zur Kontrolle, daß tatsächlich das neue System läuft, kann mit SYS 58648, SYS 58260 in den Warmstart gesprungen werden. Ein SYS 64738 schaltet immer auf das Original-ROM zurück und sollte vermieden werden. Falls er doch einmal ausgelöst wird (zum Beispiel Run-Stop/Restore), kann mit POKE 1,53 jederzeit wieder ins RAM geschaltet werden.

Da das Bearbeitungsprogramm auch das Basic-ROM ändert, muß auch immer Basic von Disk geladen werden. Andernfalls hat man englische Fehlermeldungen und OLD nur als SYS-Befehl.

Zum Abschluß muß noch erwähnt werden, daß der OLD-Befehl den Basic-Befehl END eliminiert. Bei Fremdprogrammen sollte im Hinblick auf Syntax-Fehler daran gedacht werden. Eine Verlängerung der Basic-Befehlsliste ist aus Platzgründen in dieser Programmversion nicht realisiert worden.

(Richard Diezmann/rg)

# Mehr Platz auf der Diskette durch »File-Compactor«

> Die Zeit, in der man aus Platzgründen nur ein oder zwei Programme auf einer Diskette unterbringen kann, ist vorbei. Mit diesem neuartigen File-Compactor sind Sie in der Lage, nicht nur Grafiken, sondern sogar beliebige Programme um bis zu 55 Prozent zu kürzen.

Das Problem, Programme zu packen, um so Platz auf Disket-tenzusparen, istmiteinem einfachen File-Compactor, dersich darauf beschränkt, Folgen gleicher Bytes zu erkennen und zu vereinfachen, noch langenichtbeseitigt EinsolcherCompac-tor (zum Beispiel der File-Compactor aus dem 64’er, Ausgabe 7/85) kann mit Maschinensprache-Routinen wenig anfangen, da dort selten mehr als zweimal das gleiche Byte hintereinander vorkommt. Ein guter Programm-Compactor muß daher anders arbeiten.

## Ein neuartiges Computerverfahren

Hier ist nun ein Compactor, der sich die geringe Unordnung in Programmen zunutze macht. Dadurch wird wirklich jedes Programm (miteiner Längevon mindestens 25 Blocks) erheblich gekürzt. Es gibt praktisch kein Programm, in dem die verschiedenen Zeichen gleich häufig vorkommen. In Basic-Pro-grammen wird das besonders deutlich, weil dort Leerzeichen, Doppelpunkte, das $OO-Byte oder auch einzelne Buchstaben (wie zum Beispiel das »e«) besonders oftzu finden sind. Es gibt aber auch Zeichen, die in einem Programm nur ganz selten oder überhaupt nicht vorkommen. Diese Tatsache kann man sich zunutze machen, indem man beispielsweise für häufig vorkommende Zeichen, einen 3 Bit langen Code definiert. Jeder kann sich vorstellen, was das für eine Platzersparnis mit sich bringt. Je mehr in dem Programm einige wenige Zeichen dominieren, desto geringer ist der durchschnittliche Informationswert und desto stärker läßt es sich kürzen. Natürlich müssen dabei für die weniger oft vorkommenden Zeichen längere Codes (mit einer Länge von 8 Bit und länger) definiert werden, damit die Codierung eindeutig bleibt.

Zusätzlich wurde in diesem Compactor das Verfahren aus Ausgabe 7/85 (Zählen gleicher Bytefolgen) angewandt, da es besonders bei Spielen mit viel Grafik sehr effizient arbeitet.

Däs Programm, das gekürzt werden soll, muß ab dem Basic-Start (Adresse $0801) in den Speicher geladen werden (also laden mit »LOAD"Name",8«) und darf nicht längerals 48639 Bytes sein. Nach dem Kürzen steht eine SYS-Zeile am Anfang, die den Entpacker startet. Dieser wandelt den komprimierten Code wieder in ein lesbares Programm. Auch Basic-Programme können auf diese Weise von dem Computer bearbeitet werden. Mit »RUN« wird dann zuerst der Entpacker gestartet, der dann nach abgeschlossener Umwandlung das eigentliche Basic-Programm ausführt.

## Beispiele zur Benutzung

Das Spiel »Fort Apocalypse«, das gerne als Maßstab für die Güte eines Compactors herangezogen wird, belegt normalerweise 153 Blocks auf der Diskette. Nach der Behandlung schrumpft der Platzbedarf auf 74 Blocks. Doch vor allem bei Basic-Programmen zeigt sich die Stärke des Packers: Sie schrumpfen im Schnitt um zirka 20 Prozent, auch wenn sie überhaupt keine Folgen gleicher Bytes enthalten.

1.	Eingabe des Listings »File-Compactor« mit dem MSE.
2.	Den Verdichter mit »LOAD".. ",8« laden und mit »RUN« starten. Der Verschiebelader befördert die Routine automatisch in den richtigen Speicherbereich.
3.	Jetzt kann man das zu kürzende Programm nachladen.
4.	Den Compactor mit »SYS 51000« aufrufen. Nach getaner Arbeit zeigt er den Grad der Verdichtung (in Prozent) an.
5.	Sofern man der Meinung ist, daß sich der Aufwand lohnt, kann man das Programm danach wieder mit »SAVE".." ,8« abspeichern.

## Modifizierte SAVE-Routine

Wenn Programme gekürzt werden sollen, die nicht in den Basic-Speicher passen und sich bis unter das ROM erstrecken, dann gibt es allerdings Probleme mit dem Abspeichern. Für diesen Fall wurde eine modifizierte SAVE-Routine implementiert. Statt »SAVE ".." ,8« gibt man in diesem Fall »SYS 50965 ".."« ein; die Geräteadresse 8 wird in diesem Fall automatisch gesetzt.

(Arndt Brenschede/ev)

# Bildschirm-Effekte leicht-gemacht

> Mit dieser BasioErweiterung können Sie in beliebigen Bildschirmausschnitten Spezialeffekte wie Blinken, Invertieren oder Auffüllen mit beliebigen Zeichen einfach erzeugen.

Diese kleine Maschinensprache-Routine (»Screen«) kann in nahezu allen Programmen Verwendung finden, um zum Beispiel fehlerhafte Eingaben durch Blinken zu markieren oder um Eingabefelder zu löschen. Auch für die Gestaltung von Titelbildern bietet sich »Screen« an. Folgende Routinen sind vorhanden:
(0) Invertieren des gewählten Bereichs
(1)	Reversdarstellung eines Bildschirm-Bereichs
(2)	Normaldarstellung (Gegenstück zu (1))
(3)	Auffüllen eines Bereichs mit beliebigen Zeichen

Das Programm (Listing 1 und 2) kann auf zwei verschiedene Arten aufgerufen werden. Entweder starten Sie es mit »SYS (Anfangsadresse+36)« oder Sie benutzen statt dessen das Ausrufezeichen »!«. Der erste Weg bietet sich an, wenn schon eine andere Befehlserweiterung das »I« benutzt. Die korrekte Syntax des »!«-Befehls entnehmen Sie bitte Tabelle 1.

Das Programm ist frei im Speicher verschiebbar; die beiden notwendigen Vektoren für die Befehlserweiterung werden in Zeile 195-200 automatisch angepaßt. Möchte man lieber mit dem SYS-Befehl arbeiten, dann können die Zeilen 165-225 ersatzlos entfallen, in diesem Fall findet das Programm auch im Kassettenpuffer Platz. Tabelle 2 zeigt die Belegung der Zero-Page durch das Programm.

Zu bemerken ist noch, daß das Programm aus Platzgründen nicht auf ungültige Zeichen oder Spaltenwerte testet. In Ihren Programmen müssen Sie daher darauf achten, daß der Bildschirmbereich eingehalten wird, da sich sonst Probleme ergeben können. Das Demonstrationsprogramm in Listing 2 sieht zwar unscheinbar aus, erzeugt aber überraschende Effekte.

(Stefan Wagner/ev)

# Aus eins mach zwei

> Mit dieser kleinen Routine »verdoppeln« Sie Ihren Computer. Sie sind damit in der Lage, zwei Maschinenprogramme praktisch gleichzeitig laufen zu lassen.

Die Routine selbst belegt etwa 190 Byte und ist im freien 4-KByte-RAM-Bereich (ab Adresse 49152) abgelegt. Außerdem benötigt sie zwei Pages (Page 193 und 194) als Zwischenspeicher. Zusätzlich wird noch der Basic-Interpreter und das Betriebssystem in das darunterliegende RAM kopiert. Schließlich »verbiegt« die Routine den Interruptvektor.

Das Programm ermöglicht das »gleichzeitige« Betreiben zweier Maschinenroutinen. Jede dieser Routinen läuft nun nur noch mit der halben Geschwindigkeit.

Die Routine wird folgendermaßen gehandhabt: Die Startadresse des ersten Maschinenprogramms, das man benutzen möchte, wird in Adresse 49158 (Lo-Byte) und 49159 (Hi-Byte) abgelegt. Analog verfährt man mit der Startadresse des zweiten Maschinenprogramms, die in Adresse 49156 und 49157 gePOKEt werden muß. Der Befehl SYS 49168 aktiviert die Routine, der Befehl POKE 1,55 (oder in Maschinensprache LDA # 55; STA 1) stellt sie wieder ab. Diese Umschaltung, sei es Basic oder Assembler, wird am besten durch das erste Programm durchgeführt, da nur von dort wieder im Basic-Modus weiter gearbeitet werden kann.

## Basic und Maschinensprache gleichzeitig

Grundvoraussetzung für das Koppel-Programm ist, daß die beiden zu betreibenden Routinen in Maschinensprache geschrieben sind. Auf den ersten Blick mag es daher so aussehen, als wären die Einsatzmöglichkeiten dieser Routine sehr beschränkt. Das Gegenteil ist jedoch der Fall. Da auch das Basic-ROM »Maschinensprache« ist, kann man ohne weiteres mit RTS zum Basic-Modus zurückkehren, anstatt die erste Maschinenroutine zu beginnen. Um dies zu erreichen, ersetzt man dieZahl 108 (JMP indirekt) in Speicherstelle 49187 durch eine 96 (RTS-Code). Jetzt kann man in Basic programmieren und seine Basic-Programme auch entsprechend abarbeiten lassen, während eine zweite Maschinensprache-Routine quasi »im Hintergrund« abgearbeitet wird. Denkbare Anwendungen sind das Spielen von Melodien oder die automatische Bewegung von Sprites während des Programm-Laufs.

Nachdem Sie »Multiprogramming« (Listing 1) mit RUN gestartet haben, sehen Sie ein merkwürdiges Geflimmer auf dem Bildschirm. Dies ist kein Fehler im Programm (dessen dokumentierter Soure-Code in Listing 2 zu finden ist), sondern eine kleine Demonstration. Eine Maschinenroutine ändert fortwährend die Rahmen-, eine zweite die Hintergrundfarbe. Beide kleinen Programme (Adresse 49350 und 49375) laufen jetzt quasi »gleichzeitig« ab. Die Anwendungsbereiche der Basic-Routine sind sehr vielfältig. Sie reichen von der Ausgabe auf zwei Drucker über die »gleichzeitige« Abfrage von Port A und B bis hin zu komplexeren Realtime-Aufgaben. Da gerade bei einem solchen Programm die Dokumentation sehr wichtig ist, • drucken wir sowohl den Source-Code (Listing 2) als auch das Flußdiagramm (siehe Bild) mit ab.

(Thomas Weinbrenner/ev)

# Leichte Eingabe

> Die Benutzerfreundlichkeit eines Programmes hängt von der Behandlung der Eingabe beziehungsweise Fehleingabe ab. Dieses Programm beseitigt viele damit verbundene Probleme.

Das aufgeführte Programm (Listing 1) 2, das eine echte Hilfe beim Erstellen von benutzerfreundlichen Programmen darstellt, ist eine Basic-Eingaberoutine, das heißt, es ist in Basic geschrieben und ersetzt den normalen INPUT-Befehl.

Es ist in der Handhabung sehr einfach gehalten und dabei noch recht kurz.

Der Benutzer muß dabei nur IN$ und LT vorbesetzen (siehe Variablenliste). In der Routine wird als erstes IN$ ausgegeben. Dies hat den Vorteil, daß Standardantworten vorgegeben werden können. Danach werden die für die Darstellung des Cursors notwendigen Variablen vorbesetzt.

Dann wartet die Routine auf die Eingabe eines Zeichens. Der Cursor wird währenddessen dadurch simuliert, daß ein Leerzeichen laufend invertiert wird.

## Komfortabler als »INPUT«

Nachdem ein Zeichen eingegeben wurde, wird zuerst geprüft, ob überhaupt noch Zeichen angenommen werden dürfen. Ist dies der Fall, wird untersucht, ob das Zeichen ein Steuerzeichen ist.

Falls es keins ist, wird das Zeichen ausgegeben und an den Übergabestring angehängt. Dann wird das Hochkommaflag zurückgesetzt, um weiterhin eine vernünftige Eingabe zu gewährleisten.

Falls das eingegebene Zeichen ein Steuerzeichen ist, gibt es nur vier Möglichkeiten:

1.	Es ist ein »RETURN«, dann ist die Eingabe beendet
2.	Es ist ein »DELete«, dann wird der Übergabestring um ein Zeichen vermindert
3.	Es ist ein »SHIFT RETURN«, dann wird der gesamte String gelöscht, und der Cursor an den Anfang des Eingabefeldes positioniert.
4.	Es ist ein anderes Steuerzeichen, dann wird es ignoriert

Bei den Punkten 1. bis 3. wird auch noch getestet, ob überhaupt schon ein Zeichen eingegeben wurde. Ist dies nicht der Fall, dann haben auch diese drei Steuerzeichen keine Wirkung.

(Willi Burmeister/rg)

# Tips & Tricks

## Tips für Anfänger

### List-Bremse

Dieses kleine Programm hält das Listen einer Zeile so lange an, wie eine Taste gedrückt ist. Dazu verändert es zwei Zeiger, die normalerweise auf die Ausgabe der Schlüsselworte zeigen. Es wird durch die Adresse 203 geprüft, ob eine Taste gedrückt ist. Falls ja, so wird mit der Ausgabe weitergemacht. Wenn nein, so wird noch einmal abgefragt.

Das Programm ist mit SYS 49152 zu starten.

(Jörg Blaumeiser/tr)

TODO MSE LISTING?!

### Und wieder einige POKE’s für den C 64:

POKE768,61 — Fehlermeldungen unterdrücken
POKE768,139 — kein Unterdrücken der Fehlermeldungen mehr
POKE19,64 — Sperre des Fragezeichens bei INPUT
POKE19,0 — Auflösen der Sperre
POKE157,128 — LOADING, SEARCHING usw. erscheinen auch im Programm
POKE649,0 — Sperre der Eingabe per Tastatur
POKE649,10 — Auflösen der Sperre
POKE657,128 — Sperre der Zeichensatzumschaltung mit SHIFT+C=
POKE657,0 — auflösen der Sperre
POKE768,143 — Reset nach Programmbeendigung
POKE768,145 — Sperre der Fehlermeldungen im Direkt-Modus
POKE788,81 — schnell blinkender Cursor
POKE788,56 — Cursor aus
POKE788,56 — RUN/STOP blockiert + Cursor aus + interne Uhr bleibt stehen
POKE56325,x — Cursor-Geschwindigkeit verändern (1 =sehr schnell...255=langsam)
POKE56325,0 — langsames LIST

(Rainer Sprehe/tr)

### Die Rechengenauigkeit des C 64

In den 64’er Ausgaben 9 und 10 des letzten Jahres wurde im Leserforum die mangelhafte Rechengenauigkeit des C 64 angesprochen.
Die folgende Zeile zeigt das deutlich:
5 A=A+0,01 : ?A : GOTO 5

Die Ungenauigkeit hat schon manches Mathematikprogramm scheitern lassen. Der C 64 ist eben nicht in der Lage, eine Zahl mehrmals um eine Kommazahl zu vergrößern. Man kann diese Ungenauigkeit aber mit folgender Rundungsformel umgehen:
5 A=A+0,01 : A=INT (A* 100+0.5)/100 : ?A : GOTO 5

Die »100« in der Formel bewirkt ein Runden auf zwei Nachkommastellen. Wenn man auf drei Stellen hinter dem Komma runden will, so muß man die »100« durch eine »1000« ersetzen.

(Andreas Schilling/tr)

### Buntes Directory

Bestimmt hat sich der eine oder andere schon Gedanken darüber gemacht, wie er sein Directory bunt gestalten könnte. Nichts einfacher als das:

Man muß das Programm nur folgendermaßen speichern:
SAVE" (SHIFT-SPACE) (FARBTASTE) TEST",8

Nach dem Laden des Directory erscheint der Programm-Name »TEST« in der zuvor eingegebenen Farbe. Selbstverständlich kann man nach der Farb-Taste auch noch die Revers-Taste drücken.

Beim Laden des Programmes selbst ist jedoch darauf zu achten, daß man nach dem LOAD-Befehl ebenfalls die gleiche Tastenkombination eintippt. In unserem Beispiel würde die Programm-Zeile folgendermaßen aussehen:
LOAD" (SHIFT-SPACE) (FARBTASTE) TEST",8

Am nützlichsten erscheint mir diese Form des Speicherns bei Dateien. Man könnte die verschiedenen File-Typen farblich kennzeichnen, wodurch eine bessere Übersicht und somit auch eine gewisse Ordnung entsteht.

Die REL-Files könnten zum Beispiel gelb, die SEQ-Files revers und weiß gekennzeichnet werden. Folgende Zeile müßte im Programm so aussehen:
OPEN 1,8,1,"(SHIFT-SPACE) (FARBTASTE) TEST,S,W": CLOSE 1

Gleichzeitig entsteht so ein gewisser Programm-Schutz:

Die abgespeicherten Programme stehen nämlich wie folgt im Directory:
67 ""TEST PRG

Auf normalem Weg sind diese Programme nicht zu laden. Es muß eben wie schon erwähnt, das SHIFT-SPACE dazu.

(Dieter Plaum/tr)

# Formeln perfekt gedruckt

> Endlich ist es möglich, mit dem Epson FX-80 mathematische Sonderzeichen zu drucken.

Mit diesem Programm können mathematische Formeln in korrekter Schreibweise zu Papier gebracht werden. Es ist lauffähig auf dem Commodore 64 mit Epson-Drucker FX-80 und Görlitz-Interface.

Das Programm beinhaltet folgende Funktionen:

1.	Umwandlung des Basic-Zeichens »/«in einen echten Bruch (siehe Bild 1, Beispiel 1).
2.	Umwandlung des Basic-Zeichens »t« in echte Potenzschreibweise (siehe Bild 1, Beispiel 2).
3.	Umwandlung der Basic-Funktion »EXP(X)« in echte Expo-nentialschreibweise (siehe Bild 1, Beispiel 3).
4.	Umwandlung der Basic-Funktion »SQR(X)« in echte Wurzelschreibweise (siehe Bild 1, Beispiel 4).
5.	Mischung von Bruch-, Wurzel-, Exponential- und Potenzschreibweise (siehe Bild 1, Beispiel 5 bis 18).
6.	Beachtung der Klammerregeln (siehe Bild 1, Beispiel 8 bis 12).
7.	Ausgabe des Bruchstrichs exakt auf der Höhe der ganzrationalen Funktionsterme.
8.	Einbindung in andere Programme ohne weiteres möglich, es muß nur die Funktion und die Druckposition übergeben werden.
9.	Nach Ende des Druckvorgangs befindetsich der Druckkopf auf der gleichen Höhe wie zu Beginn, genau hinter der ausgedruckten Funktion. Es können also in einer Reihe ohne Probleme mehrere Funktionen ausgegeben werden.

Soweit eine kurze Übersicht über die Fähigkeiten des Programms. Kommen wir nun zu einer Beschreibung des Programmaufbaus (Tabelle 1).

In den Zeilen 120 bis 1150 befindet sich ein Beispielprogramm. Es bewirkt einen Ausdruck der Beispiele aus Bild 1.

Die Funktionen werden definiert und in G$(1) bis G$(18) festgehalten. In der sich anschließenden Schleife (Zeilen 1040 bis 1130) werden nun nacheinander die Funktionen einmal in Basic-Schreibweise und durch den Aufruf des Unterprogramms (Zeile 1120) in exakter Schreibweise ausgegeben. Vor dem Aufruf des Unterprogramms werden in den beiden Variablen BB und F$ die zu übergebenden Informationen definiert (siehe Tabelle 2). Zum einen ist das der Abstand vom linken Rand (hier 55) und zum anderen die Funktion selber (hier von G$(1)bis G$(18)).

Das Beispielprogramm soll nur einen kurzen Überblick über die vielfältigen Möglichkeiten von »Formel-Druck« geben und demonstrieren, wie die vom Programm benötigten Informationen zu übergeben sind. Wichtig ist in diesem Fall auch Zeile 120. In F$(..) werden im Programm späterdie einzelnen Terme der zu druckenden Funktion abgelegt. Ist eine Funktion sehr lang, kann es leicht zu einer größeren Anzahl an Einzeltermen als 11 kommen. Um allen Eventualitäten vorzubeugen, ist es besser, F$ gleich genügend groß zu dimensionieren. Hier wurde der Wert 50 gewählt, aber auch eine kleinere Zahl reicht meistens aus und kann vom Anwender nach eigenem Willen eingesetzt werden.

Ab Zeile 50000 beginnt nun das eigentliche Programm, die Routine zum Umwandeln der Basic-Funktionen mit sich anschließendem Ausdruck.

In Zeile 50170 ist zunächst einmal das sehr häufig benutzte Unterprogramm zum Auslesen eines Zeichens (in T$) aus der Funktion (FU$) angelegt. In den Zeilen bis 50400 werden nun die nötigen Anfangsbedingungen eingestellt. Das ist erstens in Zeile 50180 die Festlegung des Zeichensatzes für den Drucker (Groß-/Kleinschrift mit Zeilenabstand von sieben Punkten), in der für das Görlitz-Interface typischen Form. Zweitens die Definition der Sonderzeichen zum Wurzelausdruck (das »&« wird zum Strich über den Zeichen und das »%« zum Wurzelzeichen). Schließlich werden noch die benötigten Variablen festgelegt und der Fettdruck eingeschaltet.

In den Zeilen 50420 bis 50720 werden die beiden Basic-Befehlsworte EXP und SQR aus der Funktion eliminiert und durch für das Programm später verständliche Befehle ersetzt (Zeile 50550 und 50710). Durch die Verminderung von L wird die sich verkürzende Funktionslänge berücksichtigt.

Anschließend folgt der Test auf gebrochenrationale Funktion (Zeile 50780 bis 50850). Trittin derzu druckenden Funktion ein Divisionszeichen auf, wird in Zeile 50980 verzweigt und die Funktion in ganzrationale und gebrochenrationale Terme zerlegt. Zu diesem Zweck werden zum einen die vor dem Bruchstrich (Zeile 50980 bis 51070) und zum anderen die hinter dem Bruchstrich (Zeile 51080 bis 51180) auftretenden Zeichen betrachtet. Als Abbruchkriterium giltjeweils das erste »+«,»—« oder »*«-Zeichen, das nicht mehr zum Zähler oder Nenner gehört. In den Zeilen 51190 bis 51260 findet dann die Zuweisung der entsprechenden Einzelelemente in F$(SC) statt. Hierbei wird SC bei jedem neu hinzukommenden Term um eins erhöht. Nun wird in Zeile 51260 wieder nach 50780 zurückgesprungen und der restliche Funktionsteil untersucht. Das geschieht so lange, bis alle Divisionszeichen abgearbeitet sind. Dann wird der restliche Teil in F$(SC) abgelegt und zur Hauptschleife des Programms zurückgekehrt (Zeile 50910 bis 50920).

Diese Schleife beginnt in Zeile 51320. Mitjedem Durchlauf der Schleife wird ein in F$(SC) abgelegter Term aufgerufen, die jeweilige Druckposition festgelegt und der Fettdruck gesetzt.

Jeder einzelne Term wird in den Zeilen 51450 bis 51530 auf gebrochenrationale Funktion geprüft. Liegt eine vor, muß diese in den Zeilen 51650 bis 51720 in Zähler und Nenner zerlegt werden. Während dieser Prozedur werden auch gleich die überflüssigen Klammern entfernt (Zeile 51680 und Zeile 51720). Handelt es sich um einen ganzrationalen Funktionsteil, wird dieser in Zeile 51590 im Zähler abgelegt und der Nenner für spätere Kontrollen mit einem Leerstring belegt.

Um hinterher beim Ausdruck ein exaktes Druckbild zu erhalten (Bruchstrich mit der richtigen Länge und Zähler und Nenner zentriert übereinander) muß die Verkürzung des Druckbildes durch Potenzausdruck und Wegfall von einigen Zeichen durch die Eliminierung von SQR berücksichtigt werden. Das Ausmaß der Verkürzung wird in den Zeilen 51780 bis 52020 berechnet. Bei jeder auftretenden Potenz verkürzt sich die Länge des Ausdrucks um 0,5 und durch Wegfall des Zeichens »t« um eine Druckposition. Dies wird jeweils für Zähler und Nenner getrennt in Zeile 51970 beziehungsweise 51980 festgehalten.

Die Verkürzung durch den Wegfall der Klammern beim Wurzelausdruck wird jeweils in Zeile 52010 beziehungsweise 52020 berücksichtigt.

Die erhaltene Gesamtverkürzung ist in WO beziehungsweise WU enthalten. Diese wird beim Umwandeln von Zähler und Nenner auf die gleiche Länge (Zeile 52030 bis 52050) mit einberechnet. Dadurch wird eine ordentliche Bruchschreibweise gewährleistet.

Ab Zeile 52110 beginnt die Druckroutine. Als erstes wird der Zähler jedes einzelnen Terms ausgegeben. Hierbei wird ein ganzrationaler Funktionsteil als Zähler mit dem Nenner als Leerstring betrachtet. Handelt es sich um einen gebrochenrationalen Funktionsteil, wird in Zeile 52130 das Papier um eine Position rückwärts transportiert, um später den Bruchstrich auf Höhe der ganzrationalen Funktion ausgeben zu können. Zum Ausdruck wird jedes Zeichen des Zählers untersucht, ob es sich um ein Potenz- oder Wurzelsymbol handelt. Ist dies der Fall, werden die entsprechenden Routinen zum Potenz- beziehungsweise Wurzelausdruck ausgeführt. Alle anderen Zeichen werden sofort gedruckt.

Handelt es sich beim ausgegebenen Term um eine ganzrationale Funktion, wird ein Rückwärtstransport des Papiers von einer Zeile durchgeführt und das Ende des Terms in BB festgehalten, damit die nächsten Funktionsteile direkt im Anschluß gedruckt werden können.

Ansonsten kommt es zur Ausgabe des Bruchstrichs (Zeile 52280 bis 52360). Die Länge des Bruchstrichs wird in AA festgehalten und aus den oben genannten Verkürzungswerten WO und WU und der Länge des Zählers und Nenners berechnet (Zeile 52300 bis 52310).

Als letztes wird dann der Nenner ausgedruckt. Dies erfolgt auf die gleiche Weise wie beim Zähler. Auch hier wird am Ende ein Rücktransport des Papiers durchgeführt. Das Ende eines gebrochenrationalen Funktionsteils ergibt sich aus der Länge des Bruchstrichs und wird in BB gespeichert.

In den Zeilen 52580 bis 53090 stehen die beiden Unterprogramme zum Potenz- beziehungsweise Wurzelausdruck. Die Potenzausdruckroutine beginnt in Zeile 52580. Es wird die Superscript- und die Schmalschrift eingestellt. Dann wird jedes dem Potenzsymbol folgende Zeichen überprüft, ob es noch im Exponenten steht oder nicht. Als Abbruchkriterium gelten die gängigen mathematischen Kriterien (Zeilen 52650 bis 52705). In den Zeilen 52720 bis 52750 wird überprüft, ob die Potenz unter der Wurzel steht, in diesem Fall ist WW = 1, und der entsprechende Wurzelstrich wird ausgegeben. Nach Abarbeitung aller in Frage kommenden Zeichen wird wieder die Normalschrift und der Fettdruck eingeschaltet und zurück ins Hauptprogramm gesprungen (Zeile 52810 bis 52850). Die Variable M (Zeile 52760) dient zur Berechnung der Verkürzung des Terms durch den Potenzausdruck und wird bei ganzrationalen Funktionen berücksichtigt.

In der Wurzelausdruckroutine läuft im Prinzip das gleiche ab. Sie beginnt in Zeile 52910 und druckt zuerst das Wurzelsymbol und über alle folgenden Zeichen den Wurzelstrich. Zur Ausgabe dieses Strichs wird der Druckkopfjeweils um ein Zeichen zurück und einen Matrixpunkt nach oben bewegt und anschließend das Sonderzeichen ausgegeben (Zeile 53020 bis 53060).

Den Abschluß des Programms bilden die Zeilen 53150 bis 53170. Hier wird der Drucker normiert, das heißt in den Einschaltzustand zurückversetzt, alle offenen Kanäle geschlossen und der Epson-Modus mit automatischem Zeilenvorschub eingestellt.

(Patrick Bödeker/rg)

# Schreiben Sie Ihre eigenen Fehlermeldungen

> Wer die öden Meldungen des Betriebssystems wie »READY« oder »SYNTAX ERROR« satt hat, kann mit dem »ErrorChanger« alle Fehlerausgaben ändern und auf Diskette speichern.

Denken Sie einmal an klassisches Basic-Programmieren: Drei Zeilen eintippen, Probelauf, Fehlermeldung, Korrektur, Probelauf... und so weiter. Und bei jedem Fehler erscheinen die sattsam bekannten, äußerst langweiligen Einheitsfehlermeldungen.

Mit dem hier vorgestellten Programm »Error-Changer« ist es endlich möglich, den Wortlaut der Fehlermeldungen frei zu wählen (Bild 1 und 2). Nun, das ist immer noch nichts so Besonderes. Besonderes ist, daß der neue Textjeder Fehlermeldung bis zu 80 (achtzig) Zeichen lang sein kann.

Ob Sie den »UNDEFD STATEMENT ERROR« mit »QUO VA-DIS« oder mit »WOHIN, MEIN FREUND??« übersetzen, bleibt Ihrer Phantasie überlassen. Es schaut auch besser aus, wenn statt dem faden »READY«, zum Beispiel das warmstartsichere »ANDYS SOFTWARE IST IMMER EIN GEWINN« erscheint. Individualität ist Trumpf, Einheits-ROM ist out.

Das Programm ist kinderleicht zu bedienen: Error-Changer (siehe Listing) laden und starten.

Es erscheint der Text der alten, englischen Fehlermeldung. Sollte sie nicht geändert werden, so wird sie normal mit der RETURN-Taste übernommen. Ansonsten wird der neue Text eingetippt. Die Länge des neuen Textes kann frei gewählt werden und ist nur durch die 80 Zeichen des INPUT-Befehls begrenzt. Sollte der neue Text kürzer sein als der alte, so ist der Rest mit Leerzeichen zu überschreiben. Es kann auch die Abbruchmeldung BREAK und die READY-Meldung geändert werden. Jedoch erscheint, bedingt durch das Betriebssystem, nicht immer der geänderte Text.

Nach Beendigung schaltet das Programm automatisch auf die neuen Fehlermeldungen um. Diese können auf Kassette oder auf Disk gespeichert werden, um die kreativen Ergüsse für die Nachwelt zu erhalten.

Die neuen Fehlermeldungen werden mit
LOAD ”FEHLER.OBJ”,8,1 (für Datasette ,1,1)
geladen, mit SYS 49152 ein- und mit SYS 49226 ausgeschaltet. Nach dem Laden sollten Sie unbedingt NEW eingeben.

Nun zum Programmtechnischen.

Es wird der »Vektor auf Fehlermeldungen« $0300-$0301 (dezimal 768-769) auf das neue Programm »umgebogen«. Tritt ein Fehler auf (Fehlernummer größer 0), so stellt das Programm normale Ein- und Ausgabeverhältnisse her (Bildschirm, Tastatur). Die Fehlernummer bildet einen Vektor auf die Adresse des ersten Buchstabens der entsprechenden Fehlermeldung. Die Tdxte der Fehlermeldungen werden hintereinander gespeichert. Als Trennzeichen fungiert das siebte Bit des letzten Buchstabens. Ist es gesetzt, so weiß das Betriebssystem, daß dieser Buchstabe der letzte ist. Somit ist der erste Buchstabe (Zeiger im Steuerprogramm) und der letzte definiert (siebtes Bit gesetzt). Jetzt muß die Meldung nur noch geschrieben werden. (Das Ganze kann mit dem K-Befehl des SMON angeschaut werden. Nicht vergessen: Auf Kleinschriftmodus umschalten!)

Um Speicherplatz zu sparen, wurden im Programm die Fehlermeldungen ohne das Wort »ERROR« gespeichert, da dieses bei allen Meldungen gleich ist. Bei den neuen Meldungen muß der ganze Wortlaut angegeben werden, da bei manchen Scherzfehlermeldungen das Wort »ERROR« oder »FEHLER« stören würde.

Beschreibung der wichtigsten Variablen:

T$(I) =Text der alten und nach dem Überschreiben der neuen Fehlermeldung.
LV = Lesevektor. Liest alte Meldung aus dem ROM.
SA = Schreibvektor. Schreibt neuen Text in das RAM.
VA = Schreibvektor auf Lo/Hi-Adressen des ersten Buchstabens der neuen Meldung.
SA und EA = Start- und Endadresse als Parameter für den SAVE-Befehl
FZ = Fehlerzähler (identisch mit der betriebssysteminternen Fehlernummer!)

(Andreas Knipp/tr)

# Kopierschutz ohne Read Error

> Read Errors sind für die meisten Ko-pierprogramme kein Problem, deshalb wird hier ein anderer Weg beschritten. Basic- und Maschinen-Programme sind nur dann lauffähig, wenn vor dem Start ein Paßwort eingegeben wird.

Das Programm ist in Maschinensprache geschrieben und belegt den Speicherbereich von $CFOO bis $CF46. Der bereich von $CF47 bis $CFFF istfür ein Paßwort reserviert, das eingegeben werden muß, nachdem der zuvor abgetippte Lader (siehe Listing) mit RUN gestartet wurde. Von nun an werden alle Programme, die auf Diskette gespeichert werden, beim Speichern codiert. Solange der Computer eingeschaltet bleibt, können Programme, die mit dem eingegebenen Paßwort gespeichert wurden, ganz normal geladen werden. Programme, die unter einem anderen Paßwort gespeichert wurden lassen sich zwar auch noch Laden, sind aber nicht mehr lauffähig. Sollen solche Programme gestartet werden, muß dem Computer vor dem Laden das neue Paßwort übermittelt werden. Dies geschieht mit einem kleinen Basic-Programm:
10 INPUT C$ : C=LEN(C$)
20 FORI=1TOC
30 POKE 53072+I,ASC(MID$ (C$,I,1))
40 NEXT
50 POKE 13*16T3-1,C
60 END

Soll ein normales, also uncodiertes, Programm geladen oder gespeichert werden, so muß man den Codierer mit POKE 1,55 ausschalten. Mit POKE 1,53 läßt er sich wieder einschalten.

(Michael Dietz/ah)

# Tape Save — Maschinenprogramme einfach gespeichert

> Der Save-Befehl des C 64 erlaubt es leider nicht, bestimmte Speicherbereiche und damit Maschinenprogramme abzuspeichern. Mit »Tape Save« können Sie dies sogar im Dialogverfahren und sowohl auf Diskette als auch auf Datasette.

Wer kennt das Problem nicht: Man hat einen DATA-Lader für ein Maschinenprogramm und kann das Programm wegen eines fehlenden Monitors nicht direkt abspeichern! Hier setzt nun unser Programm »Tape Save« ein, das es auch Anfängern ermöglicht, im Dialogverfahren Maschinenprogramme auf Kassette oder Diskette zu speichern.

»Tape Save« (siehe Listing) tippen Sie bitte mit dem MSE ab. Es kann dann mit »LOAD ”TAPE SAVE” ,1,1« beziehungsweise »..,8,1« geladen werden. Gestartet wird »Tape Save« mit SYS 49152. Vor dem Start müssen Sie noch NEW eingeben, um keinen »OUT OF MEMORY ERROR« zu erhalten.

## Bedienungshinweise

Als erstes wird nach dem Namen des zu speichernden Programms gefragt. Der Computer akzeptiert höchstens 16 Zeichen, verlangt aber mindestens ein Zeichen, sonst wird die Eingabe abgelehnt. Danach gibt man Start- und Endadresse in hexadezimaler Form ein. Dabei erscheint allerdings kein Cursor, die eingetippten Werte werden aber angezeigt. Nach Eingabe der beiden vierstelligen Zahlen fährt das Programm mit der Frage nach der Nummer des Peripheriegerätes fort. Auch hier wird nur eine gültige Eingabe akzeptiert, wobei »1«für Da-tasette und »8« für das Diskettenlaufwerk einzugeben ist. Danach startet »Tape Save« den Speichervorgang. Nach dem Speichern ermöglicht es dann dem Benutzer, mittels der Funktionstasten den weiteren Programmablauf zu gestalten. Man kann den Speichervorgang wiederholen, das Programm abbrechen oder aber nochmals beginnen, um ein weiteres Programm zu speichern.

Hier noch einige wichtige Bedienungshinweise:

Diskettenbenutzer müssen aufpassen, wenn sie mit der Funktionstaste »F3« nochmals ohne Parameteränderung speichern wollen. Wurde die Diskette nicht gewechselt, erhält man einen »FILE EXISTS ERROR«, weil auch der Filename nicht geändert wird.

Der wichtigste Nachteil von »Tape Save« ist seine Lage im Speicher: Es liegt von $c000 bis $c369. Das bedeutet, daß Programme, die im $c-Bereich liegen, auch nichtvon »Tape Save« gespeichert werden können. Ebenso können keine Maschinensprache-Programme, die sich im Kassettenpuffer befinden, auf Kassette gespeichert werden. Hier ist nur die Speicherung auf Diskette möglich.

(Johannes Rest/bs)

# Linker 64 — Schluß mit dem Nachladen

> Wenn Sie öfters mehrere Maschinenprogramme gleichzeitig im Speicher haben wollen und es leid sind, jedes Programm einzeln nachzuladen, dann ist der Linker das ideale Arbeitswerkzeug für Sie.

Seine Anwendungen sind vielfältig: vom einfachen Basic-Start-Generator für Maschinenprogramme bis zum Verketter (= Linker) von mehrteiligen Spielen. Das Endprodukt, also das generierte Programm, kann dann ganz einfach auch von der Datasette geladen werden, was bisher an den Diskettenlade-routinen der Programme scheiterte. Diese Laderoutinen müssen natürlich vorher entfernt werden.

Die Bedienung ist denkbar einfach: Diskette mit den einzelnen Programmen nehmen, Linker 64 (siehe Listing) starten und bedienen. Es wird eine lauffähige Version generiert, die man mit LOAD und RUN starten kann.

Die einzige Denkarbeit besteht in der Überlegung, in welcher Reihenfolge die Programme wieder an ihre ursprünglichen Adressen verschoben werden sollen. Das ist wichtig, da sonst während des Verschiebevorgangs bereits verschobene Programmteile, die noch nicht verschobenen überschreiben könnten. Im allgemeinen wird man zuerst die Maschinenroutinen verschieben, die an die höchste Adresse geschrieben werden sollen.

### Die Arbeitsweise des Linkers

Der Linker generiert drei Programmteile, die am Ende verkettet werden: Teil »S« besteht aus der Basic-Zeilennummer, dem SYS-Befehl und dem anschließenden Text, gleich einer REM-Zeile. Teil »V« besteht aus dem generierten Verschiebeprogramm. Für Interessierte sei gesagt, daß bei einer Verschiebung nach oben die betriebssysteminterne Blockverschieberoutine ($a3bf) angesprungen wird. Bei Transfer nach unten kommt eine »handgestrickte« Routine zur Anwendung. Teil »P« enthält schließlich die aneinandergehängten Maschinenprogramme.

Der Linker kennt zwei Betriebsarten: entweder Verschiebeteil vor oder nach den gelinkten Programmen. Im Modus »0« ist die Reihenfolge der drei Teile S-V-P, im Modus »1« ist sie S-P-V. Der Modus »0« (LoMem-Modus) wird fast immer benutzt, da nursehrselten Programmteile im Basic-Startbereich (2049 = $0801) laufen. Sollte dies aber doch der Fall sein, oder sollen Basic-Programme mit Maschinenprogrammen zusammengelinkt werden, so muß Modus »1« (HiMem-Modus) verwendet werden. Die Verschieberoutine würde sich sonst selbst überschreiben.

### Anwendung des Linkers

Beispiel: Wir wollen aus dem SMON $c000, einer RENEW-Routine mit der Startadresse 36 000 und einem Assembler ASS $9000 ein einziges Programm machen. Dieses sollte nach dem Laden die einzelnen Teile gleich an die richtigen Adressen im Speicher versetzen und mit »RUN« zu starten sein. Weiterhin soll danach gleich der SMON starten:

(Alle drei Programme müssen sich auf der gleichen Diskette befinden.) Zuerst lädt man den Linker und startet ihn. Dann gibt man die Zeilennummer, in der später der SYS-Befehl stehen soll, einen erklärenden REM-Text und den Namen ein, den das fertige Programm erhalten soll. Als Betriebsart wählen wir »0«, da der Basic-Startbereich von unseren Programmen nicht berührt wird. Die Frage nach der Anzahl der Programme beantworten wir mir »3«. Nun werdendie Namen der einzelnen Programme eingegeben, woraufhin der Linker deren Startadressen berechnet und ausgibt. Diese könnten jetzt noch geändert werden, was aber nicht sehr ratsam ist. Maschinenprogramme haben im allgemeinen nämlich die Eigenschaft, nur in dem Speicherbereich zu laufen, für den sie geschrieben wurden. In unserem Fall übernehmen wir also die Startadressen mit der RETURN-Taste.

Jetzt fragt der Linker nach der Reihenfolge, in der später die Programme verschoben werden sollen (ist in unserem Fall egal, da sich unsere Beispielprogramme nicht im geringsten gegenseitig stören). Der Linker meldet sich mit:

TODO TABLE

1	= SMON $c000
2	= ASS $9000
3	= RENEW
4	= ENDE

Wir tippen zum Beispiel »2« für die Verschiebung des Assemblers. Nun wird für ihn die Einsprungsart verlangt: EINSPRUNG: O = KEINER, 1=JSR, 2=JMP

Da nach der Verschiebung des Assemblers dieser nicht gleich gestartet werden soll, geben wir eine »0« ein. Es erscheint am Bildschirm:

TODO

1	= SMON $c000
2	=
3	= RENEW
4	= ENDE

Sie sehen, der Assembler ist »verschwunden«. Der Linker wartet auf dasnächste Kommando. Wir geben »3« für die RENEW-Routine ein. Da diese ebenfalls nicht gleich gestartet werden soll, beantworten wir die nachfolgende Frage mit »0«. Dann verschieben wir mit »1« den SMON. Wir haben vorher gesagt, daß das fertige Programm diesen gleich starten sollte. Also Einsprungsart »2«. Die Einsprungsadresse, die der Linker daraufhin verlangt, ist 49152 (SMON).

Es wird noch einmal nach der Einsprungsart gefragt, da bei der Eingabe von »1« (JSR) noch weitere Einsprünge erfolgen könnten. Wir quittieren das Ganze mit »0« und das Abenteuer ist für uns erledigt.

Jetzt wirft der Linker die DOS-interne Copy-Routine an, die die vorher generierten Teile »V« und »S« auf der Diskette direkt aneinanderhängt. Nach einiger Zeit meldet sich der Computer mit READY, und der Link-Vorgang ist beendet. Auf der Diskette befindet sich jetzt das fertige Programm, das mit LOAD"na-me”,8 geladen und mit »RUN« gestartet werden kann. Es werden zuerst die gelinkten Programme in der festgelegten Reihenfolge an ihren Platz im Speicher verschoben und die durch JMP oder JSR definierten Adressen angesprungen. Achtung: Vor einem erneuten Start durch »RUN« sollte das Programm erst noch einmal geladen werden, ebenso sollte es nach dem Verschieben nicht mehr gespeichert werden.

Die wichtigsten Unterprogramme des Linkers sind in der Tabelle beschrieben. Die Röutine »Test auf Vorhandensein von Programmen auf Disk« eignet sich gut zum Einbau in eigene Programme.

(Andreas Knipp/tr)

# Variablen-Dump

> Mit diesem kleinen Programm und einem SYS-Befehl haben Sie alle Ihre BasicVariablen voll im Griff. Eine, nicht nur zum Austesten von Programmen, nützliche Erweiterung.

»Dump« bedeutet übersetzt Speicherauszug oder Speicherausdruck eines Computers. Ein Variablen-Dump ist eine Übersicht aller Variablen, die in einem (Basic-)Programm verwendet werden. Es gibt verschiedene Möglichkeiten, die Erweiterung »Dump« zu benutzen:

- SYS 49152,A: Listet alle im Programm verwendeten indizierten Variablen mit dem Namen A auf; also A(1), A(2) und so weiter.
- SYS 49152 ohne Zusatz: Listet alle nichtindizierten Variablen.
- SYS 49152,$: Listet nur alle nichtindizierten Stringvariablen.
- SYS 49152,%: Listet nur alle nichtindizierten numerischen Variablen (das Gegenstück zu SYS 49152,$).

(Herbert Kunz/tr)





















Escape-Taste für Gänsefüß-chen-Modus
Beim Editieren geschieht es oft, daß man anstelle einer Cursorbewegung ein reverses Feld erhält, auch wenn man das gar nicht wünscht. Der einzige Weg zurück zur normalen Cursorkontrolle führte bis jetzt über das Drücken der RETURN-Taste. Mit dieser Routine kommen Sie durch einfachen Druck auf die »F7«-Taste aus dem »Gänsefüßchen-Modus« heraus.
Vielleicht haben Sie sich auch schon über die etwas exotisch klingenden Ausdrücke im Titel gewundert, aber sie beziehen sich auf eine typische Eigenschaft des Commodore Basic-Editors. Wenn man Anführungszeichen oder die INSERTTaste getippt hat, wird jedes Drücken einer Cursortaste nicht durch eine direkte Bewegung des Cursors, sondern durch ein reverses Steuerzeichen quittiert. Nebenbei: dasselbe geschieht beim Drücken der Funktions-, der CLR/HOME- oder der CTRL-Taste zusammen mit den Farbentasten. Dieser Modus, in dem sich der Editor dann befindet, wird Quote-Modus, zu deutsch »Gänsefüßchen-Modus« oder programmierter Cursor genannt.
Manchmal ist das sehr erwünscht, wenn man zum Beispiel die Cursor- oder Farbsteuersequenzen ins Programm einbinden möchte. Oft ist es aber auch unerwünscht, und man überschreibt durch Unachtsamkeit eine halbe Programmzeile mit reversen »Q« oder sonstigen Steuerzeichen. Aus dem »Gänsefüßchen-Modus« heraus gelangt man nur, indem man noch einmal die Taste für Anführungsstriche oder RETURN drückt. Wie gut wäre es, wenn man mit einem einfachen Tastendruck aus dem störenden Quote-Modus herausgelangen könnte, ohne irgendein Zeichen überschreiben zu müssen.
Die Escape-Routine realisiert diese Möglichkeit vollständig. Durch simplen Druck auf die Funktionstaste »F7« werden alle Bits gelöscht, die verhindern, daß sich der Cursor normal steuern läßt. »F7«ermöglichtalsodas Entkommen (englisch: escape) aus diesem Modus.
Damit Sie auch immer genau wissen, wann welcher Modus aktiv ist, stehen in der rechten oberen Bildschirmecke die entsprechenden Buchstaben in weißer Farbe. Haben Sie Anführungsstriche geschrieben, dann erscheint ein »Q« als Zeichen dafür, daß der Quote-Modus eingschaltet ist. Das »Q« steht dort so lange, bis der Modus ausgeschaltet wird, das heißt, bis entweder RETURN, Schlußzeichen oder »F7« gedrückt wurde. Wollen Sie etwas in reverser Schrift erscheinen lassen, dann müssen Sie CTRL/RVS ON drücken und schon erscheint ein weißes »R« als Abkürzung für Revers-Modus in der Bildschirmecke. Als drittes Zeichen kann noch das »I« vorkommen, nämlich dann, wenn die INSERT-Taste benutzt wurde. Im lnsert-Modus kann man nicht einmal ein falsch eingetipptes Zeichen mit der DEL-Taste löschen, da nur reverse »T«s erzeugt
programm : escape-t.cod cOOO cOBf
cOOO		78	a9	11	a2	cO	8d	14	03	b4
c008	ff	8e	15	03	58	a9	02	85	fb	a5
cOlO	■	60	c6	fb	fO	03	4c	31	ea	ld
cO18		a9	02	85	fb	a9	00	85	fc	4e
cO2O	S	a5	d4	fO	11	a9	ff	85	fc	38
c028		a9	11	8d	27	04	a9	01	8d	4f
c030	■	27	d8	4c	3a	cO	a9	20	8d	13
c038	ff	27	04	a5	c7	fO	Od	a9	12	06
c040		8d	26	04	a9	01	8d	26	d8	dd
c048	«	4c	50	cO	a9	20	8d	26	04	31
cO5O	ff	a5	d8	fO	11	a9	ff	85	fc	6a
c058	ff	a9	09	8d	25	04	a9	01	8d	3b
c060	«	25	d8	4c	6a	cO	a9	20	8d	47
c068	■	25	04	a5	d7	c9	88	dO	lb	4e
c070	a	a2	00	86	d4	86	c7	86	d8	cl
c078	a	a5	fc	fO	Of	e8	86	c6	a4	eO
c080	a	d3	88	a5	ce	91	dl	a9	9d	64
c088	a	8d	77	02	4c	31	ea	00	aO	87
Listing 2. Das MSE-Ladeprogramm zu »								EscapeTaste«.		
Bitte beachten Sie die Eingabehinweise auf Seite 6
Eingabehinweise
Wer im Besitz eines Assembler ist, kann das Assemblerprogramm (Listing 1) abtippen, alle anderen verwenden bitte den Weg über den MSE (Listing 2).
Die Startadresse des Programmes liegt bei $C000 gleich 49152 dezimal, die Endadresse bei $C08F oder 49295.
Das Programm wird natürlich nach dem Abtippen und Speichern wieder mit der Sekundäradresse 1, das heißt absolut geladen. Nach dem Laden muß »NEW« eingegeben werden, damit die Basic-Zeiger, die in den Bereich $C000-$CFFF verstellt wurden, wieder »zurechtgebogen« werden.
10 SYS9*4O96
15 .DPT P,00
20 ;
25 ;****************************************
30 ;*==== ESCAPE-TASTE FUER QUOTE-MODE ====*
35 ;*	AUF COMMODORE 64	*
40 ;****************************************
45 ;*	*
50 ;*	CHRISTIAN SPOERRI	*
60 ;*	LANGWEID 9	*
70 ;*	CH-8045 ZUERICH/SCHWEIZ	*
75 ;*	*
80 ;*	TEL.00411/463 65 94	*
85 ;*	*
90 ;**************************************** 95 ;
100 ;			
105			
110	COUNT	=$FB	;VERZOEGERUNGSZAEHLER
115	DELAY	=$02	;ANZAHL DURCHLAEUFE BIS
120			;ZUR ABFRAGE
125	LASTKEY	=$D7	;ASCII-CODE DER LETZTEN
130			;GEDRUECKTEN TASTE
135	QUOTE	=$D4	;FLAGGE FUER QUÖTE-MODE
140			;(GAENSEFUESSCHEN-MODUS)
145	INVERS	=$C7	;RVS FLAG FUER BILDSCHIRM
150	NINSERT	=$D8	;ANZAHL FAELLIGER INSERTS
155	FLAG	=$FC	;FLAGGE, OB ZEICHEN GE-
160	■		;LOESCHT WERDEN MUSS
165	BSPALTE	=$D3	;ZEIGER AUF BILDSCHIRM-
170			;SPALTE
175	ZEILE	=$D1	;VEKTOR, ZEIGT AUF ZEILENBE-
180			;GINN IM BILDSCHIRMSPEICHER
185	CHCURSOR	=$CE	;ZEICHEN UNTER CURSOR
190	NOKEYS	=$C6	;ANZAHL ZEICHEN IM TASTATUR-
195			;PUFFER
200	KBBUFFER	=$277	;BEGINN DES TASTATURPUFFERS
205	F7	=$88	;ASCII-CODE DER FUNKTIONS-
210	:		;TASTE 'F7'
215	QSCODE	=$11	;BILDSCHIRMCODE VON "Q"
Listing 1. Das Assemblerlisting zum Programm »EscapeTaste«
99
Tips & Tricks
220 RSCODE	=$12 ;BILDSCHIRMCODE VON "R"
225 ISCODE	=$09 ;BILDSCHIRMCODE VON "I”
230 NORMIRQ	=$EA31 ;EINSPRUNGADRESSE FUER NOR-
235 :	;MALE INTERRUPTROUTINE
240 IRQVCT	=$314 ;ADRESSE DES INTERRUPTVECTOR
245 C0L0R	=$01 ;FARBE DER INDIKATORBUCH-
250 :	;STABEN (WEISS)
255 SCREEN	=$427 ;SPEICHERPLATZ IM BILD-
260 :	;SCHIRMSPEICHER
265 CLRTBL	=$D827 ;SPEICHERPLATZ IN DER
270 : 275 ; 280 ; 285 *= $C000 290 ;	;COLORTABELLE
295 :	SEI	;INTERRUPT VERHINDERN
300 :	LDA #<START ;STARTADRESSE DER NEU-
305 s	LDX #>START ;EN ROUTINE LADEN
310 :	STA IRQVCT	;IRQ-VEKTOR AUF NEUE
315 s	STX IRQVCT+1 ;ROUTINE STELLEN
320 :	CLI	;INTERRUPT ERLAUBEN
325 :	LDA #DELAY	;VERZOEGERUNGS-
330 s	STA COUNT	;ZAEHLER SETZEN
335 : 340 ;	RTS	;ZURUECK INS BASIC
345 START	DEC COUNT	;VERZ. ZAEHLER-1
350 :	BEQ CHANGE	;GENUEGEND UEBERSPR.
355 :	JMP NORMIRQ ;NEIN, NORMALER IRQ
360 CHANGE	LDA #DELAY	;JA,NEUE ROUTINE
365 ;	STA COUNT	;ZAEHLER HOCHSETZEN
370 :	LDA #$00
375 :	STA FLAG	;FLAGGE LOESCHEN
380 :	LDA QUOTE	;EDITOR IM QUOTEMODE
385 :	BEQ NOTQUOTE ;NEIN, UEBERSPRINGEN
390 :	LDA #$FF
395 :	STA FLAG	;FLAGGE SETZEN
400 :	LDA #QSCODE ;LADE “Q”
405 :	STA SCREEN	;BRINGE AUF BILDSCHIRM
410 :	LDA #COLOR	;SETZE FARBE INS
415 :	STA CLRTBL	;FARBRAM
420 :	JMP REVERS	;NAECHSTE ABFRAGE
425 NOTQUOTE	LDA #" ”	;LEERZEICHEN AN STELLE
430 :	STA SCREEN	;DES "Q” SCHREIBEN
435 REVERS	LDA INVERS	;EDITOR IN REVERSMODE
440 :	BEQ NOREVERS ;NEIN, UEBERSPRINGE
445 s	LDA #RSCODE ;LADE "R", PRINTE EINE
450 :	STA SCREEN—1 ;STELLE LINKS VON "Q“
455 :	LDA #COLOR	;FARBE
460 :	STA CLRTBL—1 ;SETZEN
465 ;	JMP INSERT	;NAECHSTE ABFRAGE
470 NOREVERS	LDA #" "	;LEERZEICHEN AN STELLE
475 :	STA SCREEN-1 ;DES "R" SCHREIBEN
480 INSERT	LDA NINSERT ;WURDE 'INSERT'
485 ;	;GEDRUECKT
490 :	BEQ NOINSERT ;NEIN, UEBERSPRINGE
495 :	LDA #$FF
500 :	STA FLAG	;FLAGGE SETZEN
505 :	LDA #ISCODE ;"I" LINKS VON "R“
510 :	STA SCREEN-2 ;HINSCHREIBEN
515 s	LDA #COLOR	;FARBE
520 :	STA CLRTBL-2 ;SETZEN
525 :	JMP KEYTEST ;ZUR ABFRAGE VON 'F7'
530 NOINSERT	LDA #" "	;BLANK AN STELLE
535 :	STA SCREEN-2 ;DES "I" SCHREIBEN
540 KEYTEST	LDA LASTKEY ;LETZTE GEDRUECKTE
545 :	CMP #F7	;TASTE GLEICH 'F7'
550 :	BNE END	;NEIN, ZUM ENDE
555 :	LDX #$00	;JA
560 :	STX QUOTE	;QUOTE-MODE LOESCHEN
565 :	STX INVERS	;REVERS-FLAGGE AUS
570 :	STX NINSERT ;INSERT-MODUS AUS
575 :	LDA FLAG	;WENN FLAGGE GLEICH
580 s	BEQ END	;NULL, DANN ZEICHEN
585 :	;NICHT LOESCHEN
590 :	INX	;JETZT 1 IM X-REG
595 s	STX NOKEYS	;TASTATURBUFFER ENT-
600 s	;HAELT EIN ZEICHEN
605 s	LDY BSPALTE ;CURSOR EINE STELLE
610 =	DEY	;ZURUECKBEWEGEN
615 :	LDA CHCURSOR ;CHAR. UNTER CURSOR
620 ;	STA <ZEILE),Y ;AUF BILDSCHIRM
625 :	LDA #$9D	;ASCII-CODE FUER
630 :	;CURSOR ZURUECK
635 :	STA KBBUFFER ;IN TASTATURPUFFER
640 END	JMP NORMIRQ ;ENDE, GEHE ZUR NOR-
645 : READY.	;MALEN IRQ-ROUTINE
Listing 1. Das Assemblerlisting zum Programm »Escape-Taste« (Schluß)	
werden, aber ein Druck auf »F7« genügt, und das Problem ist behoben.
Das Programm wird dann mit SYS49152 aufgerufen, und ab sofort ist die Routine »Escape-Taste« in den Systeminterrupt eingebunden. Das allerdings nur solange bis RUN/STOP-RESTORE gedrückt wird, dann wird der lnterruptvektorwieder direkt auf die normale Interruptroutine gelenkt und die neue Routine wird so lange übergangen, bis das Programm neu gestartet wird.
Da diese Routine für den Einsatz beim Programmieren gedacht ist, sollten dabei keine Probleme entstehen.
Als einzige Einschränkung muß gesagt werden, daß die Benutzer von Kassettengeräten bei einem Zugriff auf die Data-sette die Routine mit RUN/STOP-RESTORE ausschalten sollten, da Kassettenoperationen den Interruptvektor auf spezielle Kassettenroutinen umschreiben und sich ein schon verstellter IRQ-Vektor negativ auswirkt. (Christian Spörri/aw)
Daten komprimieren — Sparen Sie Speicherplatz und Ladezeit!
Schreiben Sie öfter Programme, bei denen Sie größere Datenmengen verwalten müssen? Mit dem »Daten-Packer« wird der Aufwand an Ladezeit und Speicherplatz auf Diskette um 25 Prozent reduziert.
Dieses Programm kürzt Strings auf % der normalen Länge. Wenn man zum Beispiel einen String mit 12 Zeichen Inhalt hat, und den »Daten-Packer« darauf losläßt, ist der String nur noch neun Zeichen lang, bei gleichem Inhalt!
Um ihn sich änsehen zu können, muß er natürlich erstwieder in eine lesbare Form gebracht, also »entpackt« werden.
Bei selbstgeschriebenen Adressenverwaltungen läßt sich das gut anwenden:
Bevor man die Adressen, die ja meist in Strings enthalten sind, auf der Diskette abspeichert, »packt« man sie mit dem Daten-Packer, und speichert sie dann. So spart man eine Menge wertvollen Diskettenplatz und Ladezeit.
Nach dem Einladen müssen die Adressen wieder »entpackt« werden, bevor man mit ihnen weiterarbeiten kann.
Das Programm (siehe Listing) wird mit dem MSE eingegeben und ist dann sofort einsatzbereit.
Umgang mit dem Daten-Packer
Packen: SYS 49152, A$, B$
In A$ muß der zu packende String stehen. Danach enthält B$ die gepackte Version.
Entpacken: SYS 49339, C$, D$
In C$ muß der gepackte String stehen. In D$ ist dann der entpackte String zur Weiterverarbeitung bereit.
100
Tips & Tricks
Natürlich kann an Stelle von A$, B$, und D$ jede andere Stringvariable stehen.
Das geht doch nicht mit rechten Dingen zu, wird der eine oder andere Leser jetzt vielleicht denken.
Nun, dieses Programm kürzt 4 Byte auf 3 Byte. Ein Byte hat bekannterweise 8 Bit, gebraucht werden aber nur 6 Bit, um die ASCII-Werte darzustellen, aus denen Datenstrings ja bestehen.
Mit diesen 6 Bit kann man alle alphanumerischen Zeichen und einige Sonderzeichen darstellen. Der Alogrithmus des Programms besteht nun darin, vom ASCII-Wert des zu packenden Byte 32 abzuziehen, um eine Darstellung mit 6 Bit zu ermöglichen. Dann wird jedes vierte Byte auf die vorhergehenden 3 Byte verteilt, bei denen die letzten 2 Bit nach unserer Subtraktion nun nicht mehr gebraucht werden. »Überhang-Bytes«, also die letzten Zeichen eines Strings, die keine vollen 4 Byte mehr ergeben, werden nicht gepackt, sondern nur an den gepackten String angehängt.
Beim Entpacken läuftderVorgang in umgekehrter Reihenfolge ab.	(Joachim Matzner/gk)
PROGRAMM : PACKROUTOBJ
C000 ClEB
C000 : 20 9C C0 20 6D Cl A0 00 0A C008 : A2 00 Bl 22 38 E9 20 0A C2 C010 s 0A 9D EE Cl E8 C8 E0 03 3B C018 : D0 F0 Bl 22 38 E9 20 8D 7F C020 s Fl Cl AC F3 C1 18 6E Fl 16 C028 3 Cl 6E EE Cl 6E Fl Cl 6E 6E C030 ; EE Cl 6E Fl Cl 6E EF C1 AB C038 : 6E Fl Cl 6E EF Cl 6E Fl 88 C040 : Cl 6E F0 Cl 6E Fl Cl 6E 07 C048 : F0 Cl AD EE 01 99 F5 Cl A6 C050 ! C8 AD EF C1 99 F5 Cl C8 05 C058 : AD F0 C1 99 F5 Cl C8 8C CA C060 : F3 Cl AD F4 C1 18 69 04 C8 C068 : 8D F4 01 CD F2 Cl F0 28 EB C070 : 18 69 04 CD F2 Cl F0 02 FD C078 s B0 06 AC F4 Cl 4C 08 C0 15 C080 : AE F3 Cl AC F4 Cl Bl 22 96 C088 : 38 E9 20 9D F5 Cl C8 E8 D3 C090 : CC F2 Cl D0 Fl 8E F3 C1 47 C098 3 20 BB C1 60 20 FD AE 20 FF C0A0 : 8B B0 85 64 84 65 20 A3 AC C0A8 : B6 A0 00 Bl 47 8D F2 C1 15 C0B0 : C8 Bl 47 85 22 C8 Bl 47 91 C0B8 : 85 23 60 20 9C C0 20 6D 16 C0C0 : Cl A8 A2 00 Bl 22 9D EE FE C0C8 s Cl C8 E8 E0 03 D0 F5 20 12 C0D0 s 76 Cl AC F3 Cl A2 00 BD 7D C0D8 s EE C1 99 F5 Cl E8 C8 E0 14 C0E0 : 04 D0 F4 8C F3 Cl AD F4 09 C0E8 ! C1 18 69 03 8D F4 C1 CD 93 C0F0 s F2 Cl F0 52 69 03 CD F2 15 C0F8 s Cl F0 23 B0 06 AC F4 Cl 2D C100 : 4C C2 C0 AC F4 Cl AE F3 73 C108 3 Cl Bl 22 18 69 20 9D F5 27 C110 : Cl C8 E8 CC F2 Cl D0 Fl 6D C118 : 8E F3 Cl 4C 69 Cl A2 00 C9 C120 : AC F4 Cl Bl 22 9D EE Cl 3B C128 s C8 E8 E0 03 D0 F5 2C EE 48 C130 s C1 30 19 70 17 2C EF C1 74 C138 : 30 12 70 10 2C F0 C1 30 41 C140 : 0B 70 09 4C 03 Cl AD F3 2C C148 s Cl 4C 69 C1 20 76 Cl AC D8 C150 s F3 Cl A2 00 BD EE C1 99 5A C158 s F5 Cl E8 C8 E0 04 D0 F4 DC C160 s AD F3 C1 18 69 04 8D F3 4F C168 s C1 20 BB C1 60 A9 00 8D CF C170 s F4 Cl 8D F3 C1 60 A9 00 EC C178 s 8D Fl Cl AA 18 2E F0 Cl FE C180 s 2E Fl Cl 2E F0 Cl 2E Fl 97 C188 8 Cl 2E EF Cl 2E Fl Cl 2E 6A C190 s EF Cl 2E Fl Cl 2E EE Cl F6 C198 s 2E Fl Cl 2E EE Cl 2E Fl 8F C1A0 s Cl BD EE Cl 4A 4A 18 69 5E ClA8 s 20 9D EE Cl E8 E0 03 D0 CE C1B0 s F0 AD Fl C1 18 69 20 BD 94 ClB8 s Fl C1 60 20 FD AE 20 8B 93 C1C0 8 B0 85 49 84 4A 85 64 84 81 ClC8 s 65 20 A3 B6 AD F3 C1 20 BF C1D0 s 75 B4 A0 00 B9 61 00 91 91 ClD8 s 49 C8 C0 03 D0 F6 A0 00 5D C1E0 s B9 F5 C1 91 62 C8 C4 61 79 ClE8 s D0 F6 60 A5 B6 D0 25 33 ED
Das Listing zum »Datenpacker«. Eingabe mit dem MSE. Beachten Sie bitte die Eingabehinweise auf Seite 8
Der C 64 lernt sprechen
Dieses Programm ist wohl die billigste Sprachein^ausgabe, die es gibt. Man kann sie vielseitig einsetzen, zum Beispiel bei Spielen, sprechenden Menüs oder einfach als Spielerei.
Außer dem C 64 ist für dieses Programm eine Datasette erforderlich. Nachdem das Listing abgetippt und das Programm mitSYS49231 gestartetwurde, ändernsichdieBildschirmfar-ben, und eine Einschaltmeldung erscheint. Jetztstehen Ihnen 2045 Byte für Basic-Programme zur Verfügung. Der Grund dafür ist, daß die Aufzeichnung von Sprache äußerst speicherintensiv ist. Selbst der Bereich unter dem Basic-ROM ($ A000 bis $BFFF) wird ausgenutzt. Die Tonwiedergabe hat zwar keine Hi-Fi-Qualität, wenn man aber laut und deutlich spricht, kann man sich gut wiedererkennen. Während der Tonein-/ausgabe wird der Bildschirm abgeschaltet, damit der Prozessor nicht ständig vom Video-Controller unterbrochen wird.
Das Arbeiten mit diesem Programm ist denkbar einfach. Es stehen fünf neue Basic-Befehle zur Verfügung. Der Speicher des C 64 wird in verschiedene Abschnitte aufgeteilt (Bild 1), in denen Wörter gespeichert werden. Hinter allen Befehlen (außer ^R und —G) ist anzugeben, in welchen Bereich gespeichert werden soll.
x= 1 bis16:DieseAbschnittesindfürein-biszweisilbigeWör-ter reserviert. Hier können zum Beispiel Zahlen oder kurze Wörter abgelegt werden.
x = 17: Dies ist ein Abschnitt für 4 Sekunden Sprechzeit.
Hier kann ein kleiner Satz abgelegt werden.
x = 255: Hier wird der gesamte Speicher beschrieben, also auch die Abschnitte 1 bis 17. Es stehen etwa 13 Sekunden Sprechzeit zur Verfügung.
Alle anderen Zahlen werden als 17 interpretiert.
Befehle
Doch nun zu den Befehlen:
—Lx: »learn« — Nach Eingabe dieses Befehls wird der Bildschirm abgeschaltet. Die Tonsignale werden digitalisiert und im Speicher abgelegt, x entscheidet, in welchen Bereich die Sprache gespeichert wird.
^Sx: »say«—Bei diesem Befehl wird ebenfalls der Bildschirm gelöscht. Aus dem Lautsprecher des Fernsehgerätes ertönt nun Ihre eigene Stimme. Im Gegensatz zu dem Befehl »learn« benötigt dieser Befehl keinerlei Hardware. Er kann also ohne irgendwelchen Umbau benutzt werden, x entscheidet, aus welchem Bereich die Sprache entnommen wird.
—P”Filename”x: »put« — Mit diesem Befehl kann die Sprache, die sich im Speicher befindet, auf Diskette gespeichert werden. Da das Speichern von Sprache sehr aufwendig ist, belegen 13Sekunden Sprechzeit178 Blöcke, xgibtan, in welchem Bereich die Sprache gespeichert wird.
—G”Filename”: »get« — Dieser Befehl wird zum Laden der Sprache benutzt.
—R: »rate«—Mitdiesem Befehl läßtsich die Sprechgeschwindigkeit einstellen. Nach dem Befehl muß ein numerischer Aus-
101
Tips & Tricks
programm : sprache	c000 c25S
c000 : 93 90 20 20 20 20 20 20 ab c008 : 2a 2a 2a 20 56 4f 49 43 62 c010 : 45 20 36 34 20 53 59 53 22 c018 s 54 45 4d 20 56 32 2e 30 76 c020 : 20 2a 2a 2a 0d 0d 31 39 96 c028 : 38 35 20 42 59 20 4d 2e 73 c030 : 4b 4c 49 4e 47 45 52 20 e6 c038 ; 20 32 30 34 35 20 42 41 e4 c040 ; 53 49 43 20 42 59 54 45 d8 c048 s 53 20 46 52 45 45 00 a9 59 c050 : 00 a0 c0 20 le ab a9 0f d8 c058 : 8d 21 d0 a9 0b 8d 20 d0 le c060 : 4c 42 c2 00 00 00 20 73 e5 c068 : 00 08 c9 5f f0 04 28 4c 33 c070 : e7 a7 28 20 73 00 08 c9 24 c078 ; 4c f0 24 c9 53 f0 2b ea be c080 : 4c 3a cl ea 20 9b b7 08 85 c088 : e0 11 90 04 ea 4c ad cl el c090 : ea a9 06 69 09 ca d0 fb 20 c098 : 85 fb 69 09 85 fc 60 28 a8 c0a0 : 20 9b b7 08 20 88 c0 4c 5f c0a8 : 5d cl 28 20 9b b7 08 20 cc c0b0 : 88 c0 4c dd cl 28 20 13 6b
Listing zum Programm
c0b8 : cl ea ea c0c0 : a2 08 a0 c0c8 : 3c a0 03 c0d0 : a9 00 a2 c0d8 : ff ea 4c c0e0 ; 28 20 9b c0e8 a a9 36 85 c0f0 : H a2 3c c0f8 : bd ff a2 cl00 s 84 fe a9 cl08 a 20 d8 ff cll0 : 4c e7 a7 cll8 a *0 03 4c cl20 ; 20 73 00 cl28 s 3c 03 c8 cl30 : 20 cl ea cl38 : 00 00 c9 cl40 : f0 9b c9 cl48 s 08 af 4c cl50 : b7 08 e0 cl58 s b2 4c c3 cl60 : 29 ef 8d cl68 ; 0d dc 78 cl70 : fb 85 fb cl78 : 0d dc 4a cl80 : 06 ff a5
ea ea ea ea ea 8e 01 20 ba ff a2 cc a5 ff 20 bd ff c2 00 a0 00 20 d5 58 e4 a7 20 13 cl 47 b7 08 20 88 c0 lb 01 a2 08 20 ba 8e a0 03 a5 ff 20 01 00 a4 fb 86 fd 9e fd a2 01 a4 fc ec a9 37 85 01 28 bd 20 73 00 c9 22 e0 08 af ea a0 00 73 c9 22 f0 0b 99 3c c0 10 f0 03 4c 5d 84 ff 60 00 00 7f 47 f0 0c c9 50 cb 52 f0 07 28 4c 3b b5 c0 28 20 9b f7 14 90 03 4c 48 a9 cl ea ad 11 d0 5b 11 d0 a9 7f 8d 7a a9 00 85 fa a5 9a a0 00 a2 08 ad dl 4a 4a 4a 85 fe da ff 05 fe 85 ff 4d
cl88 : cl90 : cl98 s cla0 : cla8 : clb0 : clb8 s clc0 a clc8 : cld0 : cld8 : cle0 : cle8 : clf0 a clf8 s c200 : c208 : c210 : c218 s c220 : c228 : c230 a c238 : c240 ; c248 : c250 :
ca d0 d0 e3 d0 d9 11 d0 28 4c 09 a9 fc 60 85 fc c2 28 00 00 00 00 01 a9 11 d0 a9 00 a0 00 90 0a 00 8d ea ea ea ea ea ea dl e6 c7 ad d0 58 a3 cl c0 8d 85 38
ec 91 e6 fb ad 11 58 a9 e7 a7 9f 85 a9 10 60 8a 4c e7 00 00 00 00 7f 8d 29 ef 85 bb a2 08 a9 0f 18 d4 ea ea ea ea 68 ca bc a5 11 d0 a9 37 a9 66 09 03 20 44
fa 86 a5 fb d0 09 81 8d ea e0 fb a9 85 fb 69 0f a7 00 00 00 00 a9 0d dc 8d 11 a5 fb bl bb 8d 18 4c lc ea ea ea ea d0 d8 bc c5 09 10 85 01 8d 08 a9 10 a6 4c
ff 88 c5 fc 10 8d 0d dc ff f0 c0 85 a9 c0 8d 0d 00 00 00 00 36 85 78 ad d0 ea 85 bc 0a 48 d4 a9 c2 ea ea ea ea ea 88 d0 fc d0 8d 11 ea 4c 03 a9 85 34 74 a4
lc d6 93 d7 7d 41 bl 8c 29 dl 0a 3c 24 3c f4 22 f6 0f 17 8a e0 96 2a 73 0b 6a
»Der C 64 lernt sprechen«. Bei der Eingabe Seite 8 beachten.
Bild 1. Bereichs- und Speicheraufteilung nach dem Stert
Bild 2. So schließt man ein Mikrofon an die Datasette an
druck folgen, der die Geschwindigkeit angibt. Erlaubt sind Zahlen von 0 bis 19. Dabei entspricht 19 der schnellsten Sprechgeschwindigkeit und 0 der langsamsten. Alle anderen Zahlen werden mit einer Fehlermeldung quittiert. Die Grundeinstellung ist 13. Das ist etwa die normale Sprechgeschwindigkeit.
Jetzt werden Sie sich fragen, wie man in den Computer hineinspricht. Dazu ist natürlich ein Mikrofon erforderlich und somit auch ein wenig Umbau. Aber keine Angst, der Umbau hält sich in Grenzen. Es ist jedoch erforderlich, die Datasette zu öffnen. Lösen Sie dazu die vier Schrauben auf der Rückseite. Nachdem der Deckel abgenommen wurde, läßt sich auf einer Seite eine Platine erkennen, die mit einer Aluminiumfolie abgeschirmt ist. Auf der Seite, wo sich die Drucktasten befinden, ragt eine Anschlußleiste unter der Folie hervor (Bild 2). Löten Sie nun an die in Bild 2 gekennzeichneten Punkte eine Mikrofonbuchse an. Das war schon der ganze Umbau. Wollen Sie die Datasette wieder als Massenspeicher benutzen, darf das Mikrofon nicht mit der Buchse verbunden sein, da Geräusche im Raum den Datentransfer zwischen Datasette und Computer stören.
(Martin Klinger/ah)
102

Basic-Erweiterungen
ON ERROR GOTO
Routinen, die bei einem auftretenden Programmfehler zu einer bestimmten Zeile verzweigen, sind inzwischen Standardausrüstung jeder guten Ba-sic-Erweiterung. Das vorliegende Maschinenprogramm ist nur 88 Byte lang.
Um einen Fehler während des Programmlaufs abzufangen, kennen viele Computer den Befehl ON ERROR GOTO. Mit diesem kurzen Maschinenprogramm kann auch Ihr C 64 auf Fehler im Programm reagieren.
Nachdem das Programm (Listing 1) im Speicher steht, kann es mit SYS 50000, ZL aktiviert werden. Dabei bedeutet ZL die Zeilennummer, zu der bei einem Fehler verzweigt werden soll. Die Fehlernummer wird dann in Speicherstelle 2 gespeichert und kann mit PEEK(2) abgefragt werden. Tabelle 1 zeigt, welche Nummer welcher Fehlermeldung entspricht. Die Zeile, in der der Fehler auftrat, wird in Speicherstelle 249 und 250 gespeichert. Damit Sie zu der fehlerhaften Zeile zurückspringen können, wurde noch die Routine »GOTO X« eingebaut. Damit läßt sich zu einer berechneten Zeile springen. Aufgerufen wird diese Routine mit SYS 50076, ZL. Schauen wir uns einmal das Beispiel ab Zeile 200 im Basic-Lader an. In Zeile 210 wird mit SYS 50000, 1000 die Fehlerbehandlungsroutine auf Zeile 1000 gelegt. In Zeile 220 wird der Benutzer aufgefordert, eine Zahl einzugeben. Solange diese Zahl positiv ist, wird in Zeile 230 die Wurzel aus dieser Zahl errechnet und ausgegeben. Bei einer negativen Zahl wird zur Zeile 1000 verzweigt. Hier wird die Fehlernummer ausgegeben. In diesem Falle 14. In Zeile 1010 wird nun die Zeile errechnet, in der der Fehler auftrat und ausgegeben. Zeile 1020 schließlich ruft die »GOTO X«-Routine auf und springt in die Zeile ZL —10.
Listing 2 zeigt den dokumentierten Assemblerteil der Routine. (Kunz/tr)
100	REM *** ON ERROR UND GOTO X ***	<029>
101	DATA 32,253,174,32,107,169,165,20	<202>
102	DATA 164,21,133,247,132,248,169,116	<191>
103	DATA 160,195,141,0,3,140,1,3,96,169	<188>
104	DATA 139,160,227,141,0,3,140,1,3	<006>
105	DATA 96,138,48,30,165,58,201,255	<148>
106	DATA 240,27,134,2,165,57,164,58,133	<145>
107	DATA 249,132,250,165,247,164,248	<193>
108	DATA 133,20,132,21,32,163,168,76	<254>
109	DATA 174,167,76,116,164,138,76,58	<188>
110	DATA 164,32,253,174,32,138,173,32	<156>
111	DATA 247,183,76,143,195	<154>
112	S=0:FOR 1= 50000 TO 50087 sREAD D	<150>
113	POKE I,D:S=S+D:NEXT	<177>
114	PRINT"DIE DATAZEILEN SIND”	<206>
115	IF S<>10886 THEN PRINT"FEHLERHAFT":STO P	<163>
116	PRINT”IN ORDNUNG"sEND	<113>
120	3	<096>
130		<106>
200	REM BEISPIEL FUER ON ERROR UND GOTO X	<028>
210	SYS 50000,1000	<244>
220	INPUT"EINE ZAHL "jA	<237>
230	WU=SQR(A)sPRINT"DIE WURZEL AUS"A"="WU	<130>
240	END	<242>
1000 PRINT"FEHLER NUMMER*'PEEK(2)		<214>
1010 ZL=PEEK(249)+PEEK(250)*256-10		<239>
1020 SYS 50076,ZL		<039>
Listing 1. Der Basic-Lader zu »On-Error«. Bitte verwenden Sie zur Eingabe den neuen Checksummer (Seite 6.)		
Fehlernummer Fehlermeldung
1	TOO MANY FILES
2	FILE OPEN
3	FILE NOT OPEN
4	FILE NOT FOUND
5	DEVICE NOT PRESENT
6	NOT INPUT FILE
7	NOT OUTPUT FILE
8	MISSING FILENAME
9	ILLEGAL DEVICE NUMBER
10	NEXT WITHOUT FOR
11	SYNTAX
12	RETURN WITHOUT GOSUB
13	OUTOFDATA
14	ILLEGALQUANTITY
15	OVERFLOW
16	OUTOFMEMORY
17	UNDEF’DSTATEMENT
18	BADSUBSCRIPT
19	REDIM’DARRAY
20	DIVISION BY ZERO
22	TYPE MISMATCH
23	STRING TOO LONG
24	FILE DATA
25	FORMULA TOO COMPLEX
27	UNDEF’D FUNCTION
28	VERIFY
29	LOAD
Tabelle 1. Die Fehlermeldungen des Betriebssystems, je-weils mit dem Zusatz »ERROR«.
.ba=50000 jsr $aefd jsr $a96b Ida $14 ldy $15 sta $f7 sty $f8 Ida #$74 ldy #$c3 sta $0300 sty $0301 rts	; prüft auf Komma ; holt Zeilennummer nach $14/$15 ; Zeilennummer in ; $f7/$f8 speichern ; Vektor für Fehlermeldung ; auf neue Routine
Ida #$8b ldy #$e3 sta $0300 sty $0301 rts	Vektor für Fehlermeldung zurückstellen
txa bmi noerr Ida $3a cmp #$ff beq dirmod stx $02 Ida $39 ldy $3a sta $f9 sty $fa Ida $f7 ldy $f8 sta $14 sty $15 go jsr $a8a3 jmp $a7ae noerrjmp $a474 dirmod txa jmp $a43a routine goto x jsr $aefd jsr $ad8a jsr $b7f7 jmp go	größer 127 dann kein Fehler Direktmodus? ja Fehlernummer speichern Momentane Zeilennummer nach $f9/$fa Zeilennummer für on error nach $14/$15 goto-Befehl Zur Interpreterschleife ready ausgeben Fehlermeldung ausgeben prüft auf Komma numerischen Wert holen nach $15/$14 wandeln
Listing 2. Der dokumentierte Assemblerteil.
103
Tips & Tricks___________________________
Übersichtliches Listing
Diese kleine Erweiterung spaltet beim Listen eine Programmzeile in mehrere Zeilen auf. Dadurch wird die Analyse auch komplizierter Programmteile zum Kinderspiel.
Die Idee zu dieser Erweiterung kam durch den Einzeiler-Wettbewerb im 64’er-Magazin, bei dem die abgedruckten Programme durch ihre gedrängte Darstellung schlecht lesbar waren. Damit ist nun Schluß. Wenn in einer Programmzeile ein Doppelpunkt vorkommt, so wird der darauf folgende Befehl in die nächste Zeile geschrieben.
Beispiel:
Aus
10 A=53280:POKE A,I:POKE A+1,I+1:I=PEEK(53248+ 18):GOTO 10 wird
10A= 53280
POKE A,l
POKEA+1,I+1
l=PEEK(53248+18)
GOTO 10
Die Erweiterung liegt in dem Bereich von 49152 bis 49239, nimmt also keinen Basic-Speicherplatz in Anspruch. Sie läßt sich aber beliebig verschieben, damit sie auch bei Basic-Erweiterungen funktioniert, die den Bereich ab 49152 benutzen (man muß nur den Wert der Variablen ADRESSE in Zeile 0 ändern). Die 87 Byte lange Erweiterung läßtsich mit POKE 2,0 einschalten und mit POKE 2,1 wieder ausschalten.
So arbeitet die Routine
Das Maschinenprogramm liegt als Basic-Lader (Listing 1) und als Source-Code (Listing 2) vor. Zuerst wird der LIST-Vektor auf die neue Routine gePOKEt, dann erfolgt ein Rücksprung zum Basic. In der neuen LIST-Routine wird abgefragt, ob es sich bei dem zu listenden Zeichen um einen Befehl handelt. Ist dies der Fall, so wird zu der Routine gesprungen, die den Befehl ausgibt.
Anschließend erfolgt eine Überprüfung auf einen Doppelpunkt. Handelt es sich nicht um dieses Zeichen, so wird normal weitergelistet. Andernfalls findet eine Überprüfung der Speicherstelle 2 statt. Ist sie nicht 0, so wird der Doppelpunkt ausgegeben und mit dem normalen Listing weitergemacht. Steht in der Speicherstelle 2 eine 0, so wird ein CHR$(13) ausgegeben.
Im darauffolgenden Teil werden die untereinanderstehenden Teilprogrammzeilen linksbündig gemacht und ausgegeben. Danach wird wieder zum »normalen« Listing gesprungen.
Die Routine »Übersichtliches Listing« ist in erster Linie natürlich für das Arbeiten mit einem Drucker gedacht, denn eine Bildschirmausgabe mit einem Basic-Befehl pro Zeile würde den Vorteil der erhöhten Übersicht wohl bald zunichte machen, jedenfalls bei längeren Programmen. Der Einsatzschwerpunkt dieser Routine liegt damit bei der Analyse fremder, unübersichtlicher Programme mittels eines Druckers.
(Frank Barcikowski/ev)
0 ADRESSE = 49152:REM BELIEBIG	<0S7>
1 REM	*******************	<113>
2 REM * WRITTEN BY *	<207>
3 REM	*FRANK BARCIKOWSKI*	<009>
4 REM	* MORAENENWEG 33 *	<250>
5 REM	*3320 SALZGITTER-1*	<077>
6 REM	*******************	<118>
10 FOR I=ADRESSE TO ADRESSE+87	<213>
20 READ A:S=S+A:POKE I,A	<215>
30 NEXT	<040>
31 IF S<>10407 THEN PRINT"DATA ERROR!"sEND	<062>
35 REM DEM JEWEILIGEN BERREICH ANPASSEN	<103>
36 HI=INT((ADRESSE+ll)/256)	<157>
37 L0=ADRESSE+ll-INT((ADRESSE+ll)/256)*256	<179>
38 POKE ADRESSE+6,HI	<107>
39 POKE ADRESSE+l,LO	<069>
40 SYS ADRESSEsPOKE 2,0:END	<006>
50 REM-------------------------------------- <100>
60 REM EINSCHALTEN DER ERWEITERUNG :	<008>
70 REM POKE 2,0	<089>
80 REM-------------------------------------- <130>
90 REM AUSSCHALTEN DER ERWEITERUNG :	<104>
99 REM POKE 2,<>0	<007>
100 REM--------------------------- <150>
101 DATA 169,11,141,6,3,169,48,141,7,3,96,
16,3,76,28,167,201,58,240,3,76,243	<093>
102 DATA 166,166,2,240,3,76,243,166,169,13 ,32,210,255,152,72,160,2,177,95	<003>
103 DATA 170,200,177,95,133,98,134,99,162,
144,56,32,73,188,32,223,189,162	<209>
104 DATA 0,189,0,1,240,3,232,208,248,169,3
2,32,210,255,202,208,250,104,168	<038>
105 DATA 169,32,76,243,166,48,141,7,7,96	<180>
© 64'er
Listing 1. »Übersichtliches Listing« als Basic-Lader.
Beachten Sie die Eingabehinweise auf Seite 6.
2 20:	3000					. opt	P1
25:	3000				list	=	$0306
26:	3000				altlist		$a71c
30:	3000						$3000
40:	3000	a9	0b			lda	#<nlist
50:	3002	8d	06	03		sta	list	;listvektor verbiegen
60:	3005	a9	30			lda	#>nlist
70:	3007	8d	07	03		sta	list +1
80:	300a	60				rts	:wieder zu basic
					.			 neue listroutine 		
90:	300b	10	03		nl ist	bpl	nint	;pruefung auf inter—
100:	300d	4c	lc	a7		jmp	altlist ;pretercode (>$80)
110:	3010	c9	3a		nint	cmp	#$3a	;code fuer
110:	3012						
120:	3012	f0	03			beq	doppelp ;code gefunden
130:	3014	4c	f3	a6		jmp	$a6f3 ;weiterlisten
					.		- doppelpunkt gefunden —			
137:	3017	a6	02		doppelp	ldx	2	;2 laden
138:	3019	f0	03			beq	ok	;wenn 0 dann newlist
139:	301b	4c	f3	a6		jmp	$a6f3 ;sonst altlist
140:	301e	a9	0d		ok	lda	#13	;return
150:	3020	20	d2	ff		jsr	$ffd2 ;printen
160: 170:	3023 3024	98 48				tya pha	;y zwischenspeichern ;fuer spaeter
						berechnung der zu 		
					.		printenden spaces 		
210:	3025	a0	02			ldy	#2
220:	3027	bl	5f			lda	($5f),y ;zeilennr. lo
230:	3029	aa				tax	;mer ken
240:	302a	c8				iny	;zeiger erhoehen
250:	302b	bl	5f			lda	($5f),y ;zeilennr. hi
260:	302d	85	62			sta	$62
270:	302f	86	63			stx	$63
280:	3031	a2	90			ldx	#$90
290:	3033	38				sec	
300:	3034	20	49	bc		jsr	$bc49 ;zeilennr. in fac
310:	3037	20	df	bd		jsr	$bddf ;fac nach ascii und $0100
							;nach $0100
330:	303a	a2	00			ldx	#0
340:	303c	bd	00	01	loop	lda	$100,x
350:	303f	f0	03			beq	endloop ;0 = stringende
360:	3041	e8				inx	;zaehler fur space
370:	3042	d0	f8			bne	loop
					:		space	x tnal printen	
380:	3044	a9	20		endloop	lda	#32	;space laden
400:	3046	20	d2	ff	prin	jsr	$ffd2 ;printen
410:	3049					dex	
420:	304a	d0	fa			bne	prin	;schon fertig
430:	304c	68				pla	;y wiederholen
435:	304d	a8				tay	
440:	304e	a9	20			1 da	#32	;space in accu
450:	3050	4c	f3	a6		jmp	$a6f3 ;accu printen
					;und weiterlisten		
Listing 2.		Assembler-Listing zu »Übersichtliches					
Listing«.		Es dient nur zur Dokumentation, braucht					
also nicht eingegeben zu werden.							
104
Tips & Tricks
Programmieren Sie Ihre Tastatur!
Mit diesem Programm werden nicht nur die Funktionstasten, sondern die gesamte Tastatur frei programmierbar.
Wenn Sie das Programm KEY-PROGGER (Listing 1) eingegeben haben, können Sie es mit LOAD"KEY-PROGGER",1,1 oder, wenn Sie ein Diskettenlaufwerk besitzen, mit LOAD"KEY-PROGGER",8,1 laden. Nach dem Laden geben Sie am besten den Basic-Befehl NEW ein, da Sie sonst später eine OUT OF MEMORY-Meldung erhalten. Nun sind Sie soweit, daß Sie das Programm mit SYS 49152 starten können. Nach dem Starten istjedoch keine Veränderung zu bemerken. Durch den SYS-Befehl wird nur die Tastaturabfrage über eine neue Routine geleitet, welche die Tastenfunktionen aus einer Tabelle liest, die im RAM steht, und daher verändert werden kann. Wie aber ändert man nun die Tastenbelegung? Dazu ist der leistungsfähige #-Befehl implementiert. Damit KEY-PROGGER mit möglichst vielen Erweiterungen zusammenarbeitet, ist es möglich, diesen Befehl ein- und auszuschalten. Um also die Tastenbelegung zu ändern, muß dieser Befehl zuerst eingeschaltet werden. Dies geschieht mit SYS 49152+3. Ausgeschaltet wird er mit SYS 49152+6. Die Anwendung des # -Befehls ist sehr einfach. Sie geschieht in der Form: #nr,string
nr entspricht in den allermeisten Fällen dem ASCII-Wert eines Zeichens. Alle möglichen Tastaturzuordnungen sind in Bild 1 aufgeführt. Wo dies nicht so ist, kann die Nummer mit einem kleinen Programm festgestellt werden:
10 FORI=0TO255
20 #I,STR$(I)
30 NEXTI
Nachdem dieses kleine Programm mit RUN gestartet wird, erscheint beim Druck auf jede Taste eine Zahl auf dem Bildschirm. Diese Zahl ist die Nummer der Taste. Es sind jedoch nicht alle 256 Werte von der Tastatur aus erreichbar. Insgesamt erhält man jedoch 187 programmierbare Tastenfunktionen. Diese Zahl reduziert sich jedoch noch einmal, da es nicht sinnvoll ist, manche Tasten, wie zum Beispiel die RETURN-Taste umzudefinieren, da diese wichtige Funktionen erfüllen.
Mit dem # -Befehl können jeder Taste bis zu 10 Zeichen zugeordnet werden. Versuchen Sie es doch einmal, zum Beispiel mit:
#12,"LIST"+CHR$(13)
Wenn Sie nun gleichzeitig CTRL und L drücken, erscheint der Befehl LIST auf dem Bildschirm und wird gleich ausgeführt. Haben Sie nach einer Zeit des Herumprobierens den Wunsch,
Tastencodes:
-	1	2	3	4	5	6	7	8	9	0	+	-	£	HOME DEL	Fl
95	49	50	51	52	53	54	55	56	57	48	43	45	92	19	20	133
CTRL Q	W	E	R	T	Y	U	I	O	P	@	*	t	RESTORE	F3
81	87	69	82	84	89	85	73	79	80	64	42	94	134
sTOPSHiFT A	S	D	F	G	H	J	K	L ;	=	RETURN	F5
3 LOCK 65	83	68	70	71	72	74	75	76	58 59	61	13	135
C= SHIFT Z	X	C	V	B	N	M	,	.	/	SHIFT l	-	F7
90	88	67	86	66	78	77	44	46	47	17	29	136
SPACE
32
Zusammen mit SHIFT:
	!	"	#	$	%	&	/	(	)	0	+	-	£ CLR INST 33	34	35	36	37	38	39	40	41	219 221 169 147 148		F2 137
CTRL Q W E R T Y U I O P @	* vr RESTORE 209 215 197 210 212 217 213 201 207 208 186 192 222			F4~ 138
RUN 131	SHiFT A S	D F G H J K L	[	]	= LOCK 193 211 196 198 199 200 202 203 204 91 93	RETURN 141	F6 139
C =	SHIFT Z X C V B N M <	>	? SHIFT 218 216 195 214 194 206 205 60 62 63	I — 145 157	F8 140
SPACE
160
Zusammen mit C=:
	1	2	3	4	5	6	7	8	9	0 129 149 150 151 152 153 154 155	+ - £ 166 220 168		CLR DEL	F2
CTRL Q W E R T Y U I O P @ 171 179 177 178 163 183 184 162 185 175 164			* 7T RESTORE 223		F4
RUN	sHiFT A S D F G H	J	K	L LOCK 176 174 172 187 165 180 181 161 182	[	] =	RETURN	F6
c=	SHIFT Z X	C V B	N M < > 173 189 188 190 191 170 167	?	SHIFT	t *-	
SPACE
Zusammen mit CTRL:
~	1	2	3	4	5	6	7	8	9	0 + - 6* 144 5* 28* 159 156 30* 31* 158 18* 146	£ 28*	HOME DEL	Fl
CTRL Q W	E	R T Y	Ü	I	Ö	P	@ * 17* 23	5*	18* 20* 25	21	9	15	16	0	''' t RESTORE 30*		F3
STOPSHiFT A	S	D	F	G	H	J	K	L	; LOCK 1	19*	4	6*	7	8	10	11	12	27 29*	31*	RETURN	F5
C= SHIFT Z	X	C	V	B	N	M ,	/ SHIFT 26	29	3*	22	2	141	3*		I -	F7
SPACE
*Die Tastenfunktion kann auch auf andere Weise erzeugt werden, zum Beispiel CTRL-2 = CTRL-E oder CTRL-M = RETURN
Bild 1. Tastaturzuordnung auf einen Blick
programm :	: key-progger	c000	clb6	c088 :	03	8c	09	03	60	a9	b6	a0	e4	cl20 s	65	fc	85	fa	18	a5	f7	65	ld
				c090 :	cl	85	f7	84	f8	86	f9	a2	93	cl28 s	f9	85	f7	a5	f8	65	fa	85	48
c000 : 4c	72 cl 4c 82 c0	4c 67	ad	c098 :	00	86	fa	a5	f9	0a	85	fb	4d	cl30 :	f8	20	fd	ae	20	9e	ad	24	83
c008 : cl	4c 4b c0 4c 7f	cl 4c	3b	c0a0 :	a5	fa	2a	85	fc	06	f9	26	32	cl38 :	0d	30	05	a2	16	4c	3a	a4	e9
c010 : 97	cl 4c af cl a9	00 a0	3b	c0a8 :	fa	06	f9	26	fa	06	f9	26	fd	cl40 :	20	a6	b6	c9	0b	90	05	a2	29
c018 : a0	85 f7 84 f8 a2	20 a0	70	c0b0 :	fa	18	a5	f9	65	fb	85	f9	9f	cl48 :	17	4c	3a	a4	aa	a0	00	e8	2a
c020 : 00	bl f7 91 f7 c8	d0 f9	26	c0b8 s	a5	fa	65	fc	85	fa	18	a5	af	cl50 :	ca	f0	09	bl	22	91	f7	c8	2b
c028 : e6	f8 ca d0 f4 60	a9 00	50	c0c0 :	f7	65	f9	85	f7	a5	f8	65	f4	cl58 :	c9	0d	d0	f4	c0	0b	f0	04	ab
c030 : a0	e0 85 f7 84 f8	a2 20	7b	c0c8 :	fa	85	f8	a0	00	84	c6	bl	7a	cl60 :	a9	00	91	f7	4c	ae	a7	a9	99
c038 : a0	00 bl f7 91 f7	c8 d0	el	c0d0 :	f7	99	77	02	f0	0a	e6	c6	3a	cl68 :	e4	a0	a7	8d	08	03	8c	09	15
c040 : f9	e6 f8 ca d0 f4	a9 35	09	c0d8 :	c8	c0	0a	f0	03	4c	cf	c0	f4	cl70 :	03	60	20	15	c0	20	2e	c0	95
c048 : 85	01 60 a9 b6 a0	cl 85	le	c0e0 :	4c	42	eb	20	73	00	c9	23	fl	cl78 :	20	4b	c0	20	70	c0	60	20	41
c050 s f7	84 f8 a2 00 a0	00 8a	36	c0e8 :	f0	06	20	79	00	4c	e7	a7	64	cl80 :	fd	ae	20	d4	el	a9	b6	a0	fe
c058 s 91	f7 c8 a9 00 91	f7 18	e9	c0f0 :	20	9b	b7	86	f9	a2	00	a9	a4	cl88 :	cl	85	f7	84	f8	a9	f7	a2	9c
c060 : a5	f7 69 0a 85 f7	a5 f8	3d	c0f8 :	b6	a0	cl	85	f7	84	f8	86	b4	cl90 s	b7	a0	cb	20	d8	ff	60	20	dd
c068 : 69	00 85 f8 e8 d0	e6 60	c3	cl00 :	fa	a5	f9	0a	85	fb	a5	fa	51	cl98 :	fd	ae	a9	00	85	0a	20	d4	2a
c070 : a9	8d a0 c0 a2 4c	78 8e	ab	cl08 :	2a	85	fc	06	f9	26	fa	06	bd	cla0 :	el	a9	01	85	b9	a5	0a	a2	7d
c078 : 34	eb 8d 35 eb 8c	36 eb	80	cll0 s	f9	26	fa	06	f9	26	fa	18	89	cla8 :	b6	a0	cl	20	d5	ff	60	20	42
c080 : 58	60 a9 e3 a0 c0	8d 08	45	cll8 :	a5	f9	65	fb	85	f9	a5	fa	47	clb0 :	4b	c0	20	70	c0	60	ff	ff	80
Listing 1. Hauptprogramm »Frei programmierbare Tastatur«. Bitte beachten Sie die Eingabehinweise auf Seite 8.
105
Tips & Tricks
die alte Tastaturbelegung wieder herzustellen, so ist dies ganz einfach mit dem Befehl SYS 49152+9 möglich.
Außerdem kann die Belegung der Tastatur gespeichert und wieder geladen werden. Die Befehle dazu sind:
Speichern: SYS 49152+12,"name",ga
Laden: SYS 49152+15,"name",ga
»ga« ist dabei die Geräteadresse, also 1 für Kassettenrecorder und 8 für Diskettenlaufwerk. So kann jeder seine »ideale« Lösung auf einfachste Weise festhalten.
Tastatur-Generator
Die Anwendungsgebiete der programmierten Tastaturen sind nahezu unbegrenzt. So läßt sich der C 64 wie der SX 64 an ein Diskettenlaufwerk anpassen. Mit:
#131, "LOAD"+CHR$(34)+ " * " +CHR$(34)+ ",8"
wird die RUN/STOP-Taste so umdefiniert, daß nicht mehr ein Kassettenprogramm, sondern das erste Programm von der Diskette geladen wird.
Da KEY-PROGGER auch ohne Probleme mit dem DOS 5.1 zusammenarbeitet, istjetztauch ein Directoryauf Knopfdruck möglich.
Will man gleichzeitig mit KEY-PROGGER und Hypra-Load arbeiten, so muß man erst Hypra-Load und dann KEY-
PROGGER mitSYS 49152+18 statt mitSYS 49152 starten.
Am einfachsten ist die Belegung der Tastatur mit dem Tastatur-Generator. Nach Abtippen von Listing 2 speichern Sie den Tastatur-Generator zuerst ab. Nun laden Sie KEY-PROGGER wie oben beschrieben und geben anschließend NEW ein. Danach können Sie den Tastatur-Generator laden und mit RUN starten. Der Tastatur-Generator startet KEY-PROGGER automatisch. Nach zirka fünf Sekunden meldet sich der Tastatur-Generator mit der Frage, welche Taste umdefiniert werden soll. Sie brauchen nur diese Taste zu drücken. Der Computer zeigt dann, wie die Taste bisher belegt war. Danach können Sie Ihre neue Belegung in ein 10Zeichen breites Feld eingeben. Die Taste DEL löscht die Eingabe. Mit RETURN wird die Eingabe abgeschlossen. Haben Sie einen Befehl eingegeben, der sofort nach Drücken der Taste ausgeführt werden soll, zum Beispiel RUN, so schließen Sie die Eingabe mit SHIFT RETURN ab. Drücken Sie RETURN,'ohne eine neue Belegung eingegeben zu haben, so bleibt die alte Belegung erhalten.
Nach der Eingabe erscheint ein Menü, mit dem Sie die Definitionen fortsetzen können (1), die letzte Eingabe rückgängig machen (2), die neue Tastaturbelegung speichern (3), die ursprüngliche Belegung wieder herstellen (4) oder das Programm beenden können (5). Somit kann sich jeder auf einfachste Weise eine individuelle Tastaturbelegung gestalten.
(Markus Stecher/ah)
1000	REM TASTATUR-GENERATOR	<198>	1440	PRINT"<DOWN > TASTATURBELEGUNG SPEICHER	
1010	REM	<054>		N...3"	<094>
1020	REM 1985 VON MARKUS STECHER	<123>	1450	PRINT"<DOWN>ALTE BELEGUNG HERSTELLEN.	
1030	REM	<076>		....4"	<142>
1040	POKE 53280,0	<074>	1460	PRINT"<DOWN>ENDE		
1050	POKE 53281,0	<212>		....5<2D0WN>"	<233>
1060	SYS 49152	<102>	1470	GET A$:IF A$<"l"OR A$>"5"THEN 1470	<235>
1070	SYS 49152+3	<128>	1480	ON VAL(A$)GOTO 1490,1500,1520,1610,16	
1080	DIM B#(255)	<096>		60	<165>
1090	GOSUB 1700:GOSUB 1740	<026>	1490	GOTO 1100	<176>
1100	PRINT"<CLR,RVSON,1lSPACE)TASTATUR-GEN		1500	B#(Z)=AL#	<233>
	ERATOR{11SPACE}"5CHR$(8)	<236>	1510	GOTO 1100	<196>
1110	POKE 1,53	<121>	1520	INPUT"<CLR,2D0WN>NAME ";N#	<109>
1120	PRINT"WELCHE TASTE ? ";	<036>	1530	PRINT"<2D0WN><D>ISK ODER <T>APE ? "5	<250>
1130	Z#=" "	<243>	1540	GET G#:IF G$<>"D"AND G#<>"T"THEN 1540	<031>
1140	GET A$:IF A#=""THEN 1140	<111>	1550	GA=1	<146>
1150	IF A$=CHR$(13)THEN 1180	<050>	1560	IF G#="D"THEN GA=8	<152>
1160	Z#=Z$+A$	<119>	1570	PRINT"<2D0WN>BITTE WARTEN"	<126>
1170	GOTO 1140	<238>	1580	GOSUB 1780	<125>
1180	Z=VAL(Z#)	<212>	1590	SYS 49152+12,N#,GA	<008>
1190	PRINT CHR$(34)jCHR$(20)jCHR$(Z)	<047>	1600	GOTO 1100	<032>
1200	B#=B#(Z):CR=0	<167>	1610	PRINT"<CLR,2DOWN>SOLL WIRKLICH DIE AL	
1210	L=LEN(B$(Z))	<052>		TE BELEGUNG"	<221>
1220	IF RIGHT#(B#,l)=CHR#(13)THEN B#=LEFT#		1620	PRINT"<DOWN>HERGESTELLT WERDEN <J/N)	
	(B#,L-1):CR=1	<040>			<103>
1230	PRINT"{DOWN>ALTE BELEGUNG: ";CHR#(34)		1630	GET A#:IF A#=<>"J"AND A#<>"N"THEN 163	
	;B$;CHR$(34);	<199>		0	<199>
1240	IF CR THEN PRINT"+CHR#(13)";	<161>	1640	IF A$="J"THEN SYS 49152+9	<184>
1250	PRINTsPRINT"<DOWN>NEUE BELEGUNG: -<11		1650	GOTO 1100	<082>
	SPACE>-<12LEFT>"jCHR#(34);CHR#(20);	<166>	1660	PRINT"{CLR,2D0WN,SPACE>AUF WIEDERSEHE	
1260	POKE 1,55	<144>		N	<212>
1270	F#=" •'	<047>	1670	GOSUB 1780	<215>
1280	GET A$:IF A#=""THEN 1280	<063>	1680	POKE 1,53	<183>
1290	IF A#=CHR#(20)THEN PRINT:PRINT"{4UP}"		1690	END	<168>
	:GOTO 1250	<248>	1700	FOR 1=0 TO 255	<018>
1300	IF A#=CHR#(13)THEN 1370	<201>	1710	#I,STR#(I)+CHR#(13)	<057>
1310	IF A#=CHR#(141)THEN 1360	<090>	1720	NEXT I	<024>
1320	IF LEN(F#)=10 THEN 1280	<245>	1730	RETURN	<008>
1330	PRINT A#;	<085>	1740	FOR 1=0 TO 255	<058>
|340	F#=F#+A#	<090>	1750	B#(I)=CHR#(I)	<223>
1350	GOTO 1280	<053>	1760	NEXT I	<064>
1360	F#=F#+CHR#(13)	<235>	1770	RETURN	<048>
1370	IF F#=""THEN F#=B#(Z)	<085>	1780	FOR 1=0 TO 255	<098>
1380	AL#=B#(Z)	<143>	1790	#I,B#(I)	<162>
1390	B#(Z)=F#	<160>	1800	NEXT I	<106>
1400	PRINT	<232>	1810	RETURN	<090>
1410	PRINT"<2D0WN>BITTE WAEHLEN:"	<003>			
1420	PRINT"<DOWN>NAECHSTE EINGABE				© 64'er		
	. . . . 1"	<105>			
1430	PRINT"<DOWN>LETZTE EINGABE LOESCHEN..		Listing 2. »Tastaturgenerator«. Bitte beachten Sie die Ein-		
	..-.2"	<045>	gabehinweise auf Seite 6.		
106
H. L Schneider
(sFr. 45,10/öS 382,20)
DM 49,
Best.-Nr. MT 710 (Beispiele auf Diskette)
(sFr. 29,90/öS 269,10)
Unverbindliche Preisempfehlung
H. Ponnath
DM 49
Best.-Nr. MT 830, ISBN 3-89090-168-9
DM 29,90 * inki. MwSt.
Best.-Nr. MT 756, ISBN 3-89090-130-1 (sFr. 45,10/öS 382,20)
Werden Sie ein Profi — mit dem Commodore 64
Fragen Sie dort nach unserem Gesamtkatalog mit über 200 neuen Computerbüchern.
DM 52,— (sFr. 47,80/öS 405,60)
C64 - Programmieren in Maschinensprache
August 1985, 327 Seiten inklusive Beispieldiskette
In diesem Buch finden Sie über 100 Beispiele zur Assembler-Programmierung mit viel Kommentar und Hintergrundinformationen: Das Schreiben von Maschinenprogrammen - Rechnen und Texten mit vorhandenen Routinen • Bedienung von Drucker und Floppy • wie man BASIC- und Maschinenprogramme verknüpft • Erstellen von eigenen Befehlen in Modulform. Für Profis!
C64 — Wundorland der Grafik. Juli 1985, 236 Seiten inklusive Beispieldiskette
Grafik und der C64 — ein schier unerschöpfliches Thema! Dieses Buch zeigt eine Vielzahl sehr interessanter Lösungen, um die grafischen Möglichkeiten des Commodore 64 optimal zu nutzen. Als Krönung enthält es ein zuschaltbares Assemblerprogramm, das umfangreiche grafische und einige neue BASIC-Befehle anbietet. Im zweiten Teil des Buches wird eine Möglichkeit gezeigt, wie man bis zu 70verschiedene Farberterzeugen kann. Viele Beispielsprogramme begleiten die Reise durch das Wunderland der Grafik.
Dieses Buch ist eine Fundgrube für alle ambitionierten C64-Benutzer, die wirklich das Letzte aus ihrem Rechner herausholen wollen. Alle Beispiele auf Diskette im Buch enthalten.
K. Schramm
Die Floppy 1541 April 1985, 434 Seiten
Für alle Programmierer, die mehr über ihre VC 1541-Floppystation erfahren wollen. Der Vorgang des Formatierens • das Schreiben von Files auf Diskette • die Funktionsweise von schnellen Kopier- und Ladeprogrammen • viele fertige Programme.
Best.-Nr. MT 806, ISBN 3-89090-098-4
Commodore 64 Listings, Band 2: Dateiverwaltung ■ Schule - Hobby Oktober 1984,179 Seiten
Ein Buch mit Programmen für die ganze Familie • DATAVE—EineDateiverwaltung • mathematische Funktionen • Konjugation und Deklination in Latein • Regressionsanalyse ■ Bundesligatabelle. Teilweise Vorkenntnisse erforderlich.
Best.-Nr. MT 766
ISBN 3-89090-071-2
(sFr.23,-/oS193,40) UM Z4,OU
Dr. W.-J. Becker/M. Folprecht
Programmieren unter CP/M mit dem C64 Juni 1985, 290 Seiten
Wenn Sie wissen wollen, wie das Betriebssystem CP/M 2.2 auf dem C64 implementiert ist, außerdem einiges über Turbo-Pascal, Nevada-Fortran, MBasic-80 erfahren wollen, dann ist dieses Buch genau richtig für Sie! Mit Schaltplänen zur eigenen Fertigung des CP/M-Moduls. Füreingefleischte C64-Profis.
Best.-Nr. 751
ISBN 3-89090-091-7
(sFr. 47,80/öS 405,60) UM 34,“
H. L. Schneider/W. Eberl
DasC64-Profihandbuch
Juli 1985, 410 Seiten
Ein Buch, das alle wichtigen Informationen für professionelle Anwendungen mit dem C64 enthält. Mit allgemeinen Algorithmen, die auch auf andere Rechner übertragbar sind, und vielen Utilities, getrennt nach BASIC- und Maschinenprogrammen. Besonders nützlich: erweiterte PEEK- und POKE-Funktionen.
Best.-Nr. MT 749
ISBN 3-89090-110-7
(sFr. 47,80/öS 405,60) UM 0^,“
Mehr als 32 BASIC-Programme für den Commodore 64. Februar 1984,279 Seiten
ProgrammespeziellfürdenCommodore64 • umfassendepraktischeAnwendungen jedeMen-ge Lehr- und Lernhilfen • super Spiele • für Basic-Neulinge und Experten.
Best.-Nr. MT 613 (Buch), ISBN 3-922120-66-0	DM 49,— (sFr. 45,10/öS 382,20)
Best.-Nr. MT 614 (Beispiele auf Diskette)	DM 48,— * (sFr. 48,—ZöS 432,—)
* inki. MwSt. Unverbindliche Preisempfehlung
Eia vollständiger Grafikkur«:
♦ Sprit^rogrammmrun« • 20- und 3O-Effakta • Maschinenspracheroatinen ♦ Animation, Mit Sondertail: 70 Farben auf dem C 64.
Markt&Technik-Fachbücher erhalten Sie bei Ihrem Buchhändler.
Maria&Mmik-Buchreriag
Das
Profihandbuch


MSX Basic. April 1985, 236 Seiten
Alles über den neuen Heimcomputerstandard MSX: zusätzlich zum »normalen« BASIC können mit insgesamt mehr als 150 Befehlen und Funktionen Grafiken erstellt, Töne erzeugt, Melodien komponiert und ganze Spielhandlungen programmiert werden • 32 Sprites garantieren abwechslungsreiche Action-Spiele • die Hardware des MSX-Systems • nützliche Hinweise zur Dateibehandlung • das MSX-BASIC anhand der Entwicklung eines Spielszenarios mühelos lernen • drei vollständige Spiele: Der eisige Planet, Autorennen und Bilder entwerfen ■ mit ausführlicher Befehlsübersicht • für Anfänger!
Best.-Nr. MT 805, ISBN 3-89090-107-7	DM 44,— (sFr. 40,50/öS 343,20)
Best.-Nr. MT 825 (Beispiele auf Kassette)	DM 19,90* (sFr. 19,90/öS 179,10)
* inkl. MwSt. Unverbindliche Preisempfehlung
BASICProgrammierbuch. i984,506 seiten
Ein BASIC-Lehrbuch, das ebensoviel Spaß macht wie BASIC selbst. Locker und unterhaltsam geschrieben, mit vielen Zeichnungen und Grafiken bestückt, sagt der Text selbst dem Einsteiger alles, was für das erfolgreiche Programmieren in BASIC erforderlich ist.
Best.-Nr. MT 658, ISBN 3-922120-92-X	DM 78,— (sFr. 71,80/öS 608,40)
Bestellkarten bitte an Ihren Buchhändler oder an einen unserer Depot-Händler. Adressenverzeichnis am Ende des Heftes. Beim Markt&Technik Verlag eingehende Bestellungen werden von den Depot-Händlern ausgeliefert.
Markt & Technik Verlag AG Hans-Pinsel-Straße 2, 8013 Haar bei München Schweiz: Markt&TechnikVertriebs AG, Kollerstraße 3, CH-6300 Zug, ® 0 42/22 3155 Österreich: RudolfLechner & Sohn, Heizwerkstraße 10, A-1232 Wien S 02 22/67 75 26
Die angegebenen Preise sind Ladenpreise.
Tips & Tricks
Komfortable Menüsteuerung
Mit diesem Basic-Unterprogramm läßt sich durch einfache Parameterübergabe eine Menü-Zeile frei definieren, mit der Sie auf Tastendruck bis zu 19 weitere Routinen anwählen können.
Das zirka 800 Byte lange Unterprogramm (ohne REM) erspart bei der Erstellung eines menügesteuerten Programms die immer wiederkehrenden Abfragen nach gedrückten oder nichtgedrückten Tasten.
Man ruft im laufenden Programm nur das Unterprogramm (Listing) auf und die gewünschte Menüzeile erscheint zentriert in der vorletzten Zeile des Bildschirms.
Mit den Cursor-Tasten (links/rechts) verschiebt man ein re-vers erleuchtetes Feld, das auf das Menü-Wort positioniert werden kann. Mit RETURN übernimmt man das Menü-Wort und verläßt das Unterprogramm. Um mehrere Menüs zu erstellen, sind die Angaben aller Menüs am Anfang des Hauptprogramms den Variablen d$(1), d$(2) undsoweiterzuzuordnen.
Im laufenden Programm wird nun das Unterprogramm folgendermaßen aufgerufen:
AN=3:az=4:GOSUB 1000
AN=Anfang des Menü-Wortes (hier drittes Menü-Wort) AZ=Anzahl der Menü-Worte (hier vier Worte)
Es werden also die Strings d$(3) bis d$(4) ausgegeben. Das Unterprogramm übergibt den Parameter kk in Abhängigkeit des gewählten Menü-Wortes und der Position der Menü-Zeile. Hat man also zum Beispiel das dritte Menü-Wort von links ausgewählt, so wird kk=3 übergeben.
Nach dem GOSUB ist eine Weiterbehandlung mit
ON kk GOSUB 11,22,33,44,... am sinnvollsten.
Man erkennt sofort, welche Vorteile das Programm hat. Änderungen können sehr einfach durchgeführt werden und im laufenden Programm sind nur zwei Zeilen nötig, um eine Verzweigung zu bewirken.
Anmerkung: Die Menü-Zeile sollte nicht mehr als 38 Zeichen haben, sonst werden die Menü-Worte jeweils um ein Zeichen gekürzt dargestellt. Bei mehr als 38 Zeichen plus Anzahl der Menü-Worte erscheint eine Fehlermeldung. (M. Schacht/ah)
2 REM ****** MENUE-DEMO ******	<233>
4 POKE 53280,0:POKE 53281,0:PRINT CHR$(147 )	<206>
5 REM * * * MENUE-WORTE EINLESEN * * *	<229>
6 AM=12:DIM D$(AM+l):DIM AA(AM+l):REM AM=M AX. ANZAHL DER WORTE	<103>
7 1 = 1	<212>
8 READ D$(I):D$(I)=CHR$(32)+D$(I)+CHR$(32) ;IF D$(I)<>" f- “THEN I=I+l:GOTO 8	<083>
9 DATA START,HELP,GOTO,RENUM,LIST	<037>
10 DATA OLD,FIND,CTRL,CLR,NEW,RUN,ENDE,<-	<167>
13 REM * * * * * * * * * * * * * * * *	<069>
14 POKE 214,15:PRINT:PRINT TAB(10)"<=CRSR = X2SPACE>UND RETURN"	<023>
15 REM BEISPIEL	<220>
16 AN=l:AZ=5:G0SUB 1000:REM l.MENUE	<217>
17 ON KK GOSUB 27,27,27,27,27	<071>
18 :	<250>
19 AN=6:AZ=7:G0SUB 1000sREM 2.MENUE	<140>
20 ON KK GOSUB 27,27,27,27,27,27,30	<200>
22 GOTO 16	<040>
25 ;	<001>
26 REM ANZEIGE	<087>
27 POKE 214,15:PRINT:PRINT TAB(18)"C15SPAC E)"	<144>
28 POKE 214,15sPRINTsPRINT TAB(10)"GEWAEHL T:";D$(AN+KK-1);"(";KK;")":RETURN	<253>
29 s	<005>
30 PRINT CHR$(147):END	<177>
32 s	<ii6>
1000 REM ******************************	<036>
1010 REM **** MENUE UNTERPROGRAMM ****	<120>
1020 REM ******************************	<056>
1030 REM ****	MARIO SCHACHT ****	<109>
1040 REM ****	(030)4968872	****	<014>
1050 REM ******************************	<088>
1060 REM **** AUFRUF (BEISPIEL)	****	<023>
1070 REM **** AN=l:AZ=4:GOSUB1000 ****	<011>
1080 REM **** ON KK G0SUBll,22,... ****	<065>
1090 REM ****— — — — — — — — — — — ***»	<067>
1100 REM **** ANs ANFANG MIT AN-TEN****	<166>
1110 REM ****	STRING	****	<024>
1120 REM **** AZ; ANZAHL DER MENUE-****	<003>
1130 REM ****	PUNKTE	****	<188>
1140 REM **** KK: 1 BIS AZ WIRD	****	<011>
1150 REM ****	UEBERGEBEN	****	<043>
1160 REM ******************************	<198>
1170 REM **** VERWENDETE VARIABLEN ****	<215>
1180 REM **** D$(AM);AA(AM);A$	****	<217>
1190 REM **** AM;AZ;AN;AL;DI;AY;KK ****	<145>
1200 REM :***	****	<243>
1210 REM ******************************	<248>
1220 AL=0	<100>
1230 FOR I=AN TO(AN+AZ-l):AL=AL+LEN(D$(I)) :NEXT:REM AL=GESAMTLAENGE	<065>
1240 IF AL>38+AZ THEN POKE 214,22:PRINT:PR INT" MENUE-WORTE KUERZEN !";RETURN	<177>
1250 IF AL<39 THEN 1290	<097>
1260 REM WORTE KUERZEN	<093>
1270 DI=AL-39:FOR I=AN TO(AN+DI):D$(I)=LEF T$(D$(I),LEN(D$(I))-l):NEXT:AL=38	<069>
1280 REM MENUE DARSTELLEN	<118>
1290 POKE 214,22:PRINT:PRINT TAB((40-AL)/2 )	<035>
1300 FOR I=AN TO(AN+AZ-1)	<232>
1310 PRINT CHR#(18)CHR$(30);D$(I);:NEXT	<192>
1330 REM ANZEIGE	<121>
1340 AA(AN)=(40-AL)/2:REM ERSTE STELLE	<023>
1350 FOR I=AN T0(AN+AZ-2)	<155>
1360 AA(I+l)=AA(I)+LEN(D$(I)):NEXT	<074>
1380 REM STARTPOSITION	<094>
1390 KK=INT(AZ/2):FL=0:FR=158:GOSUB 1550	<075>
1400 REM ABFRAGE	<187>
1410 GET A#:IF A$=""THEN 1410	<190>
1420 IF A$<>CHR$(29)AND A$<>CHR$(157)AND A $<>CHR$(13)THEN 1410	<149>
1430 IF A$=CHR#(29)THEN KK=KK+l:FL=-l:FR=3 0:GOSUB 1550sIF KK=AZ THEN KK=0	<023>
1440 IF A$=CHR$(157)THEN KK=KK-l:FL=l:FR=3 0:GOSUB 1550:IF KK<0 THEN KK=AZ-1	<016>
1450 FL=0:FR=158:GOSUB 1550	<089>
1460 IF A$<>CHR$(13)THEN 1410	<017>
1470 POKE 214,22sPRINT:PRINT"<39SPACE>":RE M MENUE LOESCHEN	<145>
1500 KK=KK+l:RETURN:REM RUECKSPRUNG MIT PA RAMETER KK	<117>
1540 REM ANZEIGE GELB	<160>
1550 POKE 214,22:PRINT:PRINT TAB(AA(KK+AN+ FL))CHR$(18)CHR$(FR);D$(KK+AN+FL):RET URN	<022>
Listing »Komfortable Menüsteuerung«. Bitte die Eingabehinweise auf Seite 6 beachten.
108
Tips & Tricks
Anhalter — Programmstop auf Tastendruck
Mit dieser kleinen Maschinensprach-Routine können Sie jedes Programm anhalten. Der Computer stoppt so lange, bis Sie eine Taste drücken
Dieses kleine Maschinenprogramm kann Ihnen in vielerlei Hinsicht nützlich sein. Man kann sich beispielsweise folgende Anwendungsgebiete vorstellen: In einem selbstprogrammierten Spiel wird oft eine Pause-Taste benötigt, ähnlich, wie es sie auch in manchen kommerziellen Spielen gibt Auch das Auflisten von Programmen kann jederzeit angehalten werden und sogar der Datenfluß zur Floppy ist gegen eine Unterbrechung nicht gefeit Mit dem Programm »Anhalter« steht es Ihnen vollkommen frei, zu entscheiden, an welchen Stellen ein Programm angehalten werden soll.
Nach dem Starten des Programms (siehe Listing 1) werden Sie zunächst gefragt, wohin das Programm verschoben werden soll (bitte Dezimalzahlen eingeben). Da das Programm vollkommen frei verschiebbar ist, brauchen Sie keine weiteren Angaben zu machen. Danach brauchen Sie nur noch die Funktionstaste F1 zu drücken um Ihr Programm zu stoppen. Soll das Programm weiter laufen, so genügt es, eine beliebige Taste zu betätigen.
Falls Sie nicht die F1-Taste, sondern eine andere mit der An-halte-Funktion belegen möchten, so ist dies möglich. Dazu brauchen Sie nur in die Speicherstelle (Startadresse + 16)
0 REM		<012>
1 REM	♦*	+++ ANHALTER +++	**	<230>
2 REM		<107>
	—		
3 REM	** WRITTEN BY GEORG KRAMER **	<149>
4 REM	**	AUF DEM MOORE 15	**	<233>
5 REM	**	4783 ANROECHTE	♦*	<140>
6 REM	**	TEL.; 02947/3511	**	<121>
7 REM	**	(C) 07.06.1985	**	<035>
8 REM		<020>
9 :		<241>
10 PRINT"{CLR,D0WN,3SPACEJ++ ANHALTER ++"s
PRINT	<126>
15 INPUT"{SPACE,RVSONJSTARTADRESSE s<RVOFF
,SPACE}49152 <7LEFT >";S	<195 >
20 IF S<0 OR S>65535 THEN 10	<022>
30 FOR 1=0 TO 33sREAD A:X=X+A	<226>
40 POKE S+I,A:NEXT	<221>
50 IF X<>4231 THEN PRINT"DATA-FEHLER !"sEN
D	<146>
60 POKE S+7,(S+13)/256	<139>
70 POKE S+2,(S+13)-PEEK(S+7)*256	<098>
80 SYS(S)	<101>
90 PRINTzPRINT” PROGRAMM ANHALTEN => Fl" <039> 95 END	<097>
100 REM *** MASCHINENPROGRAMM ***	<154>
101 DATA 120,169,13,141,20,3,169,192,141,2
1,3,88,96,165,203,201,4,240,3,76	<081>
102 DATA 49,234,32,135,234,165,203,201,64, 240,247,76,49,234	<040>
Listing 1. »Anhalter«.
Bitte beachten Sie die Eingabehinweise auf Seite 6
,c000	7B	IIHIIIIi|	;lnterruptabschalten
,C001	A9 0D	LDA #$0D	;lnterruptaufCOOD
,C006	A9 C0	LDA #$C0	setzen
,C008	8D 15	03 STA $0315	
,C00B ,C00C ,C00D	58 60 A5 CB	CLl RTS LDA $CB	;lnterruptzulassen ;ROckkehrzum Basic ;holeWertderletzten
,COOF	C9 04	CMP #$04	gedrückten Taste ;vergleichemitWert
,C011	F0 03	BEQ $C016	fürF1-Taste ;verzweige:ja
,C013	4C 31	EA JMP $EA31	=eig. Routine, nein=norm. IRQ ;verlasse
,C016	20 87	EA JSR $EA87	Routine zum normalen IRQ ;springe zur normalen
,C019	A5 CB	LDA $CB	Tastaturabfrage ;hole Wert der letzten
,C01B	C9 40	CMP #$40	gedrückten Taste ;vergleiche mit $40
,CO1D	F0 F7	BEQ $CO16	(#64) = keineTaste ;wenn keine Taste,
,C01F	4C 31	EA JMP $EA31	dann zurTastaturabf. ;wenn Taste gedrückt,
dann norm. IRQ
Listing 2. Schnell eingegeben und leicht zu verstehen — der SourceCode von »Anhalter«
den Wert der neuen Taste hineinschreiben. Diesen Wert erhalten Sie, indem Sie folgende Zeile im Direktmodus eingeben, die gewünschte Taste drücken und sich die angezeigte Zahl merken.
FOR 1=1 TO 10000 : PRINT PEEK(203): NEXT
Jetzt können Sie die Abfrage ändern:
POKE Startadresse + 16,X (X=neuer Wert)
Listing 2 erläutert die genaue Funktionsweise des Programmes.
(Georg Kramer/aw)
Variable Funktionen
Normalerweise werden Formeln in Programmen fest definiert. Mit dieser kleinen Basic-Erweiterung können Sie Funktionen auch während des Programmablaufs eingeben und ändern.
Um in einem Basic-Programm Formeln zu definieren hatte man bislang nureine Möglichkeit: die Formel mitdem DEF FN-Befehl in einer Basic-Zeile zu definieren. Vom laufenden Programm aus war das nicht möglich. Dabei wird der Funktionswert zum Beispiel mit A=FNA(X) oder mit PRINT FNB(Y) aufgerufen.
Es geht aber auch anders, nämlich mit diesem kurzen Maschinenprogramm (Listing 1), das mit dem MSE einzugeben ist. Den Quell-Code dazu finden Sie in Listing 2. Das Programm wird mit LOAD"VARFUNKT",8,1 und nachfolgendem NEW geladen, sofern es nicht von einem anderen Programm nachgeladen wird. Das Einbinden in die Interpreter-Routine (=lnitialisierung) wird mit SYS(49351) vorgenommen.

109
Tips & Tricks
ASSEMBLERLISTING (ASSEMBLER■PROFI-ASS)						
NUMERISCHER NERT EINES STRINGS						Listing 2. AssemblerOuell-Listing
2 100:	C010			.OPT	‘ P2,G0	zu »Variable Funktionen«.
105:	C010				$C010	
110:	C010		CHRGET		$73	
115:	C010		CHRGÜT		$79	
120:	C010		FRMEVL		$AD9E	
130:	C010		Hl		139	
140:	C010		H2		140	
150:	C010		H3		$C002	
160:	C010		H4	3	$C003	
170:	C010		H5		$C004	
180:	C010		H6	3	$C005	
			i NUMERISCHER WERT EINES STRINGS			
212:	C010 A5 9D		NERT	LDA	157	
214'	C012 F0 05			BEQ	RUH	. ;KEIN DIREKT-MÜDUS
216:	C014 A2 15			LDX	#21	JILLEGAL DIRECT ERROR
' 218:	C016 4C 37	A4		.JMP	$A437	
220:	C019 A5 7A		RUN	LDA	$7A	1PROGRAMMZEIGER SPEICHERH
230:	C01B 85 8E			STA	Hl	
240 :	C01D A5 7B			LDA	$7B	
250:	C01F 85 8C			STA	H2	
260:	C021 A0 00			LDY	#0	
270:	C023 Bl 7A		X	LDA	<$7A),Y	M. ZEICHEH NACH DEM BEFEHL EINLADEH
280:	C025 F0 0D			EEQ	SYHERR	;KEIN ZEICHEN DA
290:	C027 C9 E2			CMP	#$B2	
300:	C029 F0 0E			EEQ	PROGR	;ZEICHEN EIH z = z
310:	C02E E6 7A			INC	$7A	;NEIN,DANN NAECHSTES ZEICHEH HOLEN
320 :	C02D D0 F4			BNE		
330:	C02F E6 7E			INC	$7B •	
340:	C031 4C 23	C0		•JMP	X	;ZURUECK ZUM CHECK.
360 :	C034 A2 0E		SYNERR	LDX	#$0B	"SYHTAX-ERROR"
370:	C036 4C 37	A4		JMP	$A437	
390:	C039 20 73	00	PROGR	JSR	CHRGET	.:HAECHSTES ZEICHEH IH AKKU
400:	C03C 20 9E	AD		JSR	FRMEVL	lAUSWERTEH DES TERMES HIHTER z = z
410:	C03F A5 7A			LDA	$7A	1PROGRAMM-U.ZEILEHZEIGER SPEICHERN
420:	C041 8H 02	C0		STA	H3	
430 :	C044 A5 7E			LDA	$7E	
440 :	C046 8D 03	C0		STA	H4	
450:	C049 A5 39			LDA	$39	
460 :	C04E 8B 04	C0		STH	H5	
470:	C04E A5 3A			LDA	$3A	
480:	C050 8H 05	C0		STA	H6	
490:	C053 A0 00			LDY	#0	
500 :	C055 El 64			LDH	($64>,Y	;$64/$65 SlHD ZEIGER AUF DEN STRINGD
ESCRIPTOR						
510:	C057 85 61			SIH	$61	..DESCRIPTOR HHCH $61-$63 HOLEN
512:	C059 D0 05			EHE	RI	
514:	C05E A2 0E			LDX	#14	
516:	C05D 4C 37	A4		JMP	$A437	;FEHLER,NEIL STRING LEER
520:	C060 C8		RI	INY		
530 :	C061 El 64			LDA	$64.3 . Y	
540:	C063 85 62			STA	$62	
550 :	C065 C8			INY		
560:	C066 El 64			LDA	(.$64;'.Y	
570 :	C068 85 63			STA	$63	
580:	C06A A0 00			LDY	#0	
590 :	C06C El 8E			LDH	(Hl>,Y	H.TEIL DES TERMS IN EIHGABEPUFFER
600 :	C06E 99 00	02		STA	$0200,Y	
610:	C071 C8			INY		
620 :	C072 C9 E2			CMP	#$B2	;<Eis zu
6.30 :	C074 D0 F6			ENE		
635:	C076 A9 3D			LDA	#$3D	
637:	C078 99 FF	01		STA	$01FF..Y	"=" IH STRINGCODE NANDELN
640 :	C07E A2 00			LDX	#0	
650:	C07D Al 62		LY	LDH	<$62),X	;2. TEIL DES TERMS UEBERTRAGEN
660 :	C07F 99 00	02		STA	$0200.Y	
670 :	C082 C8			INY		
680:	C083 E6 62			INC	$62	
690:	C085 H0 02			ENE	LZ	
700 :	C087 E6 63			INC	$63	
710:	U089 C6 61		LZ	DEC	$61	
720 :	C08B D0 F0			EHE	LY	
730 :	C08D 8A			TXA		
740 :	C08E 99 00	02		STA	$0200/?	lLETZTES ZEICHEN = 0
750 :	C091 A9 FF			LDA	#$FF	;DIREKTMODUS SIMULIEREN
760:	C093 85 7A			STA	$7A	
770:	C095 A9 01			LDA ,	#$01	
780:	C097 85 7B			STA	$7E	
790:	C099 A9 80			LDA	#$80	
800 :	C09E 20 18	FE		JSR	$FE18	
810:	C09E 20 73	00		JSR	CHRGET	H.ZEICHEN AUS EIHGABEPUFFER IN AKKU
820:	C0A1 A2 FF			LDX	#$FF	
830 :	C0A3 86 3A			STX	$3A	
840:	C0A5 20 79	A5		JSR	$A579	:TERM IN INTERPRETERCODE NANDELN
350 :	C0A8 20 73	00		JSR	CHRGET	
860 :	C0AE 20 ED	A7		JSR	$H7ED	1 BEFEHL HUSFUEHREH
870 :	C0AE AD 02	C0		LDA	H3	;ZEIGER ZURUECKHOLEN
880 :	C0B1 85 7A			STA	$7A	
890:	C0B3 AD 03	C0		LDA	H4	
900 :	C0E6 85 7E			STA	$7E	
910:	C0E8 AD 04	C0		LDA	H5	
920 :	C0EB 85 39			STA	$39	
930:	C0ED AD 05	C0		LDA	H6	
940 :	C0C0 85 3A			STH	$3A	
950:	C0C2 A9 00			LDA	#0	;RUN-MODUS WIEDERHERSTELLEN
960:	C0C4 85 9D			STA	157	
970:	C0C6 60			RTS		1 ZUR IHTERPRETERSCHLEIFE
1000:	C0C7 A9 D2			LDA	#<AUS	;VEKTOR NEU BESTIMMEN
1010:	C0C9 8D 08	03		STA	$0308	
1020:	C0CC A9 C0			LDA	#>AUS	
1030:	C0CE SD 09	83		STA	$6309	
1040:	C0D1 60			RTS		
1050:	C0D2 20 73	00	AUS	JSR	CHRGET	;BEFEHL "T ?"
1060:	C0D5 C9 AE			CMP	#$AE	
1070:	C0D7 F0 0A			EEQ	C'	
1072:	C0D9 C9 8E			CMP	'#$8E	
1074:	C0DE F0 0C			EEQ	T	; IF-STRUKTUR
1080:	C0DD 20 79	00	ST	JSR	CHRGQT	
1090:	C0E0 4C E7	A7		JMP	$A7E7	lNEIN
1100:	C0E3 20 10	C0	.“l	JSR	NERT	;NEUEN BEFEHL AUSFUEHREN
1110:	C0E6 4C AE	A7		JMP	$A7AE	;ZUR INTERPRETERSCHLEIFE
1120:	C0E9 20 F2	C0	T	JSR	IF	lIF-BEFEHL AUSFUEHREN
1130:	C0EC 4C AE	A7		JMP	$A7AE	;ZUR INTERPRETERSCHLEIFE
1140:	C0EF 4C FB	A8	R	JMP	$A8FB	
1200:	C0F2 20 73	00	IF	JSR	CHRGET	
1200:	C0F5 20 9E	AD		JSR	$AD9E	
1210:	C0F8 20 79	00		JSR	CHRGOT	
1220:	C0FE C9 89			CMP	#$89	
1230:	C0FD F0 05			BEQ	U	
1240:	C0FF A9 A7			LDA	#$A7	
1250:	C101 20 FF	AE		JSR	$AEFF	
1260:	C104 A5 61		u	LDA	$61	
1270:	C106 D0 05			ENE		
1280:	C108 20 09	A9		JSR	$A909	
1290:	C10E F0 E2			BEQ	R	
1300:	C10D 20 79	00	'l/	JSR	CHRGOT	
1310:	C110 E0 03			ECS	W	
1320:	C112 4C A0	A8		JMP	$A8A0	
1330:	C115 C9 AE		N	CMP	#$HE	
1340 :	C117 F0 06			BEQ	NE	
1350:	C119 C9 8E			CMP	#$8E	
1360:	CHB F0 05			EEQ	IF2	
1370:	CllD D0 EE			ENE	W I	
1380 : TUR	CllF 4C 10	C0	NE	JMP	NERT	;JMPJJEIL NOCH INNERHALB DER IF-STRUK
1390:	C122 4C F2	C0	IF2	JMP	IF	
programm			: \	rarfunkt					cOl(	) cl25
cOlO		a5	9d	{0	05	a2	15	4c	37	d3
c018		a4	a5	7a	85	8b	a5	7b	85	bd
c020	■	8c	aO	00	bl	7a	fO	Od	c9	2a
c028		b2	fO	Oe	e6	7a	dO	f4	e6	82
c030		7b	4c	23	cO	a2	Ob	4c	37	d4
c038		a4	20	73	00	20	9e	ad	a5	c2
c040		7a	8d	02	cO	a5	7b	8d	03	8c
c048		cO	a5	39	8d	04	cO	a5	3a	2c
c050		8d	05	cO	aO	00	bl	64	85	ce
c058		61	dO	05	a2	Oe	4c	37	a4	20
c060		c8	bl	64	85	62	c8	bl	64	c7
c068		85	63	aO	00	bl	8b	99	00	a5
c070		02	c8	c9	b2	dO	f6	a9	3d	85
c078		99	H	01	a2	00	al	62	99	6f
c080		00	02	c8	e6	62	dO	02	e6	13
c088		63	c6	61	dO	fO	8a	99	00	8a
c090		02	a9	ff	85	7a	a9	01	85	lb
c098		7b	a9	80	20	18	fe	20	73	ed
cOaO	>	00	a2	ff	86	3a	20	79	a5	98
cOa8		20	73	00	20	ed	a7	ad	02	5d
cObO		cO	85	7a	ad	03	cO	85	7b	ca
cOb8		ad	04	cO	85	39	ad	05	cO	df
cOcO		85	3a	a9	OO	85	9d	60	a9	e7
cOc8	*	d2	8d	08	03	a9	cO	8d	09	ac
cOdO		03	60	20	73	00	c9	ae	fO	65
cOd8	:	Oa	c9	8b	fO	Oc	20	79	OO	6f
cOeO		4c	e7	a7	20	10	cO	4c	ae	a3
cOe8	■	a7	20	f2	cO	4c	ae	a7	4c	e5
cOfO		4b	a8	20	73	00	20	9e	ad	8d
cOfB		20	79	00	c9	89	fO	05	a9	96
clOO		a7	20	ff	ae	a5	61	dO	05	40
clO8		20	09	*9	fO	e2	20	79	00	4a
cllO		bO	03	4c	aO	a8	c9	ae	fO	de
cll8		06	c9	8b	fO	05	dO	be	4c	6e
cl20		10	cO	4c	f2	cO	ff	00	ff	Oe
Listing 1			I. »Variable Funktionen							«.
Beachten Sie die Eingabehinweise auf Seite 8.										
Aufrufaus dem Programm
Die Übergabe der Variablen erfolgt in der denkbar einfachsten Art: die Formel steht in einer String-Variablen wie zum Beispiel X$. DaX$ ein normalerString ist, kann man die Formel natürlich auch über den INPUT-Befehl oder eine GET-Schleife eingeben, wobei man bei INPUT nicht über 80 Zeichen kommt undGET eineprogrammbedingteLängenbegrenzungvon 127 Zeichen hat. Die Syntax ist dabei die des normalen Basic mit sämtlichen Basic-Funktionen. Das heißt, daß man zum Beispiel die Formel »5 SIN X« als »5 * SIN(X)« eingibt. Dabei bedeutet X wiederum eine Variable. Natürlich kann die Formel beliebig viele Variablen, beziehungsweise beliebig verschachtelte Basic-Funktionen enthalten.
Die Syntax des neuen Befehls ist
f Y=B$
Hier wird der Variablen Y der Wert des berechneten Strings X$ zugewiesen.
Hierzu noch ein Beispielprogramm, das das Programm »Var-funkt« auf Diskette erwartet:
10 IFA=0THENA=1 :PRINT"[home]" :LOAD"VARFUNKT",8,1 20 SYS 49351
30 INPUT " pown] FUNKTION UEBER X " ;X$
40 INPUT " WERT FUER X " ;X
50 t Y=X$
60 PRINT " FUNKTIONSWERT = " ;Y
70 GOTO 30
In Zeile 10 wird beim Start die Maschinenroutine »Varfunkt« nachgeladen. Die IF-Abfrage ist nötig, da der Interpreter nach einem LOAD-Befehl das Programm erneut startet.
Der SYS-Aufruf in 20 bindet das nachgeladene Programm in das Betriebssystem ein.
In den Zeilen 30 und 40 werden Funktion und Wert für die Funktion eingegeben.
Zeile 50 schließlich übergibt den berechneten Wert aus X$ an die Variable Y, die in 60 ausgegeben wird.
Zeile 70schließt das Beispielprogramm ab, indem wieder in Zeile 30 zur Funktionseingabe gesprungen wird.
(Jens Weber/og)
110
Tips & Tricks
Cross-Ref 64 — Basic-Pro-gramme unter der Lupe
Wenn man zu einem Basic-Programm eine Liste aller Sprungadressen, Schleifen und Variablen hat, ist das eine sehr gute Hilfe Nicht nur während des Programmierens, sondern auch zur nachträglichen Dokumentation. Eine solche Liste erstellt dieses Maschi-nen-Programm.
Cross-Ref 64 durchsucht in zwei Durchgängen (Passes) ein Basic-Programm nach Sprungbefehlen und Variablen. Sämtliche Sprungziele und Variablennamen werden dann auf einem Drucker in Form einer Tabelle ausgegeben. Eine solche Tabelle nennt man Cross-Reference-List.
Das Basic-Programm kann dazu übrigens irgendwo im Basic-Speicher liegen. Es muß nicht bei Adresse $0801 beginnen. Das ist wichtig, denn häufig wird der untere Basic-Speicherteil für Sprites reserviert.
1.	Durchgang
lm ersten Durchlauf (Pass) werden Sprunganweisungen und FOR-NEXT-Schleifen gesucht und alle Zeilennummern der Zeilen ausgegeben, die eine Sprunganweisung enthalten oder angesprungen werden. Dabei werden alle Sprünge berücksichtigt, die das C 64-Basic 2.0 bietet. FOR-NEXT-Schleifen werden durch die Laufvariable gekennzeichnet. Eventuell vorhandene, noch nicht zu Ende geschriebene FOR-NEXT-Schleifen werden mit einem »*« markiert.
2.	Durchgang
Hier werden alle Variablen eines Basic-Programms gesucht und ausgegeben.
Die Ausgabe der Cross-Reference-Liste kann in beiden Durchgängen entweder auf Bildschirm oder Drucker erfolgen. Bei Bildschirmausgabe allerdings auch im Druckerformat mit 80 Zeichen/Zeile. Das bedeutet, daß zwei Bildschirmzeilen immer eine Druckerzeile darstellen. Doch wie sinnvoll ist überhaupt eine Dokumentation auf dem Bildschirm? Das Programm ist auf einen Epson-Drucker mit Görlitz-Interface angepaßt. Es kann aber leicht so verändert werden, daß es auch für andere
Drucker geeignet ist. Es müssen nur vier Speicherzellen mit POKE-Befehlen verändert werden.
Einstellung der Geräteadresse:
POKE 50517, GA : POKE 50519, GA
Einstellung der Sekundäradresse:
POKE 50521, SA+96 : POKE 50529, SA+96
Mit einem Monitor wie dem SMON oder dem Einzeiler »Maschinenprogramme speichern« (Ausgabe 11/84) können Sie die auf Ihren Drucker angepaßte Programmversion speichern:
SYS57812a$,x:POKE193,ls:P0KE194,hs:P0KE174,le:POKE 175,he:SYS62957
Dadurch ersparen Sie sich die lästigen POKE-Befehle nach jedem Laden von Cross-Ref 64. Das Programm belegt den Speicherbereich von $C000 (49152) bis $CAB6 (51894). Um Ihnen eventuelle Berechnungen zu ersparen: Das Highbyte (hs) von 49152 ist 192 das Lowbyte (ls) 0. Das Highbyte von 51894 (he) ist 202, das Lowbyte (le) 182.
Übersichtliches Ausgabeformat
Wie schon erwähnt, werden alle Zeilen, in denen ein Sprung erfolgt, ausgegeben. Die gezeigte Tabelle (Tabelle 1) bezieht sich auf das Beispielprogramm (Listing 1). Man kann sich auch eine Liste aller Sprungziele drucken lassen (Tabelle 2). Die Ausgabe erfolgt mit 80 Zeichen pro Zeile, dem üblichen Druckerformat.
Sollten offene FOR-NEXT-Schleifen (ohne NEXT) vorhanden sein, wird nach einem »*« die Anzahl der fehlenden NEXT-Befehle angezeigt. Sollte die Anzahl 255 betragen, heißt das, daß ein NEXT zuviel gefunden wurde.
Sollten in einer Basic-Zeile mehrere Sprünge auftreten, wird die mehrmalige Ausgabe der Zeilennummer unterdrückt.
Bei Sprungbefehlen der Form ON X GOSUB wird das Argument nach ON durch »—« ersetzt, da auch ganze Basic-Funk-tionen als Argument erlaubt sind. Um diese Funktionen zu berücksichtigen, wäre ein zu großer Programmieraufwand nötig. Treten nach einem THEN mehrere Sprünge auf, wird jedem Sprungziel ein THEN vorangestellt. Eine solche Befehlsfolge ist beispielsweise
IF X=1 THEN GOSUB 100:GOSUB 200:GOSUB 300.
Bei FOR-NEXT-Schleifen wird der ganze Variablenname angegeben.
Die Variablennamen werden in einer eigenen Tabelle ausgegeben (Tabelle 3). Hier werden die Namen allerdings auf zwei Zeichen gekürzt. In der Tabelle steht nach dem Namen der Variable der Variablentyp (Real, Integer oder String). Zwei Klammern »()« zeigen an, daß es sich um eine indizierte Variable handelt. Da eine Variable in einem Programmbereich sehr häufig benutzt werden kann, werden bei Mehrfachnennung einer Variablen nur noch die Zeilennummern angegeben; so lange, bis eine andere Variable aufgerufen wird. Wird einer Variablen ein anderer Wert zugeordnet (A=A+1), wird die Zeilennummer mit einem Stern »*« gekennzeichnet. Bei der sortierten
SPRUNGBEFEHLE
IN ZEILE	SPRUNG DURCH	NACH	IN ZEILE	SPRUNG DURCH	NACH
#xxxxxxxx	x X ::x x x x x x xn x x x x x x x x c	5 EX ^L X XE XE EX XE EX :x:	XX##XXXXKXXX#XXWXXXXXXXXXS8CXXXXX	#xxxxxaxxx*
20	GSUB	100	GOTO	200
40	RUN	50	60	THEN GSUB	100
	THEN GOTO	50	80	ON - GOTO	10,20,
30,40
100 THEN ON - GSUB	100,90,70,80
Tabelle 1. Liste der Zeilen, die Sprungbefehle enthalten
3J^
111
Tips & Tricks
Variablenausgabe (Tabelle 4), werden nach dem Variablenna-men alle Zeilen aufgeschlüsselt, in denen die Variable vorkommt. Das Sortieren geschieht nach den folgenden Kriterien:
1.	Typ: Real, integer, Strings, Felder
2.	Name alphabetisch
3.	Zeilennummern in aufsteigender Reihenfolge.
Die Ausgabe kann jederzeit durch Tastendruck gestoppt werden. Eine begonnene Druckzeile wird zu Ende gedruckt. Bei einem weiteren Tastendruck fährt das Programm fort. Mit RUN/STOP kann die Ausgabe abgebrochen werden.
Tips zu Eingabe und Benutzung
Das Maschinen-Programm (Listing 2) sollten Sie mit dem MSE eingeben. Es wird durch »SYS 49152, Parameterliste, Bereich« gestartet. Die »Parameterliste« muß aus genau fünf Zeichen bestehen (Leerzeichen nicht mitgerechnet). Folgende Zeichen sind erlaubt:
1.	Steife: P — Ausgabe auf Drucker
2.	Stelle: S — Ausgabe der Zeilen mit Sprungbefehlen (Tabelle 1)
3.	Stelle: J — Ausgabe der angesprungenen Zeilen (nur zusammen mit »S« an zweiter Stelle möglich (Tabelle 2)
4.	Stelle: V — Ausgabe der benutzten Variablen in der Reihen-
folge des Auftretens (Tabelle 3)
5.	Stelle: J — Ausgabe der benutzten Variablen in sortierter Reihenfolge (Tabelle 4)
Werden andere Zeichen an der entsprechenden Stelle angegeben, dann wird der Programmpunkt nicht ausgeführt.
Die Bereichsangabe ist optional und hat die gleiche Syntax wie beim LIST-Befehl. Falls ein Zeilenbereich angegeben wird, analysiert das Programm auch nur den entsprechenden Abschnitt. Ein Beispiel:
Es sollen alle Sprungbefehle und alle Variablen im Zeilenbereich 100-200 gesucht werden. Die Ausgabe soll auf dem Drucker erfolgen. Der entsprechende SYS-Aufruf lautet dann: SYS 49152, PS..J,100-200
Anstelle der Punkte kann dabei jedes beliebige andere Zeichen mit Ausnahme des Kommas angegeben werden.
Zum Sortieren der Variablen und für die Ausgabe der angesprungenen Zeilen wird das »Bubblesort«-Verfahren verwendet, da es besonders einfach in Assembler (Listing 3, Quellcode) programmiert werden kann. Die Variablen- und Sprungtabelle wird im Bereich $A000 bis $BFFF, also »unter« dem Basic-ROM, abgelegt. Falls also eine Basic-Erweiterung verwendet wird, darf dieser Speicherbereich dadurch nicht verändert werden.	(Peter Rüschhoff-Nadermann/hm)
			SPRUNGBEFEHLE			
			SÄÄ	22 22 22 22 22 22 22:22 22 22		
* ZIEL	* SPRUNG	DURCH	*	IN	** ZIEL	* SPRUNG DURCH	* IN	*
*==== = = = = =		::= := :s == = = = 2=	=S * 22 22 22 22 22 22	22 22 22^-^-22 22 22 22 22 22 22	22-M-22 22 22 22 22 22 22 22 22 22 22 22 22 22 22S2 23 22 2	S* = =33= = =3SS3S=S3=*
10	ON - GOTO		80	20	ON - GOTO	80
30	ON ~ GOTO		80	40	ON ~ GOTO	80
50	RUN		40	50	THEN GOTO	60
70	THEN ON ~	GSUB	100	80	THEN ON ~ GSUB	100
90	THEN ON -	GSUB	100	100	GSUB	20
100	THEN GSUB		60	100	THEN ON - GSUB	100
200	GOTO		20			
Tabelle 2. Liste der angesprungenen Zeilen

VARIABLEN
VARIABLE	ZEILEN	VARIABLE	ZEILEN
-» 22 22 22 22 22 22: 32 22 ^- ^-	= = = 3= = = 2a = **== = = ==22== = =S**2= = ==S=3= = =	= ** = = = =S = = ====**	22 32 22 22 22 2232 22^-4^22 22 2222 22 32 22 32^-^-2=22 22 22 22 22 22 22*
A	60	80	100	100	
B	120*	120	120*	120	
D	140	G	140
E	140	K	140
E	160*	G	160
D	160	K	160
D	160	K	160
Tabelle 3. Alle im Beispiel-Programm verwendeten Variablen
VARIABLEN
VARIABLE	ZEILEN		VARIABLE		ZEILEN	
* = = = = = =2 = = **;	2=2==3=3 = 23=3 3=**	32 32 32 32S2	=2==2**==2=s===2=	= =2**=3S=3= = =S = =S = **	SSS33X = 23SK	**=5 = =8 = =3S=3==S**S= = = S=S=S==33=*
A	60	80	100	100		
B	120	120	120*	120*		
D	140	160	160	E	140	160*
G	140	160		K	140	160	160
Tabelle 4. Alle Variablen des Beispiel-Programms in sortierter Reihenfolge.
Tips & Tricks
programm		: cross-ref					c000 cab7		
c000	4c	03	c9	20	55	c0	20	e3	e8
c008	c8	20	fe	c5	4c	ff	c4	ad	8c
c010	b0	ca	4a	4a	b0	03	20	55	50
c018	c0	20	7e	c7	20	8b	c2	20	2b
c020	36	c4	b0	01	60	20	9c	c7	0e
c028	20	8d	c7	20	e3	c8	20	fe	08
c030	c5	4c	ff	c4	20	c9	c0	20	47
c038	H	c4	4c	7e	c7	20	8b	c2	ad
c040	20	36	c4	b0	01	60	20	9c	8f
c048	c7	20	8d	c7	20	ad	c8	20	4e
c050	16	c8	4c	ff	c4	a9	06	85	9a
6058	b6	20	bl	c3	20	ba	c3	4c	83
c060	65	c0	20	b8	c2	a9	80	8d	db
c068	ad	ca	a5	bd	c9	ff	d0	01	7d
c070	60	20	e5	c3	c9	20	f0	f9	27
c078	c9	00	f0	e6	c9	22	f0	32	30
c080	c9	8f	+ 0	de	c9	a7	+ 0	22	0b
c088	c9	88	f0	le	c9	3a	f0	la	fc
c090	c9	81	f0	16	20	10	c4	90	cf
c098	09	20	96	c6	20	0f	c7	20	0a
c0a0	45	c4	ä2	00	8e	ad	ca	4c	0a
c0a8	71	c0	a2	80	8e	ad	ca	4c	4c
c0b0	71	c0	20	e5	c3	c9	79	f0	3b
c0b8	07	c9	00	f0	06	4c	b2	c0	dl
C0C0	4c	71	c0	20	b8	c2	4c	71	af
c0c8	c0	a9	05	85	b6	8d	ae	ca	77
c0d0	20	bl	c3	20	ba	c3	a5	bd	9a
c0d8	c9	ff	f0	15	20	c3	c8	a9	16
c0e0	00	8d	a5	ca	4c	ea	c0	20	c9
c0e8	b8	c2	a5	bd	c9	ff	d0	01	04
c0f0	60	a9	01	8d	a8	ca	20	e5	44
c0f8	c3	c9	00	f0	ea	c9	22	f0	25
cl00	3b	c9	8f	f0	e2	c9	89	f0	a6
cl08	lb	c9	8d	f0	la	c9	a7	f0	fa
cll0	19	c9	8a	f0	18	c9	91	f0	c6
cll8	17	c9	81	f0	16	c9	82	f0	2e
cl20	15	4c	f6	c0	4c	53	cl	4c	30
cl28	5b	cl	4c	52	c2	4c	63	cl	61
cl30	4c	d6	cl	4c	7c	cl	4c	9d	23
cl38	cl	4c	f6	c0	20	e5	c3	c9	c9
cl40	22	f0	07	c9	00	f0	06	4c	0e
cl48	3c	cl	4c	f6	c0	20	b8	c2	cc
cl50	4c	f6	c0	20	5d	c4	a9	02	f2
cl58	4c	76	c2	20	5d	c4	a9	04	3f
cl60	4c	76	c2	20	25	c4	20	19	c7
cl68	c4	90	0e	20	5d	c4	ce	a4	7c
cl70	ca	ac	a4	ca	a9	10	4c	76	4c
cl78	c2	4c	f6	c0	20	5d	c4	ee	14
cl80	a6	ca	a9	40	8d	a3	ca	20	5f
cl88	d4	c5	20	25	c4	c9	b2	f0	33
cl90	06	20	f7	c3	4c	8a	cl	20	7d
cl98	d2	c4	4c	f6	c0	ad	a4	ca	60
cla0	48	ce	a6	ca	20	e5	c3	20	d3
cla8	2d	c4	f0	07	c9	2c	f0	fl	fa
clb0	4c	a4	cl	68	8d	a4	ca	20	35
clb8	5d	c4	a9	20	8d	a3	ca	20	47
clc0	d4	c5	20	25	c4	20	2d	c4	af
clc8	f0	06	20	f7	c3	4c	c2	cl	ef
cld0	20	d2	c4	4c	f6	c0	20	5d	c5
cld8	c4	20	25	c4	c9	89	f0	07	49
cle0	c9	8d	f0	08	4c	d9	cl	a9	9b
cle8	0a	4c	ee	cl	a9	0c	20	0b	9e
clf0	c8	ad	a3	ca	29	fe	85	bd	ed
clf8	8d	a%i	ca	a2	00	20	d4	c5	3e
c200	20	3c	c5	20	25	c4	ce	a4	bl
c208	ca	20	d4	c7	a5	bd	20	3f	58
c210	c2	20	ea	c7	20	79	00	f0	46
c218	ld	c9	2c	d0	ef	20	f7	c3	a6
c220	ad	a5	ca	c9	4b	90	e5	20	9d
c228	f7	c4	20	3c	c5	20	3c	c5	eb
c230	20	3c	c5	4c	0c	c2	20	2e	ld
c238	c5	20	f7	c4	4c	f6	c0	a0	64
c240	02	91	fb	20	a2	c4	a0	03	e7
c248	a5	62	91	fb	c8	a5	63	91	6c
c250	fb	60	20	25	c4	20	19	c4	63
c258	90	11	20	5d	c4	a9	80	20	00
c260	0b	c8	ce	a4	ca	ac	a4	ca	52
c268	4c	76	c2	ce	a4	ca	a9	80	c2
c270	8d	a8	ca	4c	f6	c0	8d	a3	80
c278	ca	20	0b	c8	20	d4	c5	20	2e
c280	3c	c5	20	e7	c7	20	d2	c4	f6
c288	4c	f6	c0	20	00	c4	a9	00	50
c290	8d	a7	ca	8d	a5	ca	8d	a6	89
c298	ca	8d	a3	ca	85	bd	8d	ad	43
c2a0	ca	85	57	a9	a0	85	58	a9	23
c2a8	f9	8d	a9	ca	85	fb	a9	bf	8a
c2b0	8d	aa	ca	85	fc	4c	d2	c3	fb
c2b8	a0	00	bl	f9	d0	05	c8	bl	c0
c2c0	f9	f0	0f	a5	f9	85	f7	a5	al
c2c8	fa	85	f8	20	a5	c3	f0	11	25
c2d0	90	0f	a5	fb	8d	ab	ca	a5	7d
c2d8	fc	8d	ac	ca	a9	ff	85	bd	4b
c2e0	60	ad	a7	ca	29	0e	8d	a7	e3
c2e8	ca	a0	03	8c	a4	ca	a0	00	78
c2f0	bl	f7	85	f9	c8	bl	f7	85	42
c2f8	fa	60	a9	00	8d	b0	ca	8d	31
c300	bl	ca	8d	b2	ca	a9	ff	8d	e5
c308	b3	ca	8d	b4	ca	20	79	00	ae
c310	c9	2c	f0	05	a2	0b	4c	37	ee
c318	a4	20	73	00	c9	50	d0	03	12
c320	20	56	c5	20	73	00	c9	53	e6
c328	d0	05	a9	08	20	92	c3	20	cc
c330	73	00	c9	4a	d0	05	a9	04	43
c338	20	92	c3	20	73	00	c9	56	al
c340	d0	05	a9	02	20	92	c3	20	23
c348	73	00	c9	4a	d0	05	a9	01	55
c350	20	92	c3	20	73	00	c9	4b	a3
c358	d0	08	a9	10	20	92	c3	20	7f
Listing 2. »Cross-Ref 64«. Das Programm sollte mit dem MSE eingegeben werden. Beachten Sie dazu bitte die Eingabehinweise auf Seite 8.									

113
Tips & Tricks
c360		73	00	c9	2c	d0	2b	c9	ab	b0	c538	■	20	f7	c4	60	ad	a5	ca	38	35
c368		f0	17	20	73	00	20	6b	a9	5c	c540	a	e9	0a	b0	fc	49	ff	69	01	36
c370		a5	14	8d	bl	ca	a5	15	8d	02	c548	B	aa	e8	ca	f0	08	a9	20	20	c6
c378	■	b2	ca	20	79	00	c9	ab	d0	65	c550	a	f7	c3	4c	4a	c5	60	a9	04	93
c380	B	10	20	73	00	20	6b	a9	a5	cd	c558	a	a2	04	a0	68	20	ba	ff	20	4a
c388	*	14	8d	b3	ca	a5	15	8d	b4	4c	c560	a	bl	ff	a9	68	20	93	ff	a9	7a
c390	B	ca	60	0d	b0	ca	8d	b0	ca	55	c568	a	04	85	9a	60	ad	b5	ca	c9	29
c398		60	20	a2	c4	ec	b2	ca	d0	7b	c570	a	35	d0	19	a9	37	85	01	a9	80
c3a0	■	03	cd	bl	ca	60	20	a2	c4	6b	c578	a	a0	85	04	a0	00	bl	03	91	ad
c3a8	v	ec	b4	ca	d0	03	cd	b3	ca	be	c580		03	c8	d0	f9	e6	04	a5	04	88
c3b0	a	60	a9	a0	85	58	a9	00	85	9b	c588	■	~c9	c0	d0	fl	ad	b6	ca	85	ea
c3b8	*	57	60	20	8b	c2	20	b8	c2	4e	c590	a	7a	ad	b7	ca	85	7b	a9	04	0b
c3c0		a5	bd	c9	ff	d0	06	20	6c	4d	c598	a	20	ae	ff	20	c3	ff	a9	03	fc
c3c8		c5	4c	ae	a7	20	99	c3	90	53	c5a0	a	85	9a	ad	b5	ca	85	01	60	32
c3d0	£	ec	60	a5	2b	85	f9	a5	2c	d2	c5a8	a	20	09	c4	20	87	b4	20	a6	6e
c3d8		85	fa	60	ce	a4	ca	20	e8	bf	c5b0	a	b6	48	a6	bd	d0	03	20	cl	15
c3e0		c3	ee	a4	ca	60	ee	a4	ca	42	c5b8	a	c4	68	aa	a0	00	e8	ca	f0	c3
c3e8		ac	a4	ca	bl	f7	60	20	09	e4	c5c0	a	10	bl	22	20	f7	c3	c8	c9	8a
c3f0		c4	20	3e	fl	4c	00	c4	ee	48	c5c8	a	0d	d0	f3	20	e5	aa	4c	be	al
c3f8		a5	ca	20	09	c4	20	d2	ff	c4	c5d0	a	c5	4c	00	c4	a2	00	ad	a8	86
c400		48	a5	01	29	fe	85	01	68	71	c5d8	a	ca	0d	a3	ca	8d	a3	ca	0e	a8
c408		60	48	a9	37	85	01	68	60	a0	c5e0	a	a3	ca	b0	08	e8	e8	e8	e8	61
c410		20	09	c4	20	13	bl	4c	00	da	c5e8	a	e8	4c	df	c5	a0	05	bd	7a	c5
c418		c4	c9	3a	10	06	c9	30	30	21	c5f0	a	ca	20	f7	c3	e8	88	d0	f6	45
c420		02	38	60	18	60	20	e5	c3	80	c5f8	a	ad	a3	ca	d0	e2	60	ad	a9	7f
c428		c9	20	f0	f9	60	c9	00	f0	b3	c600	a	ca	85	fb	ad	aa	ca	85	fc	52
c430		04	c9	3a	f0	00	60	ad	aa	d5	c608	a	ad	ab	ca	85	57	ad	ac	ca	19
c438		ca	cd	ac	ca	d0	06	ad	a9	b4	c610	a	85	58	a9	05	8d	ae	ca	20	86
c440		ca	cd	ab	ca	60	20	67	c7	69	c618	a	ff	c4	20	67	c7	f0	6e	20	6c
c448		b0	12	20	6c	c5	a9	5a	a2	ef	c620	a	90	c6	a0	01	bl	fb	20	f7	c7
c450		ca	20	84	c8	ad	b5	ca	85	23	c628	a	c3	c8	bl	fb	c9	20	f0	03	a2
c458	B	01	4c	ae	a7	60	20	a2	c4	3b	c630	a	20	f7	c3	20	ea	c6	20	3c	lf
c460	a	a0	04	91	fb	88	8a	91	fb	01	c638	a	c5	a0	03	bl	fb	85	62	c8	4b
c468	a	a9	00	85	bd	ad	a7	ca	4a	02	c640	a	bl	fb	85	63	a9	00	85	bd	e9
c470	■	b0	12	ad	a7	ca	09	01	8d	9e	c648	a	20	af	c4	a0	05	bl	fb	0a	67
c478		a7	ca	20	af	c4	a2	27	a0	c2	c650	a	90	05	a9	2a	20	f7	c3	20	24
c480		02	4c	88	c4	a2	22	a0	07	2f	c658	B	3c	c5	ee	af	ca	20	41	c7	6b
c488	a	ad	a6	ca	85	63	f0	0c	85	e5	c660	8	08	20	0f	c7	20	67	c7	f0	73
c490	a	bd	20	ee	c5	a9	00	85	62	47	c668	a	23	28	f0	cd	ad	af	ca	c9	ac
c498	a	20	af	c4	a9	00	85	bd	4c	b2	c670	a	08	90	0c	20	f7	c4	20	2e	4a
c4a0	a	3c	c5	a0	03	bl	f7	aa	88	de	c678	a	c5	20	90	c6	4c	86	c6	c9	f2
c4a8		bl	f7	86	62	85	63	60	20	78	c680	a	04	90	03	20	ee	c4	20	d2	cc
c4b0		09	c4	a2	90	38	20	49	bc	f9	c688	a	c4	4c	lf	c6	28	4c	ff	c4	81
c4b8	£	20	df	bd	20	a8	c5	4c	00	25	c690	B	a9	00	8d	af	ca	60	a0	01	c7
c4c0	a	c4	49	ff	69	06	a8	f0	09	dl	c698	a	91	fb	20	e5	c3	a0	02	20	75
c4c8	a	a9	20	20	f7	c3	88	4c	c6	c8	c6a0	a	10	c4	b0	0d	20	19	c4	b0	lf
c4d0	a	c4	60	ad	a7	ca	4a	4a	90	6e	c6a8	a	08	aa	a9	20	91	fb	4c	b7	0d
c4d8	a	06	20	2e	c5	4c	f7	c4	ae	28	c6b0	a	c6	91	fb	20	e5	c3	aa	a9	bc
c4e0	a	a5	ca	e0	28	b0	08	a9	20	5a	c6b8	a	40	e0	24	f0	0a	e0	25	f0	ae
c4e8	a	20	f7	c3	4c	df	c4	ad	a7	a8	c6c0	a	05	4a	4a	4c	cd	c6	4a	48	d3
c4f0	8	ca	09	02	8d	a7	ca	60	ad	lf	c6c8	a	20	e5	c3	aa	68	e0	28	d0	fl
c4f8	£	a7	ca	29	0d	8d	a7	ca	a9	85	c6d0	8	02	09	80	a0	00	91	fb	20	48
c500	a	0d	20	f7	c3	a9	00	8d	a5	b0	c6d8	8	a2	c4	a0	04	91	fb	88	8a	b5
c508	a	ca	20	ee	c3	f0	lf	c9	03	4c	c6e0	a	91	fb	ad	ad	ca	a0	05	91	79
c510	a	d0	12	20	6c	c5	a9	6d	a2	24											
c518	■	ca	20	84	c8	ad	b5	ca	85	eb											
c520		01	4c	ae	a7	20	ee	c3	f0	52											
c52B		fb	c9	03	f0	e5	60	ce	ae	el											
c530	£	ca	d0	08	a9	05	8d	ae	ca	a7	Listing 2. >		»Cross-Ref		64«.	(Fortsetzung)					
114
Tips & Tricks
c6e8	fb	60	a0	00	bl	fb	4a	4a	f4
c6fB	4a	4a	4a	b0	0a	a2	25	4a	e7
c6f8	b0	01	ca	8a	20	f7	c3	bl	61
c700	fb	0a	90	0a	a9	28	20	f7	b2
c708	c3	a9	29	20	f7	c3	60	38	7e
c710	a5	fb	e5	b6	85	fb	b0	02	02
c718	c6	fc	60	a5	fc	85	fe	38	91
c720	a5	fb	e5	b6	85	fd	b0	02	22
c728	c6	fe	60	a0	00	18	bl	fb	19
c730	dl	fd	f0	04	b0	0a	90	08	6a
c738	c8	c4	b6	f0	03	4c	2d	c7	05
c740	60	20	lb	c7	a9	03	85	b6	a6
c748	20	2b	c7	08	a9	06	85	b6	3f
c750	28	60	a0	00	c4	b6	f0	0e	b2
c758	bl	fb	48	bl	fd	91	fb	68	7c
c760	91	fd	c8	4c	54	c7	60	a5	fc
c768	fc	c5	58	d0	04	a5	fb	c5	60
c770	57	60	18	a5	57	65	b6	85	39
c778	57	90	02	e6	58	60	18	ad	b9
c780	ab	ca	65	b6	8d	ab	ca	90	43
c788	03	ee	ac	ca	60	38	ad	ab	5d
c790	ca	e5	b6	8d	ab	ca	b0	03	86
c798	ce	ac	ca	60	ad	ab	ca	85	e9
c7a0	57	ad	ac	ca	85	58	ad	a9	77
c7a8	ca	85	fb	c5	57	08	ad	aa	ae
c7b0	ca	85	fc	c5	58	d0	03	28	9d
c7b8	f0	19	20	lb	c7	20	2b	c7	5a
c7c0	90	03	20	52	c7	20	0f	c7	6d
c7c8	20	67	c7	d0	ed	20	72	c7	el
c7d0	4c	a6	c7	60	ad	a4	ca	18	c9
c7d8	65	f7	85	7a	08	a5	f8	85	86
c7e0	7b	28	90	02	e6	7b	60	20	e0
c7e8	d4	c7	20	09	c4	20	73	00	e4
c7f0	20	6b	a9	a0	00	a5	15	91	e9
c7f8	fb	85	62	c8	a5	14	91	fb	al
c800	85	63	20	0f	c7	20	af	c4	e7
c808	4c	45	c4	a0	02	0d	a8	ca	fd
c810	8d	a3	ca	91	fb	60	ad	ab	24
c818	ca	85	57	ad	ac	ca	85	58	18
c820	ad	a9	ca	85	fb	ad	aa	ca	72
c828	85	fc	a9	00	8d	a7	ca	8d	f2
c830	a5	ca	a9	05	8d	ae	ca	a9	12
c83B	f6	8d	a6	ca	20	67	c7	f0	36
c840	42	a0	00	84	bd	bl	fb	85	c7
c848	62	c8	bl	fb	85	63	20	af	4d
c850	c4	20	3c	c5	a0	02	bl	fb	c5
c858	2c	a6	ca	d0	02	29	fe	8d	24
c860	a3	ca	a2	00	86	bd	20	df	a8
c868	c5	a0	03	bl	fb	85	62	c8	7b
c870	bl	fb	85	63	20	3c	c5	20	28
c878	af	c4	20	d2	c4	20	0f	c7	05
c880	4c	3c	c8	60	8d	90	c8	8e	c6
c888	91	c8	a2	00	8e	a5	ca	ad	c3
c890	ff	ff	f0	12	c9	ff	f0	0f	8c
c898	20	f7	c3	ee	90	c8	d0	03	lb
c8a0	ee	91	c8	4c	8f	c8	60	20	13
c8a8	3c	c5	4c	9b	c8	a9	45	a2	82
c8b0	c9	20	84	c8	a0	02	a9	ec	5e
c8b8	a2	c9	20	84	c8	88	d0	f6	d9
c8c0	4c	d6	c8	a9	45	a2	c9	20	af
c8c8	84	c8	a0	02	a9	6f	a2	c9	4d
c8d0	20	84	c8	88	d0	f6	a0	02	cl
c8d8	a9	91	d2	c9	20	84	c8	88	86
c8e0	d0	f6	60	a9	15	a2	ca	20	4a
c8e8	84	c8	a0	02	a9	39	a2	ca	bd
c8f0	20	84	c8	88	d0	f6	a0	08	ed
c8f8	a9	4f	a2	ca	20	84	c8	88	a5
c900	d0	f6	60	20	fa	c2	a5	7a	b9
c908	8d	b6	ca	a5	7b	8d	b7	ca	f0
c910	a5	01	8d	b5	ca	20	00	c4	87
c918	ad	b0	ca	4a	4a	4a	4a	90	5a
c920	0e	20	34	c0	ad	b0	ca	4a	84
c928	4a	4a	90	03	20	3d	c0	ad	66
c930	b0	ca	4a	4a	90	03	20	03	c9
c938	c0	ad	b0	ca	4a	90	03	20	ca
c940	0f	c0	4c	6c	c5	0d	ff	ff	15
c948	ff	20	20	20	20	53	50	52	e6
c950	55	4e	47	42	45	46	45	48	13
c958	4c	45	0d	ff	ff	ff	ff	20	ca
c960	3d	3d	3d	3d	3d	3d	3d	3d	60
c968	3d	3d	3d	3d	3d	0d	00	20	b7
c970	49	4e	20	5a	45	49	4c	45	8e
c978	20	20	20	20	53	50	52	55	60
c980	4e	47	20	44	55	52	43	48	88
c988	ff	20	20	4e	41	43	48	ff	b9
c990	00	2a	3d	3d	3d	3d	3d	3d	ca
c998	3d	3d	2a	3d	3d	3d	3d	3d	d3
c9a0	3d	3d	3d	3d	3d	3d	3d	3d	a0
c9a8	3d	3d	3d	3d	3d	3d	2a	3d	5c
c9b0	3d	3d	3d	3d	3d	3d	3d	3d	b0
c9b8	2a	00	ff	ff	ff	41	4e	47	b4
c9c0	45	53	50	52	55	4e	47	45	7d
c9c8	4e	45	20	5a	45	49	4c	45	67
c9d0	4e	0d	ff	ff	ff	20	3d	3d	15
c9d8	3d	3d	3d	3d	3d	3d	3d	3d	d8
c9e0	3d	3d	3d	3d	3d	3d	3d	3d	e0
c9e8	3d	3d	0d	00	2a	20	20	5a	e0
c9f0	49	45	4c	20	20	2a	20	20	07
c9f8	20	53	50	52	55	4e	47	20	45
ca00	44	55	52	43	48	20	20	20	32
ca08	20	2a	20	20	20	49	4e	20	0f
cal0	20	20	20	2a	00	0d	ff	ff	f6
cal8	ff	20	20	20	20	20	20	56	64
ca20	41	52	49	41	42	4c	45	4e	3d
ca28	0d	ff	ff	ff	ff	20	3d	3d	a5
ca30	3d	3d	3d	3d	3d	3d	3d	0d	d0
ca38	00	20	56	41	52	49	41	42	ff
ca40	4c	45	20	20	20	5a	45	49	b7
ca48	4c	45	4e	ff	ff	ff	00	2a	lf
ca50	3d	3d	3d	3d	3d	3d	3d	3d	50
ca58	2a	00	0d	53	50	45	49	43	0b
Listing 2. »Cross-Ref			64«.	(Fortsetzung)					
115
Tips & Tricks
ca60	■	48	45	52	20	56	4f	4c	4c	8d	ca98 :	47	4+	54	4+	20	20	20	20	4a
ca68	a	20	21	21	0d	00	0d	41	42	f5	caa0 :	20	20	2a	00	00	00	00	00	5b
ca70	a	42	52	55	43	48	20	21	21	e5	caa8 :	00	f9	bf	00	00	00	05	00	a9
ca78	a	0d	00	54	48	45	4e	20	46	77	cab0 :	00	00	00	00	00	00	00	00	bl
ca80	a	4f	52	20	20	4e	45	58	54	le										
ca88	a	20	52	55	4e	20	20	4+	4e	cd										
ca90	a	20	2d	20	47	53	55	42	20	61	Listing 2.	»Cross-Ref		64«.	(Schluß)					
	= $C0B0		BEQ		SETDB		CFOR	JMP	FOR	
AKOPADR	= $F7			CMP	* '	!	; STATEMENT	CNEXT	JMP	NEXT	
NKOPADR	= $F9			BEQ	SETDB			JMP	SPRLOOP	
CHRGET	= $0073			CMP	#$81	:	; FOR	SPRSUCH	JSR	NXTCHR	
CHRGOT	= $0079			BEQ	SETDB			CMP	#$22	
GETZEIL	= $A96B			JSR	CHKALPH			BEQ	LSS1	
TABENDL	= $57			BCC	LTEST1			CMP	«0	
TABENDH	= $58			JSR	VARGET			BEQ	LSS2	
ZEI1L	= $FB			JSR	I N Z E 11			JMP	SPRSUCH	
ZEIlH	= $FC			JSR	OVFLOW		LSS1	JMP	SPRLOOP	
ZEI2L	= $FD		LTEST1	LDX	#7.00000000		LSS2	JSR	NEXTLINE	
ZEI2H	= $FE			STX	DBSTAT			JMP	SPRLOOP	
LAENGE	= $B6			JMP	VARLOOP					
TEMP	= $BD		SETDB	LDX	#7.10000000		GOTO	JSR	ZEILOUT	
•***************************************				STX	DBSTAT			LDA	«7.00000010	
	JMP SCONTROL			JMP	VARLOOP			JMP	AUSGABE	
VAR	JSR VSTART	SUCHT VARIABLEN	VARSUCH	JSR	NXTCHR					
	JSR DRVAR	AUSGABE V.KOPF		CMP	#$22		GOSUB	JSR	ZEILOUT	
	JSR VAROUT	"	DER VAR.		BEQ	LWS1			LDA	«7.0000010»	
	JMP CARET2	ZEILENVORSCHUB		CMP	#0			JMP	AUSGABE	
VAR2	LDA SYSTAT	; VAR. IN REIHENF.		BEQ	LWS2					
	LSR A			JMP	VARSUCH		RUN	JSR	CHKSPC ;	NAE. ZCHN NUM.?
	LSR A	5	LWS1	JMP	VARLOOP			J4R	CHKNUM ;	JA: AUSGABE
	BCS VAR3		LWS2	JSR	NEXTLINE			BCC	LRUN1	;	NEIN: WEITER
	JSR VSTART	; NEIN: SUCHEN		JMP	VARLOOP			JSR	ZEILOUT	
VAR3	JSR INTEND ;	; TAB. UM 1 KUERZ.						DEC	POINTER ;	DA CHKSPC AUF N.
	JSR INIT	; INITIALSIEREN	SPRUNG	LDA	#5	;	= ZNR+CODE+ZNR		LDY	POINTER ;	ZCHN STELLT
	JSR TESTTAB 5	I TABELLE LEER?		STA	LAENGE			LDA	«7.00010000	
	BCS LVAR2			STA	LINES ;	LF NACH 5 ZEILEN		JMP	AUSGABE	
	RTS	;	; JA: RTS		JSR	SETTAB		LRUN1	JMP	SPRLOOP	
LVAR2	JSR SORT	; TAB. SORTIEREN		JSR	SETBER					
	JSR DECTEND			LDA	TEMP		FOR	JSR	ZEILOUT	
	JSR DRVAR			CMP	#$FF			INC	FANZ	;	OFFENE FOR+1
	JSR VAROUT			BEQ	SZEILE2			LDA	«7.01000000	
	JMP CARET2			JSR	DRSPR			STA	TSTAT	
SPR	JSR SPRUNG ;	SPRUENGE SUCHEN		LDA	#0			JSR	TEXTAUS	
	JSR CARET2 ;	UND AUSGEBEN		STA	ZLANG		LFOR1	JSR	CHKSPC ;	TEXT BIS '-' AUS-
	JMP INTEND			JMP	SZEILE1			CMP	#$B2	;	GEBEN ('*':$B2)
AN	JSR INIT	;	[ ANGESPRUNGENE	SZEILE	JSR	NEXTLINE			BEQ	LF0R2 ;	
	JSR TESTTAB ।	; ZEILEN AUSGEBEN	SZEILE1	LDA	TEMP	i	I KODE FUER ENDE?		JSR	CHROUT ;	GEBEN
	BCS LAN1			CMP	#$FF			JMP	LFOR1	
	RTS			BNE	SZEILE2		LF0R2	JSR	LINEFEED	
LAN1	JSR SORT			RTS				JMP	SPRLOOP	
	JSR DECTEND		SZEILE2	LDA	#7.00000001 : STATUS FUER					
	JSR DRAN			STA	THSTAT	; 5 LEERZEICHEN	NEXT	LDA	POINTER	
	JSR ZIELE		SPRLOOP	JSR	NXTCHR			PHA		
	JMP CARET2			CMP	«0	;	i ZEILENENDE ?	NEXT1	DEC	FANZ	
				BEQ	SZEILE		NEXT2	JSR	NXTCHR	
VSTART	LDA #6	; = ZNR+CODE+ZNR		CMP	#$22	;	, =" ODER = REM?		JSR	TRZCHN	
	STA LAENGE			BEQ	SPRSUCH J	I DANN BIS " 0.		BEQ	NEXT3	
	JSR SETTAB			CMP	*$8F	;	, NEUE ZEILE		CMP	#',	
	JSR SETBER			BEQ	SZEILE i	; WEITER		BEQ	NEXT1	
	JMP VZEILE2			CMP	#$89	;	i GOTO ?		JMP	NEXT2	
VZEILE	JSR NEXTLINE			BEQ	CGOTO		NEXT3	PLA		
VZEILE2	LDA #7.10000000			CMP	#$8D	;	GOSUB ?		STA	POINTER	
	STA DBSTAT			BEQ	CGOSUB			JSR	ZEILOUT	
	LDA TEMP	; KODE FUER ENDE?		CMP	#$A7	;	THEN ?		LDA	#7.00100000	
	CMP #$FF	; NEIN: WEITER		BEQ	CTHEN			STA	TSTAT	
	BNE VARLOOP	; JA: ENDE		CMP	#$8A	;	RUN ?		JSR	TEXTAUS	
	RTS			BEQ	CRUN		LNEXT1	JSR	CHKSPC	
VARLOOP	JSR NXTCHR			CMP	#$91	;	ON ?		JSR	TRZCHN ;	SOLANGE ZCHN
	CMP #$20			BEQ	CON			BEQ	LNEXT3 ;	AUSG. BIS Z.ENDE
	BEQ VARLOOP			CMP	#$81	;	FOR ?		JSR	CHROUT	
	CMP #0	;	I ZEILENENDE ?		BEQ	CFOR			JMP	LNEXT1	
	BEQ VZEILE			CMP	#$82	;	NEXT ?	LNEXT3	JSR	LINEFEED	
	CMP #$22	;	=” ODER = REM?		BEQ	CNEXT			JMP	SPRLOOP	
	BEQ VARSUCH ;	I DANN BIS " 0.		JMP	SPRLOOP					
	CMP #$8F	;	NEUE ZEILE	CGOTO	JMP	GOTO					
	BEQ VZEILE ;	I WEITER	CGOSUB	JMP	GOSUB					
	CMP #$A7	; BEQ SETDB	THEN	CTHEN CRUN	JMP JMP	THEN RUN		Listing	3. Der Source-Code von		
	CMF #$88	;	I LET	CON	JMP	ON		»Cross-Ref 64«.			
116

<h mehr aktueile
'ormationen zum Thema
nspeicher
das Oktoberheft
Themi
iiSr
★ Einstellhinweise für Datasette und VC 1541 ★ 100 Blocks in 3 Sekunden laden: Prologic DOS und
>s + im Test ★ 2 MByte-
Speicher an C 64: Praxistest der großen Commodore-Laufwerke ★ Marktübersicht Disketten
...weiters zum Thema
Lernsoftware:
★ Besser lernen mit dem Computer ★ Roboter — selbstgebaut ★ Lernen durch Simulation ★ Marktübersicht: Lernsoftware
...außerdem:
★ Comal 80: Eine neue Programmierspache macht aus Ihrem C 64 einen völlig neuen Computer ★ Directory-Manipulation II: Noch mehr Tricks ★ Das besondere Spiel: »Pac-Man unter der Lupe« ★ und natürlich »64’er-Extra« — geballte Information auf einen Blick. Diesmal: Alle Register des VIC II-Chips!
...und im C 128-Sonderteil:
★ Fragen und Antworten zum C 128 ★ Was kann Basic 7.0? ★ Wie kompatibel ist der C 128? ★ Im Test: das VC 1571 Laufwerk
8 ^^™ Gutechein ^^=
FÜR EIN KOSTENLOSES PROBEEXEMPLAR DES 64’er-MAGAZINS
JA, ich möchte das »64’er-Magazin« kennenlernen.
Senden Sie mir bitte die aktuellste Ausgabe kostenlos als Probeexemplar. Wenn mir »64’er« gefällt und ich es regelmäßig weiterbeziehen möchte, brauche ich nichts zu tun: Ich erhalte »64’er« dann regelmäßig frei Haus per Post und bezahle pro Jahr DM 78,— (Ausland auf Anfrage)
Vorname, Name
Straße	PLZ, Ort
Das 64’er-Magazin gibt’s jeden Monat neu bei Ihrem Zeitschriftenhändler
Datum 1. Unterschrift
Mir ist bekannt, daß ich diese Bestellung innerhalb von 8 Tagen bei der Bestelladresse widerrufen kann und bestätige dies durch meine zweite Unterschrift. Zur Wahrung der Frist genügt die rechtzeitige Absendung des Widerrufs.
Datum
2. Unterschrift
Gutschein ausfüllen, ausschneiden, in ein Kuvert stecken und absenden an: Markt&Technik
Verlag Aktiengesellschaft, Vertrieb, Postfach 1304, 8013 Haar
64S0585
Tips & Tricks
5				JMP		BASTRT		BNE		LSYS8 ;	NEIN; ENDE
ON	JSR	ZEILOUT						LSYS7	JSR	CHRGET	
LON1	JSR	CHKSPC		NEXTLINE	LDY	#0			JSR	GETZEIL	
	CMP	#$89	J	GOTO ?		LDA	(NKOPADR),Y			LDA	$14	
	BEQ	ONTO			BNE	LNL1			STA	BERENL	
	CMP	#$8D	;	GOSUB?		INY				LDA	$15	
	BEQ	ONSUB			LDA	(NKOPADR),Y			STA	BERENH	
	JMP	LON1			BEQ	NLENDE		LSYS8	RTS		
ONTO	LDA	#7.80001010		LNL1	LDA	NKOPADR					
	JMP	L0N2			STA	AKOPADR		SETSVS	ORA	SYSTAT ;	<AC> MIT SYSTAT
ONSUB	LDA	#7.00001100			LDA	NKOPADR	+ 1		STA	SYSTAT	VERKNUEPFEN
L0N2	JSR	SORCOD			STA	AKOPADR	+ 1		RTS		
	LDA	TSTAT			JSR	CKBEN ;	ENDE BEREICH?		5		
	AND	#711111110			BEQ	LNL2 ;	NEIN	;**************************************			
	STA	TEMP			BCC	LNL2 ;		CKBST	JSR	ZNR	;	TEST, OB AKT. ZNR
	STA	TSTAT							CPX	BERSTH ;	GROESSER ODER
	LDX	#0		NLENDE	LDA	,ZEIlL |	SETZT TABELLEN-		BNE	LBST1 ;	GLEICH BER. ANF
	JSR	TEXTAUS			STA	TENDL ;	ENDE AUF ZEI1		CMP	BERSTL	
	JSR	TABS			LDA	ZEIlH		LBST1	RTS		
	JSR	CHKSPC			STA	TENDH					
	DEC	POINTER			LDA	#$FF J	KODE FUER	CKBEN	JSR	ZNR	;	TEST, OB AKT. ZNR
	JSR	SETGET			STA	TEMP ;	ENDE TESTLOOP		CPX	BERENH ;	GROESSER ODER
L0N3	LDA	TEMP			RTS				BNE	LBEN1 ;	GLEICH BER. ENDE
	JSR	TSPRUNG }	SPR.ART, ZNR U.						CMP	BERENL	
	JSR	GETSPR2 ;	ZIEL IN TABELLE	LNL2	LDA	ZSTAT		LBEN1	RTS		
	JSR	CHRGOT ;	ENDE STATEMENT?		AND	#7.1110	; ZNR FLAG LOE.				
	BEQ	L0N4	;	JA: LINEFEED		STA	ZSTAT		SETTAB	LDA	#$A0	
	CMP	#',	;	WEITERE ZEILENNR.		LDY	#3	; ZEIGT AUF 0.		STA	TABENDH	
	BNE	L0N3	;	NEIN: LINEFEED		STY	POINTER	; BASIC-ZECHEN		LDA	#$00	
	JSR	CHROUT			LDY	#0			STA	TABENDL	
	LDA	ZLANG			LDA	(AKOPADR),Y ; ZEIGER AUF			RTS		
	CMP	#75			STA	NKOPADR	; NAECHSTE B.				
	BCC	L0N3			INY		: ZEILE HOLEN	SETBER	JSR	INIT	
	JSR	CARET ; LINEFEED			LDA	(AKOPADR),Y		LBER1	JSR	NEXTLINE	
	JSR	TABS			STA	NKOPADR	+ 1		LDA	TEMP	
	JSR	TABS			RTS				CMP	#$FF	
	JSR	TABS			5				BNE	LBER2	
	JMP	L0N3		■ == = === =	== = = =	:=ssss==s	:X5SSSKSBS3SZSassssz		JSR	SYSOFF	
L0N4	JSR	FUNFLIN		; HOLT	SYSTEM-PARAMETER (SYSTAT)				JMP	$A7AE	
	JSR	CARET		; SETZT DRUCKER				LBER2	JSR	CKBST	
	JMP	SPRLOOP		; HOLT	BEREICH (IN		BERST/EN)		BCC	LBER1	
				• = = = = = = =	= S5E!	=========	===================		RTS		
TSPRUNG	LDY	#2		SYSGET	LDA	«0					
	STA	(ZEIlL),Y			STA	SYSTAT		BASTRT	LDA	$2B	;	ADRESSE DER
	JSR	ZNR	; ZNR AUS $14/$15		STA	BERSTL			STA	NKOPADR ;	ERSTEN BASIC
	LDY	#3	5 IN TABELLE		STA	BERSTH			LDA	$2C	:	ZEILE HOLEN
	LDA	$62			LDA	#$FF			STA	NKOPADR +1	
	STA	(ZEIlL) ,Y			STA	BERENL			RTS		
	INY				STA	BERENH					
	LDA	$63			JSR	CHRGOT		PREVCHR	DEC	POINTER ;	HOLT VORIGES
	STA	(ZEIlL) ,Y			CMP	#' ,			JSR	AKTCHR ;	ZCHN, OHNE
	RTS				BEQ	LSYS0			INC	POINTER ;	ZEIGER ZU
					LDX	#$06			RTS	5	VERSTELLEN
THEN	JSR	CHKSPC			JMP	$A437 ;	FEHLER: SYNTAX				
	JSR	CHKNUM J	ZIFFER?	LSYS0	JSR	CHRGET ;	DRUCKER	NXTCHR	INC	POINTER ;	HOLT NAECHSTES
	BCC	THENDE 5			CMP	#'P					ZEICHEN
	JSR	ZEILOUT ;	THEN MIT ZEILE		BNE	LSYS1		AKTCHR	LDY	POINTER	
	LDA	#7.10000000			JSR	SETPRT			LDA	(AKOPADR)	,Y
	JSR	SORCOD		LSYS1	JSR	CHRGET			RTS		
	DEC	POINTER ;	EIN ZCHN ZURUECK,		CMP	#'S					
	LDY	POINTER ;	DA CHKNUM ZU WEIT		BNE	LSYS2		GET	JSR	ROMON	
	JMP	AUSGABE			LDA	#7.01000			JSR	$F13E	
THENDE	DEC	POINTER ;	TH-BIT SETZEN		JSR	SETSYS			JMP	ROMOFF	
	LDA	#7.10000000		LSYS2	JSR	CHRGET	; ANGESSPR. ZEILEN?				
	STA	THSTAT			CMP	#'J		CHROUT	INC	ZLANG	
	JMP	SPRLOOP			BNE	LSYS3			JSR	ROMON	
					LDA	«7.00100			JSR	$FFD2	
AUSGABE	STA	TSTAT			JSR	SETSYS					
	JSR	SORCOD		LSYS3	JSR	CHRGET	; VARIABLEN ?	ROMOFF	PHA		
	JSR	TEXTAUS			CMP	#'V			LDA	1	
	JSR	TABS			BNE	LSYS4			AND	#7.11111110	
	JSR	GETSPR J	ZIEL IN TABELLE		LDA	#7.00010			STA	1	
	JSR	LINEFEED ;	UND AUSGEBEN		JSR	SETSYS			PLA		
	JMP	SPRLOOP		LSYS4	JSR	CHRGET	; VARIABLEN SORT.?		RTS		
	5				CMP	#'J					
					BNE	LSYS5		ROMON	PHA		
•************************************#**					LDA	#7.00001			LDA	#$37	
5	UNTERROUTINEN				JSR	SETSYS			STA	1	
;***************************************				LSYS5	JSR	CHRGET	; KOMMENTAR ?		PLA		
INIT	JSR	ROMOFF			CMP	#'K			RTS		
	LDA	#0			BNE	LSYS6					
	STA	ZSTAT			LDA	#7.10000		CHKALPH	JSR	ROMON : TEST, OB AKKU ALPHA	
	STA	ZLANG			JSR	SETSYS			JSR	$B113 ;	C=1, WENN BUCHST.
	STA	FANZ			JSR	CHRGET			JMP	ROMOFF ;	C=0, WENN ANDERS
	STA	TSTAT		LSYS6	CMP	* i	; FOLGEN ZNRS?				
	STA	TEMP			BNE	LSYS8	; NEIN: RTS	CHKNUM	CMP	#$3A : GROESSER ALS '9?	
	STA	DBSTAT			CMP	#$AB			BPL	LCN1	
	STA	TABENDL			BEQ	LSYS7			CMP	#$30 : KLEINER ALS '0'?	
	LDA	#$A0			JSR	CHRGET			BMI	LCN1 ; JA	: C = 0
	STA	TABENDH			JSR	GETZEIL			SEC	; NE	IN: C=1
	LDA	#$F9			LDA	$14			RTS		
	STA	TABSTRTL			STA	BERSTL		LCN1	CLC		
	STA	ZEIlL	;	ANFANG DER TAB-		LDA	$15					
	LDA	#$BF	;	ELLE AB $BFF9		STA	BERSTH		Listing 3. Assembler^ourceCode			
	STA STA	TABSTRTH ZEIlH			JSR CMP	CHRGOT #$AB		zu »Cross-Ref 64« (Fortsetzung)			
Tips & Tricks
RTS 5			CPX #40	; BCS LLF2 ;			BIS POS. 40 AUFFUELLEN	STROUT	JSR ROMON	
CHKSPC	JSR	NXTCHR		LDA	#$20			JSR	$B487 ; STRINGPARAM. HOL.
	CMP	#120		JSR	CHROUT			JSR	$B6A6 ; FRESTRING
	BEQ	CHKSPC		JMP	LLF1			PHA	
	RTS		LLF2	LDA	ZSTAT			LDX	TEMP
				ORA	#7.0010 ;	LF-FLAG SETZEN		BNE	LSTR0
TRZCHN	CMP	#0	j TESTET AUF NULL		STA	ZSTAT			JSR	RECBUN
	BEQ	LTZ1 ; UND ':'		RTS			LSTR0	PLA	
	CMP	#'•.	; JA: Z = 1						TAX	; STR.LAENGE
	BEQ	LTZ1 ; NEIN; Z=0	CARET	LDA	ZSTAT ;	LF-FLAG LOESCHEN		LDY	#0
LTZ1	RTS			AND	«7.1101			INX	
				STA	ZSTAT		LSTR1	DEX	
TESTTAB	LDA	TABSTRTH	CARET2	LDA	#$0D			BEQ	LSTR2
	CMP	TENDH		JSR	CHROUT			LDA	($22) ,Y
	BNE	LTETA		LDA	#0	;	ZEILENLAENGE;=0		JSR	CHROUT ; DRUCKEN
	LDA	TABSTRTL		STA	ZLANG			INY	
	CMP	TENDL	CARET3	JSR	GET	;	TASTE GEDRUECKT?		CMP	#$0D
LTETA	RTS			BEQ	LCAR4 ;	NEINs RTS		BNE	LSTR1
			LCAR1	CMP	#3	;	RUN/STOP?		JSR	$AAE5
OVFLOW	JSR	TESTEND		BNE	LCAR3			JMP	LSTR1
	BCS	LOVF	LCAR2	JSR	SYSOFF j	JA	LSTR2	JMP	ROMOFF
	JSR	SYSOFF		LDA	#<TBREAK				
	LDA	#<TOVER		LDX	#>TBREAK		TEXTAUS	LDX	#0
	LDX	#>TOVER		JSR	MASKE			LDA	THSTAT
	JSR	MASKE		JMP	$A7AE			ORA	TSTAT
	JMP	$A7AE	LCAR3	JSR	GET	;	2. TASTE		STA	TSTAT
LOVF	RTS			BEQ	LCAR3 ;	FUER CONT.	LTA1	ASL	TSTAT
				CMP	#3			BCS	FUENFAUS
ZEILOUT	JSR	ZNR ; ZNR NACH $62/163		BEQ	LCAR2			INX	
	LDY	#4	; ZNR IN TAB	LCAR4	RTS				INX	; SETZE X AUF DEN
	STA	(ZEIlL),Y						INX	; NAECHSTEN TEXTAB-
	DEY		FUNFLIN	DEC	LINES			INX	; SCHNITT
	TXA			BNE	LFUNF1			INX	
	STA	(ZEIlL),Y		LDA	#5			JMP	LTA1
	LDA	#0		STA	LINES		FUENFAUS	LDY	#5
	STA	TEMP		JSR	CARET		LTA2	LDA	TEXT,X
	LDA	ZSTAT ; BEI 1 KEINE ZNR	LFUNF1	RTS				JSR	CHROUT
	LSR	A						INX	
	BCS	LZO1	TABS	LDA	ZLANG j	ZEILENLAENGE HOL.		DEY	
	LDA	ZSTAT ; ZNR-FLA6 «1		SEC				BNE	LTA2
	ORA	#7.0001	LTAB1	SBC	#10	;	SOLANGE POSITIV		LDA	TSTAT
	STA	ZSTAT		BCS	LTAB1 j	10 ADDIEREN		BNE	LTA1
	JSR	ZAUSGABE		EOR	#$FF ;	ERGEBNIS INVERT.		RTS	
	LDX	#39		ADC	#1			5	
	LDY	#2		TAX				= = = = =	: s x x x = x x x = x xxxx xx = = x x x x x x x x x
	JMP	LZ02		INX			; AUSGABE /		^LLER VARIABLEN IN DER TAB
LZO1	LDX	#34		DEX					
			LTAB2					. _ _ —.	
	LDY	#7		BEQ	LTAB3		VAROUT	LDA	TABSTRTL ; ZEIGER AUF
LZO2	LDA	FANZ ; FOR OFFEN?		LDA	#$20			STA	ZEIlL	; ANFANG DER
	STA	$63		JSR	CHROUT			LDA	TABSTRTH ; TABELLE SETZEN
	BEQ	LZ03 ; NEINs RTS		JMP	LTAB2			STA	ZEIlH
	STA	TEMP	LTAB3	RTS				LDA	TENDL
	JSR	LTA2		J				STA	TABENDL
	LDA	#0	SETPRT	LDA	#4			LDA	TENDH
	STA	$62		LDX	#4			STA	TABENDH
	JSR	ZAUSGABE		LDY	«$68 ;	SEK 8 + $60		LDA	#5	; STARTWERT 3
LZ03	LDA	#0		JSR	$FFBA j	FILPAR		STA	LINES ; FUER ABSAETZ
	STA	TEMP		JSR	$FFB1 ;	LISTEN		JSR	CARET2 ; ZLANG:=0 U.
	JMP	TABS		LDA	«$68 ;	SEKADR	LVARO1	JSR	TESTEND ; TABELLE ENDE?
				JSR	$FF93 ;	SEKLST		BEQ	LVAR09 ; JA: RTS
ZNR	LDY	#3	; HOLT NR. DER		LDA	«4		LVAR02	JSR	SETVANZ
	LDA	(AKOPADR),Y ; AKT. ZEILE		STA	$9A			LDY	#1	; 1. ZEICHEN
	TAX	; NACH $62/$63		RTS				LDA	(ZEIlL),Y ; AUSGEBEN
	DEY	; UND A,X						JSR	CHROUT
	LDA	(AKOPADR),Y	SYSOFF	LDA	PROPORT			INY	; 2.ZEICHEN
	STX	$62		CMP	#$35			LDA	(ZEIlL),Y ; AUSGEBEN,
	STA	$63		BNE	GETRES			CMP	#$20	; WENN <>LEER
	RTS			LDA	#$37 ;	ROM AN,		BEQ	LVAR03
				STA	1 ;	$A000 KOPIERT WIRD		JSR	CHROUT
ZAUSGABE	JSR	ROMON		LDA	#$A0		LVAR03	JSR	STATOUT
	LDX	#$90 ;$62/$63 WIRD ALS		STA	4			JSR	TABS
	SEC	;INTEGERZAHL IM		LDY	#0		LVAR04	LDY	#3	•, ZNR HOLEN
	JSR	$BC49 ;16-BIT ADRESS-	LROMK	LDA	<3> ,Y			LDA	(ZEIlL),Y ; UND NACH
	JSR	$BDDF ;FORMAT AUSGEBEN		STA	(3) ,Y			STA	$62	; $62/$63
	JSR	STROUT ; $ABlE		INY				INY	
	JMP	ROMOFF		BNE	LROMK			LDA	(ZEIlL) ,Y
				INC	4			STA	$63
RECBUN	EOR	#$FF		LDA	4			LDA	#0
	ADC	#6		CMP	#$C0			STA	TEMP
	TAY			BNE	LROMK			JSR	ZAUSGABE
LREC1	BEQ	LREC2						LDY	#5	;"*" HINTER ZNR
	LDA	#$20	GETRES	LDA	GETSP			LDA	(ZEIlL),Y ;WENN DEF
	JSR	CHROUT		STA	$7A			ASL	A	;SONST WEITER
	DEY			LDA	GETSP +1			BCC	LVAR05
	JMP	LREC1		STA	$7B			LDA	#' *
LREC2	RTS							JSR	CHROUT
			PRTOFF	LDA	#4		LVAR05	JSR	TABS
LINEFEED	LDA	ZSTAT		JSR	$FFAE ;	UNLIST		INC	VANZ
	LSR	A	; BEI BIT 1=0		JSR	$FFC3 ;	SCHLIESSEN		JSR	VARVERG ;ALTVAR=NEUVAR?
	LSR	A	; KEIN LF		LDA	#3			PHP	; JA: NUR ZNR
	BCC	LLF1		STA	$9A				
	JSR	FUNFLIN		LDA	PROPORT		Listing	3. Der Source-Code zu	
	JMP	CARET		STA	1		»Cross-Ref		64«
LLF1	LDX	ZLANG ; KEIN LF, DANN		RTS					
							(Fortsetzung)		
119
Tips & Tricks
	JSR	INZEI1 ;	NEIN: UND NAM		SSZZSZZSZSS5ZSXS5SS = xzzzzsss	DECTAB	CLC		
	JSR	TESTEND	; ENDE DER TAB?	; SORTIEREN VON FELDERN NACH			LDA	TABENDL	
	BEQ	LVAR08	; JA: ENDE	;	"BUBBLESORT"			ADC	LAENGE	
	PLF'		AUSGEBEN	; UEBERGABE:			STA	TABENDL	
	BEQ	LVAR04 ;	(NUR ZNR)	;	"LAENGE" DES FELDES			BCC	LDECTAB	
	LDA	VANZ	; MEHR ALS 7	;	"TABSTRT"	ANFANG DES FELDES			INC	TABENDH	
	CMP	#8	; VAR AUSGEG.?	;	"TABEND"	ENDE		LDECTAB	RTS		
	BCC	LVAR06	; JA: LF,		ZSZ===Z=ZZ=SSZZSE=SSSSZ=BZ=Z		5		
	JSR	CARET	; VANZ:=0	• = = = = = = ==== =	xxxxxxxxxxxxxxxxxxxxxxxxxxxx	:========	: = xx =	:==========	=================
	JSR	FUNFLIN		; ERHOEHE	ZEIGER1 UM LAENGE	; TEND	UM EIN ELEMENT		VERRINGERN
	JSR	SETVANZ		• = = = = = = = === =		;========	: = = = =	:==========	XXXX XXXXXXX X XXXXX
	JMP	LVARO7		INZEI1 SEC		INTEND	CLC		
LVAR06	CMP	#4	;	4 VAR?: LF	LDA	ZEIlL		LDA	TENDL	
	BCC	LVAR07 ;	WENIGER; WEITER	SBC	LAENGE		ADC	LAENGE	
	JSR	LLF2		STA	ZEIlL		STA	TENDL	
LVARO7	JSR	LINEFEED		BCS	LINZ1		BCC	LINTENI	
	JMP	LVAR02		DEC	ZEIlH		INC	TENDH	
LVAR08	PLP			LINZ1	RTS		LINTENi	RTS		
LVAR09	JMP	CARET2							
				• = = = = = = = === =	============================	.========	: = = = =	:==========	XXXX XXXX XXXXX X X X X
SETVANZ	LDA	#0		; ROUTINE	BESTIMMT ZEIGER AUF I+l-TES	; TEND	UM EIN ELEMENT		ERHOEHEN
	STA	VANZ		; ELEMENT;	PARAMETER: LAENGE, ZEI1	.========		:==========	X X X X X X X X X X X X X X X X X
	RTS			■ = = = = === = = = =	============================	DECTEND	SEC		
	5			IZEIG2 LDA	ZEIlH		LDA	TENDL	
■ = = = = = = =	= = = =	==========	==================	STA	ZEI2H		SBC	LAENGE	
; HOLEN EINER VARIABLEN AUS BASIC TEXT				SEC			STA	TENDL	
	= = = = .	==========	==================	LDA	ZEIlL		BCS	LDETEN1	
VARGET	LDY	#1	; ZEICHEN IN TAB.	SBC	LAENGE		DEC	TENDH	
	STA	(ZEIlL) ,Y		STA	ZEI2L	LDETEN1	RTS		
	JSR	NXTCHR	; NAECHSTES ZCHN	BCS	LADD1				
	LDY	#2		DEC	ZEI2H	• = = = = = = = =	: = = = =	: = = = = s = = = = =	XXXXXXXX XXXX X XX XX
	JSR	CHKALPH	; BUCHSTABE?	LADD1	RTS		; SORTIEREN			
	BCS	LVARGET1	; JA: IN TAB.			• = = = = = = = =	: = = = =	: = = = = = = = = = =	XXXXXXXXXXXXXX XXX
	JSR	CHKNUM	; ZIFFER?	• = = = = = = = = = = =	= X X S SSSSZ5SSZZSSZ3ZSSCZS8SS S	SORT	LDA	TENDL ;	TABEND SETZEN,
	BCS	LVARGET1	; JA: IN TAB.	; VERGLEICH DER DURCH ZEI1, ZEI2 UND			STA	TABENDL ;	GEHT BEI SORT
	TAX		; NEIN:AC SICHERN	; LAENGE BESTIMMTEN FELDER			LDA	TENDH ;	VERLOREN
	LDA	#120	; LEER IN TAB.	;	C = 1, WENN A(I)>A(I+1)			STA	TABENDH	
	STA	(ZEIlL) ,Y		;	Z = 1, WENN A(I)=A(I+1) (Y=LAENGE)		LSORT1	LDA	TABSTRTL ;	ZEIGER1 AUF
	JMP	LVARGET2			S X St X X S5BSSZ SS8SS8S X X S8ZS8S X X		STA	ZEIlL	;	TABSTRT
LVARGET1	STA	(ZEIlL) ,Y		VERGL	LDY	«0		CMP	TABENDL	
	JSR	NXTCHR		LV1	CLC			PHP		UND
	TAX			LDA	(ZEIlL) ,Y		LDA	TABSTRTH ;	TEST, OB
LVARGET2	LDA	#7.01000000		CMP	(ZEI2L),Y		STA	ZEIlH	;	ENDE DER
	CPX	#’$	; STRING?	BEQ	LV2	; GLEICH		CMP	TABENDH ;	TABELLE
	BEQ	LVARGET4		BCS	LV3	; GROESSER		BNE	LSORTY ;	ERREICHT
	CPX	#'7.	; INTEGER?	BCC	LV3	; KLEINER		PLP		JA: ENDE
	BEQ	LVARGET3		LV2	INY	; NEIN: NAECHSTES		BEQ	LSORTW	
	LSR	A	; REAL	CPY	LAENGE ; X=LAENGE?				
	LSR	A		BEQ	LV3	; JA: ENDE	LSORTY	JSR	IZEIG2	
	JMP	LVARGET5		JMP	LV1	; ELEMENT TESTEN		JSR	VERGL	VERGLEICHEN
LVARGET3	LSR	A	; INTEGER	LV3	RTS			BCC	LS0RT3 ;	GROESSER, DANN
LVARGET4	PHA		; AC SICHERN				JSR	EXCHANGE ;	TAUSCHEN
	JSR	NXTCHR		|==z====sz=z;	sxxxxxxxxxxxxxxxxxxxxxxxxxxx	LS0RT3	JSR	INZEI1	; NAECHSTES
	TAX			; VERGLEICH ZWEIER VARIABLEN			JSR	TESTEND ;	ENDE ERREICHT?
	PLA			;	Z=1, WENN NAME UND STATUS GLEICH			BNE	LSORTY ;	NEIN: WEITER
LVARGET5	CPX	#' (	; DIMENSIONIERT?	•===========:	S XXXXXX X XXXXX X XXXXXXXX XX xxxx		JSR	DECTAB ;	JA: NAECHSTER
	BNE	LVARGET6	j NEIN	VARVERG JSR	IZEIG2		JMP	LSORT1	
	ORA	#7.10000000 ; JA!		LDA	#3	; NUR 3 BYTE				
LVARGET6	LDY	#0	; STATUS AN 5.	STA	LAENGE ; (STAT, NAME)	LSORTW	RTS		
	STA	(ZEIlL) ,Y	; STELLE IN TAB.	JSR	VERGL ; VERGLEICHEN		j		
	JSR	ZNR	;ZNR IN TAB.	PHP	; LAENGE WIEDER			:==========	=================
	LDY	#4	;AN 4./5. STELLE	LDA	#6	; 6	; SETZT	CHRGET - ZEIGER AUF AKT. ZEICH.		
	STA	(ZEIlL) ,Y		STA	LAENGE	j = = = = = = = =		: = = = = = = = = = =	=================
	DEY			PLP		SETGET	LDA	POINTER	
	TXA			RTS			CLC		
	STA	(ZEIlL) ,Y					ADC	AKOPADR	
	LDA	DBSTAT	; DEF/BEN AN 5.	•===========:	: X XXXX XXXXXXX X XXXX XXXXXXXXX X		STA	$7A	
	LDY	#5	; STELLE	; TAUSCHE	ZWEI FELDER, DIE DURCH ZEIlL		PHP		
	STA	(ZEIlL) ,Y		; ZEI2L UND LAENGE BESTIMMT SIND			LDA	AKOPADR +	1
	RTS			• = = = = = = = = = = = :	SXXXXX XXXX X XXXXXXX XXX XXXXXXX		STA	$7B	
	5			EXCHANGE LDY	#0		PLP		
■	= = = = :	= === =	==========	==================	LEXCH1 CPY	LAENGE	; SOLANGE Y<LAE.		BCC	LSET1	
; PRUEFT STATUSBYTE			DER VARIABLEN	6EQ	LEXCH2		INC	$7B	
; UND ।	BIBT	TYP - $,	7., () - AUS	LDA	(ZEIlL),Y	LSET1	RTS		
.=======	= === =	==========	ss==sasssz=sss=sa=	PHA	; VERTAUSCHE				
STATOUT	LDY	#0		LDA	(ZEI2L),Y ; ZWEI BYTES	• = = = = = = = =	: = = = =	: = = = = = = = = = =	XXXXXXXXXXXBXXXXX
	LDA	(ZEIlL),Y		STA	(ZEIlL) ,Y	; HOLT	SPRUNGZIEL NACH TABELLENENDE		
	LSR	A		PLA		.========	: = = = =	: = = = = = = = = = =	xxxxxxxxxxxxxxxxx
	LSR	A	;	BITS 0-3	STA	(ZEI2L),Y	GETSPR	JSR	SETGET	
	LSR	A	;	UEBERLESEN	INY		GETSPR2	JSR	ROMON	
	LSR	A		JMP	LEXCH1		JSR	CHRGET	
	LSR	A	;	REAL?	LEX.CH2 RTS			JSR	GETZEIL	
	BCS	LSTAT2					LDY	#0	
	LDX	# ' 7.	;	INTEGER?		SXXXXXXXXXXXXXXXXXXXXXXXXXXX		LDA	115	
	LSR	A		; ENDE DER	TABENDLLE ERREICHT?		STA	(ZEIlL),Y	
	BCS	LSTAT1		;	(ZEI1 =	TABEND? ==> Z=1)		STA	$62	
	DEX	;STRING!			= = = = = = === ==== = === = = = = = = = = = = =•		INY		
LSTAT1	TXA			TESTEND LDA	ZEIlH		LDA	$14	
	JSR	CHROUT		CMP	TABENDH		STA	(ZEIlL) ,Y	
LSTAT2	LDA	(ZEIlL),Y	; FELD?	BNE	LTEND1		STA	$63	
	ASL	A		LDA	ZEIlL		JSR	INZEI1	
	BCC	LSTAT3	; NEIN: RTS	CMP	TABENDL		JSR	ZAUSGABE	
	LDA	#' (		LTEND1 RTS			JMP	OVFLOW	
	JSR	CHROUT							
LSTAT3	LDA JSR RTS 5	#') CHROUT		; TABEND Ul ? = = = = = = = = = = = =	1 EIN ELEMENT ERNIED	Listing 3. Der SourcfrCode zu »Crossflef 64« (Fortsetzung)			
120
Tips & Tricks
; SETZT BIT FUER SPRUNG NACH ON, THEN	MASKE4	JSR TABS JMP MASKE1		LSR A LSR A
SORCOD LDY #2 ORA THSTAT STA TSTAT STA (ZEIlL),Y RTS ; AUSGABE DER ANGESPRUNGENEN ZEILEN ; IN DER TABELLE: H,L DES SPRUNGZIELS, ;	CODE DER SPRUNGART, ;	L,H DER AUFRUF-ZEILE - = = = = === = = = = = = = = = = = = = === = = = = = === = = = ===== ZIELE	LDA TENDL ; ZEIGER AUF ENDE STA TABENDL ; TEND WURDE NICHT LDA TENDH ; GEAENDERT STA TABENDH LDA TABSTRTL ; ZEIGER AUF STA ZEIlL	; ANFANG LDA TABSTRTH STA ZEIlH LDA #0 STA ZSTAT STA ZLANG LDA #5 STA LINES LDA #7.11110110 STA FANZ LZIEL1 JSR TESTEND ; TABELLE LEER? BEQ STPZIEL ; JA: BEENDEN LDY	#0	;	HIGH, LOW-BYTE STY	TEMP	;	F.	RECBUN LDA	(ZEIlL) ,Y	;	DES ZIELS STA	$62	;	HOLEN INY LDA (ZEIlL) ,Y STA $63 JSR ZAUSGABE JSR TABS LDY #2	; SPRUNGART HOLEN LDA (ZEIlL) ,Y BIT FANZ BNE LZIEL2 AND #7.11111110 LZIEL2 STA TSTAT LDX #0 STX TEMP	;	F.	RECBUN JSR LTA1	;	TEXTAUSGABE LDY #3	;	LOW,HIGH-BYTE LDA (ZEIlL),Y	;	DER AUWUFENDEN STA $62	;	ZEILE INY LDA (ZEIlL) ,Y STA $63 JSR TABS JSR ZAUSGABE JSR LINEFEED JSR INZEI1 JMP LZIEL1 STPZIEL RTS " X = X = X X X = = X XX SXXXXX XXXXX XXXX XXXXXX XX X X X X ; AUSGEBEN VON TEXT j======================================= MASKE	STA ADRE+1 STX ADRE+2 LDX #0 STX ZLANG ADRE	LDA $FFFF BEQ MASKE3 CMP #255 BEQ MASKE4 JSR CHROUT MASKE1 INC ADRE+1 BNE MASKE2 INC ADRE+2 MASKE2 JMP ADRE MASKE3 RTS	5 ; AUSGABE DER "MASKEN" DRAN	LDA #<TSPRK LDX #>TSPRK JSR MASKE LDY #2 LDRAN1 LDA #<TANR LDX #>TANR JSR MASKE DEY BNE LDRAN1 JMP DRSPR1 DRSPR	LDA #<TSPRK LDX #>TSPRK JSR MASKE LDY #2 LDSP1	LDA #<TSPRR LDX #>TSPRR JSR MASKE DEY BNE LDSP1 DRSPR1	LDY #2 LDSP2	LDA #<TSPRU LDX #>TSPRU JSR MASKE DEY BNE LDSP2 RTS DRVAR	LDA #<TVARK LDX #>TVARK JSR MASKE LDY #2 DRVAR1 LDA #<TVARR LDX #>TVARR JSR MASKE DEY BNE DRVAR1 LDY #8 DRVAR2 LDA #<TVARU LDX #>TVARU JSR MASKE DEY BNE DRVAR2 RTS * X X X X X X X X X 3 X 3 X 3 X X X X X X X X ; STEUERROUTINE ;	RUFT DIE ROUTINEN ;	DER PARAMETER AUF j = = = = = = = = = = = = = = = = = = = = = = SCONTROL JSR SYSGET ; LDA $7A	; STA GETSP ; LDA $7B	; STA GETSP +1 LDA 1	; STA PROPORT ; JSR ROMOFF ; LDA SYSTAT ;' LSR A	; LSR A LSR A LSR A BCC LCON1 JSR SPR LDA SYSTAT LSR A LSR A LSR A BCC LCON1 JSR AN LCON1	LDA SYSTAT		FUER SPR U. VAR ENTSPRECHEND PARAMETER HOLEN GET-ZEIGER RETTEN PROZESSORPORT RETTEN ROM AUSSCHALTEN ABFRAGE DER PARAMETER	BCC LC0N2 JSR VAR LC0N2	LDA SYSTAT . LSR A BCC LC0N3 JSR VAR2 LC0N3	JMP SYSOFF ; STARTZUSTAND ; WIEDERHERSTELLEN .======================================= ; TEXTE TSPRK .BYTE 13,255,255,255 .TEXT "	SPRUNGBEFEHLE" .BYTE 13,255,255,255,255 .TEXT " =============" .BYTE 13,0 TSPRR .TEXT " IN ZEILE	SPRUNG DURCH" .BYTE 255 .TEXT " NACH" .BYTE 255,0 TSPRU .TEXT "#========*============“ .TEXT "=======*=========♦" .BYTE 0 TANK .BYTE 255,255,255 .TEXT "ANGESPRUNGENE ZEILEN" .BYTE 13,255,255,255 .TEXT " ====================« .BYTE 13,0 TANR .TEXT "* ZIEL * SPRUNG DURCH	* .TEXT " IN	*" .BYTE 0 TVARK .BYTE 13,255,255,255 .TEXT "	VARIABLEN" .BYTE 13,255,255,255,255 .TEXT " =========“ .BYTE 13,0 TVARR .TEXT " VARIABLE ZEILEN" .BYTE 255,255,255,0 TVARU .TEXT "*========*" .BYTE 0 TOVER .BYTE 13 .TEXT "SPEICHER VOLL !! .BYTE 13,0 TBREAK .BYTE 13 .TEXT "ABBRUCH ! ! " .BYTE 13,0 TEXT	.TEXT "THEN FOR NEXT " .TEXT "RUN ON - GSUB " .TEXT "GOTO	*" TSTAT	.BYTE	0 POINTER .BYTE 0 ZLANG	.BYTE	0 FANZ	.BYTE	0 ZSTAT	.BYTE	0 THSTAT .BYTE 0 TABSTRTL .BYTE $F9 TABSTRTH .BYTE $BF TENDL	.BYTE	0 TENDH	.BYTE	0 DBSTAT .BYTE 0 LINES	.BYTE	5 VANZ	.BYTE	0 SYSTAT .BYTE 0 BERSTL .BYTE 0 BERSTH .BYTE 0 BERENL .BYTE 0 BERENH .BYTE 0 PROPORT .BYTE 0 GETSP	.BYTE	0,0 .END Listing 3. Der Source-Code zu »Cross-Ref 64« (Schluß)
10 rem 20 gosub 100 : goto 200 30 rem 40 run 50 50 rem 60 if a=0 then gosub 100 : goto 50 70 rem 80 on a goto 10,20,30,48 90 rem 100 if a<>0 then on a gosub 100,90,70,80	110 rem 120 b=0 : it b=l then b*b+2 130 rem 140 print d;g;e;k 150 rem 160 e=g+d+k:d=k Listing 1. Dieses, für sich unsinnige, Basic-Programm soll die Leistungsfähigkeit der Dokumentationshilfe »Cross-Reference-Liste« veranschaulichen

121
Marid<technik-BudBtriag
MariMfedmikBucfoeriaq
Impressum
Depot-Händler
H.L. Schneider/W. Eberl
Das Commodore 64-Buch, Bd. 1 1984, 270 Seiten
Der Commodore 64 und seine Handhabung • Einführung in die Grafik • Balkendiagramme ■ Einführung in die Spritetechnik • Basic-Erweiterungen in Assembler • Ein Leitfaden für Erstanwender.
Best.-Nr. MT 591 (Buch) nM -o (Sfr.44,20/oS374,40) UIVI HO,— Best.-Nr. MT 592(Beispiele auf Diskette) (Sfr. 58,—ZÖS 522,—)	‘DM 58,-
*	inkl. MwSt. Unverbindliche Preisempfehlung
H.L. Schneider/W. Eberl
Das Commodore 64-Buch, Bd. 2 1984,.181 Seiten
Spiele nicht nur zum Abtippen ■ Programmlisting • Programmbeschreibung • Variablenübersicht • Programme nach Anleitung frei ergänzbar • das ideale Buch, um Programmieren spielend zu lernen.
Best.-Nr. MT 593 (Buch) »■■ no (Sfr.35,-/oS296,40)	ÜO,—
Best.-Nr. MT 594 (Beispiele auf Diskette) (Sfr. 58,—föS 522,—)	‘DM 58,-
*	inkl. MwSt. Unverbindliche Preisempfehlung
H. L. Schneider/W. Eberl
Das Commodore 64-Buch, Bd. 3 1984, 206 Seiten
Alles überSprites • Wissenswertes über Multi-Color-Grafik • Assembler/Disas-sembler • jede Menge Basic-Erweiterungen • Umgang mit dem Soundgenerator • ein Leitfaden für Fortgeschrittene.
Best.-Nr. MT 595 (Buch) n n. o o (Sfr.35,-/oS296,40) UM üO,— Best.-Nr. MT 596 (Beispiele auf Diskette) (Sfr. 58,—ZöS 522,—)	‘DM 58,-
*	inkl. MwSt. Unverbindliche Preisempfehlung
H. L. Schneider/W. Eberl
Das Commodore 64-Buch, Bd. 4 1984, 261 Seiten
Einführung in Maschinenprogrammierung • Verknüpfung von Maschinenprogrammen mit Basic-Programmen • alles über Assembler/Disassembler • der Leitfaden für Systemprogrammierer.
Best.-Nr. MT 597 (Buch) nia OO (Sfr.35,-/oS296,40) UM üO,— Best.-Nr. MT 598(Beispiele auf Diskette) (Sfr. 58,—ZöS 522,—)	‘DM 58,-
*	inkl. MwSt. Unverbindliche Preisempfehlung
H. L. Schneider/W. Eberl
Das Commodore 64-Buch, Bd. 5
Juli 1984, 322 Seiten
Ein Leitfaden durch Simon’s Basic • ausführliche Besprechung aller Befehle • viele erklärende Beispiele • mit kom-mentierterAssembler-Listing • das richtige Nachschlagewerk für den geübten Commodore 64-Benutzer.
Best.-Nr. MT 599 (Buch) naa (Sfr.35,-/oS296,40) UM OO,— Best.-Nr. MT 600 (Beispiele auf Diskette) (Sfr. 58,-/oS 522,—)	‘DM 58,-
*	inkl. MwSt. Unverbindliche Preisempfehlung
Bestellkarten bitte an Ihren Buchhändler oder an eine unserer Depotbuchhandlungen. Adressenverzeichnis am Ende des Heftes!
MadÄchnik Verlag Aktiengesellschaft
Buchverlag
Hans-Pinsel-Straße 2, 8013 Haar
Tragen Sie Ihre Buchbestellung und die Anschrift des Depotbuchhändlers auf die Bestellkarte in diesem Heft ein. Bitte vergessen Sie den Absender nicht.
Buchhandlung Herder, Kurfürstendamm 69
1OOO Berlin 15, Tel. (0 30) 8 83 50 02, BTX *921782#
Computare Fachbuchhandlung, Keithstraße 18
1000 Berlin 30, Tel. (0 30) 2 13 90 21
Thalia Buchhaus, Große Bleichen 19
2000 Hamburg 36, Tel. (0 40) 3 00 50 50
Boysen + Maasch, Hermannstraße 31
2000 Hamburg 1, Tel. (040) 30050515
Electro-Data, Wilhelm-Heidsiek-Straße 1 2190Cuxhaven,Tel. (0 47 21) 512 88 Buchhandlung Muehlau, Holtenauer Straße 116 2300 Kiel, Tel. (04 31) 8 50 8 5 ECL, Norderstraße 94-96
2390 Flensburg, Tel. (04 61) 2 81 81
Buchhandlung Weiland, Königstraße 79
2400 Lübeck, Tel. (04 51) 7 4006-09
Buchhandlung Storm, Langenstraße 10
2800 Bremen 1, Tel. (04 21) 32 15 23
Buchhandlung Lohse-Eissing, Marktstraße 38
2940Wilhelmshaven, Tel. (04421) 416 87
Buchhandlung Schmorl u. v. Seefeld, Bahnhofstraße 13
3000 Hannover 1, Tel. (05 11) 32 76 51
Buchhandlung Graff, Neue Straße 23
3300 Braunschweig, Tel. (05 31) 4 92 71
Deuerlich'sche Buchhandlung, Weender Straße 33
3400 Göttingen, Tel. (05 51) 5 68 68
Buchhandlung an der Hochschule, Holländische Straße 22
3500 Kassel, Tel. (05 61) 8 38 07
Stern Verlag, Friedrichstraße 24-26
4000 Düsseldorf, Tel. (02 11) 37 30 33
Buchhandlung Baedeker, Kettwiger Straße 33-35
4300 Essen 1, Tel. (02 01) 22 13 81
Regensberg'sche Buchhandlung, Alter Steinweg 1
4400 Münster, Tel. (02 51) 40541-5
Buchhandlung Acker, Johannisstraße 51
4500 Osnabrück, Tel. (0541) 28488
Buchhandlung Lensing, Westenhellweg 86-88
4600 Dortmund, Tel. (02 31) 1 69 80
Buchhandlung Brockmeyer, Querenburger Höhe 281/Unicenter
4630 Bochum, Tel. (02 34) 7013 60
Buchhandlung Meier + Weber, Warburger Straße 98
4790 Paderborn, Tel. (0 52 51) 6 31 72
Buchhandlung Phönix GmbH, Oberntorwall 25
4800 Bielefeld 1, Tel. (05 21) 6 90 71
Buchhandlung Gonski, Neumarkt 24
5000 Köln 1, Tel. (02 21) 21 05 28
Mayer'sche Buchhandlung, Ursulinerstraße 17-19
5100 Aachen, Tel. (02 41) 4 81 42
Buchhandlung Behrendt, Am Hof 5a
5300 Bonn 1, Tel. (0228) 658021
Buchhandlung Cusanus, Schloßstraße 12
5400 Koblenz, Tel. (02 61) 3 62 39
Akad. Buchhandlung Interbook, Fleischstraße 61-65
5500Trier, Tel. (06 51) 4 35 96
Buchhandlung W. Finke, Kipdorf 32
5600Wuppertal 1, Tel. (02 02) 45 42 20
Buchhandlung Balogh, Sandstraße 1
5900 Siegen, Tel. (02 71) 5 52 98-9
Buchhandlung Naacher, Steinweg 3
6000 Frankfurt 1, Tel. (069) 29 80 50
Buchhandlung Wellnitz, Lautenschlägerstraße 4
6100 Darmstadt, Tel. (0 61 51) 7 6 5 48
Buchhandlung Feller + Gecks, Friedrichstraße 31
6200 Wiesbaden, Tel. (0 61 21) 30 49 11
Ferber'sche UNI-Buchhandlung, Seltersweg 83
6300 Gießen, Tel. (0641) 1 2001
Sozialwissenschaftliche Fachbuchhandlung, Friedrichstraße 24
6400 Fulda, Tel. (06 61) 7 50 77
Gutenberg Buchhandlung, Große Bleiche 29
6500 Mainz, Tel. (0 61 31) 3 7011
Buchhandlung Bock + Seip, Futterstraße 2
6600 Saarbrücken, Tel. (06 81) 3 06 77
Buchhandlung Wilhelm Hofmann, Bismarckstraße 98
6700 Ludwigshafen, Tel. (06 21) 51 60 01
Buchhandlung Loeffler, B 1,5
6800 Mannheim 1, Tel. (06 21) 2 89 12
Buchhandlung Stehn, Bahnhofstraße 13
7000 Stuttgart 50, Tel. (07 11) 56 14 76
Buchhandlung am Markt, Kramstraße 6
7100 Heilbronn, Tel. (071 31) 68682
PCB Micro-Computer, Oskar-Kalbfell-Platz 8
7410 Reutlingen, Tel. (0 71 21) 2 7 04 43 UNI Buchhandlung Kellner + Moessner, Kaiserstraße 18 7500 Karlsruhe, Tel. (07 21) 69 1436 Buchhandlung Roth, Hauptstraße 45 7600 Offenburg, Tel. (07 81) 2 20 97 Rombach Center, Bertholdstraße 10 7800 Freiburg, Tel. (07 61) 4 90 91 Fachbuchhandlung Hofmann, Hirschstraße 4 7900 Ulm, Tel. (07 31) 6 09 49 Schauties Elektronik, Bachstraße 52 7980 Ravensburg, Tel. (07 51) 2 61 38 Buchhandlung Hugendubel, Marienplatz 8000 München 2, Tel. (0 89) 23 89-1 Computerbücher am Obelisk, Barerstraße 32-34 8000 München 2, Tel. (0 89) 28 23 83 Pele's Computerbücher, Schillerstraße 17 8000 München 2, Tel. (0 89) 55 52 29 Universitätsbuchhandlung Lachner, Theresienstraße 43 8000 München 2, Tel. (0 89) 52 13 40 Buchhandlung Schönhuber, Theresienstraße 6 8070 Ingolstadt, Tel. (08 41) 3 3146/47 Computerstudio Gertrud Friedrich, Ludwigstraße 3 8220 Traunstein, Tel. (08 61) 1 47 67 Buchhandlung Pustet, Kl. Exerzierplatz 4 8390 Passau, Tel. (08 51) 5 69 45 Buchhandlung Pustet, Gesandtenstraße 6 8400 Regensburg, Tel. (09 41)5 30 61 Buchhandlung Dr. Büttner, Adlerstraße 10-12 8500 Nürnberg, Tel. (0911) 23 2318 STS Computer Vertrieb, Werner-Siemens-Straße 19 8580 Bayreuth, Tel. (09 21) 6 23 20 Computer-Center-Burger, LeimitzerStraße 11-13 8670 Hof, Tel. (0 92 81) 4 00 7 5 Sortiments- u. Bahnhofsbuchh. J. Strykowski, Bahnhofplatz 4 8700Würzburg, Tel. (09 31) 5 43 89 Buchhandlung Pustet, Grottenau 4 8900Augsburg, Tel. (08 21) 3 54 37 Kemptener Fachsortiment, Salzstraße 30 8960 Kempten, Tel. (08 31) 1 4413
Belgien:
Eicher Micro & Personal Computer, Hünningen 56-58 B-4780St.Vith,Tel. (0 80) 22 73 93
Luxemburg:
Libralrie PromocuKure, 14, rue Duchscher (PI. de Paris) L-1011 Luxembourg-Gare, Tel. 480691, Telex 31 12 Schweiz:
Buchhandlung Meissner, Bahnhofstraße 41
5000 Aarau, Tel. (0 64) 24 71 51
Bücher Balmer, Neugasse 12
6300 Zug, Tel. (0 42) 21 41 41
Buchhandlung Enge, Bleicherweg 56
8002 Zürich, Tel. (01) 2 01 20 78
Buchhandlung Orell Füssli, Pelikanstraße 10
8022 Zürich, Tel. (01) 2 11 8011
FreihoferAG, Wissenschaftliche Buchhandlung, Universitätsstr. 11
8033 Zürich, Tel. (01) 3 63 42 82
Buchhandlung am Rößlitor, Webergasse 5
9001 St.Gallen, Tel. (071) 228726
Herausgeber: Carl-Franz von Quadt, Otmar Weber
Chefredakteur: Michael Scharfenberger Leitender Redakteur: Albert Absmeier Redaktion: Volker Everts, Achim Hübner, Georg Klinge, Harald Meyer, Markus Ohnesorg, Christian Rogge, Thomas Röder, Arnd Wängler.
Fremdautoren:
Barcikowski, Baumann, Blaumeiser, Brenschede, Bretthauer, Brunzema, Burmeister, Bödecker, Dietz, Diezmann, Feldmann, Frink, Gerlach, Golombek, Graves, Großauer, Hahn, lrkens, Klinger, Knipp, Kramer, Kunz, Kusch, Köhler, Köhne, Lang, Linsd, Lonczewski, Luhmann, Mann, Matzner, Mayer, Pflaum, Rest, Rüschhoff-Nadermann, Sauer, Schacht, Schneider, Sprehe, Spörri, Stecher, Stuke, Temme, Wagner, Weber, Weihe, Weinbrenner, Weineck.
Layout: Leo Eder (Ltg.)
Herstellung: Klaus Buck
Auslandsrepräsentation:
Schweiz: Markt & Technik Vertriebs AG, Kollerstr. 3, CH-6300 Zug, Tel. 042-22 31 55, Telex: 862 329
USA:	M&T Publishing lnc.; 2464 Embarcadero
Way, Palo Alto, CA 94303
Manuskripteinsendungen: Manuskripte und Programmlistings werden gerne von der Redaktion angenommen. Sie müssen frei sein von Rechten Dritter. Sollten sie auch an anderer Stelle zur Veröffentlichung oder gewerblichen Nutzung angeboten werden, so muß dies angegeben werden. Mit der Einsendung von Manuskripten und Listings gibt der Verfasser die Zustimmung zum Abdruck in von der Markt & Technik Verlags AG herausgegebenen Publikationen und zur Vervielfältigung der Programmlistings auf Datenträger. Mit der Einsendung von Bauanleitungen gibt der Einsender die Zustimmung zum Abdruck in von Markt & Technik Verlag AG verlegten Publikationen und dazu, daß Markt & Technik Verlag AG Geräte und Bauteile nach der Bauanleitung herstellen läßt und vertreibt oder durch Dritte vertreiben läßt. Honorare nach Vereinbarung. Für unverlangt eingesandte Manuskripte und Listings wird keine Haftung übernommen.
Vertriebsleitung: Hans Hörl
Anzeigenverwaltung und Disposition: Michaela Hörl
Verlagsleiter M&T-Buchverlag: Günther Frank
Druck: Druckhaus München GmbH, Schellingstraße 39-43, 8000 München 40 Auch Anschrift für Beihefter und Beilagen.
Preis: Das Einzelheft kostet DM 14,—
Vertrieb Handelsauflage: Inland (Groß-, Einzel- und Bahnhofsbuchhandel) sowie Österreich und Schweiz: Pegasus Buch- und Zeitschriften-Vertriebs GmbH, Hauptstätter Straße 96, 7000 Stuttgart 1, Telefon (0711) 76 48 30
Urheberrecht: Alle in diesem Heft erschienenen Beiträge sind urheberrechtlich geschützt. Alle Rechte, auch Übersetzungen, vorbehalten. Reproduktionen gleich welcher Art, ob Fotokopie, Mikrofilm oder Erfassung in Datenverarbeitungsanlagen, nur mit schriftlicher Genehmigung des Verlages. Anfragen sind an Michael Scharfenberger zu richten. Für Schaltungen, Bauanleitungen und Programme, die als Beispiele veröffentlicht werden, können wir weder Gewähr noch irgendwelche Haftung übernehmen. Aus der Veröffentlichung kann nicht geschlossen werden, daß die beschriebenen Lösungen oder verwendeten Bezeichnungen frei von gewerblichen Schutzrechten sind. Anfragen für Sonderdrucke sind an Peter Wagstyl (185) zu richten.
© 1985 Markt & Technik Verlag Aktiengesellschaft
Verantwortlich:
Für redaktionellen Teil: Michael Scharfenberger Für Anzeigen: Brigitte Fiebig
Redaktions-Direktor: Michael M. Pauly
Vorstand: Carl-Franz von Quadt, Otmar Weber
Anschrift für Verlag, Redaktion, Vertrieb, Anzeigenverwaltung und alle Verantwortlichen:
Markt & Technik Verlag Aktiengesellschaft, Hans-Pinsel-Straße 2, 8013 Haar bei München, Telefon (0 89) 4613-0, Telex 5-22 052
Aktionäre, die mehr als 25% des Kapitals halten: Otmar Weber, Ingenieur, München; Carl-Franz von Quadt, Betriebswirt, München. Aufsichtsrat: Dr. Robert Dissmann (Vorsitzender), Karl-Heinz Fanselow, Eduard Heilmayr
122

COMPUTER-ZEOSCHRIFIEN VON PROFIS FÜR PROFK
COMPUTER PERSÖNLICH
PC MAGAZIN
Das aktuelle Fachmagazin für Personal-Computer.
* Wenn Sie jetzt den Schritt vom Heim-Computer zur professionellen Anwendung eines Personal Computers planen
* Wenn Sie beruflich oder privat bereits einen Personal Computer benutzen
* Wenn Sie regelmäßig Informationen über das aktuelle Produktangebot benötigen
★ Wenn Sie selbst programmieren
★ Wenn Sie professionelle Hard-und Softwaretests suchen
* Wenn Sie Ihr eigenes System möglichst effizient einsetzen wollen
dann ist »Computer persönlich«, das aktuelle Fachmagazin für Personal Computer, genau Ihre Zeitschrift.
Die konsequente Ausrichtung auf professionelle Anwendungen bietet Ihnen alle wichtigen Informationen.
Von Profis für Profis!
»Computer persönlich« gibt es alle 14 Tage neu bei Ihrem Zeitschriftenhändler oder im Computer-Fach-geschäft.
Einzige Wochenzeitung für Personal Computer im IBM-Standard.
Sie beschäftigen sich beruflich oder privat mit dem Einsatz und der Anwendung von Personal Computern?
Sie sind an aktuellen, professionellen Informationen über IBM-PCs, kompatible Systeme und deren professionellen Einsatz interessiert?
Dann ist das PC Magazin genau auf Ihre persönlichen Bedürfnisse zugeschnitten.
Es wird von anerkannten und erfahrenen Fachjournalisten für professionelle Anwender und Fachleute geschrieben.
Es berichtet jede Woche ausschließlich über Computer im IBM-Standard und kompatible Systeme, über Hard- und Softwareneuheiten.
Es bringt ausführliche Testberichte und gibt Ihnen wichtige Informationen über Netzwerke sowie die PC/Host-Verbindung.
Nur diese Spezialisierung ermöglicht eine gezielte Berichterstattung und bietet genügend Raum, um auf Anwenderprobleme spezifisch eingehen zu können.
Von Profis für Profis!
Und das jeden Mittwoch neu bei Ihrem Zeitschriftenhändler oder im Computer-Fachgeschäft.
GUTSCHEIN
für ein kostenloses Probeexemplar
Senden Sie mir die neueste Ausgabe der von mir
□ COMPUTERPERSÖNLICH
Wenn mir Computer persönlich zusagt und ich es regelmäßig weiterbeziehen möchte, brauche ich nichts zu tun: Ich erhalte Computer persönlich dann regelmäßig alle 14 Tage per Post frei Haus geliefert und bezahle pro Jahr nur DM 98,— Zustellung und Postgebühren übernimmt der Verlag.
Vorname/Name
Straße	PLZ/Ort
angekreuzten Zeitschrift kostenlos als Probeexemplar:
□ PC-MAGAZIN
Wenn mir das PC-Magazin zusagt und ich es regelmäßig weiterbeziehen möchte, brauche ich nichts zu tun: Ich erhalte mein PC-Magazin dann regelmäßig jede Woche per Post frei Haus geliefert und bezahle pro Jahr nur DM 155— Zustellung und Postgebühren übernimmt der Verlag.
Mir ist bekannt, daß ich diese Bestellung innerhalb von 8 Tagen bei der Bestelladresse widerrufen kann und bestätige dies durch meine zweite Unterschrift. Zur Wahrung der Frist genügt die rechtzeitige Absendung des Widerrufs.
Datum	1. Unterschrift
Datum	2. Unterschrift
Gutschein ausfüllen, ausschneiden, auf Postkarte kleben und einsenden an: Markt&Technik Verlag Aktiengesellschaft, Vertrieb, Postfach 1304, 8013 Haar.
Bücher zum «^ÄT.!“ ^
• Die drei Betriebsmod^	mit entsprechenden
überzeugt aueh^e “	dje ricMigen Bucher,	-,
Dann brauchen iie nu
Madi^^
^tatt^111^
Conunodore
Handbuch
p Rosenbeck	OR-Hondbuch
Das Commodore u
1985, 383 Seiten	Querechnitt durch alle
In diesem Buchfinden^e^^j^gsberei^^^
MoHus und der Benutzung	und Soundmög-
lichkeiten des C \28>m	und werden n dte
^KÄÄ^	d“510 “'
|riffbereit haben sollten.
K’Ä»
jürg^HückatMt
BAS^7.0
aufdeff^
I Commodore
BASIC7 0 auf dem CommodoreU8
1985,239Seiten	-^rProarammierkenntnisse
Ganz gleich, ob Sie ^tsu e lhnen helfen verfügen oder nicht, dieses dem |eistungSStarken den qrößtmöghchen r~]78PC zu ziehen. Sie nr>twendiqen Kenntnisse	iictenverarbeitung,
Aufgabenstellungen ^.^ag	,' Grafikdarstellungen
indexsequentielle D°e' unenfbehrliches 4^uch, sä xs^ s«*« ^0*' * schlagewerk eignet.
^Ä7Ä«__________________________??^^
Markt&Technik-Produkte erhalten Sie bei Ihrem Buchhändler.	^^ Buchhändler oder
Bestellkartenbit	andlungen.
an eine unserer Oepo	Hettes
Adressenverzeichnis am Ende o
® JQ Q> s' ® Q N ™ ■— W ^ > O) *- v. f- ^- m
I «X
> CO ™J
p
N
... daß Sie jetzt bisher erschienene 64’er-Ausgaben und Sonderhefte nachbestellen können?
.. daß es jetzt eine schöne und praktische Sammelbox fiir Ihre wertvollen Hefte gibt?
CO
3

CO CO CD


Bitte benützen Sie für Ihre Bestellung nur diese Postscheck-Zahikarte!
LU
1
CB C
CB I E
Übrigens...
... die 64’er-Sammelbox ist nicht nur praktisch für den eigenen Gebrauch, sondern auch ein heißer Geschenktip zu vielen Anlässen!
O 'co
CO
E
<0 c O o
£
C0 0)
9? ° § W^’o) c o £
CD
o
.2
TD
2
CD
O
3
▼ Postscheck-Zahlkarte für die Bestellung bereits erschiener 64’er-Ausgabe und Sonderhefte
Für Mitteilungen an den Empfänger
Bestellung Leser-Service Wichti9: Lieferanschrift (Rückseite) nicht vergessen!			
Bestell-Nr.	Anzahl	x Einzelpreis	= Gesamtpreis
Sammelbox »64’er«		DM 14,-	
Sonderheft:		DM 14,-	
Sonderheft:		DM 14,-	
Ausg	/1984		DM 6,50	
Ausg	/1985		DM 6,50	
Zzgl. einm. Versandkostenpauschale (DM 3,-)			DM 3,-
Summe bitte auf Vorderseite übertragen.		Gesamtsumme:	DM
I
co o
00
I
O) o
CD £ O
s
... daß Sie alle im Heft abgedruckten Listings sowie die Listings aus allen 64’er-Ausgaben auch auf Diskette bestellen können?
Die in diesem Sonderheft abgedruckten Listings gibt es auf Kassette und auf Diskette:
-~ Best.-Nr.L6 85 S5K (Kassette) DM 19,90*
BestNr. L6 85 S5 D (Diskette) DM 29,90*
* inkl. MwSt. Unverbindliche Preisempfehlung.
Verwenden Sie dafür nur die nebenstehende Postscheck-Zahlkarte,
Bestellungen in der Schweiz richten Sie bitte an: Markt&Technik Vertriebs AG, Kollerstrasse 3, 6300 Zug in Österreich: Buchhandlung Bücherzentrum Meidling, Schönbrunnerstraße 261, 020 Wien
Microcomput-ique Erhard Schiller, Fasangaße 21, 1030 Wien
Alle anderen Markt&Technik-Produkte erhalten Sie bei Ihrem Buchhändler oder bei unseren Depot-Händlern. Adressenverzeichnis am Ende des Heftes.
Für Mitteilungen an den Empfänger
Bestellung Listing-Service Wichtig: Lieferanschrift (Rückseite) nicht vergessen! _____________________________________________
Bestell-Nr. Anzahl x Einzelpreis - Gesamtpreis
«Effi	fe^L._
t&tWA_____M^L___________
Summe bitte auf
Vorderseite übertragen. Gesamtsumme:
inkl. MwSt. Unverbindliche Preisempfehlun<