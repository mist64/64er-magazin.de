# Programme, die jeder braucht \[3\]

Interessante Informationen und hervorragende Listings zu ausgesuchten Themen finden Sie in unserer 64’er Sonderheftreihe. In diesem Sonderheft haben wir bislang noch nicht veröffentlichte Listings und Tips & Tricks zu den Themen
- Datasette,
- Floppy
- Basic-Erweiterungen
- Programmier-Hilfen
zusammengetragen. Ob Anfängeroder Profi — für jeden ist etwas dabei.

Zwei Speichermedien sind es, die der C 64-Besitzer in erster Linie einsetzt: die Datasette und die Floppy 1541. Die Datasette trifft man hauptsächlich dort an, wo entweder die Finanzlage nicht allzu rosig aussieht, oder wo jemand erst einmal in die Computerwelt hineinschnuppern will. »Aufrüsten« ist ja immer noch möglich. Aber Berichte von Händlern und Umfragen zeigen es ganz deutlich: der Vormarsch der Floppy ist nicht zu bremsen. Und das mit Recht.

### Schnelle Datasette

Datasetten-Benutzer haben oft Schwierigkeiten, Kassetten von Freunden oder Bekannten zu laden. Vielfach liegt es an einem verstellten Tonkopf. Wir geben Ihnen wertvolle Tips, wie man fremde Kassetten trotzdem nutzen kann. Das Laden und Speichern von Programmen ist bei der Datasette ein langwieriges Unternehmen. Mit unserem Quick-Tape wird sie auf einmal schneller als die Floppy.

### Floppy- und Anwendungslistings

Unwahrscheinlich vielseitig ist der Komplex »Floppy«, für den wir einiges an Hilfsprogrammen und wertvollen Anwendungen anbieten. Eine schnelle Formatierroutine und ein sehr schnelles Kopierprogramm sind ebenso gefragt wie einige Programme zur Manipulation des Directorys. Greifen Sie in das DOS der Floppy ein mit dem Floppy-Monitor! Vergessen Sie die manchmal sehr umständliche Bedienung des Floppy-Lauf-werks! Arbeiten Sie mit »Disk-Master«! Eine komplette Dateiverwaltung, mit der unter anderem eigene Masken erstellt werden können, wird Sie begeistern!

### Basic-Erweiterungen

Wir haben einige sehr interessante Basic-Erweiterungen für Sie herausgesucht, die alles bieten, was Sie sich vorstellen können. SindSie ein Liebhaberderstrukturierten Programmierung? Dann ist »aufpoliertes Basic« das Richtige für Sie. Sogar Programmierer von Spielen dürfen sich auf eine spezielle Basic-Erweiterung für Spiele freuen. Und mit »Disc-Basic« bekommen Sie das Floppy-Laufwerk erst richtig in den Griff.

### Tips und Tricks-Listings

Tips und Tricks sind immer wieder begehrt und kommen selbstverständlich nicht zu kurz. Darunter sind einige echte Leckerbissen, zum Beispiel die Cross-Reference-List, die Ihre Basic-Programme durchleuchtet. Komplettin Maschinencode geschrieben und deshalb sagenhaft schnell. Für Neugierige ist der Sourcecode gleich mit abgedruckt.

Alles in allem erhalten Sie in diesem Sonderheft rund 45 Listings, die es in sich haben. Alle Programme wurden mit Prüfsummen versehen, um Ihnen das Eintippen zu erleichtern. Sie finden dazu zwei Programme, den Checksummer 64 V3 (auf Seite 6 für Basic-Programme) und den MSE (für Maschinensprache-Listings auf Seite 8). Damit können Sie alle anderen Programme sicher und bequem abtippen.

### Listing-Service auf Kassette und Diskette

Wer keine Zeit oder keine Lust hat, alle Programme selbst in mühevoller Kleinarbeit abzuschreiben, kann wieder auf den bewährten Leserservice zurückgreifen.

Alle Listings befinden sich auf

- Diskette mit der Bestellnummer L6 85 S5D. Die Diskette kostet 29,90 Mark.
- Kassette mit der Bestellnummer L6 85 S5K. Die Kassette kostet 19,90 Mark.

Bitte verwenden Sie für Ihre Bestellung die beigefügte Postscheck-Zahlkarte zur Überweisung des Rechnungsbetrags. Sie erleichtern uns die Auftragsabwicklung und Sie sparen sich die 3 Mark Versandkosten!

# Checksummer 64 — Neu \[6-7\]

Der Checksummer 64 V3 überprüft jede Basic-Zeile direkt nach der Eingabe, erkennt Fehleingaben und auch Vertauschungen von Zahlen und Ziffern, und erspart deshalbeine aufwendige Fehlersuche.

Der Checksummer 64 V3 ist ein kleines Maschinenprogramm, das Sie sofort unterrichtet, ob Sie die jeweilige Programmzeile korrekt eingegeben haben.

So gehen Sie vor:

1.	Programm abtippen und speichern.
2.	Starten mit RUN
3.	Nach kurzer Zeit sehen Sie am Bildschirm:<br>CHECKSUMMER 64, CHECKSUMMER AKTIVIERT, AUSSCHALTEN MIT POKE 1,55, ANSCHALTEN MIT POKE 1,53, READY.
4.	Anschalten des Checksummer 64V3 mit POKE 1,53.
5.	Test: Geben Sie in einer freien Zeile ein: »1 REM« und drücken die RETURN-Taste. Am Bildschirm oben links sollten Siedie Prüfsumme <63> sehen.
6.	Geben Sie ein Listing aus unserem Heft ein. Nach jeder Zeile wird die Zahl, die im Listing in Klammern < > steht, in den Bildschirm eingeblendet. Stimmen die Zahlen nicht überein, so liegtvermutlich ein Eingabefehlervor. Die Zahl in den Klammern, und auch die Klammern selbst, dürfen beim Abtippen nicht mit eingegeben werden!
7.	Dieser neue Checksummer 64V3 bemerkt, im Gegensatz zu den bisherigen, auch Vertauschungen von Zahlen und Buchstaben.
8.	Unsere Basic-Listings enthalten keine Steuerzeichen mehr. Diese werden ersetzt durch Klartext und stehen zwischen geschweiften Klammern. Deshalb sind weder die Klammern noch was dazwischen steht, abzutippen, sondern die in Tabelle 1 aufgeführten Tasten zu drücken. Auf Ihrem Bildschirm erhalten Sie dann wieder die entsprechenden Grafikzeichen (siehe Bild 1 und 2).
9.	Alle Grafikzeichen werden ebenfalls ersetzt durch unterstrichene oder überstrichene Großbuchstaben. Unterstrichene Buchstaben bedeuten, daß Sie die SHIFT-Taste und den angegebenen Buchstaben drücken müssen, überstrichene jedoch die Commodore-Taste mit dem Buchstaben. Auch hier erhalten Sie am Bildschirm das entsprechende Grafikzeichen und nicht etwa das im Listing erkennbare Zeichen (siehe Bild 1 und 2).

## Checksummer VC 20 V3

Der Checksummer VC 20 V3 ist im Prinzip genauso aufgebaut wie der Checksummer 64. Da beim VC 20 jedoch nicht die Möglichkeit besteht, das ROM softwaremäßig zu modifizieren, mußte ein anderer Weg als beim Commodore 64 gewählt werden, um die Checksumme zu generieren.

In ihrer Funktionsweise unterscheiden sich der Checksummer VC 20 und der Checksummer 64 nicht. Es gelten folgende Sonderregelungen bei der Benutzung des Checksummer VC 20:

- Da der Basic-Bereich nicht belegt werden soll, ist das Programm im Kassettenpuffer abgelegt.
- Angeschaltet wird der Checksummer VC 20 mit »SYS 955«.
- Abschaltung des Checksummer VC 20 wird mit »SYS 58459« vollzogen.

Achtung: Nehmen Sie keine Kassetten-Operationen vor, wenn der Checksummer VC 20 eingeschaltet ist. Da das Betriebssystem den Kassettenpuffer mit Daten belegt, kann der Checksummer VC 20 überschrieben werden, was zur Folge hat, daß sich der Computer bei aktiviertem Checksummer VC 20 »aufhängt«. Wollen Sie deshalb ein Programm auf (von) Kassette abspeichern (laden), so müssen Sie erst den Checksummer VC 20 abschalten (SYS 58459).

Daraufhin kann der Kassettenpuffer mit Daten überschrieben werden, ohne daß der Computer »aussteigt«.

Als Sicherung wird bei der Initialisierung geprüft, ob das zuletzt angesprochene Peripherie-Gerät der Kassettenrecorder war. Ist das der Fall, so werden die Betriebssystemroutinen LOAD und SAVE für die Benutzung gesperrt. Der Rechner meldet bei Aufruf einer dieser beiden Routinen READY, ohne weitere Aktionen durchzuführen. Diese Sicherung kann man nach der Tipparbeit aufheben, wenn man den Checksummer VC 20 mit SYS 58459 abschaltet. Dadurch wird der Kassettenpuffer für andere Daten freigemacht. Weiterhin wird dann durch gleichzeitiges Drücken der Tasten »Run-Stop & Restore« erreicht, daß die Betriebssystemroutinen LOAD und SAVE wieder eingerichtet werden.

- Bei Benutzung einer Diskettenstation brauchen Sie nicht darauf zu achten, daß bei LOAD beziehungsweise SAVE der
C 64/VC 20 Checksummer VC 20 überschrieben wird, da der Kassettenpuffer für die Diskettenstation normalerweise nicht genutzt wird. Deshalb können Sie die beiden Routinen weiterhin normal nutzen, sofern der Rechner bei der Initialisierung des Checksummer VC 20 feststellt, daß das zuletzt angesprochene Peripherie-Gerät nicht der Kassettenrecorder war.
- Bedingt durch den anderen Aufbau des Checksummer VC 20 wird anders als beim Checksummer 64 nach der LOAD-Routine keine Checksumme ausgegeben.
- Wird eine Zeile gelöscht, also eine Zahl zwischen 0 und 65999 eingegeben, und danach Return gedrückt, so wird eine Checksumme ausgegeben, die aber keine Bedeutung hat.

Sie können die Programme auch weiterhin ohne den Checksummer eintippen.

(F. Lonczewski/gk)

**Hinweis: {13 SPACE} bedeutet 13mal die Leertaste drücken**

TODO ASIDE

CTRL steht für Control-Taste, so bedeutet \[CTRL-A\], daß Sie die	
Control-Taste und die Taste »A« drücken müssen. Im folgenden steht:	
{DOWN}	Taste neben rechtem Shift, Cursor unten
{UP}	Shift-Taste & Taste neben rechtem Shift; Cursor hoch
{CLR}	Shift-Taste & 2. Taste ganz rechts oben
{INST}	Shift-Taste & Taste ganz rechts oben
{HOME}	2. Taste von ganz rechts oben
{DEL}	Taste ganz rechts oben
{RIGHT}	Taste ganz rechts unten
{LEFT}	Shift-Taste & Taste unten rechts
{SPACE}	Leertaste
{F1}	grauer Tastenblock rechts
{F3}	grauer Tastenblock rechts
{F5} .	grauer Tastenblock rechts
{F7}	grauer Tastenblock rechts
{F2}	grauer Tastenblock rechts & Shift
{F4}	grauer Tastenblock rechts & Shift
{F6}	grauer Tastenblock rechts & Shift
{F8}	grauer Tastenblock rechts & Shift
{RETURN}	Shift-Taste & Return
{BLACK}	Control-Taste & 1
{WHITE}	Control-Taste & 2
{RED}	Control-Taste & 3
{CYAN}	Control-Taste & 4
{PURPLE}	Control-Taste & 5
{GREEN}	Control-Taste & 6
{BLUE}	Control-Taste & 7
{YELLOW}	Control-Taste & 8
{RVSON}	Control-Taste & 9
{RVOFF}	Control-Taste & 0
{ORANGE}	Commodore-Taste & 1
{BROWN}	Commodore-Taste & 2
{LIG.RED}	Commodore-Taste & 3
{GREY 1}	Commodore-Taste & 4
{GREY 2}	Commodore-Taste & 5
{LIG.GREEN}	Commodore-Taste & 6
{LIG.BLUE}	Commodore-Taste & 7
{GREY 3}	Commodore-Taste & 8

Wenn Sie sich erst einmal an die in Klartext geschriebenen Steuerzeichen gewöhnt haben, werden Sie den Vorteil dieser Schreibweise erkennen. Der zu dem jeweiligen Steuerzeichen gehörende Klartext ist so verfaßt, daß Sie leicht die Taste beziehungsweise die Tastenkombination finden, die Sie drücken müssen.

Die Steuerbefehle im Klartext	

## MSE - Abtippen sicher und leicht gemacht

> Ähnlich wie der »Checksummer« ist auch der MSE ein Hilfsmittel bei der Eingabe von Listings, diesmal jedoch bei reinen Maschinensprache-Programmen.

Im Gegensatz zum »Checksummer« aber ist die Eingabe nicht ohne den MSE möglich. Der MSE verringert die Tipparbeit um ein Drittel und schließt Fehleingaben vollkommen aus. Außerdem können Sie die Werte blind eingeben, ohne andauernd auf den Bildschirm schauen zu müssen. Dies wird durch akustische Meldungen realisiert.

MSE ist ein Maschinenspracheditor, mit dem ein Vertippen ausgeschlossen ist. Eine abgetippte Zeile wird nur angenommen, wenn sie richtig ist. Eine Checksumme am Ende jeder Zeile prüft, ob die richtigen Werte in der richtigen Zeile an der richtigen Stelle stehen. Wenn nicht, ertönt ein Warnsignal, und man beseitigt den Fehler.

War die Zeile korrekt, erklingt ein Gong, und die nächste Zeilennummer wird ausgegeben. Damit ist also auch »blindes« Eintippen möglich; Sie können sich voll auf den Text konzentrieren.

### So arbeitet man mit MSE

Laden und starten Sie MSE. Zuerst wird der Programmname und die Start- und Endadresse erfragt. Diese Angaben entnehmen Sie dem Kopf des jeweiligen abgedruckten Listings. MSE meldet sich dann mit der Zeilennummer der ersten Zeile. Wenn Sie die Zeile richtig eingegeben haben, erscheint die nächste Zeilennummer und so weiter bis zum Ende. Zum Schluß wird das fertige Programm mit »CTRL-S« auf Diskette oder Kassette abgespeichert. Dazu sind keine weiteren Angaben mehr erforderlich. Das Programm kann dann ganz normal wieder geladen und gestartet werden. Wenn Sie nicht alles auf einmal tippen wollen, können Sie jederzeit unterbrechen und den eingetippten Teil mit »CTRL-S« abspeichern. Wollen Sie weiterarbeiten, laden und starten Sie MSE wieder.

Geben Sie auf die Frage nach der Startadresse aber jetzt »L« ein, um Ihr Teilprogramm zu laden. Jetzt können Sie mit »CTRL-N« die Adresse eingeben, an der Sie weitertippen müssen. Wenn Sie sich nicht gemerkt haben, wie weit Sie gekommen sind, geben Sie nach dem Laden »CTRL-M« ein.

Auf die Frage nach der Startadresse antworten Sie mit der Anfangsadresse, die links in der Kopfzeile auf dem Bildschirm steht. Nun wird Ihr Programm aufgelistet. Mit »SPACE« wird das Listen fortgesetzt, mit »STOP« abgebrochen. Das Ende Ihres Programmteils erkennen Sie sehr einfach daran, daß nur noch der Wert »AA« in der Zeile steht. Die Adresse dieser Zeile müssen Sie anschließend mit »CTRL-N« eingeben. Das Programm ist nur mit »STOP/RESTORE« zu verlassen. Speichern Sie aber vorher unbedingt immer Ihren Text ab.

### Hinweise zum Abtippen

Vor dem Abtippen oder späteren Wiederladen des MSE-Laders müssen Sie unbedingt folgende Zeile eingeben:
**POKE 43,1: POKE 44,32: POKE 8192,0: NEW**

Starten Sie das Programm mit RUN. Fehlerhafte Zeilen werden angezeigt und müssen korrigiert werden, bis der Lader zum »READY« durchläuft. Jetzt müssen Sie das fertige MSE-Programm abspeichern. Dazu brauchen Sie nur »RETURN« zu drücken, weil die erforderlichen Angaben schon auf dem Bildschirm stehen. (Kassettenbesitzer müssen in Zeile 343 die letzte Zahl in »1« abändern.) Ab jetzt können Sie »MSE V1.0« direkt, also ohne den DATA-Lader, benutzen. MSE V1.0 wird ganz normal mit »,8« geladen (keine POKEs notwendig).

(N. Mann / D. Weineck / gk)

TODO ASIDE

MSE-Befehle:
DEL löscht die letzte Eingabe.
CTRL-S speichert das eingetippte Programm ab.
CTRL-L lädt ein Programm. Start- und Endadresse werden automatisch ermittelt.
CTRL-M listet den Speicherinhalt. Abbruch mit STOP-Taste, weiter mit Leertaste.
CTRL-N erlaubt die Eingabe einer neuen Adresse zum Weitertippen.
CTRL-P gibt ein MSE-Listing auf dem Drucker aus.

# Komfortable Befehlserweiterung \[8-9\]

> »Basic-Expansion« ist ein universelles Programm, das den Befehlssatz des C 64 um 42 neue Kommandos erweitert, die das Arbeiten mit Floppy und Grafik enorm vereinfachen.

Das Besondere an dieser Erweiterung ist zudem, daß sie sich »unter« dem Basic-ROM befindet. Trotz der Länge von 6625 Byte des Maschinenprogramms werden nur 260 Byte des freien Basic-RAM benötigt.

Nachdem das Programm (siehe Listing) mit »SYS 40700« gestartet wurde, erscheint nach kurzer Zeit die Einschaltmeldung von »Basic-Expansion«. 42 neue Befehle (siehe Tabelle) können von nun an ganz normal verwendet werden.

**Hier die neuen Befehle im Überblick:**
Bei der Beschreibung gelten folgende Symbole:
**ga**: Geräteadresse
**lfn**: logische Filenummer
**fa**: Farbe (1 bis 16, 1=schwarz, 2=weiß, 3=rot, etc.); der Farbcode entspricht genau der Anordnung auf der Tastatur (CRTL 1 = schwarz, CRTL 2 = weiß etc.)
**PLOT x,y,fa**: Punkt mit den Koordinaten (x,y) und der Farbe fa setzen (nur im Grafikmodus)
**LINE a, b, x, y, fa**: Linie von Punkt (a,b) bis Punkt (x,y) in der Farbe fa zeichnen
**SETARC Startwinkel, Endwinkel, Schrittweite, Mittelpunkt x, Mittelpunkt y, Radius in x-Richtung, Radius in y-Richtung, Farbe fa**: Diese Routine zeichnet einen Kreisbogen (im Bogenmaß) um einen Mittelpunkt.
**Beispiel**: »SETARC 0,2*3.14,0.1,200,100,100,3«zeichnet einen vollen Kreis um den Mittelpunkt (100,100) mit dem Radius 100 in roter Farbe.

Diese Zeichenroutine kann jedoch nicht nur Punkte setzen, sondern auch wieder löschen. Dazu setzt man fa einfach auf Null.
Beispielsweise löscht»PLOT 100,100,0«den Punkt(100,100), weil der Farbcode gleich Null ist. Das giltauch für LINE und SETARC.
**GRAPHICS** schaltet die hochauflösende Grafik ein (320x200 Punkte).
**NORM** ist der Gegenbefehl zu GRAPHICS und schaltet wieder zurück in den Textmodus.
**GCLEAR** löscht eine hochauflösende Grafik.
**GCOL r, h** setzt die Farbe r als Rahmenfarbe und h als Hintergrundfarbe für die hochauflösende Grafik.
**GSAVE "PRG-NAME ", ga** speichert die hochauflösende Grafik auf Kassette oder Diskette.
**GLOAD "PRG-NAME", ga** lädt eine hochauflösende Grafik von Diskette oder Kassette. GSAVE und GLOAD speichern, beziehungsweise laden auch den Farbspeicher der hochauflösenden Grafik.
**COLOUR r, h** arbeitet im Textmodus und setzt die Farben für Rahmen (r) und Hintergrund (h).
**HBLOCK l, fa** zeichnet im Textmodus einen horizontalen Balken der Länge I in der Farbe fa ab der aktuellen Cursorposition und setzt den Cursor eine Zeile tiefer. L darf nur Werte zwischen 0 und 319 annehmen.
**VBLOCK l, fa** arbeitet wie HBLOCK, nur in vertikaler Richtung. Zugelassen sind Werte zwischen 0 und 199.
**CURSCOL fa** ändert die Cursorfarbe, das heißt man kann so die Schrittfarbe wählen.
**SCROLL r, uz, oz** scrollt den Bildschirm zwischen den Zeilen uz und oz in der Richtung, die der Parameter r angibt. Dabei bedeutet: 0 nach rechts; 1 nach oben; 2 nach links und 3 nach unten, uz ist die untere und oz die obere Zeile, die beide im Bereich zwischen 0 und 24 liegen.
**DOKE a, b** bedeutet ein »Doppelbyte-POKE«, das heißt, a und b sind 2-Byte-Zahlen. In die Speicherstelle a wird das Low-Byte von b gePOKEt, entsprechend wird der Speicherstelle a+1 das High-Byte von b zugewiesen.
**SIZE** gibt die Speicherplatzbelegung aus: gesamter Basic-Speicher, Programm, Variablen, Arrays, Strings, freier Basic-Speicher.
**RESTORE n** setzt den DATA-Zeiger auf die Zeile n oder auf die nächste darauffolgende Zeile, n muß dabei eine Zeilennummer sein. Der normale RESTORE-Befehl funktioniert natürlich auch noch.
**ON...RESTORE a, b, c, d..** läuft ähnlich ab wie ON..GOTO. Je nach dem Ergebnis des Ausdrucks nach dem ON-Befehl wird der DATA-Zeiger auf die Zeile a, b, c,.. positioniert.
**MERGE "PRG-NAME", ga** hängt ein Basic-Programm von Diskette oder Kassette mit Geräteadresse ga an ein im Speicher befindliches Basic-Programm an und sortiert die Basic-Zeilen nach ihren Zeilennummern.
**GEN "String"** arbeitet nur im Programm-Modus. Dieser Befehl erzeugt eine neue Basic-Zeile in einem Basic-Programm. Der String muß am Anfang eine Zeilennummer und danach den Basic-Text enthalten. Zum Beispiel erzeugt der Befehl GEN "10 DATA 1,2,3" die Basic-Zeile »10 DATA 1,2,3« im Programm. Nach der Erzeugung fährt das Programm mit der auf den GEN-Befehl folgenden Basic-Zeile fort. Der Computer springt nach dem GEN-Befehl immer in die nächste Zeile, so daß Basic-Befehle in derselben Zeile nach dem GEN-Befehl i nicht ausgeführt werden. Zu beachten ist aber, daß alle Varia-tolenwerte gelöscht werden und daß der String nur 80 Zeichen umfassen darf. Und noch ein Hinweis: Enthält der String nur eine Zeilennummer, so wird die entsprechende Basic-Zeile gelöscht. In keinem Falle sollte der GEN-Befehl in einem Unterprogramm verwendet werden, da er den Basic-Stack manipuliert.
**DUMP** listet alle verwendeten Variablen tabellarisch auf. Lediglich die Arrays werden dabei nicht berücksichtigt.
**ARRAY** gibt sämtliche Arrays mit Werten aus. Die Ausgabe kann durch einmaligen Druck der SHIFTTaste angehalten werden. Dann wartet das Programm so lange, bis die Commodore-Taste gedrückt wird. Dies gewährleistet, daß der Benutzer alle Arraywerte genauestens ablesen kann.
**RENUM z, s** numeriert ein Basic-Programm neu. RENUM ändert neben den Zeilennummern die Adressen bei GOTO, GOSUB, THEN, RESTORE, RUN sowie bei sämtlichen ON..GOTO, ON..GOSUB oder ON..RESTORE-Ausdrücken. Z gibt die erste neue Zeilennummer, s die Schrittweite an. RENUM berücksichtigt ebenfalls, ob möglicherweise zu große Zeilennummern erreicht werden. Bevor die Zeilennummern verändert werden, wird geprüft, ob die zu erzeugenden Zeilennummern auch im Bereich 0 bis 64000 liegen, andernfalls wird eine Fehlermeldung ausgegeben. Die Schrittweite 0 wird auch nicht akzeptiert. RENUM kann im Programm-Modus verwendet werden. Dabei werden alle Variablenwerte gelöscht. Wie beim GEN-Befehl springt der Computer nach dem RENUM-Befehl automatisch in die nächste Basic-Zeile. Der RENUM-Befehl kann zwei Fehlermeldungen ausgeben: »US-ERROR IN xx« bedeutet, daß im Programm eine Sprungadresse nichtvor-handen war. »US« steht für '»UNDEFINED STATEMENT«. Der RENUM-Befehl unterbrichtjetztaber nicht einfach, sondern er ersetzt die nicht-definierte Sprungadresse durch die Adresse derjenigen Basic-Zeile, die als nächste auf die nicht-definierte folgen würde. Die zweite Fehlermeldung lautet: »SN-ERROR IN xx«, welche anzeigt, daß bei einer Sprungadresse eine zu große Zahl angegeben wurde. Hier verfährt der Befehl so, daß statt der fehlerhaften Adresse die Adresse der ersten Basic-Zeile im Programm eingesetzt wird. Dadurch wird verhindert, daß ein Programm durch die falsche Adresse möglicherweise abstürzt. Die Zeilennummern xx in den Fehlermeldungen gibt natürlich die neue Adresse der Zeile an, in der ein Fehler auftrat.
**OLD** ist der Gegenbefehl zu NEW. So können durch NEW oder Reset gelöschte Programme wieder »zurückgeholt« werden.
**CURSOR s,z(,"Drucktext")** ist der Positionierbefehl für den Cursor. S gibt die Spalte (0 bis 39) und z die Zeile (0 bis 24) der gewünschten Position an. Es existieren zwei CURSOR-Varianten:
CURSOR s, z setzt nur den Cursor.
CURSOR s, z , "String " dagegen positioniert den Cursor auf die Position (s,z) und druckt an diese Stelle den Text »String«. Wird also hinter der Zeilenangabe noch ein Komma gesetzt, so wird praktisch wie beim PRINT-Befehl fortgefahren.

Die nächsten Befehle beziehen sich nur auf das 1541-Floppy-Laufwerk. gn ist hierbei die Geräteadresse der Diskettenstation.
**DIRgn** listet das Directory der Diskette auf dem Bildschirm, ohne ein im Speicher befindliches Programm zu löschen. Der Benutzer kann während des Auflistens mit der gedrückten SHIFT-Taste das Listen so lange verzögern, bis die SHIFTTaste wieder entriegelt wird. Die Commodore-Taste unterbricht das Auflisten des Inhaltsverzeichnisses ebenfalls, nur wird damit das Listen einfach abgeschlossen und der Computer verarbeitet den nächsten Befehl.
**RECORD#,lfn,rn(,bp)** ist der Positionierbefehl für relative Dateien. Ifn bezeichnet die Filenummer des geöffneten relativen Files, rn stellt die Recordnummer (1-65535) und bp eventuell die Position innerhalb dieses Records (1-254) dar. Ohne Angabe von bp wird immer der Wert 1 angenommen.
**DISC "Befehl", gn** übermittelt dem 1541-Laufwerk DOS-Befehle wie zum Beispiel
DISC "I0", gn

Hier wird die Diskette in der Floppy-Station mit der Geräteadresse gn initialisiert. Mit DISC können alle DOS-Befehle, die an den Befehlskanal gehen, übertragen werden. Die Befehle müssen aber innerhalb der Anführungsstriche stehen.
**DISCGET# lfn,Variable$ (,Länge I)** ist ein erweiterter INPUT #-Befehl. Ifn bezeichnet die logische Filenummer; danach muß eine Stringvariable angegeben werden. Diese Routine liest nun bis zum nächsten RETURN-Code Zeichen ein und speichert sie unter der Stringvariablen ab. Dabei können bis zu 255 Zeichen eingelesen werden. Wird zusätzlich noch eine Länge I mit angegeben, so liest der Befehl genau I Zeichen ein, so daß die Stringlänge der Variablen vorbestimmt wird. Dies erweist sich beispielsweise beim Einlesen von Records aus relativen Dateien als sehr nützlich, denn hier kann der Parameter I die Länge des Records darstellen.
**PROTECT "File-Name", gn** schützt ein File auf der Diskette gegen den SCRATCH-Befehl. Files, die so geschützt sind, werden im Directory gesondert gekennzeichnet. Mit dem SCRATCH-Befehl können diese Files nicht mehr gelöscht werden.
**FREE "File-Name", gn** ist der Gegenbefehl zum PROTECT-Befehl. Hiermit werden geschützte Files auf der Diskette wieder freigegeben und können nun mit SCRATCH gelöscht werden. Für PROTECT und FREE gibt es auch die Möglichkeit, den Namen des Files mit dem Jokerzeichen " * " abzukürzen.
**DOSTYPE "Stringzeichen ", gn** verändert das DOS-Flag der Floppy-Station. Das Zeichen »A« kennzeichnet das DOS der VC 1541. Wird jetzt DOSTYPE "B", gn eingegeben, so hat der Benutzer das DOS-Flag verändert. Dies aber bedeutet, daß man nichts mehr auf die Diskette schreiben kann. Bei jedem Schreibbefehl wird geprüft, ob auch das »richtige« DOS-Flag vorhanden ist (DOS»A«), Trifft dies nicht zu, so kann eine Diskette nicht mehr beschrieben werden. Durch »DOSTYPE **"A",gn**« erzeugt man wieder das richtige DOS-Flag, so daß die Diskette wieder beschrieben werden kann. Insofern bedeutet der DOSTYPE-Befehl eine Art Schreibschutz der Diskette. Anzumerken ist noch, daß die Routine immer nur das erste Zeichen im Stringausdruck berücksichtigt.
@: Dieser Befehl dient demjenigen, der mit dieser Basic-Erweiterung noch nicht zufrieden ist, als zusätzlicher Erweiterungsbefehl. Der @-Befehl bewirkt normalerweise nichts. Der Zeiger in der Sprungtabelle der Basic-Befehle ist auf ein RETURN (RTS) positioniert. Der Benutzer kann nun ein Maschinenprogramm mit dem Klammeraffen aufrufen. Dazu muß er die Werte in der Sprungtabelle für den @-Befehl ändern. Der Sprungvektor liegt in den Speicherstellen 40221 und 40222 (dezimal). Normalerweise steht dort der Vektor 40804, weil in der Speicherstelle 40805 ein RTS-Code enthalten ist. Der Sprungvektor kann vom Benutzer verändert werden (durch die POKE- oder DOKE-Befehle), indem der Vektor auf die Einsprungadresse gesetzt wird. Wenn ein Programmierer beispielsweise einen neuen Befehl als Maschinenprogramm ab Adresse 828 (Kassettenpuffer) angelegt hat, so POKEt er das Low-Byte von (828—1) in 40221 ein und speichert das High-Byte von (828—1) in 40222 ab. Nun kann die neue Routine mit @ angesprochen werden. Durch Zuweisung des ursprünglichen Wertes von (40805—1) in die Speicherstellen der Sprungtabelle wird der neue Befehl wieder aufgehoben.
**Soweit die neuen Befehle. Nun kommen wir zu den neuen Funktionen der Erweiterung:**
**RAM (xx)** gibt den Inhalt der RAM-Speicherstelle xx an und ähnelt dadurch sehr der PEEK-Funktion. Doch die RAM-Funktion liest die Werte immer aus dem RAM aus. Zusätzlich wird im Bereich $D000 bis $DFFF (hexadezimal) der Charaktergenerator ausgelesen, so daß die Werte für die Zeichen aus dem Charakter-ROM aufgelistet werden können.
**CVAL ("String ")** ähnelt der VAL-Funktion, kann jedoch auch Rechnungen auswerten. So ergibt »CVAL("5*6+3")« als Beispiel den Wert 33, wogegen »VAL("5*6+3")« gleich 5 ist. CVAL verarbeitet alle Funktionen, jedoch darf der String nicht länger als 80 Zeichen sein.
**ROUND(x,y)** rundet eine Zahl x auf y Nachkommastellen. Somit kann man eine Fließkommazahl auf eine ganze Zahl runden, wenn y=0 ist.
**&(xxxx)** wandelt die dezimale Zahl xxxx (oder einen numerischen lnteger-Ausdruck) in den entsprechenden hexadezimalen String, welcher zwei oder vier Zeichen umfaßt, je nachdem ob der Wert xxxx kleiner oder größer als 256 ist. Der Ausdruck xxxx muß eine positive Zwei-Byte-Zahl darstellen. Beispiel: »PRINT &(15)« ergibt »OF«.
**!("yyyy")** ist das Gegenstück zur &-Funktion. Sie wandelt einen hexadezimalen String in die entsprechende dezimale, positive Zwei-Byte-Zahl. Der String muß zwei oder viör Zeichen umfassen, je nachdem ob der Hex-Wert kleiner oder größer als "FF" ist.
**TEST(x,y)** fragt ab, ob in der hochauflösenden Grafik der Punkt mit den Koordinaten (x,y) gesetzt ist. Trifft dies zu, so erhält man das Ergebnis -1, sonst ergibt sich der Wert 0.
**INSTR(1. String, 2. String)** oder **INSTR(1. String, 2. String, a)** untersucht, ob der zweite String im ersten String enthalten ist und gibt die Position an, ab der der zweite String gefunden wird. Ist der zweite String nicht im ersten String enthalten, so wird eine Null ausgedruckt. Der Parameter a, der zusätzlich mit angegeben werden kann, gibt die Position im ersten String an, ab der getestet werden soll, ob der zweite String ein Teil des ersten ist. Wird a nicht mit angegeben, so wird er automatisch auf 1. gesetzt, das heißt es wird ab der ersten Position im ersten String untersucht.
**DS$(ga)** liest den Fehlerkanal der Floppy-Station aus, wobei ga die Geräteadresse angibt.
**DS(ga)** ermittelt nur die Nummer der Fehlermeldung der Floppy-Station mit der Geräteadresse ga.
**HEADBYT ("File-Name", ga, n)** bezieht sich auf das n-te Byte im Eintrag eines Files im Inhaltsverzeichnis. Die Geräteadresse ist ga. Der String »File-Name« stellt den Namen des Files dar. Jeder Eintrag eines Files enthält 30 Byte mit wichtigsten Informationen über Länge des Files, File-Typ etc. Diese Bytes können nun einzeln mit der HEADBYT-Funktion ausgelesen werden. Beispielsweise stellt Byte 0 im Eintrag eines Files den File-Typ dar. Mit der HEADBYT-Funktion kann der Benutzer den File-Typ auslesen, wobei n=0 sein muß. Bei einer relativen Datei befindet sich im 21. Byte des Eintrags die Recordlänge, so daß mit HEADBYT die Recordlänge schnell festgestellt werden kann (bei n=21). Zu beachten ist, daß der Parameter n nur im Bereich 0 bis 29 liegen darf. Welche Bedeutung nun die einzelnen Bytes im Eintrag eines Files haben, läßt sich anhand des Bedienungshandbuches für die 1541 feststellen. Wichtig ist auch noch, daß bei der Angabe des File-Namens mit dem Jokerzeichen »*« gearbeitet werden kann. DEEK(xxxx) stellt ein Doppelbyte-PEEK dar. DEEK (xxxx) ist die Gegenfunktion zu DOKE. Es werden die Inhalte der Speicherstellen xxxx und xxxx+1 als positive Zwei-Byte-Zahl dargestellt. xxxx muß die Adresse des Low-Bytes markieren; das Ergebnis ist eine Zahl zwischen 0 und 65535. Die DEEK-Funktion liest immer aus dem RAM aus. In den Bereichen des Basic-lnterpreter-ROMs und dem Betriebssystem-ROMs wird ebenfalls immer das RAM ausgelesen. Das ROM kann nur mit PEEK ausgelesen werden. DEEK unterscheidet sich von der RAM-Funktion nur im Bereich $D000 bis $DFFF. Hier hat DEEK keinen Zugriff auf den Charaktergenerator.

Soweit sind nun alle neuen Befehle und Funktionen beschrieben worden. Eines sollte man jedoch unbedingt beachten: Bei der Benutzung des THEN-Befehls muß darauf geachtet werden, daß nach dem THEN ein Doppelpunkt»:«folgt, um danach die neuen Basic-Befehle benutzen zu können. Wird der Doppelpunkt weggelassen, so gibt der Computer »SYNTAX ERROR« aus, wenn nach THEN ein neuer Basic-Befehl verwendet wird.
**Hinweise zur Eingabe:**

Geben Sie das Programm mit dem MSE ein (siehe Seite 8). Geladen wird es dann mit »LOAD".. ",8,1«. Danach geben Sie bitte NEW ein. Der Start erfolgt mit »SYS 40700«.

Sollte während der Benutzung der Erweiterung ein RESET ausgelöst werden, so erscheint wieder das gewohnte Bild des Basic V2, was jedoch nicht heißt, daß die Basic-Erweiterung gelöscht worden ist. Die Erweiterung ist nicht gegen RESETs des Computers geschützt. Um das zu erreichen, hätte der gesamte Bereich von hexadezimal $8000 bis $A000 vor Überschreiben geschützt werden müssen, was aber einem Basic-Speicherverlust von 8 KByte gleichkäme. Doch eben dieser Speicherverlust sollte vermieden werden. Dem Benutzer sollte noch möglichst viel Speicherplatz für Basic-Programme und Daten zur Verfügung stehen. Doch wenn der Benutzer nach einem RESET sofort »SYS 40700« eingibt, so ist die Basic-Erweiterung wieder aktiviert, wenn nicht schwerwiegende Programmfehler einen Teil der Erweiterung verändert haben.

(Bernd Stuke/ev)

# Disk-Basic – programmieren Sie Ihre eigene Datenverwaltung! \[10-15,18-19\]

> Disk-Basic ergänzt das magere Basic V 2.0 um einige Befehle zum komfortablen Programmieren von sequentiellen und relativen Dateien.

Disk-Basic ist entstanden, um beispielsweise eine leistungsfähige Dateiverwaltung miteinfachen Befehlen zu programmieren. Das ist natürlich nur eines der denkbaren Anwendungsgebiete von Disk-Basic, denn sein umfangreicher Befehlsvorrat erleichtert generell das Arbeiten mit dem 1541-Floppy-Laufwerk. Disk-Basic hatdasZiel, nichtmehrmitspektakulären Kommandokombinationen die Laufwerke zum Arbeiten zu animieren, sondern mit Klartextbefehlen. Damit trägt es dem Prinzip einer Hochsprache wie Basic, komfortabel Daten zu verarbeiten, Rechnung.

Nach dem fehlerfreien Eingeben (verwenden Sie bitte den MSE) und Abspeichern des Programms (siehe Listing) kann Disk-Basic mit SYS 49152 gestartet werden. Die Befehlssyntax aller neuen Befehle richtet sich nach der altbewährten Methode: Sonderzeichenerkennung — Befehlsidentifizierung — Ausführung. Bevor nun die Wirkung der einzelnen Befehle erläutert wird, noch einige andere allgemeine Hinweise.

- Da, zumindest in Deutschland, das englische Pfund-Zeichen relativ wenig verwendet wird, wurde es als Einleitungszeichen für die neuen Befehle gewählt.
- Beim Start oder bei der Initialisierung werden zwei Kommandokanäle geöffnet:
OPEN 15,8,15 und OPEN 16,9,15

Es ist dabei ohne Belang, ob die Floppy-Laufwerke eingeschaltet sind oder nicht. Da der Befehl RUN alle Kanäle schließt, muß am Programmanfang immer mit INIT initialisiert werden. Der Grund für diese Forderung ist, daß während des Arbeitens mit relativen Dateien an den Zuständen der Kanäle nichts verändert werden darf.

- Um auch bei den Sekundäradressen Ordnung zu schaffen, wird beim Öffnen einer Datei die Sekundäradresse gleich der Kanalnummer gesetzt (zum Beispiel OPEN 2,8,2). Aus diesem Grund darf die Kanalnummer nur zwischen 2 und 14 liegen.
- Das zweite Floppy-Laufwerk (nicht unbedingt notwendig) sollte die Geräteadresse 9 haben. Ist es bereits fest auf eine höhere Nummer eingestellt, muß das Programm geringfügig verändertwerden. Ansonsten stehtzurVeränderung derGerä-teadresse ein gesonderter Befehl zur Verfügung.

Die 38 Befehle des Disk-Basic unterteilen sich in zwei Gruppen:

Die eigentlichen DOS-Befehle und allerlei Hilfsbefehle, zum Beispiel zur Aufbereitung von Datensätzen.

Folgendes zur Erklärung:

Steht »dr« in Klammern, so bedeutet das, daß die Geräte-Nummer weggelassen werden kann. Dabei wird angenommen, daß es sich um Gerät 8, das Floppy-Laufwerk handelt.

”...” bedeutet, daß weitere Parameterkombinationen angehängt werden können.

### Befehle für die Laufwerksbedienung

£CATALOG (.’’Parameter”) (,dr)
Ausgabe des Directorys. Als Parameter sind Standardjoker (siehe 1541-Handbuch Seite 11) einsetzbar.
£COLLECT (,dr)

»Aufräumen« führt eine Disk-Garbage-Collection durch (entspricht dem Validate.
£COPY,”neufile=altfile,...” (,dr)
Kopieren von Files
£CLALL

schließt alle Kanäle und öffnet die Kommandokanäle sofort wieder
£OPEN,fn,”filename,x,y”
öffnet Kanal fn.

TODO

x = s sequential
p	program
u	user
y = w	write
r	read
a	append
m Lesen einer nicht gechlossenen Datei

fn muß zwischen 2 und 14 liegen
£ERROR,dr,ds (,ds$) (,tr) (,se)
dr muß angegeben werden. Fehlerkanal wird gelesen £FORMAT,”diskname,id” (,dr) formatieren einer Disk
£RENAME,”neuname=altname” (,dr)
umbenennen von Dateien
£SCRATCH,”filename,...” (,dr)
löschen von Dateien
£CHANGE,neue nr, alte nr
Die Gerätenummer des »alten« Floppy-Laufwerks wird umgeändert.
£INIT (,dr)
Das betreffende Laufwerk wird initialisiert
£CHAIN,”Programmname” (,dr)
Aneinanderhängen von Programmen mit Variablenschutz; darf nur bei fertig entwickelten Programmen verwendet werden, da das Programm im Speicher nach Ende oder Abbruch nicht mehr ordnungsgemäß zu listen und zu starten ist. £SYSTEM,”Programmname” (,dr) die Erweiterung wird gespeichert
£FETCH,fn,az,er$,...
vom File fn werden az Zeichen in er$ eingelesen
£TRANS, Sendedatei-Nr., Empfangsdatei-Nr.
beide Dateien müssen geöffnet sein. Die Daten können zwischen allen Peripheriegeräten ausgetauscht werden.
£RANDOM,fn,”Name”,le,az (,dr)
fn = Kanalnummer
le = Länge eines Records
az = die Anzahl derfreigemachten Records (record az wird mit CHR$(255) beschrieben)
£CLEAR
löscht den Datenpuffer für relative Dateien
£PUT,fn,rn,az (,dr)
schreibt az Byte des Puffers in den Record rn
£GET,fn,rn,az (,dr)
liest az Byte des Records rn in den Puffer
£WRITE,pos,x$,az,...
schreibt az Zeichen des Strings x$ ab pos (Position) in den Puffer.
Ist der String zu kurz, wird mit CHR$(O) aufgefüllt.
£READ,Pos,az,x$... liestab Pos (Position) az: Zeichen des Puffers in x$

### Andere Befehle:

£COMRa,a$,...
wandelt die Zahl a (integer oder real) in den äquivalenten String. Real 5 Zeichen, Integer 2 Zeichen.
£RECOMP,a$,a,...
Umkehrung von COMP
£BEEP
Ausgabe eines Signaltones
£CSET,x,y
Cursorpositionierung
x = Zeile, y = Spalte
£CREAD,x,y
Cursorabfrage
gibt aktuelle Cursorposition aus (x = Zeile, y = Spalte)
£RESTORE, Ausdruck
Positioniert den Lesezeiger für Daten auf Zeile »Ausdruck«
£INSTR$,a$,b$,Pos,erg,...
durchsucht a$ ab Pos nach b$. Ist erg = 0, dann nicht vorhanden
£STORE,adresse,”XXYYXXYYXXYY...” ...
speichert Hexbytes ab Adresse (ideal für Sprites)
£STR$,”XXYYXXYYXXYY”,a$...
wandelt Hexbytes in ASCII-Zeichen und speichert sie in a$
£STRING,a Zeichen,er$ ...
erzeugt einen a Zeichen langen String aus
£COLOUR,f1,f2
verändert die Bildschirmfarben
£GOTO,Ausdruck
GOTO wird »berechenbar«
£HEX,z,h$...
wandelt z in h$ (hexadezmalzahl) um
£DEZ,h$,z...
wandelt h$ (hexadezimal) in z (dezimal) um
£LINPUT,a$
Übernimmt eine ganze Zeile mit allen Zeichen
£SYS,adresse,akku,xreg,yreg...
SYS mit Parameterübergabe der 6510-Register
akku = Akkumulator
xveg = X-Register
yveg = y-Register
£QUIT
verlassen des Interpreters

(Harald Großauer/aw)

# Record-Befehl für den C 64 \[20-21\]

> Dieses Programm erleichtet Ihnen den Umgang mit relativen Files.

Bei relativen Files kann auf jeden Satz des Files direkt zugegriffen werden, ohne die vorherigen Sätze lesen zu müssen. Außerdem kann ein eröffnetes File nach Belieben beschrieben und gelesen werden, es ist also zum Beispiel möglich, Satz 12 zu beschreiben, auch wenn bereits höhere Sätze existieren. Ein relatives File wird durch folgenden OPEN-Befehl eingerichtet:

OPEN lfn,ga,sa,”filename,l,”+chr$(sl). Dabei bedeutet:
**lfn** = logische Filenummer.
**ga** = Geräteadresse (normalerweise 8)
**sa** = Sekundäradresse (mindestens 2, höchstens 14)
**sl** = maximale Satzlänge des relativen Files (mindestens 1, höchstens 254). Diese Angabe ist entscheidend für den späteren Diskettenplatzverbrauch des Files, da auch Sätze, die nicht mit voller Satzlänge beschrieben werden, den gesamten durch sl reservierten Platz verbrauchen. Ist ein relatives File erst einmal eingerichtet, so kann die Satzlänge nicht mehr verändert werden. Es genügt dann der folgende OPEN-Befehl:
OPEN lfn,ga,sa,”filename”

Selbstverständlich muß ein relatives File auch mit CLOSE lfn geschlossen werden. Auf die einzelnen Sätze eines relativen Files wird normal mit PRINT #lfn, INPUT#lfn oder GET#lfn zugegriffen, allerdings muß vor jedem Zugriff auf den gewünschten Satz positioniert werden. Dies übernimmt die vorliegende Basic-Erweiterung.

Durch **RECORD#lfn,sn,(,p)** wird auf den Satz mit der Nummer sn positioniert, wird zusätzlich noch p angegeben, so wird innerhalb des Satzes das p-te Zeichen angewählt. Der neue Befehl muß von THEN durch einen Doppelpunkt abgetrennt werden. Es können folgende Basic-Fehlermeldungen auftreten:
?SYNTAX ERROR: Schreibfehler im Befehl oder die Erweiterung war nicht eingeschaltet.
?ILLEGAL QUANTITY ERROR: Ein Argument lag außerhalb des erlaubten Bereichs.
?FILE NOT OPEN ERROR: Das File mit der logischen Filenummer lfn war nicht eröffnet.
?ILLEGAL DEVICE NUMBER ERROR: Dem File mit der Nummer lfn ist ein Gerät mit einer Adresse kleiner als 8 oder größer als 15 zugeordnet.
Es können außerdem folgende Floppy-Fehlermeldungen auftreten (Sie müssen durch den Fehlerkanal ausgelesen werden):
50,RECORD NOT PRESENT: Der Satz, auf den positioniert wurde, existiert nicht. Diese Meldung kann ignoriert werden, wenn der Satz beschrieben werden soll, denn durch das Beschreiben wird er eingerichtet. (Und alle nicht existierende Sätze mit kleinerer Nummer ebenfalls.) Aus Geschwindigkeitsgründen empfiehlt es sich, bei der Einrichtung eines Files den höchsten Satz zuerst zu beschreiben.
51,OVERFLOW IN RECORD: Die maximale Satzlänge sl wurde beim Schreiben überschritten. Zu beachten ist, daß das Carriage Return am Ende des Satzes mitzählt.
52,FILE TOO LARGE: Die Diskette ist voll, der letzte Schreibzugriff kann nicht durchgeführt werden.

### Aufbau des Programms

Der Basic-Interpreter besitzt einen Zeiger (Adresse $0308, im Listing »decod« genannt), derauf die Routine zur Befehlsinterpretation zeigt. Dieser Vektor wird nach dem Aufruf der Erweiterung zuerst gemerkt und danach auf eine eigene Routine zur Befehlsinterpretation gesetzt. Vor dem Merken wird noch geprüft, ob der Vektor schon auf die eigene Routine zeigt. Damit wird verhindert, daß der Computer bei einem versehentlichen Doppelaufruf abstürzt. Die eigene Routine rettet zunächst den Zeiger, der auf das augenblickliche Zeichen im Basic-Text zeigt, und ruft dann die CHRGET-Routine (Befehlscodierung siehe Bild 1, Symboltabelle Bild 2) auf. Diese Routine holt das nächste Zeichen aus dem Basic-Text. Sie überliest automatisch Leerzeichen. Wenn das Ende einer Zeile oder ein Doppelpunkt erreicht wird, so wird die Z-Flag des Prozessors gesetzt. Ein Problem ergibtsich dadurch, daß in »RECORD#« der Simons Basic-Befehl »REC« vorkommt. Er wird bei Verwendung von Simons Basic also in eine interne Darstellung beginnend mit $64 umgewandelt. Das Programm testet daher, ob $64 vorliegt und verzweigt bei positiver Antwort. In beiden Fällen wird nun getestet, ob der Befehl »RECORD#«vorliegt. Unter dem Namen tab 1 (beziehungsweise tab 2 für Simons Basic) steht (rückwärts) die interne Darstellung des Befehls »RECORD«. Dabei ist zu beachten, daß »OR« wiederum nicht im ASCII-Code abgelegt ist, sondern als Token. Wird nur eine Abweichung gefunden, so wird der gemerkte CHRGET-Zeiger zurückgeholt und zur normalen Interpreterroutine gesprungen, anderenfalls tritt eine eigene Routine in Funktion (sie beginnt beim Label OK). Sie holt die Satznummer und, wenn angegeben, die Position im Satz aus dem Basic-Text und sendet die Informationen an die Floppy über die Sekundäradresse 15 (Kommandokanal). Die Floppy erwartet die Werte in folgender Form: »p« als Zeichen, das positioniert werden soll; die Sekundäradresse, mit der das relative File eröffnet wurde; die Satznummer in der Reihenfolge niederwertiges — höherwertiges Byte und, falls angegeben, die Position im Satz. Es werden folgende Routinen des Interpreters und des Betriebssystems verwendet:

TODO TABLE

getbyt : Holt einen beliebigen Ausdruck in das x-Register.
search : Sucht nach der logischen Filenummer in x.
parset : Holt logische Filenummer, Geräteadresse und Sekundäradresse in die Speicherzellen $b8,$ba und $b9
listen : Teilt dem angesprochenen Gerät mit, daß es Daten empfangen soll.
seclis : Sendet die Sekundäradresse zum angesprochenen Gerät.
iecout : Sendet den Wert im Akkumulator zum angesprochenen Gerät.
chkcom : Prüft auf Komma im Basic-Text.
getrec : Holt einen numerischen Ausdruck in den Fließkomma-Akkumulator.
fac16 : Wandelt den Wert im Fließkomma-Akkumulator in eine 16-Bit-Zahl und speichert sie in $14 und $15.
comget : =chkcom + getbyte.
unlist : Beendet die Übertragung an die Floppy.

Das Programm wurde mit dem Assembler »ASSI« übersetzt, eine Übernahme auf andere Assembler dürfte nicht schwierig sein. Der Basic-Lader (Listing 1, Source-Code: Listing 2) legt das Programm ab der Adresse 49152 ($C000) ab, schaltet die Erweiterung ein und löscht sich dann selbst, er muß also vorher auf Diskette abgespeichert werden. Die Erweiterung wird durch SYS49152 ein- und durch SYS49155 ausgeschaltet. STOP/RESTORE schaltet die Erweiterung nicht ab.

(Bernward Bretthauer/rg)

# Aufpoliertes Basic \[22-25\]

> 39 zusätzliche und leistungsfähige Befehle stellt dieses Programm dem Programmierer zur Verfügung.

Das Programm (siehe Listing) belegt nur 8 KByte des Basic-RAMs. Der Restbedarf an Arbeitsspeicher wurde mit den Bereichen $C000 bis $CFFF und $E000 bis $FFFF abgedeckt.

Der zusätzliche Interpreter arbeitet nach demselben Prinzip wie der Commodore-Interpreter, das heißtjeder Befehl belegt nur genau 1 Byte. Die Erweiterung ist so geschrieben, daß Verzögerungen der Befehlserkennung kaum auftreten.

Das Programm wird mit SYS 64738 oder einem RESET-Schalter gestartet.

Die Basic-Erweiterung kann noch durch eigene Befehle ergänzt werden. Dazu hängt man die neuen Befehlsnamen an das Ende derTabelle, die bei $800A beginnt. Die Adresse der neuen Befehle wird an das Ende der Tabelle gehängt, die bei $8275 beginnt. Hierbei muß der Wert »Adresse — 1« angegeben werden. Beispiel: Für eine Routine ab $9E00 muß die Adresse $9DFF (im Lo-Byte/Hi-Byte-Format) angegeben werden. Bei den Befehlen ist darauf zu achten, daß das letzte Zeichen geSHIFTet angegeben wird (MSB gesetzt), damit der Computer weiß, wo das Befehlswortendet. Alle Befehle lassen sich abkürzen, da sie in 1-Byte-Tokens umgesetzt werden.

Zusätzliche Befehle kann man risikolos von $9875 unmittelbar nach dem JMP $984F-Befehl bis $9FFF (Basic-RAM-Ende) hinzufügen.

(Markus Feldmann/rg)

### Hinweise:

Wird während des Listens die SHIFTTaste gedrückt, so hält der Computer so lange damit an, wie diese gedrückt bleibt; wird jedoch die »Commodore-Taste« gedrückt, so wird sehr langsam gelistet (auch nur solange die Taste gedrückt bleibt).

Wenn der C 64 sich längere Zeit (einige Sekunden) mit der Grafik beschäftigt (Abspeichern, Laden von Grafiken) sollte man ihn auf keinen Fall mit RUN/STOP-RESTORE abbrechen, da es sonst zum System-Absturz kommen kann (das Kernal-ROM ist während des Zeichnens, und der Basic-Interpreter

während des Abspeicherns und Einladens von Grafiken abgeschaltet)!

Die Erweiterung ist darauf ausgelegt, auf ein EPROM gebrannt zu werden. Dieses ist daher ein recht einfacher Vorgang. Ist die Erweiterung nur als Programm vorhanden, läßtsie sich durch »POKE32776,0:COLD« abschalten.

Wichtig: Sollen die neuen Basic-Befehle nach »IF...THEN« benutzt werden, so müssen sie mit einem Doppelpunkt vom »THEN« getrennt werden. (Beispiel: IF A=0 THEN:PLOT X,Y)

TODO ASIDE/TABLE

# PRINT USING mit der USR-Funktion \[26-27\]

> Haben Sie sich auch schon über die unformatierte Zahlenausgabe Ihres C 64 geärgert? Dann nehmen Sie in Zukunft die folgende USR-Funktion, um für Ihren C 64 ein PRINT USING zu erhalten.

Wie allgemein bekannt und vielfach bemängelt, bietet das Commodore-Basic keinen PRINT USING-Befehl. Doch gerade bei kommerziellen Problemen kann auf eine Druckaufbereitung von Zahlen nicht verzichtet werden. Eine Rechnung, in der nicht einmal die Dezimalpunkte untereinander stehen, ist eben unübersichtlich und keine Reklame. Für die Druckaufbereitung gibt es verschiedene Lösungen.

Die beste Lösung ist ein Maschinenprogramm. Interessierte Maschinenprogrammierer finden den Quellcode zu dieser Routine in Listing 1. Doch zunächst stellt sich die Frage, wie ein Maschinenprogramm für die Druckaufbereitung aufgerufen werden soll. Offensichtlich ist die USR-Funktion am geeignetsten, da sie sowohl in einer PRINT- als auch in einer PRINT#- oder einer LET-Anweisung verwendet werden kann. Der Aufruf der Funktion erfolgt durch USR(X),L,NK. Dabei ist X die Zahl, die aufbereitet werden soll, L die Gesamtfeldlänge der aufbereiteten Zahl einschließlich Vorzeichen und Dezimalkomma und NK die Anzahl der darzustellenden Nachkommastellen. Die USR-Funktion wandelt zunächst die Zahl X in einen ASCII-String um und berechnet die Stringlänge und die Anzahl der Nachkommastellen. Wenn bei der Wandlung von X der Interpreter die Exponentialform wählt, dann wird die Exponen-tialdarstellung zunächst in die Fließkommadarstellung umgewandelt. Danach werden die Nachkommastellen aufbereitet. Fehlende Nachkommastellen werden durch angehängte Nullen ergänzt. Müssen Nachkommastellen abgeschnitten werden, dann*wird die Zahl gerundet, wenn die erste abgeschnittene Dezimalstelle größer oder gleich 5 ist. Wenn die Anzahl der gewünschten Nachkommastellen null ist, dann wird die Zahl als ganze Zahl (Integer) ohne Dezimalkomma aufbereitet. Wegen der kaufmännischen Anwendung wird der Dezimalpunkt durch ein Dezimalkomma ersetzt. Nach der Aufbereitung der Nachkommastellen wird durch Voranstellen von Leerzeichen der String auf die erforderliche Länge gebracht. Ist der String nach der Aufbereitung der Nachkommastellen schon länger als gewünscht, dann wird er nicht mehr verändert, sondern in voller Länge ausgegeben, um einen Datenverlust zu verhindern.

Das hier vorgestellte Maschinenprogramm verwendet nur relative Sprünge — außer bei den Aufrufen der Betriebssystemroutinen. Daher kann sich jeder Anwender das Programm ohne Änderungen in den Speicherbereich laden, der ihm am geeignetsten erscheint. Als Stringpuffer wird der Bereich ab $100 benutzt. DashatzurFolge, daß die GETSTR-Routinedie-sen String nicht in den Stringbereich kopiert. Der Stringbereich wird also nicht unnötig belastet. Eine Wertzuweisung A$=USR(X),L,NK ist dadurch aber auch nicht möglich, da die nächste Stringfunktion den Bereich ab $100 wieder überschreibt. Wenn druckaufbereitete Werte einer Variablen zugewiesen werden sollen, dann muß die Anweisung A$= " " +USR(X),L,NK oder A$=(USR(X),L,NK)+" " lauten, da dann das Ergebnis der Stringverknüpfung in den Stringbereich kopiert wird und der Variablen A$ dauerhaft zugewiesen ist.

Vor dem ersten Aufruf der USR-Funktion muß jetzt noch in Adresse 785 (Low-Byte) und 786 (High-Byte) die Startadresse der USR-Funktion hinterlegt werden. Listing 2 zeigt das Basic-Ladeprogramm für die USR-Funktion. Die Ladeadresse können Sie selbst bestimmen. Das Ladeprogramm setzt die Startadresse der USR-Funktion in den Speicherstellen 785 und 786 entsprechend. Zur Verdeutlichung der Anwendung der USR-Funktion enthält das Ladeprogramm verschiedene Druckaufbereitungen der Zahl r. Das Ergebnis des Beispiels ist in Bild 1 wiedergegeben.

(Dr. Michael Irskens/ah)

# Game-Basic \[28-31\]

> Mit dieser Befehlserweiterung lassen sich mit wenig Aufwand sehr effektvolle Spiele schreiben. Es wird dabei der Umgang mit Sprites und Sonderzeichen und die Bildschirmverwaltung (Scrolling) unterstützt.

Da ich einen Großteil meiner eigenen Programme in Basic schreibe und mir dabei die nicht sehr komfortable »POKE«-erei auf die Nerven geht, habe ich nun eine Basic-Erweiterung geschrieben die, wie ich meine, diese Vorgänge um Einiges erleichtert.

Eingabe des Programms
1)	Das Programm »Game-Basic-C000« mitdem MSE-V 1.0 eingeben (siehe Listing 1) und speichern.
2)	Programm mit »SYS 49152« starten. Das Programm kopiert sich nun selbständig an den Basic-Start ab $0800.
3)	Das Programm nun mit SAVE ”GAME-BASIC”,8 (oder bei Kassette: ,1)speichern.

Das Game-Basic kann nun ganz normal geladen und mit »RUN« gestartet werden.

## Die Speicherbelegung

Alle wichtigen Adressen (Bildschirm, Farbspeicher, Sprites, SID, Timer etc.) bleiben unverändert. Der Bereich $0800-$OFFF ist für 32 Sprites reserviert, die dort abgelegt werden. Die Erweiterungselbstliegtim Bereich $1000-$17B0. Der Bereich $17B1-$1FFF bleibtfrei und kann füreigene Maschinenprogramme genutzt werden. Ab der Adresse $2000 bis $27FF liegt ein frei definierbarer Zeichensatz. Ab $2800 beginnt der Basic-Speicher(!). Dieser dehnt sich wie gewohnt bis zurAdresse $9FFF. Das RAM im Bereich $A000-$CFFF und von $E000-$FFFF bleibtfrei und kann für eigene Zwecke verwendet werden.

## Die Befehle

Der Befehl »RESET« bewirkt einen Neustart der Basic-Erweiterung, wobei ein vorhandenes Basic-Programm nicht gelöscht wird.

Da es gerade bei Basic-Erweiterungen leicht vorkommen kann, daß man einzelne Befehle vergißt und nicht immer eine Anleitung zur Hand hat, habe ich den Befehl HELP mit eingebaut. Er listet alle zusätzlichen Kommandos auf.

Auf HiRes-Befehle habe ich grundsätzlich verzichtet, da meine Erweiterung ja hauptsächlich für die Verwendung im Spiele-Bereich vorgesehen ist. Normalerweise ist es nicht üblich, ein Spielprogramm in HiRes-Grafik zu erstellen (außer Lo-derunner und ein paar anderen), sondern mit Hilfe von Sonderzeichen. Außerdem wäre das Programm dann um einiges länger. (Es genügen schon zwei KByte, wenn man sie abtippen muß.)

Alle reinen Basic-Programme laufen natürlich auch mit der Erweiterung. Will man die Erweiterung trotzdem abschalten, ohne den Computer ausschalten zu müssen, so kann man das mittels des Befehls »BASIC« tun. Die Erweiterung kann dann mit SYS 4096 wieder aktiviert werden, falls sie nicht aus irgendeinem Grund überschrieben wurde.

Wer hat sich nicht auch schon über das lästige POKE 53281,xx:POKE 53280,xx:POKE 646,xx... geärgert? Mit dem Befehl »COLOR« lassen sich Bild-, Rahmen- und Zeichenfarbe ganz einfach einstellen. Zum Beispiel blauer Rahmen, weißer Hintergrund und grüne Schrift: COLOR6,1,5

## Steuerzeichen entfallen

Damit wären wir auch schon bei den Befehlen, die den Bildschirm betreffen. Der Befehl »SCROFF« schaltet den Bildschirm aus; zum Beispiel während vom Programm ein Bild aufgebaut wird. Mit »SCRON« wird er wieder eingeschaltet. Die komplizierte »POKE«-erei im VIC hat nun ein Ende.

Mit »PAINT« wird der Farbspeicher für den Bildschirm mit der angegebenen Farbe gefüllt. Ein beschriebener Bildschirm kann natürlichauch nachträglich umgefärbt werden. Man kann damit ganz hübsche Effekte erzielen.

»REVERS« invertiert den Bildschirminhalt.

Auch die lästigen Steuerzeichen entfallen mit der Erweiterung bis auf RVSON und RVSOFF. (Aber auch die kann man durch POKE 199,1 beziehungsweise POKE 199,0 umgehen.) Der Bildschirm wird nicht mehr mit PRINTCHR$(147),sondern einfach mit »CLS« gelöscht.

Mit dem Befehl »CLEAR« kann man sogar einzelne Zeilen beziehungsweise Zeilenblöcke löschen. Zum Beispiel »CLEAR 12,24« löscht den Bildschirm ab der 13. Zeile (die erste Zeile ist Zeile 0).

Das Editieren von Programmen wird mit meiner Erweiterung fast nicht unterstützt, da die Aufgabe der Expansion ja darin liegen soll, Spielprogramme in Basic schneller ablaufen zu lassen. Mit dem Befehl »TAB« kann man zumindest die Übersicht in einem Listing etwas erhöhen. Es wird jeder Befehl in eine eigene Zeile geschrieben, was, die Übersicht betreffend, auch nicht zu verachten ist. Bevor man dann eine Zeile wieder ändern will, muß unbedingt durch einen erneuten >TAB«-Befehl diese Darstellung wieder abgeschaltet werden.

Die Befehle INC und DEC, also Inkrement (Erhöhen) und Dekrement (Erniedrigen) sind eine Abwandlung des POKE-Befehls. Es wird nicht wie bei POKE eine Zahl in eine Adresse geschrieben, sondern eine in einer Adresse vorhandene Zahl um den angegebenen Wert erhöht beziehungsweise erniedrigt.

Sollte ein Programm für eine Sekunde anhalten, mußte man bisher eine umständliche Zeitschleife verwenden (FOR T = 1 TO 1000: NEXT). Diese wird nun durch den Befehl PAUSE ersetzt. 1 Sekunde Wartezeit = PAUSE 500.

## Zeichensatz verändern

Jedes professionelle Spiel kommt nicht ohne Sonderzeichen aus. Daher war es von vornherein klar, daß meine Erweiterung Befehle zur Erstellung eines eigenen Zeichensatzes enthalten sollte. Dabei ist die Darstellungsweise in Form von DATA-Zeichen die übersichtlichste. Ich habe dazu den Befehl »CODE« gewählt (siehe Beispiel »0« im folgenden Text).

In meiner Erweiterung gibt es den Befehl COPY: Er kopiert den Zeichensatz ins RAM, wo er dann mittels CREATE und CODE verändert werden kann. Mit CREATE wird das zu verändernde Zeichen festgelegt. Wir wollen zum Beispiel aus dem 0 einen Umlaut Ö machen. So schreiben wir folgendes: CREATE 1,15.

Die 1 bewirkt, daß wir ein Zeichen (0 wäre für Sprites) verändern und die 15 ist der POKE-Code für den Buchstaben 0. Der Befehl CODE bestimmt nun das Bitmuster für das mit CREATE ausgewählte Zeichen. Unser Ö würde nun im Programm so aussehen:

TODO

10	CREATE	1 ,1 5	oder	10	CREATE	1 ,15
20	CODE	. 11 . . 11.	20	CODE	.11 . . 11.
30	CODE		30	CODE	. . 1 1 1 1 . .
40	CODE	. .1111 ..	40	CODE	
50	CODE	.11 . .11.	50	FORI = 1TO4	
60	CODE	. 11 . . 11.	60	CODE	.11 . .11.
70	CODE	.11 . .11.	70	NEXT I	
80	CODE	.11 . .11.	80	CODE	. . 1 1 1 1 ..
90	CODE	. . 1111 ..			

Es würde auch schon folgendes genügen, da die restlichen Bitmuster mit dem 0 übereinstimmen:

10 CREATE 1 , 1 5
20 CODE .11 . . 11.
30 CODE ............
40 CODE . . 1 1 1 1 ..

Der Zeichensatz kann natürlich auch durch die altbewährte POKE-Methode verändert werden, da er jetzt »mitten« im RAM-Bereich liegt (ab $2000 dez. 8192).

Auch der Multicolor-Modus wird in meiner Erweiterung sowohl für Zeichen als auch für Sprites voll unterstützt:

Aktiviert wird dieser mit dem Befehl MULTI 1 beziehungsweise ausgeschaltet mit MULTI 0. Die Multicolor-Zusatzfarben (zwei an der Zahl) bestimmt man ebenfalls mit MULTI.

»MULTI 2, 5, 2, 6, 7« bedeutet zum Beispiel, daß ab jetzt Zeichen in den Farben Grün (5) und Rot (2), Sprites in den Farben Blau (6) und Gelb (7) dargestellt werden. MULTI 2,... bedeutet: Multicolor-Modus mit den folgenden Farben einschalten. Bei den Bitmustern ändern sichjetztallerdings die Codes: 1 = Zusatzfarbe 1,2 == Zusatzfarbe 2, 3 = normale Zusatzfarbe, . = leer

Die bunte Version unseres Ö sähe nun so aus:

TODO

CODE .	. 1 1 . . 11	
CODE .	.11 . .11	entspricht grün
CODE .		
CODE .	.222222	
CODE .	.22..22	
CODE .	.22..22	entspricht rot
CODE .	.33..33	
CODE .	.333333	entspricht aktueller Zeichenfarbe

Es ist darauf zu achten, daß die Zahlen der CODEs immer paarweise angegeben werden (Multicolor). Bei der Erstellung von Sprites wird genauso vorgegangen, bis auf folgende Änderungen:
1)	»CREATE 0, Spriteblock (32-63)«. Statt dem Zeichensatz wird der gewählte Block angegeben (32-63). Die 0 teilt dem Computer mit, daß ein Sprite und kein Zeichen verändert beziehungsweise erstellt werden soll.
2)	Das Bitmuster beim CODE-Befehl hat jetzt 24 Stellen anstatt acht bei Zeichen.

## Bildschirmverwaltung

Der Befehl SET ist ein erweiterter PRINT-Befehl. Der Unterschied zum PRINT-Befehl liegt darin, daß die Steuerzeichen entfallen (wie anfangs erwähnt).

Zum Beispiel SET 18,12,1,”TEXT”

Dieser Befehl schreibt das Wort TEXT in die zwölfte Zeile ab der 18. Spalte in weißen Zeichen. Mit dem normalen PRINT-Befehl würde man dazu eine Unmenge Steuerzeichen benötigen; außerdem ist der SET-Befehl schneller.

Der Befehl SCROLL verschiebt beziehungsweise verändert beliebige Bildschirmbereiche. Eine genauere Erklärung möchte ich an dieser Stelle unterlassen, da man die Möglichkeiten durch eigene Versuche am besten sehen kann.

Die restlichen sechs der insgesamt 26 Befehle meiner Erweiterung unterstützen ausschließlich den Umgang mit Sprites. Mit SON wird ein Sprite ein- beziehungsweise mit SOFF wieder ausgeschaltet.

SSET positioniert ein Sprite an eine beliebige Stelle im (oder außerhalb vom) Bildschirm. Das achte Bit im VIC-Register 16 für die Sprite X-Position braucht dabei nicht beachtet zu werden. Mit SPRITE wird ein Sprite definiert. Folgende Parameter werden hier angegeben:

Spritenummer, Block (Aussehen des Sprites — 32-63), Y-Expanded (ja oder nein), X-Expanded üa oder nein), vor oder hinter Bildschirmzeichen, Multicolor (ja oder nein), Grundfarbe.

Ein ganz spezieller Befehl ist SRUN. Mit SRUN kann ein beliebiges Sprite (oder auch mehrere) in eine von acht möglichen Richtungen bewegt werden. Das Programm wird dadurch aber nicht aufgehalten, da die Sprites vom Interrupt gesteuert wer-

den. Dadurch ist es zum Beispiel möglich, daß ein Sprite, während es bewegt wird, seine Gestalt verändern oder sogar das Programm gelistet werden kann. Man kann sich so zum Beispiel ein Sprite in Bewegung ansehen, während man es editiert. Aber auch hier sind natürlich eigenen Versuchen keine Grenzen gesetzt. Der letzte Befehl SSTOP ist der Gegensatz zu SRUN, das heißt er stoppt die mit SRUN gestarteten Sprites. Die Positionen der Sprites können wie bisher mit dem normalen PEEK ausgelesen werden.

Eine Befehlsübersicht gibt Tabelle 1. Das Beispielprogramm (Listing 2) zeigt, wie man innerhalb von Spielen diese neuen Befehle einsetzt. Bitte zur Eingabe von Listing 2 nicht den Checksummer verwenden, da dieser nicht mit Basic-Erwei-terungen zusammenarbeitet.

(Ronald Mayer/tr)

TODO ASIDE

## Alle neuen Befehle auf einen Blick

**RESET** Neustart der Erweiterung; bereits vorhandene Basic-Programme werden nicht gelöscht.
**HELP** Auflistung aller Befehle von Game-Basic.
**BASIC** Abschalten der Erweiterung; auch hier werden Programme nicht gelöscht
**COLOR rf,hf,zf** Rahmen- {rf), Hintergrund- (hf) und Zeichenfarbe (zf) setzen.
**REVERS** Invertiert den gesamten Bildschirminhalt.
**PAINT f** Färbt Bildschirminhalt mit Farbe f.
**CLS** Bildschirm löschen.
**SCROFF** Bildschirm ausschalten.
**SCRON** Bildschirm wieder einschalten.
**CLEAR an,en** Bildschirm wird von Zeile an bis Zeile en gelöscht.
**COPY** Zeichensatz ins RAM kopieren.
**TAB** Formatierten LIST-Modus ein- beziehungsweise ausschalten.
**PAUSE t** Das Programm wird t*0,002 Sekunden lang angehalten. INC ad,eh Addiert eh zum Inhalt der Adresse ad.
**DEC ad,eh** Subtrahiert eh vom Inhalt der Adresse ad.
**SET s,z,f,”text”** Schreibt »text« in die Zeile z, Spalte s mit der Farbe f.
**SCROLL az,ez,s,z,f,r** Scrollt Bildschirmbereich von Anfangszeile az bis Endzeile ez in Richtung r (O=nach rechts, 1-nach links). Dabei werden Zeichen mit dem Code z in der Farbe f nachgescrollt.
**SON s** Schaltet Sprite Nummer s ein.
**SOFF s** Schaltet Sprite Nummer s aus.
**SPRITE s,bl,ye,xe,pr,mc,f**
Bestimmt Sprite Nummer s:
bl = Block (32-64)
ye = doppelte Höhe (O=nein, 1=ja)
xe = doppelte Breite (O=nein, 1=ja)
pr = Priorität vor (=0) oder hinter (=1) Bildschirmzeichen
mc = Multicolor an (=1) oder aus (=0)
f = Farbe des Sprites
**SSET s,x,y** Setzt Sprite Nummer s an Position x (0-511!), y (0-255).
**SRUN s,ri** Sprite s bewegt sich in angegebene Richtung:
0	7	6	5	4	3	2	1
**SSTOP s** Sprite s hält wieder an.
**MULTI c,z1,z2,s1,s2** Multicolor-Mode ein- und ausschalten: c = 0 = Multicolor für Zeichen an
1	= Multicolor für Zeichen aus
2	= Angabe von Zusatzfarben
Bei Verwendung von 0 oder 1 brauchen die Zusatzfarben nicht mit angegeben werden.
z1 = Zusatzfarbe 1 für Zeichen
z2 = Zusatzfarbe 2 für Zeichen
s1	= Zusatzfarbe 1 für Sprites
s2	= Zusatzfarbe 2 für Sprites
**CREATE m,b1** Erstellen eines neuen Zeichens/Sprites:
m = Mode (O=Sprite, 1=Zeichen)
b1 = Spriteblock oder Zeichencode
**CODE bits** Nur in Zusammenhang mit dem CREATE-Befehl.
Bei Sprites 24 Bits, bei Zeichen 8 Bits.
.	= Hintergrundfarbe.
1	= Farbedes Zeichens/Sprites (bei Multicolor-Mode Zusatzfarbe 1) 2 = Zusatzfarbe 2
3	= Farbe des Zeichens/Sprites bei Multicolor-Mode

# Disk-Basic 64 \[32,34-36\]

> Disk-Basic 64 ist eine besonders leistungsfähige diskettenorientierte Ba-sic-Erweiterung, die mit fast 50 neuen Befehlen das Arbeiten mit dem Diskettenlaufwerk enorm erleichtert.

Wer kennt sie nicht, die unzähligen OPENs und PRINTs, die notwendig sind, wenn man Befehle an das 1541-Laufwerk senden will. Auch beim Laden und Speichern ist das normale Commodore-Basic nicht gerade komfortabel. Abhilfe schafft die Basic-Erweiterung »Disk-Basic 64«. Sie enthält unteranderem fast alle diskettenorientierten Befehle des Basic 4.0 von Commodore, das der C 128 ebenfalls kennt. Viele Funktionen die sich bisher nur mit Spezialprogrammen oder einem Diskmonitor realisieren ließen, werden nun auf einen Basic-Befehl hin ausgeführt und sind somit auch programmierbar.

Zur Eingabe von »Disk-Basic 64« verwenden Sie bitte den MSE. Nach dem Speichern kann die Basic-Erweiterung dann jederzeit mit »LOAD " DISK-BASIC ",8« geladen und mit »RUN« gestartet werden. Danach steht »Disk-Basic 64« im Speicherbereich von $9200 bis $9DFF. Dieser Bereich wird für Basic automatisch gesperrt, so daß nur noch 35327 Bytes, also 3584 Bytes weniger, für Basic-Programme zurVerfügung stehen. Der $C-Bereich bleibt für eigene Maschinenprogramme oder einen Monitor frei.

Doch jetzt zur Beschreibung der neuen Befehle:

### DLOAD"name"

Das Programm »name« wird von der Diskette an den Basic-Anfang geladen. Entspricht»LOAD"name",8«.

### DSAVE"name"

Das momentan im Speicher befindliche Basic-Programm wird auf der Diskette gespeichert. Entspricht »SAVE" name ",8«.

### DVERFIY"name"

Das momentan im Speicher befindliche Basic-Programm wird mit dem auf Diskette gespeicherten Programm »name« verglichen. Entspricht »VERIFY "name ",8«.

### REPLACE"name"

Ersetzt das Programm »name« auf der Diskette durch das im Speicher befindliche. Entspricht dem Basic-Befehl »SAVE" @:name",8«

### SCRATCH"name"

Das File »name« wird gelöscht. Im Namen dürfen auch die Jokerzeichen »?« und »*« verwendet werden. Es werden dann sämtliche Files, die dem Namen entsprechen, gelöscht. Entspricht dem Floppy-Befehl »S:«.

### RENAME "altname" TO "neuname"

Das File mit dem Namen »altname« wird in »neuname« umbenannt. Entspricht dem Floppy-Befehl »R:«.

### COPY"altfile"TO"neufile"

Das File »altfile« wird auf dieselbe Diskette als »neufile« kopiert. So können Sicherheitskopien von Files hergestellt werden. Mit diesem Befehl kann nicht von einer Diskette auf eine andere kopiert werden. Entspricht dem Floppy-Befehl »C:«.

### HEADER"name,id"

Die im Laufwerk befindliche Diskette wird mit dem Namen »name« und der ID »id« formatiert. Wird »,id« weggelassen, so wird die Diskette nur gelöscht. Entspricht dem Floppy-Befehl »N:«

### COLLECT

Die Diskette wird aufgeräumt, das heißt, daß alle Blöcke, die nicht von Files belegt sind, freigegeben werden und sämtliche nicht ordnungsgemäß geschlossenen Files gelöscht werden. Entspricht dem Floppy-Befehl »V«.

### INIT

Die Diskette wird initialisiert. Entspricht dem Floppy-Befehl »I«.

### CHECK

Der Fehlerkanal des Laufwerks wird auf dem Bildschirm ausgegeben (siehe auch DS$).

### CATALOG

Das vollständige Directory wird auf dem Bildschirm ausgegeben. Dabei verlangsamt die CTRL-Taste den Ausdruck, die Commodore-Taste hält die Ausgabe an und die Stop-Taste beendet den Befehl.

### DIR"$:auswahl"

Die dem Ausdruck entsprechenden Teile des Directory werden auf dem Bildschirm ausgegeben. »DIR"$:*=P"« druckt beispielsweise nur die Programme, »DIR"$:?=R"« alle einbuchstabigen, relativen Files. Ansonsten gelten die Kontrollmöglichkeiten von CATALOG.

### BSAVE"name",start,ende+l

Mit diesem Befehl kann der Speicherbereich von start bis ende auf Diskette gespeichert werden. Dies können Maschinenprogramme, Grafikbilder oder sonstiges sein.

### BLOAD"name" <,adr >

Das File »name« wird an die angegebene Speicheradresse geladen. Wird keine Adresse angegeben, so wird das File an die Adresse geladen, an der es beim Speichern stand. Da keine Basic-Vektoren verändert werden, tritt kein »OUT OF MEMORY ERROR« mehr auf, wenn in den $C-Bereich geladen wurde. Ebenso wird bei einem BLOAD in einem Basic-Programm das Programm nicht neu gestartet, wie bei LOAD, sondern direkt hinter dem BLOAD fortgesetzt.

### CHAIN"name" <,zn >

Das Basic-Programm »name« wird geladen und bei der Zeilennummer zn gestartet. Fehlt die Zeilennummer, so wird bei der ersten Zeile gestartet. Wird eine nicht existierende Zeilennummer angegeben, so gibt der Computer einen »UNDEF’D STATEMENT ERROR«aus. Achtung! Bei CHAIN gehen die Inhalte der Variablen wie bei LOAD verloren! Dies muß man beachten, wenn man CHAIN zum Nachladen von Programmteilen in Basic-Programmen einsetzen will.

### PASS"kommando"

Mit diesem Befehl lassen sich Kommandos an das Laufwerk senden, die nicht direkt von Disk-Basic unterstützt werden, so zum Beispiel die »U«- oder »B«-Kommandos.

### DPOKE adresse,wert

Dieser Befehl entspricht dem normalen POKE mit der Ausnahme, daß der Wert in der Adresse des Laufwerk-RAMs gespeichert wird. Er ist nur im Adressenbereich von 0 bis 2047 sinnvoll.

### DPEEK(adresse)

Diese Funktion entspricht dem PEEK. Der Inhalt einer Speicherstelle des Laufwerkes kann mit »?DPEEK(adresse)« ausgedruckt oder mit »variable = DPEEK(adresse)« in eine Variable übergeben werden.

### DSYS(adresse)

Mit diesem Befehl können Maschinenprogramme im Laufwerk gestartet werden. Entspricht dem Basic-Befehl SYS. Ein Beispiel: DSYS (60064) löst in dem angeschlossenen Floppy-Laufwerk einen Reset aus.

### NAME"nome"

Der 16 Zeichen lange Name einer Diskette wird umgeändert Hat der Stringname mehr als 16 Zeichen, wird ein »STRING TOO LONG ERROR« ausgegeben.

### ID"id"

Mit diesem Befehl kann die ld sowie das Formatkennzeichen in der ersten Zeile des Directory geändert werden. Der String »id« kann maximal 5 Buchstaben haben und überschreibt dann die ID, das Fbrmatkennzeichen (normalerweise »2A«) und das Leerzeichen zwischen den beiden. Achtung! Diese Änderungen beziehen sich nur auf das Directory. Die tatsächliche ID und Fbrmatkennzeichen werden nicht verändert.

### PROTECT < "name" >

Mit dem Befehl PROTECT wird eine ganze Diskette schreibgeschützt, indem das echte Fbrmatkennzeichen von »A« auf »X« geändert wird. Es sind dann keinerlei Schreibzugriffe mehr auf diese Diskette möglich.

Wird beim PROTECT-Befehl ein Name angegeben, so wird nur das File mit diesem Namen gegen Löschen und Überschreiben geschützt. Der Schreibschutz ist am Kleinerzeichen hinter dem Filetyp im Directory erkennbar. Es dürfen keine Joker im Namen angegeben werden.

### REPROTECT<"name">

Mit diesem Befehl lassen sich der Disketten- und File-Schreibschutz wieder rückgängig machen. Siehe PROTECT.

### CHANGE dev.alt TO dev.neu

Hiermit lassen sich softwaremäßig die Gerätenummern des 1541-Laufwerks verändern. So ändert »CHANGE 8 TO 9« die Gerätenummer des gerade eingeschalteten Laufwerkes auf 9. So lassen sich mehrere Laufwerke gleichzeitig betreiben.

### DEVICE dev

Mit diesem Befehl läßt sich einstellen, auf welche Gerätenummer sich die Befehle des Disk-Basics beziehen. Nach »DEVICE 9« werden sämtliche Befehle am Laufwerk unter der Gerätenummer 9 ausgeführt. Dieser Wert wird in der Speicherstelle 2 gespeichert.

### RESET d

Das Laufwerk mit der Gerätenummer d wird in den Einschaltzustand versetzt. Aus Sicherheitsgründen muß immer die Gerätenummer angegeben werden. Bitte warten Sie einige Sekunden bevor Sie dieses Laufwerk wieder ansprechen.

### MERGE"name"

Das Programm »name« wird von der Diskette geladen und an das im Speicher befindliche angehängt. Achten Sie darauf, daß das zweite Programm höhere Zeilennummern als das erste hat.

### CONCAT "altfilel" & "aMile2" TO "neufile"

Mit diesem Befehl können zwei sequentielle Files zu einem verkettet werden. Dies funktioniert nicht mit Programmen!

### DS$ und DS

In diesen beiden Variablen ist stets die aktuelle Fehlermeldung (DS$) beziehungsweise die aktuelle Fehlernummer (DS) des Laufwerkes. Sie dürfen deswegen nicht in Zuweisungen wie »DS$= "HALLO"« verwendet werden.

### DOPEN# lfn,"name",p1,p2

Mit DOPEN lassen sich alle Arten von Files auf dem Laufwerk eröffnen. Die Filenummer darf von 2 bis 255 gehen. Empfehlenswert sind Nummern von 2 bis 14, da die Sekundäradresse des Files immer gleich der Filenummer logisch »UND«-verknüpft mit 15 ist, also immer im Bereich von 0 bis 15 liegt. Für den Fileparameter p1 sind die Buchstaben »S«, »U«, »P« und »L« erlaubt. Die ersten drei stehen für sequentielle, User- und Programm-Files. Der Parameter p2 ist dann entweder »W« oder »R« für Schreiben oder Lesen.

Lautet der erste Parameter »L« so wird ein relatives File zum Schreib/Lese-Zugriff eröffnet. Die Länge eines Datensatzes (Record) wird direkt an das »L« angehängt. Der zweite Parameter entfällt. Ein Beispiel: »DOPEN 2, "name",L40« eröffnet ein relatives File mit der Record-Länge 40.

### DCLOSE<#lfn>

Dieser Befehl schließt das File mit der Nummer lfn. Wird keine Filenummer angegeben, werden alle geöffneten Files ordnungsgemäß geschlossen.

### APPEND#lfn/"name"

Ein sequentielles File wird zum Erweitern (Anhängen von Datensätzen) geöffnet. Die Sekundäradresse errechnet sich wie bei DOPEN.

### FETCH#lfn,len,xx$

Mit diesem Befehl werden aus dem File mit der Nummer lfn eine festgelegte Anzahl (len) von Zeichen in eine beliebige Stringvariable (xx$) übertragen. Die Vorteile gegenüber dem INPUT #-Befehl sind: Datensätze sind nicht mehr auf 88 Zeichen beschränkt, sondern dürfen bis zu 255 Zeichen haben. Es werden auch Kommata und Doppelpunkte übernommen. Der Befehl kann auch im Direktmodus eingesetzt werden.

### RECORD # lfn,rec < ,pos >

Mit diesem Befehl wird die Bearbeitung von relativen Dateien zum Kinderspiel. Der Zeiger auf die Datei mit der Filenummer lfn wird auf den Datensatz mit der Nummer rec positioniert. Zusätzlich kann noch die Position des Datei-Zeigers innerhalb dieses Datensatzes angegeben werden. Wird dieser Parameter weggelassen, wird immerauf das erste Zeichen positioniert. Dies entspricht der Befehlsfolge: »PRINT#15,"P";CHR$(lfn);CHR$(reclo);CHR$(rechi); CHR$(pos)«.

### LIST"name" <,start-ende >

Der LIST-Befehl wurde erweitert, so daß bei Angabe eines Namens das Listing im ASCII-Code als sequentielles File auf der Diskette abgelegt wird. Sollen nur Teile abgespeichert werden, so kann die normale LIST-Syntax für Bereichsmarkierungen angehängt werden. Basic-Programme können somit in Textverarbeitungsprogramme übernommen werden.

### ENTER"name"

Mit ENTER kann ein auf Diskette gelistetes Programm wieder in den Speicher übernommen werden. Die Zeichen, die gerade gelesen werden, werden zusätzlich auf dem Bildschirm ausgegeben. Eine Anwendungsmöglichkeit ist ein »echtes« MERGE, bei dem das zweite Programm nicht einfach angehängt, sondern die beiden entsprechend der Zeilennummern zusammengemischt werden. Achtung! Es dürfen keine doppelten Zeilennummern vorkommen!

### BLOCKS

Dies ist eine weitere Basic-Funktion. Mit ihr erhält man die Anzahl der freien Blöcke einer Diskette. Diese Funktion kann wahlweise in PRINT-Befehlen oder Wertzuweisungen verwendet werden.

### START("name")

Mit dieser Funktion läßt sich die Startadresse des Programms »name« ermitteln. Auch diese Funktion kann in PRINT-Befehlen und Wertzuweisungen verwendet werden. Ist dieses Programm nicht vorhanden, wird als Startadresse der Wert 51143 ermittelt.

### SIZE("name")

Mit dieser Funktion läßt sich die Länge eines Files in Blocks ermitteln. Hier gilt dasselbe wie bei den beiden anderen beschriebenen Funktionen.

### RESCUE"name",ft

Mit diesem Befehl kann ein soeben gelöschtes File wieder gerettet werden beziehungsweise der Filetyp eines Files geändert werden. Für den Parameter ft sind die Zahlen 1 bis 4 erlaubt. Sie bedeuten:
0 = DELeted
1 = SEQuential
2 = PRoGram
3 = USeR
4 = RELative

Der Filetyp im Directory wird angepaßt und anschließend ein VALIDATE ausgeführt, um die Blöcke dieses Files wieder zu belegen. Achtung! Wurde zwischen dem Löschen und dem Rettungsversuch auf die Diskette geschrieben (SAVE oder ähnliches), dann läßt sich mit hoher Wahrscheinlichkeit das gelöschte Programm nicht mehr retten!

### ENTRY$("name")

Mit dieser Funktion lassen sich die kompletten 30 Bytes eines Directory-Eintrags in einen String ablegen: »xx$= ENTRY$("name")«. Die Verwendung im PRINT-Befehl ist zwar möglich aber sinnlos. Achtung! An den 30 Byte langen Fileeintrag werden drei Bytes angehängt, die Spur, Sektor und Position des gelesenen Eintrages darstellen. Diese drei Bytes dürfen nicht verändert werden, da sonst beim Zurückschreiben mit WRITE das Directory zerstört wird!

### WRITE xx$

Mit diesem Befehl kann ein manipulierter Directory-Eintrag zurückgeschrieben werden. Zusammen mit der ENTRY$-Funktion läßt sich beispielsweise ein Directory-Sortierpro-gramm aufbauen. Siehe ENTRY$.

### DESTROY n

Der Track mit der Nummer n wird endgültig zerstört. Beim Zugriff auf diesen Track erhält man nur den 21 READ ERROR. Die Diskette kann nur noch durch komplettes Neuformatieren normalisiert werden. Nach der Ausführung dieses Befehls muß das Laufwerk kurz ausgeschaltet werden.

### QUIT

Mit QUIT wird Disk-Basic verlassen, ohne daß das im Speicher befindliche Basic-Programm gelöscht wird. Allerdings gehen die Variablen-Inhalte verloren.

### COMMANDS

Auf dieses Kommando hin werden alle zusätzlichen Befehle von Disk-Basic auf dem Bildschirm ausgegeben.

Noch einige kleine Anmerkungen: Anders als bei vielen Basic-Erweiterungen muß zwischen dem THEN-Befehl und einem Disk-Basic-Kommandp kein Doppelpunkt stehen! Bei allen Befehlen wird, ist das durch DEVICE festgelegte Laufwerk nicht angeschlossen, ein »DEVICE NOT PRESENT ER-ROR« gemeldet. Bei fehlendem Filenamen gibt es einen »MIS-SING FILENAME ERROR«.

(Alexander Frink/bs)

# COP — Hilfe für Datasette \[37-38\]

> COP ist die Abkürzung für »Cassette Operations Program«. Es erleichtert den Umgang mit der eigenen Programmsammlung auf Kassetten.

COP ist ein Hilfsprogramm zur Verwaltung von Programmsammlungen. Mit ihm können Sie Programme auf einer Datasette leichter und schneller finden und bei Bedarf ein Inhaltsverzeichnis einer Kassettenseite ausdrucken.

COP besteht aus zwei Teilen: Einem Hauptprogramm, das auf einer separaten Kassette gespeichert werden kann, und den Datensätzen für die einzelnen Kassetten-Seiten, die zur einfacheren Handhabung am Anfang jeder Kassettenseite abgelegt werden sollten.

Nach dem Starten des Programms mit »RUN« erscheint ein Menü auf dem Bildschirm, dessen einzelne Punkte hier erklärt werden:

### 1)	Anfänge ermitteln

In diesem Programmpunkt können Sie die Programme einer Kassette katalogisieren. Zunächst geben Sie bitte den Namen und die Seite der Kassette ein. Danach wird nach den Titeln der einzelnen Programme gefragt. Hier können Sie auch persönliche Zusätze angeben wie zum Beispiel Zählerstand oder Fast-Tape, da der eingegebene Titel nicht mit dem Namen des Programms auf der Kassette übereinstimmen muß. Haben Sie alle Titel eingegeben, tippen Sie bitte ein »*« als Endekennzei-chen ein.

Nun wird die zu katalogisierende Kassette im zurückgespulten Zustand eingelegt und immer bis zumjeweiligen Programm vorgespult. Dann drücken Sie die STOP-Taste. Zu diesem Zweck sollte man sich vorher den Stand des Zählwertes der einzelnen Programme notiert haben. Dies geschieht fortgesetzt bis zum letzten Programm, dann wird wieder zum Eingangsmenü zurückgesprungen.

### 2)	Programm suchen

Nach der Anzeige des Kassettennamens und der Seite können die Programmnamen mit der Leertaste durchgeblättert werden. Hat man das zu suchende Programm gefunden, drückt man die Taste »RETURN«. Nun spult man die Kassette vor, der Computer stoppt den Spulvorgang automatisch kurz vor dem Programm. Drücken Sie nun »Stop« und »Play« an der Datasette, und das gewünschte Programm wird automatisch geladen. COP wird dabei gelöscht.

### 3)	Zeiten abspeichern

In diesem Programmteil werden alle erstellten Daten (Kassetten- und Programmnamen und Zeitzum Stoppen) in einem Datensatz gespeichert. Dies kann zum Beispiel am Anfang der zu bearbeitenden Kassette geschehen. Dann sollte man das erste Programm allerdings nicht direkt am Anfang des Bandes speichern, da es dann den Datensatz überschreibt oder umgekehrt. Am praktikabelsten hat sich ein Vorspulen bis zum Zählwerksstand »30« erwiesen, bevor man das erste Programm speichert.

### 4)	Zeiten laden

Hier werden die unter Punkt 3 abgespeicherten Datensätze wieder geladen.

### 5)	Verzeichnis ausdrucken

Zunächst erscheinen die ersten 14 der auf der Kassette befindlichen Programme auf dem Bildschirm. Mit der Leertaste kann zu den nächsten 14 weitergeblättert werden. Wurden alle Programme aufgelistet, kann man sich das komplette Verzeichnis auf dem Plotter 1520 ausgeben lassen. Eine Anpassung an andere Drucker dürfte überhaupt kein Problem sein, dakeinedruckerspezifischen Befehleverwendetwerden. Einzig und allein der OPEN-Befehl in Zeile 5160 muß entsprechend des vorhandenen Druckers geändert werden.

Noch einige Hinweise: Das Programm ist auf 30 Titel pro Kassette beschränkt, mehr sind auf einer Kassette kaum sinnvoll. >Turbo-Tape«-Benutzer müssen noch die Zeile 2200 ändern. Dort wird das Eintippen der Tastenkombination »SHIFT/LOAD« simuliert, um das angewählte Programm zu laden, was mit manchen »Turbo-Tape«-Versionen nicht funktioniert. Am allereinfachsten wird dort nur der END-Befehl eingesetzt und der LOAD-Befehl dann von Hand eingegeben.

Für diejenigen, die das Programm verändern wollen, hier noch eine Variablenliste:

(Hubertus Luhmann/bs)

### Variablenliste:

TODO TABLE

A$	Eingabe über GET
C$	Kassettennummer
CS$	Kassettenseite
PP$(Q)	laufende Programmtitel
Q	Zählervariable
P$/P1$	Play/Play löschen
F$/F1$	FFwd/FFwd löschen
S$/S1$	Stop/Stop löschen
R$/R1$	Record/Record löschen
Z$/Z1$	Rewind/Rewind löschen
PR$/PL$	Anzeige »Programm:«/PR$ löschen
Q1	Höchste Anzahl Programme
Q2	Höchste Anzahl Programme und Sternchen (Q2=Q1 + 1)
TI$(Q)	Zeitvariable
T1$(Q)	Zwischenspeicher der Zeitvariablen

# So stellt man die Datasette ein! \[39\]

> Die Fehlermeldung »LOAD ERROR« weist meistens auf eine defekte Kassette oder einen dejustierten Tonkopf hin. Dieser läßt sich allerdings mit einem Schraubenzieher einstellen.

Wer mit seiner Datasette Programme eines anderen Data-setten-Besitzers laden will, der erlebt nach Eingabe des LOAD-Befehls oft die bizarrsten Dinge. Neben einem lapidaren »LOAD ERROR«, kann man andere Fehlermeldungen wie »OUT OF MEMORY ERROR« erhalten, aber auch Meldungen wie »FOUND A!.;$Y&«, (meist folgt dann innerhalb von Sekunden ein »LOAD ERROR«). Wenn es ganz schlimm kommt, stürzt der Computer auch noch ab und läßt sich nur mit einem Reset zu einem weiteren Ladeversuch bewegen, der dann allerdings ähnlich effektvoll endet.

Hier gibt es mehrere mögliche Fehlerursachen: die Kassette ist defekt, der Tonkopf ist verstellt oder die elektromagnetischen Störstrahlungen eines Fernsehers oder Monitors verhindern einen einwandfreien Betrieb. Das letzte Problem läßt sich lösen, wenn man die Datasette bis auf maximale Kabellänge vom Fernseher während dem Laden entfernt. Sollte die Kassette defekt sein, hilft nur eine Sicherheitskopie. Am häufigsten tritt allerdings der zweite Grund, ein dejustierter Tonkopf, auf. Im folgenden soll beschrieben werden, wie man seinen Tonkopf kurzzeitig auf ein anderes Programm einstellen kann. Eine komplette, einwandfreie Einstellung läßt sich allerdings nur mit einem kleineren Bastelaufwand erreichen. Wir werden im64’er, Ausgabe 10/85, eineSchaltungvorstellen, mitderdie Datasette auf jede Kassette optimal justiert werden kann. Will man aber nur ein Programm laden, das man aufgrund einer falschen Einstellung leider nicht laden kann, reicht das folgende Verfahren aus:

Versuchen Sie, das Programm zu laden. Sollte derComputer überhaupt nichts auf der Kassette finden (Bildschirm bleibt hellblau, Datasette stoppt nicht, keine »FOUND ...«-Meldung), dann sollten Sie vorerst lieber auf das Programm verzichten. Die Tonkopfeinstellung, mit der dieses Programm gespeichert wurde, und die ihrer Datasette unterscheiden sich dann so erheblich, daß es einerseits sehr lange dauert, den Tonkopf ohne Zusatzhardware einzustellen, Sie andererseits aber mindestens die gleiche Zeit brauchen, ihre eigene Tonkopfeinstellung wiederzufinden.

Sollte der Computer etwas auf dem Band finden, dann läßt sich die Dejustierung des Kopfes in drei Klassen einteilen: — Der Computer meldet sich mit »FOUND filename«, lädt einige Sekunden bis Minuten und meldet dann einen »LOAD ERROR«: Entweder ist der Tonkopf nur sehr leicht verstellt oder die Kassette ist defekt.

- Der Computer meldet sich mit »FOUND filename« und so-fort mit »LOAD ERROR« oder »OUT OF MEMORY ERROR« oder einer anderen Fehlermeldung: Der Tonkopf ist etwas mehr verstellt als im ersten Fall, allerdings immer noch nicht sehr.
- Der Computer meldet sich mit »FOUND irgendwas«, wobei »irgendwas« meist aus Grafikzeichen und Farbumschaltungen besteht, meldet sofort oder später einen Fehler oder stürzt irgendwann ab: Der Tonkopf ist mittelstark verstellt und dürfte sich ohne Zusatzhardware noch richten lassen.

Bei der Tonkopfeinstellung tut man sich erheblich leichter, wenn man die Datasette aufschraubt. Lösen Sie also den Stecker der Datasette vom Computer, nehmen Sie eine in der Datasette liegende Kassette heraus und lösen Sie die vier Schrauben an der Unterseite.

Nehmen Sie dann das Oberteil des Gehäuses ab. Ziemlich genau in der Mitte der Mechanik befindet sich der Tonkopf. Er ist mit zwei Schrauben an der Mechanik befestigt (siehe Bild). Mit der linken Schraube läßt sich die Einstellung des Tonkopfes vornehmen. Drehen Sie niemals an der rechten Schraube!

Bevor Sie nun wild an der linken Schraube herumkurbeln, sollten Sie sich diejetztige Position merken. Die Schraube hat einen langen und einen kurzen Schlitz. Merken Sie sich die Position des langen Schlitzes am besten wie die Zeiger einer Uhr. Steht der beispielsweise senkrecht, kann man das als zwölf Uhr interpretieren. Vergessen Sie diese Einstellung nicht, sonst müssen Sie nachher stundenlang herumprobieren, bis Sie Ihre eigenen Kassetten laden können.

Legen Sie nun die Kassette mit dem Programm, das Sie laden wollen, ein. Verdrehen Sie die linke Kopfschraube ein wenig (maximal um ein bis zwei »Stunden«). Es ist egal in welche Richtung Sie drehen, Sie sollten sie sich nur merken. Machen Sie wieder einen Ladeversuch. Es gibt jetzt drei Möglichkeiten:

- Es hat sich überhaupt nichts geändert: Verdrehen Sie die Schraube wieder um ein bis zwei »Stunden« in dieselbe Richtung und machen Sie einen erneuten Ladeversuch.
- Der Fehler ist, gemäß der oben gemachten Abstufungen, kleiner geworden: Verdrehen Sie die Schraube wieder um ein bis zwei »Stunden« in dieselbe Richtung und machen Sie einen erneuten Ladeversuch.
- Der Fehler ist, gemäß der oben gemachten Abstufung, größer geworden oder der Computer findet gar nichts mehr: Drehen Sie in die Ausgangsstellung zurück und probieren Sie es nochmal in der anderen Richtung.

Sollten Sie irgendwann das Programm fehlerfrei laden können: Herzlichen Glückwunsch! Drehen Sie nun die Schraube wieder in ihre Ausgangsstellung zurück und speichern Sie das Programm.

Ein letztes Mal sei hier auf die kleine Schaltung in Ausgabe 10/85 verwiesen, mit der sich jede Datasette exakt auf jede noch so verstellt aufgenommene Kassette in wenigen Minuten einstellen läßt.

(bs)

# Turbo Tape de Luxe \[40-42\]

> Machen Sie Ihrer Datasette Beine: Mit diesem Programm wird sie sogar etwas schneller als das Floppy-Lauf-werk.

Datasettenbesitzer müssen eigentlich gemütliche Leute sein. Bis zu zwanzig Minuten kann es nämlich dauern, wenn man ein umfangreiches Programm laden will. Viele Leute haben deswegen schon schnelle Lade- und Speicherroutinen geschrieben, die die Datasette um Faktoren zwischen 5 und 15 beschleunigen. Am bekanntesten und verbreitetsten ist das Programm »Turbo Tape«.

Das hier abgedruckte Programm »Turbo Tape de Luxe« (siehe Listing) zeichnet sich vor anderen Schnelladesystemen durch folgende Punkte aus:

- Es ist kompatibel zu »Turbo Tape«, kann also mit »Turbo Tape« gespeicherte Programme lesen. Daraus folgt, daß der Kassettenbetrieb um den Faktor 10 (wie bei »Turbo Tape«) beschleunigt wurde. Das ist immerhin sogar etwas schneller als das Floppy-Laufwerk 1541 (ohne Hypra-Load).
- Es arbeitet nicht mit neuen Basic-Befehlen, sondern mit einem Eingabemenü, so daß keine Konflikte mit Basic-Erweite-rungen entstehen können.
- Das Basic-ROM kann während des Betriebs abgeschaltet werden, so daß auch Programme, die teilweise unter dem Basic-ROM liegen (lange Spiele und ähnliches), gespeichert werden können.
- Das Programm schütztsich selbstvordem Überladen durch andere Programme.
- Es können beliebige RAM-Bereiche gespeichert werden.
- Programme können codiert und decodiert werden, damit kein Unbefugter Zugriff auf die Programme hat.
- Mit Hilfe des SMON kann das Programm in beliebige Speicherbereiche geschoben und sogar in ein EPROM gebrannt werden.

Nach dem Abtippen mit dem MSE und Speichern des Programms, kann es mit »SYS 49152« gestartet werden. Vorher sollten Sie jedoch NEW eingeben. Das Hauptmenü erscheint dann sofort und wartet auf eine Eingabe. Mit der Taste »Q« kann man dieses Menü wieder verlassen und dann später mit dem Befehl »£T« wieder ins Menü zurückkehren. Damit dies funktioniert, wird allerdings ein Basic-Vektor verbogen, der von vielen Basic-Erweiterungen benutzt wird und somit eine Zusammenarbeit mit »Turbo Tape de Luxe« völlig unmöglich macht. Soll dieser Vektor nicht verbogen werden, muß »Turbo Tape de Luxe« mit »SYS 49164« gestartet werden. An den Menüfunktionen hat sich nichts geändert, allerdings kann nach dem Verlassen mit »Q« nicht mehr mit »£T« ins Menü zurückgesprungen werden, sondern nur mit dem angegebenen SYS-Befehl.

## Die Kommandos

Doch nun zur Erklärung der einzelnen Menü-Kommandos:

### L — Load

Nach dem Drücken derTaste »L« wird vom Benutzer die Eingabe des Namens des zu ladenden Programmes verlangt. Soll das nächstbeste Programm geladen werden, darf der Name weggelassen werden. Ebenso ist eine Angabe mit Abkürzung (Joker) (»*«) erlaubt (Beispiel: »TUR*«). Da bei fastjeder Programmoption ein Filename angegeben werden muß, wird im einzelnen nicht mehr darauf hingewiesen.

Nachdem das Programm gefunden wurde, werden Name und Adressen des Programmes angezeigt und auf einen Druck auf die Commodore-Taste gewartet. Wird diese Taste nicht gedrückt, wird nach zirka acht Sekunden der Ladevorgang fortgesetzt.

### P — Proload

Mit dieser Funktion können sowohl Basic-, wie auch Maschinensprache-Programme geladen und automatisch gestartet werden. Ist das eingeladene Programm ein Basic-Programm, wird der »RUN«-Befehl simuliert. Ist das geladene Programm hingegen ein Maschinen-Programm, wird es nach dem Laden an der Anfangsadresse gestartet. Dies funktioniert nicht bei allen Maschinen-Programmen!

### V — Verify

Mit Verify kann ein abgespeichertes Programm mit dem im Speicher befindlichen verglichen werden.

### S — Save

Speichert das im Speicher vorhandene Basic-Programm.

### A — Allsave

Speichert beliebige RAM-Bereiche ab. Die Start- und Endadresse müssen in hexadezimaler Form angegeben werden. Beim Laden wird das Programm wieder an diese Adressen zurückgeladen.

### O — Original

Speichert RAM-Bereiche so ab, daß sie später an andere Adressen geladen werden. Als erstes müssen Sie die Adressen angeben, an die das Programm später geladen werden soll. Danach geben Sie die Adressen an, an denen sich das Programmjetzt befindet. Zum Schluß folgt, wie bei allen Save-Befehlen, der Filename.

### R — Renew

Holt ein durch »NEW« oder einen Reset gelöschtes Basic-Programm wieder zurück.

### K — Kill

Zerstört »Turbo Tape de Luxe« und »biegt« die Vektoren wieder gerade. Zum Neuaufruf muß es erneut geladen werden.

### M — Monitor

Löscht den Bildschirm und startet einen Maschinensprache-Monitor, sofern dieser im Speicher vorhanden ist. Damit individuelle Monitore verwendet werden können, muß die Einsprungadresse in $C52C/$C52D angepaßt werden. Ist kein Monitor vorhanden, kann das Programm abstürzen!

### C — Code

Codiert einen Speicherbereich nach Adressenangabe. Das so codierte Programm kann gespeichert und später wieder geladen und decodiert werden.

### D — Decode

Decodiert einen bestimmten Speicherbereich.

Wer sich einen individuellen Code erstellen möchte, damit außer ihm niemand Zugriff auf die Programme hat, muß folgende zwei Speicherstellenpaare ändern:
CODE1 : C591 und C59C
CODE2 : C594 und C59A

In den beiden Speicherstellen eines Paares muß immer dasselbe Byte stehen!

### Q — Quit

Verläßt das »Turbo Tape de Luxe«-Menü und springt zurück in Basic.

### ± — Basic-ROM ein-/ausschalten

Im »Turbo Tape de Luxe«-Menü kann das Basic-ROM ($A000-$BFFF) abgeschaltet werden, um Programme, Grafikbilder und anderes im RAM unter dem ROM aus diesem Bereich speichern zu können. Der derzeitige Zustand des Basic-ROMs wird in dem Kästchen »BR« angezeigt.

Die abgedruckte Version von »Turbo Tape de Luxe« liegt im Speicherbereich von $C000 bis $C9B0. Sie kann mit dem SMON und seinem »C«-Befehl in beliebige Speicherbereiche geschoben werden, da alle verwendeten Sprungtabellen als BIT-Befehle getarnt sind. Genaueres zur Verwendung des »C«-Befehls beim SMON entnehmen Sie bitte der Anleitung zum SMON selbst (64’er, Ausgabe 11/84 bis 2/85).

Wer will, kann »Turbo Tape de Luxe« nach dem Verschieben sogar in ein EPROM brennen.

Sollte sich »Turbo Tape de Luxe« einmal mit »Load Memory Error« melden, dann haben Sie versucht, ein Programm zu laden, das »Turbo Tape de Luxe« teilweise überschrieben und gelöscht und somit einen sauberen Systemabsturz heraufbeschworen hätte. Diese Sicherheitsabfrage funktioniert auch in etwaigen verschobenen Versionen.

(J. Golombek/bs)

# Floppy-Fehler ohne Rätsel \[43\]

Wer kennt ihn nicht, den bekannten Vierzeiler, mit dem der Fehlerkanal des Disketten-Laufwerks abgefragt wird? Mit diesem Programm zeigt der Computer automatisch an, welcher Fehler aufgetreten ist.

Das Eintippen jenes berühmten Vierzeilers ist zwar ein einfaches, aber zeitraubendes Verfahren:
10 OPEN15,8,15
20 INPUT # 15,A1,A2$,A3,A4
30 PRINTA1,A2$,A3,A4
40 END

Immerhin sind ungefähr 56 Tasten zu drücken. Meistens vergißt der Anwender außerdem die Zeilen wieder zu löschen. Eine Alternative besteht darin, das DOS 5.1 der Demodiskette zu laden. Doch stellte auch dies keine befriedigende Lösung dar. Es sind immer noch einige Tasten zu drücken. Eine bessere Lösung ist ein entsprechendes Maschinenprogramm (Listing). Der Fehlerkanal der Floppy wird selbständig vom Computer überwacht und bei Bedarf vollautomatisch eine Fehlermeldung ausgegeben.

Das Programm ist ganz in Maschinensprache geschrieben. Nach dem Betätigen einer beliebigen Taste werden Sie aufgefordert, die Startadresse einzugeben. Das Programm ist frei verschiebbar, die entsprechenden Änderungen werden vom Programm selbst durchgeführt. Zunächst werden Sie noch nichts bemerken, außer, daß sich der Computer mit einem READY wiedermeldet. Versuchen Sie aber nun einmal eine Fehlermeldung der Floppy zu erzeugen. Als Beispiel können Sie ein Programm von der Diskette laden, das es nicht gibt. Auf dem Bildschirm erhalten Sie sofort die entsprechende Fehlermeldung und die Aufforderung, eine Taste zu drücken. Die Funktionen des Computers sind um eine wichtige und nützliche Fähigkeit erweitert worden. Außerdem arbeitet das Programm innerhalb von Basic-Programmen ebenfalls zuverlässig. Bei einem Fehler wird ein Programm nicht unterbrochen. Als weitere Besonderheit ist zu erwähnen, daß das Programm auch mit anderen Hilfsprogrammen zusammenarbeitet. Sie können zum Beispiel Hypra-Load oder das DOS 5.1 weiterhin benutzen. Das Programm wird durch Drücken der Run-Stop/ Restore-Taste unterbrochen. Ein erneuter Start istjederzeit mit SYS (Startadresse) möglich.

### Funktionsweise des Programmes

Zuerst werden die IRQ-Vektoren geändert. DerComputerar-beitet dann bei jedem Interrupt das Programm ab. Dann findet eine Verzögerung statt, damit der Fehlerkanal nicht bei jedem Interrupt abgefragt wird. Danach wird geprüft, ob die Diskettenstation arbeitet und wenn ja, wird die Routine verlassen. Als nächstes wird der Fehlerkanal abgefragt und geprüft, ob ein Fehler vorliegt. Ist dies der Fall, dann wird die augenblickliche Cursorposition zwischengespeichert und der Computer merkt sich den Inhalt der oberen drei Zeilen. Diese Zeilen werden dann gelöscht, der Cursor abgeschaltet, eine neue Schriftfarbe gewählt und die Fehlermeldung in reverser Schrift ausgegeben.

Anschließend wird die Aufforderung, eine Taste zu drücken, aufden Bildschirm geschrieben. DerComputerwartetdann so lange, bis eine Taste gedrückt wird. Dann wird der ursprüngliche Bildschirminhalt wieder hergestellt, die alte Bildschirmfarbe ins Register gePOKEt und der Cursor auf den alten Platz gebracht. Das Programm benutzt insgesamt elf Unterroutinen des Betriebssystems. Die Farbe, in der die Fehlermeldung ausgegeben werden soll, ist durch den Befehl POKE Startadresse+123, Farbcode veränderbar. Dem Programmierer ist mit diesem Programm ein sehr gutes Hilfsmittel in die Hand gegeben.

(Georg Kramer/aw)

# Diskmaster — Beherrschen Sie das 1541-Laufwerk! \[44-46\]

> Dieses Programm macht die Bedienung des Floppy-Laufwerks 1541 sicher und komfortabel. Alle Befehle, die man sich bislang mühsam aus dem Handbuch suchen mußte, stehen auf Knopfdruck parat. Außerdem gibt es die Möglichkeit, eine Reihe von kommerziellen Programmen mit eigenen Basic-Programmen zu kombinieren.

Das Programm Diskmaster (siehe Listing) ist ein Maschinensprache-Programm, das für den Commodore 64 geschrieben wurde, damitsich Floppy-geplagte Commodore-Besitzer nicht länger die Finger wund schreiben müssen, wenn sie zum Beispiel die Floppy initialisieren oder ein Programm laden wollen.

Diskmaster muß mit dem MSE eingegeben werden.

### Das Hauptmenü

Nachdem Diskmaster mit SYS 49152 gestartet wurde, meldet es sich mit dem Hauptmenü. Hier gibt es fünf Wahlmöglichkeiten:

1.	Programm laden
2.	Programm speichern
3.	Diskette verwalten
4.	Inhalt zeigen
5.	Zurück zu Basic

Man kann nun einen der Menüpunkte anwählen, indem man eine der Tasten 1 bis 5 tippt. Der angewählte Menüpunkt erscheint dann revers auf dem Bildschirm. Die Wahl wird nun durch Drücken der RETURN-Taste bestätigt.

### Programm laden

Das erste Untermenü bietet insgesamt vier Menüpunkte:

1.	laden
2.	laden und starten
3.	merge (zusammenfügen)
4.	zurück

Es gib hier nun vier verschiedene Möglichkeiten, ein Programm zu laden. Unter Menüpunkt 1 wird ein Programm genauso geladen, wie man das vom Basic her bereits kennt, allerdings geht es hier etwas komfortabler. Man gibt einfach den Namen des gewünschten Programms ein, schließt die Eingabe mit RETURN ab, und der C 64 lädt das Programm. Vom Hauptmenü aus kann man dann wieder in das Basic zurück und das Programm RUN neu starten.

Menüpunkt 1 bietet im Prinzip nichts Neues. Die Punkte 2 und 3 hingegen stellen eine Erweiterung der Bedienungsmöglichkeiten gegenüber dem Standard dar. Unter Punkt 3 wird das angegebene Programm an das bereits im Speicher befindliche Basic-Programm angehängt. Man kann also zwei (oder mehr) Programme miteinander verknüpfen und erspart sich so eine MengeSchreibarbeit. Hierbei istallerdingsunbedingtdar-auf zu achten, daß die Zeilennummern des zweiten Programms höher sind als die des ersten.

### Programm speichern

Der Menüpunkt 2 des Hauptmenüs ermöglicht das Speichern von Programmen, die sich im Basic-Speicherbereich befinden. Dazu wird einfach der Name des Programms eingegeben. Falls ein Programm gleichen Namens bereits existiert, wird eine entsprechende Fehlermeldung in der untersten Zeile des Bildschirms ausgegeben.

### Diskette verwalten

Alle Befehle, die der Floppy über den Kommando-Kanal übermittelt werden, können unter Menüpunkt 3 des Hauptmenüs übermittelt werden. Es erscheint folgendes Untermenü:

1.	Initialisieren
2.	Reorganisieren
3.	Name ändern
4.	File löschen
5.	File kopieren
6.	Name der Disk ändern
7.	Formatieren
8.	zurück

Wählt man Punkt 1 an, so wird die Floppy initialisiert.

Unter 2 wird ein Validate ausgeführt, das heißt, alle unbenutzten Blocks auf der Diskette freigegeben.

Mit Punkt 3 kann der Name eines Files geändert werden. Diskmaster fordert Sie hier auf, den alten und den neuen Namen des betreffenden Files einzugeben. Anschließend wird der Name geändert.

Menüpunkt 4 wird angewählt, wenn man ein File (Programm oder Datei) löschen möchte. Hier muß der Name des betreffenden Files eingegeben werden.

Unter Menüpunkt 5 können Files auf der Diskette kopiert werden. Auch hier müssen der Name des alten und des neuen Files angegeben werden.

Will man den Namen der Diskette ändern, so muß man den Menüpunkt 5 anwählen. Man kann dann den neuen Namen sowie die neue ID der Diskette eingeben.

Anschließend wird der Name geändert. Soll eine Diskette hingegen total gelöscht werden, ist Menüpunkt sieben an der Reihe. Auch hier werden Name und, wenn eine vollkommene Neuformatierung der Diskette verlangt wird, ID der Diskette eingegeben. Punkt acht führt Sie zurück ins Hauptmenü.

### Inhalt zeigen

Vom Hauptmenü aus kann der Inhalt der Diskette gezeigt werden. Dazu wird der Menüpunkt 4 gewählt. Es erscheint dann, nach kurzer Diskettenaktivität, ein kleines Fenster auf dem Bildschirm, in dem die erste »Seite« des Directorys ausgegeben wird. Die jeweils nächste Seite wird durch Drücken der Taste F3 aufgerufen. Mit F1 verläßt man diesen Menüpunkt wieder.

### Der Editor

Diskmaster bietet zur komfortablen Eingabe der Namen einen kleinen Eingabe-Editor. Dieser bietet die üblichen Funktionen des C 64 Basic-Editors, bis auf eine Änderung: DEL löscht den Buchstaben unter und hinter dem Cursor.

### Zeigen der Directory während der Eingabe

Das Directory kann nicht nur vom Hauptmenü aus angesehen werden, sondern auch immer dann, wenn eine Eingabe, zum Beispiel eines Filenamens, erfolgen soll. Dank dieser Funktion kann man sich zum Beispiel davon überzeugen, daß das Programm, das man laden möchte, auch wirklich existiert, ohne ins Hauptmenü gehen zu müssen. Will man das Directory ausrufen, so muß man F3 drücken. Mit F1 verläßt man das Directory wieder.

### Verlassen eines Menüpunktes

Jeder Menüpunkt kann verlassen werden, ohne daß er ausgeführt wird, in dem man F1 druckt. Es erscheint dann wieder das jeweilige Menü und es kann ein anderer Menüpunkt gewählt werden.

### Die Fehlermeldungen

Es erscheinen die üblichen Fehlermeldungen der Floppy, wenn durch einen Eingabefehler eine Fehlerbedingung entstanden sein sollte. Mit F1 wird die Fehlerroutine wieder verlassen.

### Verträglichkeit mit anderen Programmen

Diskmaster kann mit einer Reihe von bekannten Programmen benutzt werden, zum Beispiel Vizawrite. Diskmaster funktioniert, wenn man eine kleine Einschränkung macht, auch mit Hypra-Load. Man muß dann allerdings auf das Einlesen des Di-rectorys verzichten. Stellt sich das Directory als lebenswichtig heraus, so muß man mit POKE 1,55 das Hypra-Load inaktivieren. Als Alternative bietet sich außerdem an, das Directory als Basic-Programm zu laden.

### Einige technische Details

Diskmaster belegt den Speicherplatz von $C000 bis $D000. Außerdem wird der Speicherbereich von $D000 bis $FFFF zum Teil zur Zwischenspeicherung des Directorys benutzt. Daher kann kein Directory eingelesen werden, solange Hypra-Load aktiv ist. Ist Hypra-Load aktiviert, so erscheint nach dem Laden eines Programms die Warmstartmeldung der Floppy.

Das Directory wird bei Diskmaster auf eine etwas ungewöhnliche Art eingelesen: Diskmaster initialisiert zunächst die Diskette und prüft anschließend anhand des Namens und der ID, ob das Directory der betreffenden Diskette bereits eingelesen wurde. Wenn ja, so wird das Directory nicht erneut eingelesen. Das spart Zeit, besonders bei sehr vollen Disketten.

Selbstverständlich kann die Diskette vom Basic aus wie üblich benutzt werden.

(Volker Köhne/aw)

# Entstörung des 1541-Laufwerks \[47\]

> Bisher war es fast unmöglich, den Monitor oder Fernseher in die unmittelbare Nähe des Diskettenlaufwerks zu stellen. Durch die elektromagnetischen Felder ist kaum noch ein störungsfreier Zugriff möglich. Abhilfe schafft eine selbstgebastelte Abschirmung.

Eine Computeranlage braucht schon ihren Platz: Computer, Monitor, Diskettenstation und Drucker benötigen schon fast den gesamten Arbeitstisch. Warum also nicht platzsparend das Floppy-Laufwerk unter den Fernseher oder zumindest näher an ihn heran stellen. Doch unterschreitet man einen gewissen Mindestabstand, führt jeder Zugriff auf eine Diskette nur noch zu Lesefehlern. In einem Monitor und Fernsehgerät wird mit sehr starken elektromagnetischen Feldern gearbeitet, die die ungenügend abgeschirmte 1541 bei geringem Abstand aus dem Takt bringen können. Wer wenig Platz hat, und das Laufwerk am oder unter dem Fernseher stehen haben möchte, der muß die Abschirmung entscheidend verbessern. Das ist aber sehr viel einfacher als es sich anhört. Sie brauchen noch nicht einmal Ihren Lötkolben anzuheizen, ein Schraubenzieher ist schon Werkzeug genug.

Sie schrauben einfach ihre Floppy auf und nehmen den Deckel ab, natürlich erst, nachdem Sie den Netzstecker gezogen haben! In den Deckel kleben Sie nun eine möglichst starke Metallfolie, also keine einfache Alu-Frischhaltefolie. Die Folie muß aus einem Stücksein. Achten Sie auch darauf, daß Sie nur die vorderen zwei Drittel des Deckels bekleben, so daß die Lüftungsschlitze hinten frei bleiben, sonst stirbt Ihr Laufwerk recht bald den Wärmetod.

Die Metallfolie muß nun noch leitend mit dem Laufwerk-Chassis verbunden werden, damit der gewünschte Abschirmeffekt eintritt. Zu diesem Zweck benötigen Sie eine Kontaktfeder, die Sie sich sehr einfach aus einem Blech nach unserer Vorlage (siehe Bild) basteln können. Diese Kontaktfeder kann bei Laufwerken mit kurzer Platine einfach an einem der beiden vorderen Befestigungswinkel festgeschraubt werden. Bei Laufwerken mit langer Platine stehen diese beiden Befestigungswinkel nicht mehr zur freien Verfügung. Isolieren Sie einfach die Unterseite der Kontaktfeder, damit keine Kurzschlüsse auf der Platine entstehen können. Dann darf die Kontaktfeder auf der Platine am Befestigungswinkel festgeschraubt werden. Wird der Deckel wieder aufgesetzt, sollte die Kontaktfeder gegen die Metallfolie drücken und somit die Verbindung herstellen.

Wer sein Laufwerk offen, das heißt ohne Deckel, betreibt, hat es sogar noch einfacher. Sie besorgen sich dann ein dünnes Metallblech im DIN-A3-Format, das Sie halbkreisförmig über das offene Laufwerk stülpen. An den unteren Befestigungswinkeln, die das Chassis im Gehäuse halten, müssen Sie nun einfach eine leitende Verbindung zwischen Blech und Chassis herstellen. Dies geht zum Beispiel durch Zwischenklemmen von zwei Pfennig-Stücken. Da das Blech nur seitlich, aber nicht nach vorne und hinten abschließt, ist eine mehr als ausreichende Kühlung gewährleistet.

Nach diesen kleinen Umbauten sollten Sie in der Lage sein, das Laufwerk ohne Schwierigkeiten in unmittelbarer Nähe von Fernseher oder Monitor zu betreiben.

(Uwe Gerlach/bs)

# Schnelles Formatieren mit der 1541 \[48\]

> Das 1541-Floppy-Laufwerk gehört nicht nur beim Laden, sondern auch beim Formatieren einer Diskette nicht gerade zu den schnellsten seiner Gattung. »Fast Format« ändert das.

Wer bislang mit einer Datasette gearbeitet hat, wird erstaunt feststellen, daß eine Diskette erst formatiert werden muß, bevor man etwas mit ihr anfangen kann. Zu allem Unglück dauert dieser Vorgang, bei dem die Diskette in Spuren und Sektoren eingeteilt wird, fast genau 80 Sekunden. Wenn man beispielsweise ein ganzes Paket (zehn Disketten) nacheinander formatieren möchte, sitzt man fast 15 Minuten vor dem Computer. Fast Format reduziert diesen Vorgang auf nur 11 Sekunden pro Diskette, oder, bei zehn Disketten, auf unter drei Minuten.

Das eigentliche Fast Format ist als Maschinenprogramm im $C000 Bereich abgespeichert (Listing 1). Die neue Formatier-Routine wird durch folgenden Befehl aufgerufen:
SYS49152,N$,I$,D

Dabei ist N$ der neue Diskettenname, l$ die genau zwei Zeichen lange ID und D die Geräteadresse des betreffenden Floppy-Laufwerks. Der Fast Format-Befehl kann genauso wie der normale Formatierbefehl (N:Name, ID) verwendet werden. Etwas einfacher geht es mit dem kleinen Basic-Unterpro-gramm (Listing 2). Es fragt alle Parameter ab und startet die Format-Routine. Bitte vergessen Sie nicht, vor dem Start des Programms eine neue Diskette einzulegen, denn sonst ist Ihr gerade eingegebenes Programm wieder verloren.

Eine kleine Einschränkung noch zum Schluß. In der Regel gibt es keine Probleme mit schnell formatierten Disketten, bei älteren und verstellten Laufwerken sind allerdings Fehler möglich. Verwenden Sie deshalb für ganz besonders wichtige Daten-Disketten den normalen Formatier-Befehl.

(Jan Kusch/aw)

# FMON 1541 — das Werkzeug für werdende Floppy-Spezialisten \[50-53\]

> Zur Programmierung des 1541-Floppy-Laufwerks braucht man gutes Werkzeug. Mit dem FMON 1541 können Sie Programme für das Floppy-Laufwerk schreiben oder sich einfach ein wenig im Speicher umsehen.

FMON 1541 ist eine große Hilfe für alle, die Ihr 1541-Laufwerk programmieren wollen. Er erlaubt einfaches Assemblieren und Disassemblieren. Außerdem sind noch viele andere Sonderfunktionen eingebaut. In der folgenden Anleitung werden wir Ihnen die Funktionen und Befehle des FMON 1541 erläutern.

Tippen Sie zunächst den FMON 1541 (Listing 1) mit dem MSE ab und speichern Sie ihn. Nach dem Laden mit LOAD "FMON 154T,8,1 wird der Monitor mit SYS 32768 oder SYS 8 * 4096 gestartet. Folgende Befehle bietet Ihnen der FMON 1541:

**A** Direktassembler
Format :A aaaa bbb ccccc
Der Befehl bbb mit dem Operanden ccccc wird an die Adresse aaaa geschrieben (6502-Schreibweise). Alle Angaben erfolgen hexadezimal. Ein $ muß nicht vorgestellt werden. Bei der Art Immediate sind achtstellige Binärzahlen (% vorgestellt) und ASCII-Angaben (in ” (CHR$(34)) erlaubt. Beispiel: AND #%10101100 oder LDA #”A”, wobei der zweite Anführungsstrich weggelassen werden kann (LDA #”A). Bei Accu-Befehlen kann das nachfolgende A weggelassen werden. Einzelne Bytes können mit einem ».« eingegeben werden (.A9). Bei Branch-Befehlen wird die Zieladresse in Form einer zweistelligen Hexzahl angegeben. Und jetzt eine »Spezialität« des FMON 1541: Alle undefinierten Opcodes (vorgestelltim 64’er, Ausgabe 3/85) werden verarbeitet! (Tabelle 1)
**D** Disassemblieren von Speicherbereichen
Format: D aaaa, bbbb
Disassembliert den Speicherbereich aaaa bis bbbb. Wenn bbbb fehlt, wird ab der Adresse aaaa disassembliert. Wenn beide Adressen fehlen, dann wird ab 0300 disassembliert. Ändern von Bytes ist möglich. Fahren Sie an die Stelle und ändern Sie die oder das Byte und drücken »RETURN«.
**X** Exit
Springt ins Basic zurück
**Z** Exit II
Springt ins Basic zurück (wie RUN-STOP / RESTORE)
**G** GO
Format: G aaaa
Springt zur Speicheradresse aaaa. Das Programm muß mit RTS enden.
**M** Memory Dump
Format: M aaaa, bbbb
Gibt den Speicherbereich aaaa bis bbbb mitacht Byte pro Zeile und ASCII-Ausgabe aus. Wenn bbbb fehlt, wird wie beim D-Befehl gehandelt. Wenn aaaa fehlt, dann wird der Bereich $ 0300 bis 03FF gelistet. Ändern von Byte möglich.
\# Ändern der Floppyadresse.
zum Beispiel: #9. Alle Befehle wirken auf das Floppy-Laufwerk mit der Geräteadresse 9.
\> Ändern der Druckeradresse
zum Beispiel: >5
Das Floppy-Laufwerk ist auf acht und der Drucker auf vier voreingestellt.
@ Senden von Befehlen in den Befehls-Kanal
Format: @a: bbbbbb
Sendet den Befehl a mit dem Text bbbbbb an das Floppy-Laufwerk.
\* Liest Fehlerkanal aus.
**$** Listet Directory.
**C** Kaltstart des Floppy-Laufwerks. Alle Puffer werden gelöscht!.
**I** Initialisieren des Floppy-Laufwerks.
**R** Lesen eines Blocks.
Format: R tt ss
Liest den Track tt, Sector ss in Puffer Null ($0300 bis 03FF). Mit M kann er angezeigt und verändert werden.
**W** Schreiben eines Blocks auf Diskette ($0300 bis 03FF). Format: Wie bei Read.
Read und Write werden mit Jobbefehlen gehandhabt. Ein eventuell auftretender Fehler steht in Adresse $0000 (Fehlermeldungen siehe Tabelle 2). Meiden Sie ILLEGAL BLOCK OR SECTOR!
**J** Senden eines Jobbefehls für Puffer Null.
Format: J aa, bb cc
Der Jobbefehl aa wird mit den Parametern bb und cc in Speicheradresse $0000, 0006/0007 geschrieben.
**P** ASCII-Text an eine bestimmte Stelle schreiben.
Format: P aaaa, ttttttttt
Der Text ttttttttt wird an die Adresse aaaa und folgende gesetzt.
**S** Sichern von Speicherbereichen.
Format: S ’’ttttttttt“, aaaa, bbbb
Der Bereich aaaa bis bbbb wird in die sequentielle Datei ttttttttt zwischengespeichert. Da sequentielle Daten Puffer benutzen, wird der Speicherbereich aaaa bis bbbb erst in den Bereich ab $C000 im Computer zwischengespeichert, dann erst in die sequentielle Datei geschrieben. Dieses Verfahren dauert seine Zeit (der FMON ist nicht abgestürzt!). Wenn Sie Ihr Programm nach dem Speichern starten wollen, müssen Sie es erst mit »L« neu laden, da die Puffer benutzt werden.
**L** Laden von Speicherbereichen.
Format L ’’ttttttttt“
Das Programm ttttttttt wird in die Floppy geladen. Auch der L-Befehl braucht seine Zeit!
Sichern und laden Siekeine Speicherbereiche, die länger als 4 KByte sind (ist ja auch gar nicht notwendig).
**F** Füllen von Bereichen.
Format F aaaa, bbbb, cc
Der Bereich aaaa bis bbbb wird mit dem Byte cc vollgeschrieben.
**Q** Beschleunigen des Schreib-Lesekopfs (64’er Ausgabe 4/85).
Format: Q oder Qaa
Nur »Q« beschleunigt und »Qaa« schaltet wieder auf normal um, wobei aa ein beliebiges Zeichen sein kann.
**N** Druckt eine Datei.
Format: N ’’ttttttttt, X“
Druckt die Datei ttttttttt (Dateityp X).

(M. Köhler/P. Baumann/aw)

TODO TABLE

Absturzbefehle werden durch ABS gekennzeichnet
No operation (1 Byte) werden bis auf NOP mit NO1 gekennzeichnet
No operation (2 Byte) werden mit NO2 bezeichnet.
No operation (3 Byte) werden mit NO3 angezeigt.
Wenn man diese Befehle beim A-Befehl benutzt, wird der erste jeweils mögliche Befehl genommen (bei ABS: 02).
Besondere Schreibweisen:

TODO TABLE

ASL:ORA	ASO
ROL:AND	RAN
LSR:EOR	LSE
ROR:ADC	RAD
DEC:CMP	DEM
INC:SBC	INB

Ansonsten wird die übliche 6502-Schreibweise benutzt.
Hinter den Opcodes steht der Name des Befehls und danach die Adressierungsart: ZO = ZEROPAGE; ZOX = ZEROPAGE, X; ZOY = ZEROPAGE, Y; IMM = IMMEDIATE; INX = INDIRECT, X; INY = INDIRECT, Y; ABS = ABSOLUT; ABSX = ABSOLUT, X; ABSY = ABSOLUT, Y;

TODO TABLE

OB =ANN	(ZO)
2B =ANN	(ZO)
4B ==ANL	(IMM)
6B = DAR	(IMM)
83 =AXX	(INX)
87 =AXR	(ZO)
8B =TAN	(IMM)
8F =AAX	(ABS)
93 =AXY	(INY)
97 =AXI	(ZOX)
9B =AXS	(ABSY)
9C =YXA	(ABSX)
9E =XYA	(ABSY)
9F =AYY	(ABSY)
A3 =LDT	(INX)
A7 =LTA	(ZO)
AB =???	(Wirkung noch nicht ermittelt)
AF =LTX	(ABS)
B3 =LYT	(INY)
B7 =LAX	(ZOY)
BB =TSA	(ABSY)
BF =LYX	(ABSY)
CB =XAS	(IMM)
EB =SBC	(IMM (wie der normale Befehl SBC))

Tabelle 1. Eingabehinweise und besondere Schreibweisen des FMON 1541

TODO TABLE

Rückmeldungen in der Adresse 0000 bei R/W/J (Fehlermeldungen)
$01 = Fehlerfreie Durchführung (00, OK)
$02 = Blockheader nicht gefunden (20, Read Error)
$03 = Sync-Markierung nicht gefunden (21, Read Error)
$04 = Datenblock nicht gefunden (22, Read Error)
$05 = Datenprüfsumme ist falsch (23, Read Error)
$07 = Fehler nach einem Verify (25, Write Error)
$08 — Diskette ist schreibgeschützt (26, Write Protect on)
$09 = Prüfsumme im Header falsch (27, Read Error)
$0A = Datenblock auf Diskette zu lang (28, Write Error)
$0B — Falsche ID im Block Header (29, Disk ID Mismatch)
$0F = Keine Diskette im Laufwerk (74, Drive not Ready)
$10 = Fehler bei Decodierung (24, Read Error)

Tabelle 2. Die Fehlermeldungen in der Adresse 0000 werden mit dieser Tabelle entschlüsselt

# Directory-Editor mit Komfort \[54-59\]

> Mit diesem Programm gestalten Sie das Disketten-Directory ganz nach Ihren Wünschen.

Mit dem Directory-Editor kann man das Inhaltsverzeichnis einer Diskette auf komfortable Art und Weise ändern. Das Programm ist lauffähig auf dem Commodore 64 sowie seinen »großen Brüdern«CBM 2001 bis8001. EserkenntComputer-und Floppy-Laufwerk-Typ und sollte ohne Schwierigkeiten auch an andere und zukünftige Commodore-Computer und -Floppy-Laufwerke anzupassen sein.

Das Programm wird mit RUN gestartet. Es dauert einige Sekunden, bis Computer- und Floppy-Laufwerk-Typ erkannt und die Variablen entsprechend gesetzt sind.

## Befehlsbeschreibung

Tabelle 1 zeigt eine Übersicht über alle Befehle des Directory-Editors. Die Befehle im einzelnen: Durch »A« oder »SPACE« (Leertaste) erhöht man eine zweiseitige Kurzanleitung mit einer Befehlsübersicht (weiter mit beliebiger Taste).

Mit »0« und »1« kann man bei einem angeschlossenen Doppelfloppy-Laufwerk zwischen den beiden Laufwerken wählen. Falls ein Doppelfloppy-Laufwerk angeschlossen ist, wird beim Start des Programms automatisch Laufwerk 1 gewählt, so daß sich folgende Laufwerksaufteilung anbietet: Laufwerk 0 mit Systemdiskette und Laufwerk 1 mit der zu bearbeitenden Diskette.

»L« dient zur Umschaltung zwischen Groß- und Kleinschreibung. Mit »X« kann das Programm jederzeit verlassen werden. Wird gerade eine Diskette bearbeitet, so wird zunächst automatisch der Befehl »E« ausgeführt.

Der eigentliche Editor wird mit »I« initialisiert. Die Aufforderung zum Einlegen der zu bearbeitenden Diskette bestätigt man mit einem beliebigen Tastendruck. Nun wird die eingelegte Diskette initialisiert und nachgeprüft, ob sie dem Format des Floppy-Laufwerks entspricht. Jetzt werden nacheinander Diskettenname und Identität (ID) angezeigt, die man durch einfaches Überschreiben ändern kann. Die ID darf übrigens bis zu fünf (bei CBM 2040/3040 vier) Zeichen lang sein. Mit der RETURN-Taste kommt man zum Inhaltsverzeichnis.

Das Programm zeigt jetzt den ersten Eintrag an. Im ersten Feld wird die Länge des Files in Blöcken angezeigt. Das zweite Feld enthält den Filenamen, der nach dem Drücken von »N« frei geändert werden kann.

Im dritten Feld werden drei Fileparameter angezeigt, die in dem Directory auf der Diskette alle in einem Byte untergebracht sind: Wenn ein Stern vor dem Filetyp angezeigt wird, so wurde das File nach dem Schreiben nicht geschlossen, was es normalerweise unmöglich macht, auf dieses File wieder zuzugreifen. Glücklicherweisegeschiehtdies recht selten, daso etwas nur durch Stromausfall, versehentliches Ziehen des Netzsteckers oder durch Unterbrechen eines Basic-Pro-gramms mitten im Schreibvorgang zustandekommen kann. Trotzdem ist es ärgerlich, wenn es einmal passiert. Mit dem Directory-Editor können solche Files wieder lesefähig gemacht werden, indem man »*« eingibt. Dabei wird die erste Spur/Sektor-Kennzeichnung ausgelesen und das File bis zum Ende verfolgt. Danach wird die errechnete Blockzahl in das Directory geschrieben und ein Validate der Diskette nach dem Programmlauf veranlaßt (ab Zeile 6000). Der Stern vor dem Filetyp verschwindet, das File ist wieder in Ordnung. Es kann wohl vorkommen, daß die letzten (maximal 254) Bytes verlorengehen, wenn diese bei dem Zwischenfall noch im Floppypuffer zwischengespeichert waren; dafür ist der Rest aber gerettet.

Als zweite Information in diesem dritten Feld wird der Filetyp ausgegeben. Dieser kann durch Drücken des Anfangsbuchstaben des gewünschten Filetyps geändert beziehungsweise das File mit »D« gelöscht werden. Auch gelöschte Files werden mit angegeben und können (leider nicht bei den Floppy-Laufwerken CBM 2040/3040 wegen der völligen Zerstörung der Block-Zeiger) wieder eingetragen werden. Bei der Benutzung ist aber Vorsicht geboten, denn wenn nach dem Löschen schon wiederauf die Diskette geschrieben wurde, können Teile des Files oder Programms zerstört sein. Werden nach einem Validate zu viele freie Blöcke ausgegeben, dann kann man nichts mehr retten und das File sollte wieder gelöscht und die Diskette mit dem Validate-Befehl nochmals überprüft werden.

Die dritte Information, die nur ab DOS-Version 2 vorhanden ist (also nicht für 2040/3040), ist der Löschschutz. Er wird durch »+« ein- und durch »—« wieder ausgeschaltet und schützt vor dem Scratch-Befehl. Der New-Befehl beachtet solch einen softwaremäßigen Schutz nicht, hier hilft nur der physikalische Löschschutz, das Ankleben einer Schreibschutzmarke. Der softwaremäßige Löschschutz wird mit »<« hinter dem Filetyp in der Directory angezeigt.

Die letzten beiden Felder der Zeile zeigen den Startsektor, also den Anfang des Files, auf der Diskette. Bei 2040/3040-Floppy-Laufwerken sieht man, daß mit »Scratch« gelöschte Files eine Null in der Anzeige der Spur anzeigen und somit nicht mehr reparabel sind.

Mit der RETURN-Taste, »-« oder »=« kann man den nächsten Eintrag in die Anzeige holen. Sucht man nur ein bestimmtes File, um etwas zu ändern, so kann man mit »B« gleich bis zum Ende des Directory-Blocks »vorspulen«. Dies hat den Vorteil, daß es schneller geht. Trotzdem kann man immer mit »t» oder »@« ein File zurückgehen, falls es in demselben Block liegt.

Wenn ein File wieder in die Directory zurückgeholt oder gelöscht wird, so muß die Diskette später zur korrekten Blockbelegung überprüft werden. Will man diesen Vorgang erzwingen, so kann man »V« drücken. Ob überprüft wird oder nicht, steht unten in der vorletzten Textzeile hinter »V«. Ein »+« bedeutet, daß erst später überprüft wird.

Mit »E« kann die Bearbeitung jederzeit unterbrochen und zum Ende gesprungen werden. Am Ende des Directory, beziehungsweise wenn »E« eingegeben wurde, wird — falls erforderlich durch Löschen, Wiedereintragen oderSchließen eines Files — die Diskette mit dem »Validate«-Befehl überprüft. Dies kann eine Minute dauern, falls sich viele Files auf der bearbeiteten Diskette in ungelöschtem Zustand befinden. Danach wird die Anzahl der benutzten und der freien Blöcke ausgegeben. In Klammern erscheint die Anzahl der freien Blöcke, die in dem Directory abgelegt sind. Kommt es zu Unterschieden, so sollte, wenn das Directory bis zum Ende durchgeblättert wurde, mit »Validate« überprüft werden. Wenn mit »E« oder »X« abgebrochen wurde, dann sind wahrscheinlich nicht alle belegten Blöcke mitgezählt worden und die Zahlen, die nicht in Klammern stehen, sind nicht relevant. Nach Anzeige der Blockzahlen ist das Programm bereit, eine neue Diskette zu bearbeiten.

## Eingebaute Geräteanpassung

Am Anfang des Programms wird in eine Unterroutine ab Zeile 7 500 gesprungen, die durch Vergleichen eines Bytes mit einer Tabelle herausfindet, in welchem Computer sich das Programm im Augenblick befindet, und danach alle systemspezifischen Adressen, die vom Hauptprogramm benötigt werden, in Variablen einliest. Dieses Vorgehen ermöglicht es, jeden Commodore-Computer, der mindestens einen 40 Zeichen breiten Bildschirm besitzt, zu benutzen, ohne das Programm vollständig verändern zu müssen. Außerdem können auch die großen Commodore CBM 600/700 oder die kleinen C 16/C 116 und der Plus/4 mit dem gleichen Programm laufen, wenn die Abfragen entsprechend erweitert werden. Zur eigenen Anpassung des Programms sind in Tabelle 2 die benötigten Systemadressen aufgeführt. Sie müssen in dieser Reihenfolge nach dem PEEK-Wert und dem Namen des Computers ab Zeile 7 560 in DATAs abgelegt werden.

Für alle Commodore-Computer gilt, daß mindestens 16 KByte RAM vorhanden sein müssen. Hiervon sollten 12 KByte zur freien Verfügung übrigbleiben, denn der Directory-Editor belegt 10 KByte und benötigt noch einmal 2 KByte für Variablen.

Auch die Floppy-Laufwerke besitzen unterschiedliche Eigenschaften und Eigenarten, die es nötig machen, den Geräte-Typ durch das Programm erkennen zu lassen, um ein zufriedenstellendes Arbeiten des Directory-Editors mit allen Laufwerken zu gewährleisten. Diese Routine (ab Zeile 7 000) wurde aus dem Programm »Disk Addr Change« der 1541-Test/ Demo-Diskette entnommen und für den Directory-Editor erweitert. Auch dieses Unterprogramm kann leicht an neue Floppy-Laufwerke angepaßt werden. Es werden mit »M-R« einzelne Bytes aus dem Floppy-ROM gelesen, die charakteristisch für bestimmte Floppy-Laufwerke sind. Anpassungen an alle gängigen Commodore-Floppy-Laufwerke sind eingebaut (2/4031, 1540/1, 2/3040, 4040, 8050, 8250, wobei CBM 4040/8050 entweder mit DOS 2.1/2.5 oder DOS 2.7 ausgestattet sind). Die Erweiterung auf neue Commodore-Laufwerke (zum Beispiel 1571 und SFD 1001/1002) ist natürlich möglich. In Tabelle 3 werden alle erforderlichen Variablen erklärt und am Beispiel der eingebauten Anpassung demonstriert. Tabelle 4 zeigt die Bedeutung wichtiger Variablen, die bei verschiedenen Laufwerks-Typen unterschiedlich sein kann.

## Die Unterroutinen

Der Programmablauf ist in Tabelle 5 erläutert. Einige interessante, auch für andere Programme verwendbare Unterroutinen sind enthalten. Das Unterprogramm ab Zeile 8000 stellt eine neue Eingabe-Routine dar, die die Möglichkeit bietet, die Cursorsteuerung sowie lnsert/Delete zu erlauben, und trotzdem aufzupassen, daß nicht über den Rand des Eingabefeldes hinausgefahren wird. Außerdem sind zwei Tasten etwas anders belegt: Die HOME-Taste setzt den Cursor auf den Anfang des Eingabe-Feldes und CLR löscht nur das Eingabe-Feld, so daß der Bildschirmaufbau nicht aus Versehen einmal zerstört werden kann. Zeile 8021 wurde nur speziell für den Directory-Editor eingebaut: sie füllt den Rest des Strings bis zur Maximallänge IL mit SHIFT-Leerzeichen auf. Das wird zum Löschen eines möglichen Reststrings in der Directory benötigt und kann bei eigener Anwendung der Eingabe-Routine gegebenenfalls weggelassen werden. Die Eingabe von SHIFT-RETURN bewirkt, daß der Rest ab der Cursor-Position gelöscht und die Eingabe wie bei RETURN beendet wird.

Die Routine ab Zeile 8040 scrollt einen beliebigen Bildschirmbereich von Zeile X1 bis X2 aufwärts, falls der Cursor in Zeile X2 steht. Dies geschieht durch »INPUT« vom Bildschirm und Ausgabe der eingegebenen Strings je eine Zeile höher.

Ab Zeile 8060 steht die Warteschleife bis zum Drücken einer Taste. Dabei wird der Cursor eingeschaltet und an eine vordefinierte Stelle auf den Bildschirm gesetzt. In PR$ ist das Promptzeichen enthalten. Wenn das Unterprogramm von Zeile 2000 her angesprungen wird, sieht man ein »>«. Aus einem anderen Unterprogramm heraus (zum Beispiel Anleitung) zeigt sich ein » < «. Daran erkennt man, in welchem Modus man sich gerade befindet. Die gedrückte Taste wird direkt daneben angezeigt.

Ab Zeile 8 070 befindet sich eine Routine, die einen Text inklusive aller Steuerzeichen ausdruckt. Auch ein sonst »unverdauliches« RETURN-Zeichen (CHR$(13)) wird mitgedruckt. Da Sie mit einem fehlerhaft arbeitendem Directory-Editor einigen Schaden anrichten können, sollten Sie erst nach dem sorgfältigen Austesten des Programms mit Disketten, von denen ein Doppel existiert, die Arbeit mit dem Directory-Editor beginnen.

(Dieter Temme/ev)

# Programmschutz durch Autostart und Paßwort \[59-60\]

> Ein Programm, das nach dem Laden sofort gestartet wird und nicht mehr unterbrochen werden kann, ist eine Art Programmschutz. Richtig raffiniert wird es aber, wenn noch zusätzlich ein Paßwort nötig ist. »Autostart C 64 Plus« macht es Ihnen einfach, Ihre Programme so zu bearbeiten.

Das Programm »Autostart C 64 Plus« ist eine besonders komfortable und nützliche Art der Programmsicherung für den C 64 und ein Diskettenlaufwerk. Das Autostartprogramm lädt das zu bearbeitende Programm, das bis zu 230 Blöcke lang sein darf, in den Speicher des C 64, verschlüsselt es, fügt noch einige Modifizierungen ein und speichert es wieder ab. Der so eingefügte Programmschutz kann nur noch mit großem Aufwand rückgängig gemacht werden. Sicherlich kann jeder Programmschutz auch wieder entfernt werden, aber um dies so schwer wie möglich zu machen, soll hier nichts weiteres darüber verraten werden. Die Dauer des gesamten Bearbeitungsvorgangs richtet sich ganz nach der Länge des zu bearbeitenden Programms. Die Eingabe aller Parameter ist dabei komfortabel durch Menüpunkte und Abfragen realisiert worden. Ein so gespeichertes Programm startetsich nach dem Laden automatisch, wenn Sie das entsprechende Paßwort wissen.

Geben Sie zunächst das Programm Autostart C 64 Plus (siehe Listing) mit dem Checksummer ein. Nach dem Starten des Programms ist es notwendig, einige Parameter einzugeben, denn es wird zwischen Basic- und Maschinenprogrammen unterschieden. Bei Maschinenprogrammen benötigt Autostart C 64 Plus zusätzlich die Startadresse. Mit zwei weiteren Menüpunkten läßt sich jedes Programm gegen eine Unterbrechung durch RUN/STOP-RESTOREabsichern. Zuletztwirddasjewei-lige Paßwort eingegeben. Ein Paßwort ist eine Art Geheimzahl, das aber auch Buchstaben enthalten darf. Es darf bis zu 10 Zeichen lang sein. Falls kein Paßwort eingegeben wird, startet das bearbeitete Programm später ohne jegliche Abfrage. Bevor Autostart C 64 Plus nun mit der Modifizierung des Programms beginnt, wird nochmals nach der Richtigkeit aller Angaben gefragt.

Während dem Laden istjedes so modifizierte Programm gegen einen Reset geschützt. Dieser Schutz wird jedoch nach dem Laden abgeschaltet, da sonst ein Speicherplatzverlust von 8 KByte eintreten würde. Das bearbeitete Programm wird wie ein Maschinenprogramm mit LOAD »Name«,8,1 eingeladen. Danach erscheinen auf dem Bildschirm die normalen Betriebssystem-Meldungen—soweitnichtsUngewöhnliches. Nun muß man aber, und das ist der Trick, unaufgefordert das zuvor festgelegte Paßwort über die Tastatur eingeben (ohne anschließendes RETURN). Falls das Paßwort richtig war, blinkt der Bildschirm kurz auf und der Ladevorgang wird normal fortgesetzt. War das Paßwort aber falsch, so läuft das Diskettenlaufwerk ohnejede Fehlermeldung bis ans Ende ihrer Tage weiter. Falls Sie sich vertippt haben, ist es am einfachsten, eine Taste zu drücken, die nicht im Paßwort vorhanden ist, und dann nochmals das Paßwort einzugeben. Dadurch, daß keinerlei Fehler- oder Rückmeldungen ausgegeben werden, ist es für jemanden, der das Paßwort nicht kennt, fast unmöglich, Ihre Programme zu verwenden.

Ein Tip noch zum Schluß: Schreiben Sie sich Ihre Paßwörter auf, oder wenden Sie immer das gleiche Schema an (etwa jeder zweite Buchstabe des Programmnamens), denn sonst ist auch für Sie selbst der Zugang versperrt.

(Jan Kusch/aw)

# Zu zweit geht’s besser \[61\]

> Dieses Programm für C 64, Floppy und Drucker beseitigt ein lästiges und papieraufwendiges Problem: Drucker, die keinen Randsteller haben, können zwei Directories nebeneinander ausgeben.

Nachdem eine Diskette eingelegt und eine Taste gedrückt wurde, lädt das Programm die Directory in den Speicher. Nun ist die zweite Directory an der Reihe. Sobald diese geladen ist, werden die Directories nebeneinander ausgedruckt. Hierbei wird nach und vor ihnen eine Leerzeile eingefügt, damit in einer Serie von Directories nicht alle aneinanderkleben. Nach dem Ausdrucken können weitere Disketteninhalte bearbeitet werden.

Vorsicht! Es werden keinerlei Druckereinstellungen vorgenommen. Also müssen alle Einstellungen vor dem Start des Programms vorgenommen werden (Zeilenabstand etc.). Die voreingestellte Sekundäradresse ist 0. Sie kann aber mit PO-KE 2144, neue Sekundäradresse auf einen beliebigen Wert gesetzt werden. Die Geräteadresse kann mit POKE 2142,5 zum Beispiel von 4 auf 5 gesetzt werden. (Übrigens: da das Programm am Basic-Anfang liegt und weil ihm ein SYS-Befehl vorgelagert ist, kann es mit LOAD »name«,8 (,1 bei Kassette) geladen und mit RUN gestartet werden.)

(Claus Brunzema/rg)

# ProDat — Dateiverwaltung mit Raffinessen \[64-69\]

> Das Besondere an »ProDat« ist, daß man die Eingabemaske wie bei den teuren kommerziellen Programmen selbst definieren kann. Außerdem ist »ProDat« durch verschiedene Maschinenprogramme besonders schnell und einfach zu bedienen.

Wenn man das Listing vollständig und fehlerfrei eingetippt hat, darf man erst mal aufatmen. Elf KByte Basic sind schließlich kein Honiglecken. Im Bereich von $0334 (820) bis $03cf (1020) stehen verschiedene Maschinenprogramme. Da dies aber der Kassettenpuffer ist, läßt sich »ProDat« nicht ohne weiteres für Datasette verwenden.

Die Daten werden von Maschinenroutinen geladen und gespeichert. Auch das Kopieren der Bildschirmmaske deraktuel-len Datei in den Bildschirmspeicher geschieht in Maschinensprache. Da die INPUT-Routine des Betriebssystems geringfügig geändert wurde, bereitet bei der Maskenerstellung auch die Eingabe von Anführungszeichen, Doppelpunkten oder Kommata keinerlei Schwierigkeiten. Um bei der Verarbeitung der Daten der gefürchteten Garbage-Collection aus dem Weg zu gehen, wurde eine etwas geänderte Version des Stringver-tauschers von Boris Schneider aus der 64’er, Ausgabe 1/85 verwendet. FürInteressiertezeigtTabelle 1 einedokumentier-te Liste der wichtigsten im Programm verwendeten Variablen.

### Hinweise zum Abtippen:

Manche Zeilen haben Überlänge, das heißt, sie sind länger als die vom Basic-Interpreter erlaubten 80 Zeichen. Diese Zeilen können Sie nur mit den im Anhang D des Commodore-Handbuchs vermerkten Abkürzungen der Basic-Befehle eingeben. Das gilt zum Beispiel für die Zeile 360. Leerzeichen vor und nach den einzelnen Basic-Befehlen dienen nur der Übersichtlichkeit und können beim Eintippen ersatzlos weggelassen werden.

### Programmbeschreibung:
###Menü 1, Hauptmenü
**1**	— Aufruf Menü 2
**2**	— Neue Datei definieren

Zuerst muß die Eingabemaske definiert werden. Wie das aussehen kann, zeigt Bild 1. Sie können frei mit den Cursor-Tasten auf dem Bildschirm umherwandern und Ihr persönliches Eingabeformular erstellen. Dabei sind alle Tasten und Zeichen erlaubt. (VorsichtvorSHIFT-CLR!) Zahlen zum Beachten: Maximale Felderanzahl (in der Sprache der Dateiverwaltung wird jede Stelle in der Maske, an der Sie später eine Eingabe machen, als Feld bezeichnet): 1 500 pro Datei, 40 pro Datensatz (ein Datensatz ist eine mit Daten gefüllte Eingabemaske). Maximale Feldlänge: 80 Zeichen.

Wie das Beispiel Bild 1 zeigt, werden Felder mit Hochpfeilen markiert. Wird derabschließende Pfeil weggelassen, so nimmt das Programm hierfür die maximale Feldlänge von 80 Zeichen. Wird später bei der Eingabe der Schlußpfeil erreicht, so springt der Cursor automatisch zum nächsten Feld weiter. Die Pfeile selbst tauchen später nicht mit in der Eingabemaske auf (siehe Bild 2). Mit dem Pfeil nach links können Sie eine Datensatznummeranzeige programmieren. Das heißt, daß an dieser Stelle später die Nummer des Datensatzes innerhalb der Datei ausgedruckt wird. Weiterhin istwichtig, daß Sie die letzte Bildschirmzeile nichtverwenden dürfen. Ein Feld in dervorletzten Zeile darf also nur 40 Zeichen lang sein! Nachdem die Eingabemaske definiert ist, müssen noch die Druckparameter eingegeben werden (siehe nächster Menüpunkt).
**3**	— Druckparameter festlegen/ändern
Nun müssen Sie festlegen, welche Felder in welcher Reihenfolge später auf dem Drucker ausgedruckt werden sollen. Ein Feld wird mit der »eckigen Klammer auf« markiert (siehe Bild 3). Sie können natürlich auch erklärenden Text oder ähnliches ausdrucken lassen. Alles, was zwischen den »eckigen Klammern zu«steht, wird später im Breitschrift-Modus gedruckt. Durch Änderung der Zeilen 2 570 und 2 580 hat man auch andere Möglichkeiten, zum Beispiel Kursiv-Druck oder dergleichen. Es können maximal 60 Druckzeilen definiertwer-den. Zu beachten ist, daß ein angesprochenes Feld auch wirklich vorhanden ist, da dies nicht überprüft wird. Sie können ein Feld auch mehrmals ausgeben lassen, das liegt ganz bei Ihnen. Eine Druckzeile kann maximal 80 Zeichen fassen, wodurch beispielsweise auch kleinere Formbriefe möglich sind. 4 — Directory laden 5 — File löschen
**6**	— Validate
**7**	— Disk formatieren
**8**	— File umbenennen

Die Menüpunkte 4 bis 8 erklären sich von selbst, beziehungsweise sind im Floppy-Handbuch genauer erklärt.

### Menü 2, Datei verwalten
**1**	— Datei laden

Sollte eine erweiterte oder geänderte Datei noch im Speicher stehen, so wird sicherheitshalber erst gefragt, ob Sie nicht erst speichern möchten. Die vorhandene Datei wird sonst gelöscht.
**2**	— Datei pflegen/ändern/ergänzen

Nach Wahl dieses Punktes sind Sie zunächst im Anzeigemodus, der wie Bild 4 aussehen könnte. In diesem Modus sind einige Tasten mit Sonderfunktionen belegt. (Siehe Tabellen 2 und 3)
**3**	— Datei abspeichern
**4**	— Datei sortieren

Es besteht jetzt die Möglichkeit, entweder alphabetisch nach einem bestimmten Feld zu sortieren, oder man läßt sich bestimmte Daten heraussuchen, zum Beispiel alle Adressen eines bestimmten Postleitzahlbereichs. Die kann man auf dem Drucker ausgeben lassen, oder speichert sie gleich in einer neuen Datei ab.
**5**	— Alle angegebenen Felder der Datei können aufaddiert werden, zum Beispiel bei einer Haushaltsbuchhaltung alle Ausgaben für Essen, etc.
**6**	— Aufruf Menü 3

### Menü 3, Druckermenü

**1**	— Alle Datensätze mit den vorher definierten Druckparametern auf dem Drucker ausgeben.
**2**	— Gesamte Datei ausdrucken.
**3**	— Entspricht Punkt 1, aber nur in Verbindung mit der Sortierroutine.
**4**	— Entspricht Punkt 2, aber nur in Verbindung mit der Sortierroutine.

### Allgemeine Hinweise:

Sollte der Cursor einmal an einer Stelle stehenbleiben, und auch keine Taste mehr annehmen, so ist das kein Grund zur Panik. Der Computer braucht ab einer gewissen Datenmenge einfach Zeit, um das Eingegebene sinnvoll im Speicher unterzubringen. Wenn Sie »ProDat« als Textverarbeitungsprogramm verwenden wollen, so definieren Sie die Eingabefelder einfach über den gesamten Bildschirm und lassen die Datensatz-Nummeranzeige als zum Beispiel Seitennummer des Textes arbeiten.

(Wolfgang Hahn/tr)

# Schnell kopiert mit Hypra-Copy \[69-71\]

> Hypra-Copy ist ein schnelles und komfortables Filecopy-Programm für den C 64. Das Kopieren wird um das Vierbis Fünffache beschleunigt.

Trotz deraufwendigen Lade- und Speicherroutinen ist es gelungen, das Programm insgesamt recht kurz zu halten; Hypra-Copy belegt, gespeichert auf der Diskette, nur ganze 15 Blöcke. Somit ist der verfügbare Arbeitsspeicher sehr groß: Hypra-Copy kann sich bis zu 30 Filenamen »merken«, und in einem Ladegang können maximal 232 Blöcke eingelesen werden. Hat man das Programm (siehe Listing) mit dem MSE abgetippt und gespeichert, kann es später ganz normal mit »LOAD ”HYPRA-COPY”,8« geladen und mit »RUN« gestartet werden.
Es erscheint dann das Hauptmenü:
**HYPRA-COPY**
:C: Copy Files
:S: Scratch Files
:D: Directory
:O: Order Disk

Die Bedienung ergibt sich damit eigentlich schon von selbst. Drückt man die Taste »O«, erscheint auf dem Bildschirm eine eckige Klammer mit einem blinkenden Cursor dahinter.

Nun kann man den Befehl eingeben, der zur Floppy geschickt werden soll. Reagiert die Floppy mit einer Fehlermeldung, so wird diese auf dem Bildschirm ausgegeben.

Bei Betätigung der Taste »D« erscheint das Directory. Der Ausdruck kann durch die CTRL-Taste angehalten werden. Durch Drücken der »S«-Taste gelangt man in den Scratch-Modus (löschen von Files). Um Verwechslungen mit dem Copy-Modus auszuschließen, wird erst einmal mit einer dicken, reversen Balkenüberschrift darauf aufmerksam gemacht, daß man sich tatsächlich im Scratch-Modus befindet. Danach erscheintdas Directory, jedoch erscheinthinterjedem Filenamen ein »(Y/N)«; relative Files sowie Files, deren Länge gleich 0 oder größer als 232 Blöcke ist, werden bei dieser Befragung übergangen, denn diese Routine wird auch beim Kopieren gebraucht und Files mit diesen Eigenschaften kann Hypra-Copy nicht kopieren.

Files, die sich Hypra-Copy merken soll, müssen mit »Y« markiert werden. Ist man versehentlich im Scratch-Modus gelandet, so kann man diesen Modus mit der STOP-Taste verlassen (ansonsten dient die STOP-Taste dazu, Hypra-Copy zu beenden; man kann es dann aber wieder mit »RUN« starten).

So werden nach und nach alle Files der Directory durchgegangen. Will man nur einige wenige Files am Anfang einer ellenlangen Directory löschen (oder kopieren), so braucht man die restlichen Files nicht mehr mit »N« zu bearbeiten, es genügt ein Druck auf die »t «Taste, und man gelangt zum Ende des Directory. Hier wird dann gefragt, ob man nun auch sicher ist, daß diese Files gelöscht werden sollen. Beantwortet man diese Frage mit »N«, gelangt man zurück in das Hauptmenü, andernfalls werden die markierten Files gelöscht.

Damit man weiß, wie weit das Programm mit dem Löschen ist, wird immer der Name des Files ausgegeben, das gerade gelöscht wird. Am Ende des Löschvorgangs gelangt man automatisch wieder in das Hauptmenü.

## Der Copy-Modus

So, nun zum Copy-Modus, in den man mit der »C«-Taste kommt. Zuerst werden wieder, genau wie beim Löschen, die Namen der zu kopierenden Files eingelesen.

Danach wird gefragt, ob man die Files einzeln oder gesammelt kopieren will und ob beim Speichern ein »VERIFY« durchgeführt werden soll. Verzichtet man auf dieses Verify, so wird etwas schneller kopiert. Um den Bedienungskomfort zu erhöhen, werden die Antworten auf diese Fragen, wie auch auf die »SURE?«-Frage (sure = Sind Sie sicher?) im Scratch-Modus und die »SAVE BUFFER AGAIN?«-Frage (Soll das gleiche noch einmal gespeichert werden?), nicht per GET ($ffe4), sondern per BASIN ($ffcf) eingelesen, wobei die wohl gebräuchlichere Antwort schon vorgegeben ist; man braucht also nur noch RETURN drücken; natürlich kann diese vorgegebene Antwort aber auch überschrieben werden.

Nun werden die Programme geladen. Ist die Summe der Blöcke der einzelnen Files kleiner als 233, können sogar alle auf einmal eingelesen werden; andernfalls wird ein erneuter Ladeanlauf nötig.

Sind die Files geladen, wird man aufgefordert, die Ziel-Disk einzulegen; außerdem wird noch die Anzahl der zu speichernden Blocks angegeben, und ein Untermenü erscheint.

Es besteht jetzt noch die Möglichkeit, diverse Directories anzusehen oder Befehle zur Floppy zu schicken.

Man kann also in aller Ruhe eine passende Diskette aussuchen. Ist man gewillt fortzufahren, so drückt man einfach die Funktionstaste F7, dann beginnt nämlich das Speichern. Anschließend wird man gefragt, ob man eben diese Files noch einmal auf eine andere Diskette schreiben will. Beantwortet man diese Frage mit »Y«, beginnt der komplette SAVE-Vorgang von neuem. Andernfalls wird normal fortgefahren und, wie schon erwähnt, können erneute Ladeanläufe erforderlich werden.

Wurden alle Files kopiert, so wird in das Hauptmenü zurückgekehrt.

Nun zur Fehlerbehandlung: Mit »Fehlern« sind nicht Fehler gemeint, die in der Programmstruktur von Hypra-Copy liegen, sondern Fehler, die von der Floppy signalisiert werden; sei es, daß man einen unkorrekten Befehl an die Floppy schickt, man beim Kopieren die falsche Diskette einlegt oder Write- oder Read-Errors auftreten.

## Erste Hilfe bei Fehlern

ln solchen oder ähnlichen Fällen besteht immer die Möglichkeit, den Vorgang, bei dem der Fehler aufgetreten ist, zu wiederholen beziehungsweise zu übergehen. Treten Fehler beim Öffnen eines Files auf, so kann man sogar nochmals Directories ansehen und Befehle an die Floppy schicken. War es nicht möglich, ein File korrekt zu laden und wurde es übergangen, so wird dies bei der Angabe der zu speichernden Blöcke, wie auch beim Speichern selbst, berücksichtigt. Können Files aus irgendeinem Grund nicht korrekt gespeichert werden, so kann man diese auch überspringen.

(Burkhard Graves/ev)

# Programme leichter laden \[72-73\]

> Dieses Programm vereinfacht das Laden von Programmen durch direkte Auswahl aus dem Directory.

Programme werden häufig nach dem Listen des Directorys durch Voranstellen eines »LOAD« und Ergänzung durch ”,8:“ oder ”8,1“ geladen. Oftmals vergißt man dabei allerdings das Eintippen des Doppelpunktes oder man macht andere kleine Fehler, worauf sich der Computer mit einem »SYNTAX ER-ROR« meldet.

Mit »Directory-Lader« (Listing) kann das Directory einer Diskette nun so manipuliert werden, daß wahlweise ein »,8:« oder ein »,8,1« an den Filenamen angehängt wird. Das vereinfacht den Ladevorgang um einiges: Nur noch das Directory listen, mit dem Cursor in die gewünschte Zeile fahren, »LOAD« eingeben und schon geht’s los.

## So funktioniert der »Directory-Lader«

Jedes Programm auf einer Diskette ist in einem Directoryblock verzeichnet. Dort belegt der Name des Programmes 16 Byte. Ist der Name kürzer als 16 Byte, wird er durch ein »SHIFT Space« (CHR$ 160) ergänzt. Dadurch wird auch das Ende eines Namens vom DOS erkannt.

Beim Listen des Directorys werden nun alle 16 Byte des Namens auf dem Bildschirm angezeigt. Das zu lösende Problem besteht also darin, den gewünschten Zusatz ebenfalls hinter dem Programm anzuzeigen.

Dazu wird zuerst der erste Block des Directorys eingelesen. Der Bufferpointer wird auf den ersten Namen des Blocks gesetzt und der Name ausgelesen. Hierbei werden alle 16 Byte des Namens verwendet. Durch Betätigen entsprechender Tasten wird nun der Name wie folgt bearbeitet:
@ Löschen des Zusatzes
↑ Überspringen des Namens ohne Änderung
**M** Schreiben des Zusatzes»,8,1«
**B** Schreiben des Zusatzes »,8:«

Beim Schreiben des Zusatzes wird der Name des Programms von hinten durch den Zusatz ergänzt. Dabei werden Programmnamen, die längerals 11 Zeichen bei Maschinenprogrammen oder länger als 12 Zeichen bei Basic-Programmen sind, entsprechend verkürzt.

In dieser Weise werden sämtliche Namen eines Directory-Blocks bearbeitet.

Da der Bufferpointer jedesmal weitergesetzt wird, kann es vorkommen, daß auch bereits gelöschte Programme bearbeitet werden. Das hat jedoch keinen weiteren Einfluß.

Nach der Bearbeitung eines Blocks wird dieser zurückgeschrieben, und das Programm fährt mit dem nächsten Block fort.

Tabelle 1 zeigt die verwendeten Variablen, Tabelle 2 die einzelnen Routinen des Programms.

Während der Bearbeitung wird ständig der nächste zu bearbeitende Block angezeigt. Erscheinen die Werte 0 und 255, so ist der letzte Block erreicht. Man hatjetzt eine Diskette mit modifiziertem Directory und damit einfach zu ladenden Programmen vorliegen (Bild 1).

(Holger Weihe/ev)

# Disk-Füller \[74-75\]

> Ab und zu passiert es, daß auf einer Diskette nur ein paar Blöcke fehlen. Mit dem Disk-Füller können in Notfällen bis zu 17 zusätzliche Blöcke auf der Diskette genutzt werden.

Das Problem ist wohl jedem bekannt, der eine gut sortierte Programmsammlung hat: alle thematisch gleichen Programme bis auf eines passen auf eine Diskettenseite. Und gerade dieses letzte Programm benötigt nur einige wenige Blöcke. Aber hier kann in Notfällen Abhilfe geschaffen werden. Auf der Spur 18, auf der sich unter anderem das Directory befindet, sind meist noch ein paar Blöcke frei, die das DOS der 1541 aber nicht zur Verfügung stellt. Mit dem Programm Disk-Füller können diese freien Blöcke ausgenutzt werden. Zu diesem Zweck werden Blöcke von schon auf der Diskette befindlichen Programmen auf die freien Blöcke der Spur 18 umkopiert und die Blockzeiger angepaßt. Die ursprünglichen Programmblöcke stehen dann zur freien Verfügung.

Das Programm ist weitgehend selbsterklärend, hier aber einige wichtige Hinweise: Nach dem Laden darf das Programm erst mit »RUN« gestartet werden, wenn die zu behandelnde Diskette im Laufwerk liegt. Außerdem dürfen nur Disketten behandelt werden, deren BAM einwandfrei in Ordnung ist. Im Zweifelsfalle sollte vorher ein Validate mit »OPEN 15,8,15,”V”« durchgeführt werden.

Hier ist die genaue Funktionsweise des Programms beschrieben:

Nach einer kurzen Erläuterung für den Benutzer werden in den Zeilen 1050 und 1060 (Listing) zwei Kanäle zum Laufwerk geöffnet. Gleichzeitig wird die eingelegte Diskette initialisiert. In Zeile 2000 werden drei Variablenfelder dimensioniert. Sie dienen zum Ablegen der Zeiger auf den jeweils nächsten Directoryblock sowie der Anzahl der Einträge in diesem Block. Mit Zeile 2010 beginnt dann eine Schleife, die alle Directory-Blöcke verfolgt, ihre Lage auf der Diskette in den dimensionierten Feldern speichert und ihre Anzahl in der Variablen B festhält. Ab Zeile 2500 wird die Anzahl der freien Einträge im letzten Directory-Block bestimmt. Dazu wird jeweils das Filetyp-Byte abgefragt. Hat es den Wert Null, ist dieser Eintrag noch frei. Sollte der Benutzer die Frage, ob der angezeigte Platz genügt, negativ beantworten, wird ein Block für weitere acht Einträge freigehalten.

Als nächstes wird überprüft, welche Blöcke der Spur 18 noch frei sind. Dazu werden die entsprechenden Bytes der BAM in den Computerspeicher geholt und analysiert (Zeile 3120 bis 3230).

In Zeile 4000 beginnt das Verschieben schon belegter Blöcke in die Spur 18. Dazu werden in einer großen Schleife (bis Zeile 4680) alle Directory-Einträge abgearbeitet. Dies geschieht folgendermaßen: Der Zeiger auf den ersten Block des ersten Eintrags wird in den Variablen AS und AT zwischengespeichert, der zugehörige Block eingelesen und der Zeiger auf den Fortsetzungsblock ebenfalls gespeichert. Dann wird ein freier Block der Spur 18 gesucht und der alte Zeiger auf diesen umgelenkt. Der Computer gibt nun eine Protokollzeile aus. Dieser Block wird nun als belegt und der alte als frei gekennzeichnet. Als letztes wird endlich der Inhalt des zu verschiebenden Blocks auf den Block der Spur 18 geschrieben. Sollte nach dem ersten Eintrag immer noch Platz auf der Spur 18 sein, fährt das Programm mit dem zweiten Eintrag fort, bis die Spur 18 komplett belegt ist.

(U. Gerlach/bs)

# Schreibschutz per Software \[75-76\]

> Eleganter als das Hantieren mit Klebestreifen ist ein Disketten^chreib-schutz per Software: Hier ist ein Programm, das einen solchen Schreibschutz nicht nur anbringen, sondern ihn auch wieder entfernen kann.

Die Funktion dieses Programms basiert darauf, das Format-kennzeichen (»A«) auf der Diskette zu ändern (hier in »X«). Versucht man nun, Daten auf die Diskette zu schreiben, so reagiert das Floppy-Laufwerk mit der Fehlermeldung »CBM DOS V2.6 1541«. Das Lesen istjedoch weiterhin problemlos möglich. Damit erspart man sich die zuweilen umständliche Verwendung von Schreibschutz-Aufklebern auf der Diskette. Außerdem ist dieser softwaremäßig realisierte Schreibschutz um einiges sicherer, denn er kann nicht durch Leichtsinn oder Versehen entfernt werden.

Eine Schwierigkeit ergibt sich aber, wenn das neue Fbrmat-kennzeichen wieder in »A« geändert werden soll, um zum Beispiel noch ein Programm auf der Diskette zu speichern. Da ja jegliches Schreiben unmöglich ist, hat man selbst mit den Direktzugriffs-Befehlen keine Möglichkeit mehr, wieder ein »A« auf die Diskette zu bringen.

Hier liegt nun die eigentliche Neuheit dieses Programms. Mit einem Memory-Write-Befehl (Listing) wird in die Speicherstelle 257 ($0101) der Floppy der ASCII-Code von »A« (65) geschrieben. In dieser Speicherstelle wird bei jedem Initialisieren einer Diskette deren Fbrmatkennzeichen im ASCII-Fbrmat abgelegt. Ist nun dieser Inhalt gleich 65, so schreibt die Floppy wieder ohne Probleme auf die Diskette, und genau dies wird in dem Programm ausgenutzt.

Nun einige Bemerkungen zur Bedienung des Programms: Nach dem Starten mit »RUN« wird das Formatkennzeichen der Diskette eingelesen und ausgedruckt. Daraufhin gibt man das Format-Zeichen ein, das die Diskette erhalten soll. Drückt man nur RETURN, so wird das vorgegebene Zeichen übernommen und es kommt immer zu einer Änderung des Fbrmatkennzei-chens. Zum Schluß wird dann deraktuelle Zustand der Diskette angezeigt.

Achtung! Unmittelbar nach dem Programmlauf ist der Schreibschutz nicht aktiv, da in der Speicherstelle 257 noch immer 65 steht. Erst nach dem Initialisieren einer geschützten Diskette ist dieser Schutz auch wirksam. Auch gegen versehentliches Formatieren, bei dem ja alle Programme gelöscht werden, schütztdieses Programm nicht, da bei diesem Befehl logischerweise kein Formatkennzeichen gelesen wird.

In allen anderen Fällen ist der Schutzjedoch voll wirksam und macht Schreibschutz-Etiketten überflüssig.

(Manfred Lins/ev)

# Disk-Tester \[76-77\]

> Mit diesem Programm lassen sich Disketten schneller, komfortabler und schonender auf defekte Sektoren untersuchen, als das mit dem entsprechenden Programm auf der Test/De-modiskette der Fall ist.

Das Programm ist insbesondere bei Verwendung älterer Disketten oder bei Nutzung der Disketten-Rückseite zu empfehlen. Es überprüft in knapp 10 Minuten die gesamte Diskette auf schadhafte Stellen und markiert die eventuell gefundenen unbrauchbaren Sektoren als belegt, so daß sie von der 1541 nicht mehr zur Datenspeicherung verwendet werden. So ist es möglich, auch teilweise beschädigte Disketten noch zur Datenspeicherung heranzuziehen, ohne daß es zu WRITE- oder READ-ERRORS kommt.

### Programmbeschreibung:

Nach dem Starten des Programms (siehe Listing) muß man entscheiden, ob man nur die vollen Blocks (durch Lesen) oder alle Blocks (durch Lesen und Beschreiben) testen will, oder ob man die schon bei vorherigen Tests als fehlerhaft erkannten Blocks nach einem VALIDATE wieder belegen will. Danach wird gefragt, ob der Befehl »VALIDATE« an die Floppy gesendet werden soll. Dies ist nur bei Disketten sinnvoll, auf denen die Daten öfters geändert werden und die keine relativen Dateien, ISAM-Dateien oder ähnliche, im Direktzugriff arbeitenden Speicherformate, enthalten. Bei Disketten mit den oben genannten Dateien, von denen man nicht sicher weiß, ob die beschriebenen Blöcke auch in der BAM (Block Availability Map, Sektorbelegungstabelle) als belegt gekennzeichnetsind, sollte die Option »Leere Blocks testen« auf keinen Fall angewandt werden, da sonst Daten verlorengehen können.

Es folgt nach kurzer Lese- und Decodierzeit die symbolische Belegung der Diskette auf dem Bildschirm, auf der die belegten Sektoren als »-« und die nicht belegten als »*« gekennzeichnet sind. Wie kommt es dazu? Nun, jede Spur belegt in der BAM (Spur 18, Block 0, Positionen 4-143) 4 Byte. Zuerst kommt die Anzahl der freien Blöcke auf der Spur, im Programm bezeichnet mit FR$. Dann kommt nacheinander die Belegung der Sektoren 7-0, 15-8 und 23-16. Ein 1-Bit kennzeichnet dabei einen freien Block, ein O-Bit einen besetzten. Dies wird nun in der Routine »Analysieren der BAM«aufgelöst und in B%(T,S) festgehalten, wobei T die Spur und S den Sektor enthält. Die darauffolgende Testroutine beschränkt sich jetzt nur darauf, die Spuren und Sektoren einzeln durchzuzählen und in Abhängigkeit von B%(T,S) und der Variable TS (0, wenn alle, 1, wenn nur volle Blocks getestet werden sollen) entweder den Block zu lesen, oder ihn mit dem einmal aufgefüllten Puffer zu beschreiben. Danach wird der Fehlerkanal auf die Fehlernummer abgefragt, da dies schneller geht, als immer die ganze Fehlermeldung zu holen. Tritt ein Fehler auf, so wird dieser angezeigt und auf dem Monitor als roter Punkt in der BAM markiert. Gleichzeitig wird die Variable FE erhöht. Tritt kein Fehlerauf, so wird die Kennzeichnung für den gerade getesteten Block auf dem Monitor gelöscht. Sind alle Blocks getestet, werden die eventuell vorhandenen defekten Blocks auf der Diskette belegt und in dem Format »Spur,chr$(13),Block,chr$(13)« in dem USR-File ».DISKFEHLER« gespeichert. Das erste Byte entspricht in diesem Fall der Anzahl aller gefundenen Fehler.

Die Routine »Kaputte Blocks belegen« hat nun nichts weiter zu tun, als dieses File zu lesen und die Blocks zu belegen.

## Änderungen für andere Computer

Für einen der »großen« CBMs muß die Zeile 135 und sämtliche POKEs in den Zeilen 150 und 470 gelöscht werden, da sie keine Farbdarstellungen besitzen. Die Zeile 140 muß so geändert werden:
140 BI=32768

Für einen VC 20 mit 40-Zeichen-Bildschirm müssen nur die farbgebenden POKEs in Zeile 150, die Strings in Zeile 135 und die Variablen in Zeile 140 angepaßt werden. Für die Besitzer eines VC 20 mit 22-Zeichen-Bildschirm sind größere Änderungen erforderlich, da die BAM nicht angezeigt werden kann und sie sich somit mit einer numerischen Darstellung des Testablaufs zufrieden geben müssen. Es werden die freien und die belegten Blocks sowie der zuletzt getestete Sektor angezeigt. Die Zeilen 140, 470 und 635 ff. müssen vollständig gelöscht werden. Folgende Zeilen müssen geändert werden:
355 PRINTL$T$" BESETZTE BLOCKS:" O$683-FR:-PRINTT$" FREIE BLOCKS": "O$FR;D$D$
450 INPUT#15,F:IFF<20GOT0480
480 PRINTG$" T: " T;Z$"S;Z$" "U

Zehn Minuten für das Überprüfen einer Diskette mögen zwar immer noch recht lang anmuten, wenn man jedoch bedenkt, wieviel Ärger (READ-ERROR, WRITE-ERROR) ein fehlerhafter Sektor verursachen kann, dann rentiert es sich bestimmt, diese Zeit zu investieren.

(Ulrich Langler/ev)

# Betriebssystem selbst gemacht \[78-80\]

> Ein eigenes Betriebssystem zu schreiben, ist nicht jedermanns Sache. Aber warum soll man nicht das vorhandene für sich abändern?

Wie schön wäre es doch, sein eigenes, kleines Betriebssystem für den C 64 zu schreiben. Doch gewiß ist das nicht gerade jedermanns Sache. Daraus könnte sich schnell ein »Fulltime-Job« mit Beschäftigung bis ins hohe Rentenalter entwickeln. Es liegt viel näher, das vorhandene Betriebssystem einfach so lange abzuändern, bis ein eigenes, den Bedürfnissen angepaßtes Kernal entsteht. Beste Beispiele sind das Hypra-Kernal und Hypra-Perfekt (64’er, Ausgaben 12/84, 1/85 und 4/85). Bestimmt hat so mancher inzwischen schon eine kleine Kernal-Sammlung auf Diskette oder EPROM.

Ganz interessant wäre es dann, auf einfache Weise diese Systeme weiter abzuändern. Ihnen beispielsweise einen deutschen Basic-Interpreter zu verpassen, mit deutschen System-und Fehlermeldungen.

Gesagt, getan: Vorliegendes Programm erledigt dies alles. Es ist abgestimmt auf die Kernal-Version aus der 64’er-Ausgabe 1/85 sowie auf das Hypra-Perfekt-Kernal aus Ausgabe 4/85, arbeitet jedoch auch mit vielen anderen Betriebssystemen. Probieren geht hier über Studieren.

Im Gegensatz zu den oben genannten EPROM-Versionen, erzeugt dieses Programm ein lauf- und damit testfähiges Betriebssystem im freien RAM-Bereich unter dem Kernal-ROM ab $E000. Nichtjeder wird wohl gleich ein EPROM programmieren, sondern lieber zuerst etwas experimentieren wollen. Zuerst werden Basic und Kernal ins RAM kopiert (lnit-Routine ab 190). Erstdann kann geändert werden. Das Programm (siehe Listing) erlaubt auch (falls vorhanden) ein Betriebssystem von Diskette zu laden (Zeile 23, siehe Tabelle 1 und 2). Danach kann die Farbkombination beim Warm- und Kaltstart ausgetestet werden. Der SYS-Befehl in Zeile 201 löst einen Reset des Bildschirms innerhalb der geänderten Kernalroutine aus, so daß die Kombination sofort beurteilt werden kann. Erst nach Bestätigen verzweigt das Programm nach Zeile 213. Dort kann eine OLD-Routine aktiviert werden. Beginn ist ab Adresse 64608. Dies gilt es zu beachten, wenn ein Kernal abgeändert werden soll, das eventuell diesen Bereich benutzt. Es handelt sich dabei um einen Teil der normalerweise überschriebenen Kassettenroutinen des Betriebssystems. Hat man ein Betriebssystem geladen, das mit der OLD-Routine kollidiert, muß letztere verschoben werden.

Die genannten Hypra-Kernal sind diesbezüglich unkritisch. Beachtet werden muß lediglich, daß sich deren Adressen für Funktionstasten-Belegung unterscheiden. Soll OLD also auch auf Funktionstaste gelegt werden, fragt das Programm selbst nach der verwendeten Version (Zeile 218). Bei anderen Kernal-Versionen kommt es auf das berühmte Experiment an. Betriebssysteme ohne eine Belegung der Funktionstasten können selbstverständlich auch nicht den OLD-Befehl per Funktionstaste unterstützen. Es fehlen ganz einfach die nötigen Routinen (siehe Original Kernal V2.0)!

Hier bleibt ja immer noch der SYS-Befehl zum Aufruf von OLD, den man sich eben merken muß. Für ganz zerstreute Freaks ist die nachfolgende Routine am idealsten. OLD als gewöhnlicher Basic-Direktbefehl (also auch abkürzbar mit »O SHIFT L«): Zeile 224 sorgt für die entsprechende Programmierung. Da hier, wie nachher auch bei den Fehlermeldungen in deutscher Sprache, das Basic mitverändert wird, muß natürlich auch das Basic-ROM (beziehungsweise -RAM) abgespeichert werden. Wie, das wird zum Schluß erklärt.

Wurden alle Eingaben gemacht, startet das Programm die Initialisierungs-Routine, die Kernal und Basic mit deutschen System- und Fehlermeldungen versieht. Zu guter Letzt wird das neue Betriebssystem aktiviert (Zeile 133). Jetzt können ruhig mal alle Neuheiten durchgespielt werden. Gar nicht so einfach, alle Fehler-Meldungen zu »provozieren«.

Und dabei gibt es immer noch Programmierer, die sich bei Meldungen wie »Syntax Error« die Haare raufen. Aufjeden Fall: einen »Syntax Error« wird es für jene jetzt wohl kaum mehr geben.

Jetzt noch kurz zu den Änderungen gegenüber den EPROM-Versionen. Um ein EPROM zu brennen, muß das Programm in einem Bereich liegen, auf den das EPROM-Pro-grammiergerät zugreifen kann. Daher liegen die Hypra-Kernal ab $6 000 im Speicher. Die Adressen bleiben unkorrigiert, so daß als EPROM ein lauffähiges Betriebssystem im Originalbereich ab $E000 entsteht. Ausgetestet werden kann aber nur, wenn das Betriebssystem wieder an seinen Ursprung verschoben wird. Das kann am komfortabelsten mit einem Monitorprogramm durchgeführt werden.

Ohne Monitor muß mit einer Basic-PEEK/POKE-Schleife der Speicherbereich $6000 bis $7FFF auf die Adressen ab $E000 verschoben werden:
forx=24576to49151:fory=57344to65535
pokey,peek(x):nexty:nextx

Zuvor muß sichergestellt sein, daß das RAM unter dem ROM ab $E000 aktiviert wurde (wie durch die Routine ab Zeile 193). Am besten, man speichert sich diese Basic-Routine separat als Programm, da sie beim Einlesen eines Betriebssystems immer wieder benötigt wird. Aus Zeitgründen wäre eine solche Routine in Maschinen-Code auch nicht zu verachten.

Der verschobene Speicherbereich muß nun lediglich noch auf Disk abgespeichert werden. Ohne Monitor kann dazu zum Beispiel das kleine Programm im 64’er, Ausgabe 2/85, Seite 91 verwendet werden.

Mit einem Maschinensprache-Monitor geht’s einfacher:
Verschieben: .T6000,7FFF,E000-
Save Kernal: .S »K-Name«,08,E000,FFFF
Save Basic: .S »B-Name«,08,A000,BFFF

Beim SMON hat der Verschiebe-Befehl den Buchstaben »W«, und Komma, Minuszeichen und Geräteadresse entfallen.

Übrigens kann auch das ROM ins RAM mittels Monitor kopiert werden. Die Befehle dazu lauten
Kernal:TE000, FFFF, E000-Basic:TA000,BFFF,A000- (danach POKE 1,53).

Auf der Diskette hat man jetzt ein Betriebssystem, das nur mehr vom Programm nachgeladen zu werden braucht. Es kann aber auch schon vorher ein Betriebssystem im RAM aktiv sein. Das Bearbeitungsprogramm erkennt automatisch, ob das Original oder ein neues Kernal aktiv ist (Adresse 1 gleich 55 oder 53, Zeile 100/101)! Andernfalls wird immer das Original-Betriebssystem bearbeitet.

Grundsätzlich muß vor jedem Laden einer Kernal- oder Basic-Version von ROM auf RAM umgePOKEt werden.

Arbeiten mit dem neuen Betriebssystem:

1.	ROM auf RAM umPOKEn
2.	Zeropage-Adresse 1 mit POKE 1,53 umschalten
3.	Kernal laden mit »LOAD ”Name”,8,1«
4.	Basic laden mit »LOAD ”Name”,8,1«

Zur Kontrolle, daß tatsächlich das neue System läuft, kann mit SYS 58648, SYS 58260 in den Warmstart gesprungen werden. Ein SYS 64738 schaltet immer auf das Original-ROM zurück und sollte vermieden werden. Falls er doch einmal ausgelöst wird (zum Beispiel Run-Stop/Restore), kann mit POKE 1,53 jederzeit wieder ins RAM geschaltet werden.

Da das Bearbeitungsprogramm auch das Basic-ROM ändert, muß auch immer Basic von Disk geladen werden. Andernfalls hat man englische Fehlermeldungen und OLD nur als SYS-Befehl.

Zum Abschluß muß noch erwähnt werden, daß der OLD-Befehl den Basic-Befehl END eliminiert. Bei Fremdprogrammen sollte im Hinblick auf Syntax-Fehler daran gedacht werden. Eine Verlängerung der Basic-Befehlsliste ist aus Platzgründen in dieser Programmversion nicht realisiert worden.

(Richard Diezmann/rg)

# Mehr Platz auf der Diskette durch »File-Compactor« \[80-81\]

> Die Zeit, in der man aus Platzgründen nur ein oder zwei Programme auf einer Diskette unterbringen kann, ist vorbei. Mit diesem neuartigen File-Compactor sind Sie in der Lage, nicht nur Grafiken, sondern sogar beliebige Programme um bis zu 55 Prozent zu kürzen.

Das Problem, Programme zu packen, um so Platz auf Disket-tenzusparen, istmiteinem einfachen File-Compactor, dersich darauf beschränkt, Folgen gleicher Bytes zu erkennen und zu vereinfachen, noch langenichtbeseitigt EinsolcherCompac-tor (zum Beispiel der File-Compactor aus dem 64’er, Ausgabe 7/85) kann mit Maschinensprache-Routinen wenig anfangen, da dort selten mehr als zweimal das gleiche Byte hintereinander vorkommt. Ein guter Programm-Compactor muß daher anders arbeiten.

## Ein neuartiges Computerverfahren

Hier ist nun ein Compactor, der sich die geringe Unordnung in Programmen zunutze macht. Dadurch wird wirklich jedes Programm (miteiner Längevon mindestens 25 Blocks) erheblich gekürzt. Es gibt praktisch kein Programm, in dem die verschiedenen Zeichen gleich häufig vorkommen. In Basic-Pro-grammen wird das besonders deutlich, weil dort Leerzeichen, Doppelpunkte, das $OO-Byte oder auch einzelne Buchstaben (wie zum Beispiel das »e«) besonders oftzu finden sind. Es gibt aber auch Zeichen, die in einem Programm nur ganz selten oder überhaupt nicht vorkommen. Diese Tatsache kann man sich zunutze machen, indem man beispielsweise für häufig vorkommende Zeichen, einen 3 Bit langen Code definiert. Jeder kann sich vorstellen, was das für eine Platzersparnis mit sich bringt. Je mehr in dem Programm einige wenige Zeichen dominieren, desto geringer ist der durchschnittliche Informationswert und desto stärker läßt es sich kürzen. Natürlich müssen dabei für die weniger oft vorkommenden Zeichen längere Codes (mit einer Länge von 8 Bit und länger) definiert werden, damit die Codierung eindeutig bleibt.

Zusätzlich wurde in diesem Compactor das Verfahren aus Ausgabe 7/85 (Zählen gleicher Bytefolgen) angewandt, da es besonders bei Spielen mit viel Grafik sehr effizient arbeitet.

Däs Programm, das gekürzt werden soll, muß ab dem Basic-Start (Adresse $0801) in den Speicher geladen werden (also laden mit »LOAD"Name",8«) und darf nicht längerals 48639 Bytes sein. Nach dem Kürzen steht eine SYS-Zeile am Anfang, die den Entpacker startet. Dieser wandelt den komprimierten Code wieder in ein lesbares Programm. Auch Basic-Programme können auf diese Weise von dem Computer bearbeitet werden. Mit »RUN« wird dann zuerst der Entpacker gestartet, der dann nach abgeschlossener Umwandlung das eigentliche Basic-Programm ausführt.

## Beispiele zur Benutzung

Das Spiel »Fort Apocalypse«, das gerne als Maßstab für die Güte eines Compactors herangezogen wird, belegt normalerweise 153 Blocks auf der Diskette. Nach der Behandlung schrumpft der Platzbedarf auf 74 Blocks. Doch vor allem bei Basic-Programmen zeigt sich die Stärke des Packers: Sie schrumpfen im Schnitt um zirka 20 Prozent, auch wenn sie überhaupt keine Folgen gleicher Bytes enthalten.

1.	Eingabe des Listings »File-Compactor« mit dem MSE.
2.	Den Verdichter mit »LOAD".. ",8« laden und mit »RUN« starten. Der Verschiebelader befördert die Routine automatisch in den richtigen Speicherbereich.
3.	Jetzt kann man das zu kürzende Programm nachladen.
4.	Den Compactor mit »SYS 51000« aufrufen. Nach getaner Arbeit zeigt er den Grad der Verdichtung (in Prozent) an.
5.	Sofern man der Meinung ist, daß sich der Aufwand lohnt, kann man das Programm danach wieder mit »SAVE".." ,8« abspeichern.

## Modifizierte SAVE-Routine

Wenn Programme gekürzt werden sollen, die nicht in den Basic-Speicher passen und sich bis unter das ROM erstrecken, dann gibt es allerdings Probleme mit dem Abspeichern. Für diesen Fall wurde eine modifizierte SAVE-Routine implementiert. Statt »SAVE ".." ,8« gibt man in diesem Fall »SYS 50965 ".."« ein; die Geräteadresse 8 wird in diesem Fall automatisch gesetzt.

(Arndt Brenschede/ev)

# Bildschirm-Effekte leicht-gemacht \[82\]

> Mit dieser BasioErweiterung können Sie in beliebigen Bildschirmausschnitten Spezialeffekte wie Blinken, Invertieren oder Auffüllen mit beliebigen Zeichen einfach erzeugen.

Diese kleine Maschinensprache-Routine (»Screen«) kann in nahezu allen Programmen Verwendung finden, um zum Beispiel fehlerhafte Eingaben durch Blinken zu markieren oder um Eingabefelder zu löschen. Auch für die Gestaltung von Titelbildern bietet sich »Screen« an. Folgende Routinen sind vorhanden:
(0) Invertieren des gewählten Bereichs
(1)	Reversdarstellung eines Bildschirm-Bereichs
(2)	Normaldarstellung (Gegenstück zu (1))
(3)	Auffüllen eines Bereichs mit beliebigen Zeichen

Das Programm (Listing 1 und 2) kann auf zwei verschiedene Arten aufgerufen werden. Entweder starten Sie es mit »SYS (Anfangsadresse+36)« oder Sie benutzen statt dessen das Ausrufezeichen »!«. Der erste Weg bietet sich an, wenn schon eine andere Befehlserweiterung das »I« benutzt. Die korrekte Syntax des »!«-Befehls entnehmen Sie bitte Tabelle 1.

Das Programm ist frei im Speicher verschiebbar; die beiden notwendigen Vektoren für die Befehlserweiterung werden in Zeile 195-200 automatisch angepaßt. Möchte man lieber mit dem SYS-Befehl arbeiten, dann können die Zeilen 165-225 ersatzlos entfallen, in diesem Fall findet das Programm auch im Kassettenpuffer Platz. Tabelle 2 zeigt die Belegung der Zero-Page durch das Programm.

Zu bemerken ist noch, daß das Programm aus Platzgründen nicht auf ungültige Zeichen oder Spaltenwerte testet. In Ihren Programmen müssen Sie daher darauf achten, daß der Bildschirmbereich eingehalten wird, da sich sonst Probleme ergeben können. Das Demonstrationsprogramm in Listing 2 sieht zwar unscheinbar aus, erzeugt aber überraschende Effekte.

(Stefan Wagner/ev)

# Aus eins mach zwei \[84-85\]

> Mit dieser kleinen Routine »verdoppeln« Sie Ihren Computer. Sie sind damit in der Lage, zwei Maschinenprogramme praktisch gleichzeitig laufen zu lassen.

Die Routine selbst belegt etwa 190 Byte und ist im freien 4-KByte-RAM-Bereich (ab Adresse 49152) abgelegt. Außerdem benötigt sie zwei Pages (Page 193 und 194) als Zwischenspeicher. Zusätzlich wird noch der Basic-Interpreter und das Betriebssystem in das darunterliegende RAM kopiert. Schließlich »verbiegt« die Routine den Interruptvektor.

Das Programm ermöglicht das »gleichzeitige« Betreiben zweier Maschinenroutinen. Jede dieser Routinen läuft nun nur noch mit der halben Geschwindigkeit.

Die Routine wird folgendermaßen gehandhabt: Die Startadresse des ersten Maschinenprogramms, das man benutzen möchte, wird in Adresse 49158 (Lo-Byte) und 49159 (Hi-Byte) abgelegt. Analog verfährt man mit der Startadresse des zweiten Maschinenprogramms, die in Adresse 49156 und 49157 gePOKEt werden muß. Der Befehl SYS 49168 aktiviert die Routine, der Befehl POKE 1,55 (oder in Maschinensprache LDA # 55; STA 1) stellt sie wieder ab. Diese Umschaltung, sei es Basic oder Assembler, wird am besten durch das erste Programm durchgeführt, da nur von dort wieder im Basic-Modus weiter gearbeitet werden kann.

## Basic und Maschinensprache gleichzeitig

Grundvoraussetzung für das Koppel-Programm ist, daß die beiden zu betreibenden Routinen in Maschinensprache geschrieben sind. Auf den ersten Blick mag es daher so aussehen, als wären die Einsatzmöglichkeiten dieser Routine sehr beschränkt. Das Gegenteil ist jedoch der Fall. Da auch das Basic-ROM »Maschinensprache« ist, kann man ohne weiteres mit RTS zum Basic-Modus zurückkehren, anstatt die erste Maschinenroutine zu beginnen. Um dies zu erreichen, ersetzt man dieZahl 108 (JMP indirekt) in Speicherstelle 49187 durch eine 96 (RTS-Code). Jetzt kann man in Basic programmieren und seine Basic-Programme auch entsprechend abarbeiten lassen, während eine zweite Maschinensprache-Routine quasi »im Hintergrund« abgearbeitet wird. Denkbare Anwendungen sind das Spielen von Melodien oder die automatische Bewegung von Sprites während des Programm-Laufs.

Nachdem Sie »Multiprogramming« (Listing 1) mit RUN gestartet haben, sehen Sie ein merkwürdiges Geflimmer auf dem Bildschirm. Dies ist kein Fehler im Programm (dessen dokumentierter Soure-Code in Listing 2 zu finden ist), sondern eine kleine Demonstration. Eine Maschinenroutine ändert fortwährend die Rahmen-, eine zweite die Hintergrundfarbe. Beide kleinen Programme (Adresse 49350 und 49375) laufen jetzt quasi »gleichzeitig« ab. Die Anwendungsbereiche der Basic-Routine sind sehr vielfältig. Sie reichen von der Ausgabe auf zwei Drucker über die »gleichzeitige« Abfrage von Port A und B bis hin zu komplexeren Realtime-Aufgaben. Da gerade bei einem solchen Programm die Dokumentation sehr wichtig ist, • drucken wir sowohl den Source-Code (Listing 2) als auch das Flußdiagramm (siehe Bild) mit ab.

(Thomas Weinbrenner/ev)

# Leichte Eingabe \[86\]

> Die Benutzerfreundlichkeit eines Programmes hängt von der Behandlung der Eingabe beziehungsweise Fehleingabe ab. Dieses Programm beseitigt viele damit verbundene Probleme.

Das aufgeführte Programm (Listing 1) 2, das eine echte Hilfe beim Erstellen von benutzerfreundlichen Programmen darstellt, ist eine Basic-Eingaberoutine, das heißt, es ist in Basic geschrieben und ersetzt den normalen INPUT-Befehl.

Es ist in der Handhabung sehr einfach gehalten und dabei noch recht kurz.

Der Benutzer muß dabei nur IN$ und LT vorbesetzen (siehe Variablenliste). In der Routine wird als erstes IN$ ausgegeben. Dies hat den Vorteil, daß Standardantworten vorgegeben werden können. Danach werden die für die Darstellung des Cursors notwendigen Variablen vorbesetzt.

Dann wartet die Routine auf die Eingabe eines Zeichens. Der Cursor wird währenddessen dadurch simuliert, daß ein Leerzeichen laufend invertiert wird.

## Komfortabler als »INPUT«

Nachdem ein Zeichen eingegeben wurde, wird zuerst geprüft, ob überhaupt noch Zeichen angenommen werden dürfen. Ist dies der Fall, wird untersucht, ob das Zeichen ein Steuerzeichen ist.

Falls es keins ist, wird das Zeichen ausgegeben und an den Übergabestring angehängt. Dann wird das Hochkommaflag zurückgesetzt, um weiterhin eine vernünftige Eingabe zu gewährleisten.

Falls das eingegebene Zeichen ein Steuerzeichen ist, gibt es nur vier Möglichkeiten:

1.	Es ist ein »RETURN«, dann ist die Eingabe beendet
2.	Es ist ein »DELete«, dann wird der Übergabestring um ein Zeichen vermindert
3.	Es ist ein »SHIFT RETURN«, dann wird der gesamte String gelöscht, und der Cursor an den Anfang des Eingabefeldes positioniert.
4.	Es ist ein anderes Steuerzeichen, dann wird es ignoriert

Bei den Punkten 1. bis 3. wird auch noch getestet, ob überhaupt schon ein Zeichen eingegeben wurde. Ist dies nicht der Fall, dann haben auch diese drei Steuerzeichen keine Wirkung.

(Willi Burmeister/rg)

# Tips & Tricks \[87\]

## Tips für Anfänger

### List-Bremse

Dieses kleine Programm hält das Listen einer Zeile so lange an, wie eine Taste gedrückt ist. Dazu verändert es zwei Zeiger, die normalerweise auf die Ausgabe der Schlüsselworte zeigen. Es wird durch die Adresse 203 geprüft, ob eine Taste gedrückt ist. Falls ja, so wird mit der Ausgabe weitergemacht. Wenn nein, so wird noch einmal abgefragt.

Das Programm ist mit SYS 49152 zu starten.

(Jörg Blaumeiser/tr)

TODO MSE LISTING?!

### Und wieder einige POKE’s für den C 64:

POKE768,61 — Fehlermeldungen unterdrücken
POKE768,139 — kein Unterdrücken der Fehlermeldungen mehr
POKE19,64 — Sperre des Fragezeichens bei INPUT
POKE19,0 — Auflösen der Sperre
POKE157,128 — LOADING, SEARCHING usw. erscheinen auch im Programm
POKE649,0 — Sperre der Eingabe per Tastatur
POKE649,10 — Auflösen der Sperre
POKE657,128 — Sperre der Zeichensatzumschaltung mit SHIFT+C=
POKE657,0 — auflösen der Sperre
POKE768,143 — Reset nach Programmbeendigung
POKE768,145 — Sperre der Fehlermeldungen im Direkt-Modus
POKE788,81 — schnell blinkender Cursor
POKE788,56 — Cursor aus
POKE788,56 — RUN/STOP blockiert + Cursor aus + interne Uhr bleibt stehen
POKE56325,x — Cursor-Geschwindigkeit verändern (1 =sehr schnell...255=langsam)
POKE56325,0 — langsames LIST

(Rainer Sprehe/tr)

### Die Rechengenauigkeit des C 64

In den 64’er Ausgaben 9 und 10 des letzten Jahres wurde im Leserforum die mangelhafte Rechengenauigkeit des C 64 angesprochen.
Die folgende Zeile zeigt das deutlich:
5 A=A+0,01 : ?A : GOTO 5

Die Ungenauigkeit hat schon manches Mathematikprogramm scheitern lassen. Der C 64 ist eben nicht in der Lage, eine Zahl mehrmals um eine Kommazahl zu vergrößern. Man kann diese Ungenauigkeit aber mit folgender Rundungsformel umgehen:
5 A=A+0,01 : A=INT (A* 100+0.5)/100 : ?A : GOTO 5

Die »100« in der Formel bewirkt ein Runden auf zwei Nachkommastellen. Wenn man auf drei Stellen hinter dem Komma runden will, so muß man die »100« durch eine »1000« ersetzen.

(Andreas Schilling/tr)

### Buntes Directory

Bestimmt hat sich der eine oder andere schon Gedanken darüber gemacht, wie er sein Directory bunt gestalten könnte. Nichts einfacher als das:

Man muß das Programm nur folgendermaßen speichern:
SAVE" (SHIFT-SPACE) (FARBTASTE) TEST",8

Nach dem Laden des Directory erscheint der Programm-Name »TEST« in der zuvor eingegebenen Farbe. Selbstverständlich kann man nach der Farb-Taste auch noch die Revers-Taste drücken.

Beim Laden des Programmes selbst ist jedoch darauf zu achten, daß man nach dem LOAD-Befehl ebenfalls die gleiche Tastenkombination eintippt. In unserem Beispiel würde die Programm-Zeile folgendermaßen aussehen:
LOAD" (SHIFT-SPACE) (FARBTASTE) TEST",8

Am nützlichsten erscheint mir diese Form des Speicherns bei Dateien. Man könnte die verschiedenen File-Typen farblich kennzeichnen, wodurch eine bessere Übersicht und somit auch eine gewisse Ordnung entsteht.

Die REL-Files könnten zum Beispiel gelb, die SEQ-Files revers und weiß gekennzeichnet werden. Folgende Zeile müßte im Programm so aussehen:
OPEN 1,8,1,"(SHIFT-SPACE) (FARBTASTE) TEST,S,W": CLOSE 1

Gleichzeitig entsteht so ein gewisser Programm-Schutz:

Die abgespeicherten Programme stehen nämlich wie folgt im Directory:
67 ""TEST PRG

Auf normalem Weg sind diese Programme nicht zu laden. Es muß eben wie schon erwähnt, das SHIFT-SPACE dazu.

(Dieter Plaum/tr)

# Formeln perfekt gedruckt \[88-92\]

> Endlich ist es möglich, mit dem Epson FX-80 mathematische Sonderzeichen zu drucken.

Mit diesem Programm können mathematische Formeln in korrekter Schreibweise zu Papier gebracht werden. Es ist lauffähig auf dem Commodore 64 mit Epson-Drucker FX-80 und Görlitz-Interface.

Das Programm beinhaltet folgende Funktionen:

1.	Umwandlung des Basic-Zeichens »/«in einen echten Bruch (siehe Bild 1, Beispiel 1).
2.	Umwandlung des Basic-Zeichens »t« in echte Potenzschreibweise (siehe Bild 1, Beispiel 2).
3.	Umwandlung der Basic-Funktion »EXP(X)« in echte Expo-nentialschreibweise (siehe Bild 1, Beispiel 3).
4.	Umwandlung der Basic-Funktion »SQR(X)« in echte Wurzelschreibweise (siehe Bild 1, Beispiel 4).
5.	Mischung von Bruch-, Wurzel-, Exponential- und Potenzschreibweise (siehe Bild 1, Beispiel 5 bis 18).
6.	Beachtung der Klammerregeln (siehe Bild 1, Beispiel 8 bis 12).
7.	Ausgabe des Bruchstrichs exakt auf der Höhe der ganzrationalen Funktionsterme.
8.	Einbindung in andere Programme ohne weiteres möglich, es muß nur die Funktion und die Druckposition übergeben werden.
9.	Nach Ende des Druckvorgangs befindetsich der Druckkopf auf der gleichen Höhe wie zu Beginn, genau hinter der ausgedruckten Funktion. Es können also in einer Reihe ohne Probleme mehrere Funktionen ausgegeben werden.

Soweit eine kurze Übersicht über die Fähigkeiten des Programms. Kommen wir nun zu einer Beschreibung des Programmaufbaus (Tabelle 1).

In den Zeilen 120 bis 1150 befindet sich ein Beispielprogramm. Es bewirkt einen Ausdruck der Beispiele aus Bild 1.

Die Funktionen werden definiert und in G$(1) bis G$(18) festgehalten. In der sich anschließenden Schleife (Zeilen 1040 bis 1130) werden nun nacheinander die Funktionen einmal in Basic-Schreibweise und durch den Aufruf des Unterprogramms (Zeile 1120) in exakter Schreibweise ausgegeben. Vor dem Aufruf des Unterprogramms werden in den beiden Variablen BB und F$ die zu übergebenden Informationen definiert (siehe Tabelle 2). Zum einen ist das der Abstand vom linken Rand (hier 55) und zum anderen die Funktion selber (hier von G$(1)bis G$(18)).

Das Beispielprogramm soll nur einen kurzen Überblick über die vielfältigen Möglichkeiten von »Formel-Druck« geben und demonstrieren, wie die vom Programm benötigten Informationen zu übergeben sind. Wichtig ist in diesem Fall auch Zeile 120. In F$(..) werden im Programm späterdie einzelnen Terme der zu druckenden Funktion abgelegt. Ist eine Funktion sehr lang, kann es leicht zu einer größeren Anzahl an Einzeltermen als 11 kommen. Um allen Eventualitäten vorzubeugen, ist es besser, F$ gleich genügend groß zu dimensionieren. Hier wurde der Wert 50 gewählt, aber auch eine kleinere Zahl reicht meistens aus und kann vom Anwender nach eigenem Willen eingesetzt werden.

Ab Zeile 50000 beginnt nun das eigentliche Programm, die Routine zum Umwandeln der Basic-Funktionen mit sich anschließendem Ausdruck.

In Zeile 50170 ist zunächst einmal das sehr häufig benutzte Unterprogramm zum Auslesen eines Zeichens (in T$) aus der Funktion (FU$) angelegt. In den Zeilen bis 50400 werden nun die nötigen Anfangsbedingungen eingestellt. Das ist erstens in Zeile 50180 die Festlegung des Zeichensatzes für den Drucker (Groß-/Kleinschrift mit Zeilenabstand von sieben Punkten), in der für das Görlitz-Interface typischen Form. Zweitens die Definition der Sonderzeichen zum Wurzelausdruck (das »&« wird zum Strich über den Zeichen und das »%« zum Wurzelzeichen). Schließlich werden noch die benötigten Variablen festgelegt und der Fettdruck eingeschaltet.

In den Zeilen 50420 bis 50720 werden die beiden Basic-Befehlsworte EXP und SQR aus der Funktion eliminiert und durch für das Programm später verständliche Befehle ersetzt (Zeile 50550 und 50710). Durch die Verminderung von L wird die sich verkürzende Funktionslänge berücksichtigt.

Anschließend folgt der Test auf gebrochenrationale Funktion (Zeile 50780 bis 50850). Trittin derzu druckenden Funktion ein Divisionszeichen auf, wird in Zeile 50980 verzweigt und die Funktion in ganzrationale und gebrochenrationale Terme zerlegt. Zu diesem Zweck werden zum einen die vor dem Bruchstrich (Zeile 50980 bis 51070) und zum anderen die hinter dem Bruchstrich (Zeile 51080 bis 51180) auftretenden Zeichen betrachtet. Als Abbruchkriterium giltjeweils das erste »+«,»—« oder »*«-Zeichen, das nicht mehr zum Zähler oder Nenner gehört. In den Zeilen 51190 bis 51260 findet dann die Zuweisung der entsprechenden Einzelelemente in F$(SC) statt. Hierbei wird SC bei jedem neu hinzukommenden Term um eins erhöht. Nun wird in Zeile 51260 wieder nach 50780 zurückgesprungen und der restliche Funktionsteil untersucht. Das geschieht so lange, bis alle Divisionszeichen abgearbeitet sind. Dann wird der restliche Teil in F$(SC) abgelegt und zur Hauptschleife des Programms zurückgekehrt (Zeile 50910 bis 50920).

Diese Schleife beginnt in Zeile 51320. Mitjedem Durchlauf der Schleife wird ein in F$(SC) abgelegter Term aufgerufen, die jeweilige Druckposition festgelegt und der Fettdruck gesetzt.

Jeder einzelne Term wird in den Zeilen 51450 bis 51530 auf gebrochenrationale Funktion geprüft. Liegt eine vor, muß diese in den Zeilen 51650 bis 51720 in Zähler und Nenner zerlegt werden. Während dieser Prozedur werden auch gleich die überflüssigen Klammern entfernt (Zeile 51680 und Zeile 51720). Handelt es sich um einen ganzrationalen Funktionsteil, wird dieser in Zeile 51590 im Zähler abgelegt und der Nenner für spätere Kontrollen mit einem Leerstring belegt.

Um hinterher beim Ausdruck ein exaktes Druckbild zu erhalten (Bruchstrich mit der richtigen Länge und Zähler und Nenner zentriert übereinander) muß die Verkürzung des Druckbildes durch Potenzausdruck und Wegfall von einigen Zeichen durch die Eliminierung von SQR berücksichtigt werden. Das Ausmaß der Verkürzung wird in den Zeilen 51780 bis 52020 berechnet. Bei jeder auftretenden Potenz verkürzt sich die Länge des Ausdrucks um 0,5 und durch Wegfall des Zeichens »t« um eine Druckposition. Dies wird jeweils für Zähler und Nenner getrennt in Zeile 51970 beziehungsweise 51980 festgehalten.

Die Verkürzung durch den Wegfall der Klammern beim Wurzelausdruck wird jeweils in Zeile 52010 beziehungsweise 52020 berücksichtigt.

Die erhaltene Gesamtverkürzung ist in WO beziehungsweise WU enthalten. Diese wird beim Umwandeln von Zähler und Nenner auf die gleiche Länge (Zeile 52030 bis 52050) mit einberechnet. Dadurch wird eine ordentliche Bruchschreibweise gewährleistet.

Ab Zeile 52110 beginnt die Druckroutine. Als erstes wird der Zähler jedes einzelnen Terms ausgegeben. Hierbei wird ein ganzrationaler Funktionsteil als Zähler mit dem Nenner als Leerstring betrachtet. Handelt es sich um einen gebrochenrationalen Funktionsteil, wird in Zeile 52130 das Papier um eine Position rückwärts transportiert, um später den Bruchstrich auf Höhe der ganzrationalen Funktion ausgeben zu können. Zum Ausdruck wird jedes Zeichen des Zählers untersucht, ob es sich um ein Potenz- oder Wurzelsymbol handelt. Ist dies der Fall, werden die entsprechenden Routinen zum Potenz- beziehungsweise Wurzelausdruck ausgeführt. Alle anderen Zeichen werden sofort gedruckt.

Handelt es sich beim ausgegebenen Term um eine ganzrationale Funktion, wird ein Rückwärtstransport des Papiers von einer Zeile durchgeführt und das Ende des Terms in BB festgehalten, damit die nächsten Funktionsteile direkt im Anschluß gedruckt werden können.

Ansonsten kommt es zur Ausgabe des Bruchstrichs (Zeile 52280 bis 52360). Die Länge des Bruchstrichs wird in AA festgehalten und aus den oben genannten Verkürzungswerten WO und WU und der Länge des Zählers und Nenners berechnet (Zeile 52300 bis 52310).

Als letztes wird dann der Nenner ausgedruckt. Dies erfolgt auf die gleiche Weise wie beim Zähler. Auch hier wird am Ende ein Rücktransport des Papiers durchgeführt. Das Ende eines gebrochenrationalen Funktionsteils ergibt sich aus der Länge des Bruchstrichs und wird in BB gespeichert.

In den Zeilen 52580 bis 53090 stehen die beiden Unterprogramme zum Potenz- beziehungsweise Wurzelausdruck. Die Potenzausdruckroutine beginnt in Zeile 52580. Es wird die Superscript- und die Schmalschrift eingestellt. Dann wird jedes dem Potenzsymbol folgende Zeichen überprüft, ob es noch im Exponenten steht oder nicht. Als Abbruchkriterium gelten die gängigen mathematischen Kriterien (Zeilen 52650 bis 52705). In den Zeilen 52720 bis 52750 wird überprüft, ob die Potenz unter der Wurzel steht, in diesem Fall ist WW = 1, und der entsprechende Wurzelstrich wird ausgegeben. Nach Abarbeitung aller in Frage kommenden Zeichen wird wieder die Normalschrift und der Fettdruck eingeschaltet und zurück ins Hauptprogramm gesprungen (Zeile 52810 bis 52850). Die Variable M (Zeile 52760) dient zur Berechnung der Verkürzung des Terms durch den Potenzausdruck und wird bei ganzrationalen Funktionen berücksichtigt.

In der Wurzelausdruckroutine läuft im Prinzip das gleiche ab. Sie beginnt in Zeile 52910 und druckt zuerst das Wurzelsymbol und über alle folgenden Zeichen den Wurzelstrich. Zur Ausgabe dieses Strichs wird der Druckkopfjeweils um ein Zeichen zurück und einen Matrixpunkt nach oben bewegt und anschließend das Sonderzeichen ausgegeben (Zeile 53020 bis 53060).

Den Abschluß des Programms bilden die Zeilen 53150 bis 53170. Hier wird der Drucker normiert, das heißt in den Einschaltzustand zurückversetzt, alle offenen Kanäle geschlossen und der Epson-Modus mit automatischem Zeilenvorschub eingestellt.

(Patrick Bödeker/rg)

# Schreiben Sie Ihre eigenen Fehlermeldungen \[92-93\]

> Wer die öden Meldungen des Betriebssystems wie »READY« oder »SYNTAX ERROR« satt hat, kann mit dem »ErrorChanger« alle Fehlerausgaben ändern und auf Diskette speichern.

Denken Sie einmal an klassisches Basic-Programmieren: Drei Zeilen eintippen, Probelauf, Fehlermeldung, Korrektur, Probelauf... und so weiter. Und bei jedem Fehler erscheinen die sattsam bekannten, äußerst langweiligen Einheitsfehlermeldungen.

Mit dem hier vorgestellten Programm »Error-Changer« ist es endlich möglich, den Wortlaut der Fehlermeldungen frei zu wählen (Bild 1 und 2). Nun, das ist immer noch nichts so Besonderes. Besonderes ist, daß der neue Textjeder Fehlermeldung bis zu 80 (achtzig) Zeichen lang sein kann.

Ob Sie den »UNDEFD STATEMENT ERROR« mit »QUO VA-DIS« oder mit »WOHIN, MEIN FREUND??« übersetzen, bleibt Ihrer Phantasie überlassen. Es schaut auch besser aus, wenn statt dem faden »READY«, zum Beispiel das warmstartsichere »ANDYS SOFTWARE IST IMMER EIN GEWINN« erscheint. Individualität ist Trumpf, Einheits-ROM ist out.

Das Programm ist kinderleicht zu bedienen: Error-Changer (siehe Listing) laden und starten.

Es erscheint der Text der alten, englischen Fehlermeldung. Sollte sie nicht geändert werden, so wird sie normal mit der RETURN-Taste übernommen. Ansonsten wird der neue Text eingetippt. Die Länge des neuen Textes kann frei gewählt werden und ist nur durch die 80 Zeichen des INPUT-Befehls begrenzt. Sollte der neue Text kürzer sein als der alte, so ist der Rest mit Leerzeichen zu überschreiben. Es kann auch die Abbruchmeldung BREAK und die READY-Meldung geändert werden. Jedoch erscheint, bedingt durch das Betriebssystem, nicht immer der geänderte Text.

Nach Beendigung schaltet das Programm automatisch auf die neuen Fehlermeldungen um. Diese können auf Kassette oder auf Disk gespeichert werden, um die kreativen Ergüsse für die Nachwelt zu erhalten.

Die neuen Fehlermeldungen werden mit
LOAD ”FEHLER.OBJ”,8,1 (für Datasette ,1,1)
geladen, mit SYS 49152 ein- und mit SYS 49226 ausgeschaltet. Nach dem Laden sollten Sie unbedingt NEW eingeben.

Nun zum Programmtechnischen.

Es wird der »Vektor auf Fehlermeldungen« $0300-$0301 (dezimal 768-769) auf das neue Programm »umgebogen«. Tritt ein Fehler auf (Fehlernummer größer 0), so stellt das Programm normale Ein- und Ausgabeverhältnisse her (Bildschirm, Tastatur). Die Fehlernummer bildet einen Vektor auf die Adresse des ersten Buchstabens der entsprechenden Fehlermeldung. Die Tdxte der Fehlermeldungen werden hintereinander gespeichert. Als Trennzeichen fungiert das siebte Bit des letzten Buchstabens. Ist es gesetzt, so weiß das Betriebssystem, daß dieser Buchstabe der letzte ist. Somit ist der erste Buchstabe (Zeiger im Steuerprogramm) und der letzte definiert (siebtes Bit gesetzt). Jetzt muß die Meldung nur noch geschrieben werden. (Das Ganze kann mit dem K-Befehl des SMON angeschaut werden. Nicht vergessen: Auf Kleinschriftmodus umschalten!)

Um Speicherplatz zu sparen, wurden im Programm die Fehlermeldungen ohne das Wort »ERROR« gespeichert, da dieses bei allen Meldungen gleich ist. Bei den neuen Meldungen muß der ganze Wortlaut angegeben werden, da bei manchen Scherzfehlermeldungen das Wort »ERROR« oder »FEHLER« stören würde.

Beschreibung der wichtigsten Variablen:

T$(I) =Text der alten und nach dem Überschreiben der neuen Fehlermeldung.
LV = Lesevektor. Liest alte Meldung aus dem ROM.
SA = Schreibvektor. Schreibt neuen Text in das RAM.
VA = Schreibvektor auf Lo/Hi-Adressen des ersten Buchstabens der neuen Meldung.
SA und EA = Start- und Endadresse als Parameter für den SAVE-Befehl
FZ = Fehlerzähler (identisch mit der betriebssysteminternen Fehlernummer!)

(Andreas Knipp/tr)

# Kopierschutz ohne Read Error \[94\]

> Read Errors sind für die meisten Ko-pierprogramme kein Problem, deshalb wird hier ein anderer Weg beschritten. Basic- und Maschinen-Programme sind nur dann lauffähig, wenn vor dem Start ein Paßwort eingegeben wird.

Das Programm ist in Maschinensprache geschrieben und belegt den Speicherbereich von $CFOO bis $CF46. Der bereich von $CF47 bis $CFFF istfür ein Paßwort reserviert, das eingegeben werden muß, nachdem der zuvor abgetippte Lader (siehe Listing) mit RUN gestartet wurde. Von nun an werden alle Programme, die auf Diskette gespeichert werden, beim Speichern codiert. Solange der Computer eingeschaltet bleibt, können Programme, die mit dem eingegebenen Paßwort gespeichert wurden, ganz normal geladen werden. Programme, die unter einem anderen Paßwort gespeichert wurden lassen sich zwar auch noch Laden, sind aber nicht mehr lauffähig. Sollen solche Programme gestartet werden, muß dem Computer vor dem Laden das neue Paßwort übermittelt werden. Dies geschieht mit einem kleinen Basic-Programm:
10 INPUT C$ : C=LEN(C$)
20 FORI=1TOC
30 POKE 53072+I,ASC(MID$ (C$,I,1))
40 NEXT
50 POKE 13*16T3-1,C
60 END

Soll ein normales, also uncodiertes, Programm geladen oder gespeichert werden, so muß man den Codierer mit POKE 1,55 ausschalten. Mit POKE 1,53 läßt er sich wieder einschalten.

(Michael Dietz/ah)

# Tape Save — Maschinenprogramme einfach gespeichert \[95\]

> Der Save-Befehl des C 64 erlaubt es leider nicht, bestimmte Speicherbereiche und damit Maschinenprogramme abzuspeichern. Mit »Tape Save« können Sie dies sogar im Dialogverfahren und sowohl auf Diskette als auch auf Datasette.

Wer kennt das Problem nicht: Man hat einen DATA-Lader für ein Maschinenprogramm und kann das Programm wegen eines fehlenden Monitors nicht direkt abspeichern! Hier setzt nun unser Programm »Tape Save« ein, das es auch Anfängern ermöglicht, im Dialogverfahren Maschinenprogramme auf Kassette oder Diskette zu speichern.

»Tape Save« (siehe Listing) tippen Sie bitte mit dem MSE ab. Es kann dann mit »LOAD ”TAPE SAVE” ,1,1« beziehungsweise »..,8,1« geladen werden. Gestartet wird »Tape Save« mit SYS 49152. Vor dem Start müssen Sie noch NEW eingeben, um keinen »OUT OF MEMORY ERROR« zu erhalten.

## Bedienungshinweise

Als erstes wird nach dem Namen des zu speichernden Programms gefragt. Der Computer akzeptiert höchstens 16 Zeichen, verlangt aber mindestens ein Zeichen, sonst wird die Eingabe abgelehnt. Danach gibt man Start- und Endadresse in hexadezimaler Form ein. Dabei erscheint allerdings kein Cursor, die eingetippten Werte werden aber angezeigt. Nach Eingabe der beiden vierstelligen Zahlen fährt das Programm mit der Frage nach der Nummer des Peripheriegerätes fort. Auch hier wird nur eine gültige Eingabe akzeptiert, wobei »1«für Da-tasette und »8« für das Diskettenlaufwerk einzugeben ist. Danach startet »Tape Save« den Speichervorgang. Nach dem Speichern ermöglicht es dann dem Benutzer, mittels der Funktionstasten den weiteren Programmablauf zu gestalten. Man kann den Speichervorgang wiederholen, das Programm abbrechen oder aber nochmals beginnen, um ein weiteres Programm zu speichern.

Hier noch einige wichtige Bedienungshinweise:

Diskettenbenutzer müssen aufpassen, wenn sie mit der Funktionstaste »F3« nochmals ohne Parameteränderung speichern wollen. Wurde die Diskette nicht gewechselt, erhält man einen »FILE EXISTS ERROR«, weil auch der Filename nicht geändert wird.

Der wichtigste Nachteil von »Tape Save« ist seine Lage im Speicher: Es liegt von $c000 bis $c369. Das bedeutet, daß Programme, die im $c-Bereich liegen, auch nichtvon »Tape Save« gespeichert werden können. Ebenso können keine Maschinensprache-Programme, die sich im Kassettenpuffer befinden, auf Kassette gespeichert werden. Hier ist nur die Speicherung auf Diskette möglich.

(Johannes Rest/bs)

# Linker 64 — Schluß mit dem Nachladen \[96-98\]

> Wenn Sie öfters mehrere Maschinenprogramme gleichzeitig im Speicher haben wollen und es leid sind, jedes Programm einzeln nachzuladen, dann ist der Linker das ideale Arbeitswerkzeug für Sie.

Seine Anwendungen sind vielfältig: vom einfachen Basic-Start-Generator für Maschinenprogramme bis zum Verketter (= Linker) von mehrteiligen Spielen. Das Endprodukt, also das generierte Programm, kann dann ganz einfach auch von der Datasette geladen werden, was bisher an den Diskettenlade-routinen der Programme scheiterte. Diese Laderoutinen müssen natürlich vorher entfernt werden.

Die Bedienung ist denkbar einfach: Diskette mit den einzelnen Programmen nehmen, Linker 64 (siehe Listing) starten und bedienen. Es wird eine lauffähige Version generiert, die man mit LOAD und RUN starten kann.

Die einzige Denkarbeit besteht in der Überlegung, in welcher Reihenfolge die Programme wieder an ihre ursprünglichen Adressen verschoben werden sollen. Das ist wichtig, da sonst während des Verschiebevorgangs bereits verschobene Programmteile, die noch nicht verschobenen überschreiben könnten. Im allgemeinen wird man zuerst die Maschinenroutinen verschieben, die an die höchste Adresse geschrieben werden sollen.

### Die Arbeitsweise des Linkers

Der Linker generiert drei Programmteile, die am Ende verkettet werden: Teil »S« besteht aus der Basic-Zeilennummer, dem SYS-Befehl und dem anschließenden Text, gleich einer REM-Zeile. Teil »V« besteht aus dem generierten Verschiebeprogramm. Für Interessierte sei gesagt, daß bei einer Verschiebung nach oben die betriebssysteminterne Blockverschieberoutine ($a3bf) angesprungen wird. Bei Transfer nach unten kommt eine »handgestrickte« Routine zur Anwendung. Teil »P« enthält schließlich die aneinandergehängten Maschinenprogramme.

Der Linker kennt zwei Betriebsarten: entweder Verschiebeteil vor oder nach den gelinkten Programmen. Im Modus »0« ist die Reihenfolge der drei Teile S-V-P, im Modus »1« ist sie S-P-V. Der Modus »0« (LoMem-Modus) wird fast immer benutzt, da nursehrselten Programmteile im Basic-Startbereich (2049 = $0801) laufen. Sollte dies aber doch der Fall sein, oder sollen Basic-Programme mit Maschinenprogrammen zusammengelinkt werden, so muß Modus »1« (HiMem-Modus) verwendet werden. Die Verschieberoutine würde sich sonst selbst überschreiben.

### Anwendung des Linkers

Beispiel: Wir wollen aus dem SMON $c000, einer RENEW-Routine mit der Startadresse 36 000 und einem Assembler ASS $9000 ein einziges Programm machen. Dieses sollte nach dem Laden die einzelnen Teile gleich an die richtigen Adressen im Speicher versetzen und mit »RUN« zu starten sein. Weiterhin soll danach gleich der SMON starten:

(Alle drei Programme müssen sich auf der gleichen Diskette befinden.) Zuerst lädt man den Linker und startet ihn. Dann gibt man die Zeilennummer, in der später der SYS-Befehl stehen soll, einen erklärenden REM-Text und den Namen ein, den das fertige Programm erhalten soll. Als Betriebsart wählen wir »0«, da der Basic-Startbereich von unseren Programmen nicht berührt wird. Die Frage nach der Anzahl der Programme beantworten wir mir »3«. Nun werdendie Namen der einzelnen Programme eingegeben, woraufhin der Linker deren Startadressen berechnet und ausgibt. Diese könnten jetzt noch geändert werden, was aber nicht sehr ratsam ist. Maschinenprogramme haben im allgemeinen nämlich die Eigenschaft, nur in dem Speicherbereich zu laufen, für den sie geschrieben wurden. In unserem Fall übernehmen wir also die Startadressen mit der RETURN-Taste.

Jetzt fragt der Linker nach der Reihenfolge, in der später die Programme verschoben werden sollen (ist in unserem Fall egal, da sich unsere Beispielprogramme nicht im geringsten gegenseitig stören). Der Linker meldet sich mit:

TODO TABLE

1	= SMON $c000
2	= ASS $9000
3	= RENEW
4	= ENDE

Wir tippen zum Beispiel »2« für die Verschiebung des Assemblers. Nun wird für ihn die Einsprungsart verlangt: EINSPRUNG: O = KEINER, 1=JSR, 2=JMP

Da nach der Verschiebung des Assemblers dieser nicht gleich gestartet werden soll, geben wir eine »0« ein. Es erscheint am Bildschirm:

TODO

1	= SMON $c000
2	=
3	= RENEW
4	= ENDE

Sie sehen, der Assembler ist »verschwunden«. Der Linker wartet auf dasnächste Kommando. Wir geben »3« für die RENEW-Routine ein. Da diese ebenfalls nicht gleich gestartet werden soll, beantworten wir die nachfolgende Frage mit »0«. Dann verschieben wir mit »1« den SMON. Wir haben vorher gesagt, daß das fertige Programm diesen gleich starten sollte. Also Einsprungsart »2«. Die Einsprungsadresse, die der Linker daraufhin verlangt, ist 49152 (SMON).

Es wird noch einmal nach der Einsprungsart gefragt, da bei der Eingabe von »1« (JSR) noch weitere Einsprünge erfolgen könnten. Wir quittieren das Ganze mit »0« und das Abenteuer ist für uns erledigt.

Jetzt wirft der Linker die DOS-interne Copy-Routine an, die die vorher generierten Teile »V« und »S« auf der Diskette direkt aneinanderhängt. Nach einiger Zeit meldet sich der Computer mit READY, und der Link-Vorgang ist beendet. Auf der Diskette befindet sich jetzt das fertige Programm, das mit LOAD"na-me”,8 geladen und mit »RUN« gestartet werden kann. Es werden zuerst die gelinkten Programme in der festgelegten Reihenfolge an ihren Platz im Speicher verschoben und die durch JMP oder JSR definierten Adressen angesprungen. Achtung: Vor einem erneuten Start durch »RUN« sollte das Programm erst noch einmal geladen werden, ebenso sollte es nach dem Verschieben nicht mehr gespeichert werden.

Die wichtigsten Unterprogramme des Linkers sind in der Tabelle beschrieben. Die Röutine »Test auf Vorhandensein von Programmen auf Disk« eignet sich gut zum Einbau in eigene Programme.

(Andreas Knipp/tr)

# Variablen-Dump \[98\]

> Mit diesem kleinen Programm und einem SYS-Befehl haben Sie alle Ihre BasicVariablen voll im Griff. Eine, nicht nur zum Austesten von Programmen, nützliche Erweiterung.

»Dump« bedeutet übersetzt Speicherauszug oder Speicherausdruck eines Computers. Ein Variablen-Dump ist eine Übersicht aller Variablen, die in einem (Basic-)Programm verwendet werden. Es gibt verschiedene Möglichkeiten, die Erweiterung »Dump« zu benutzen:

- SYS 49152,A: Listet alle im Programm verwendeten indizierten Variablen mit dem Namen A auf; also A(1), A(2) und so weiter.
- SYS 49152 ohne Zusatz: Listet alle nichtindizierten Variablen.
- SYS 49152,$: Listet nur alle nichtindizierten Stringvariablen.
- SYS 49152,%: Listet nur alle nichtindizierten numerischen Variablen (das Gegenstück zu SYS 49152,$).

(Herbert Kunz/tr)

# Escape-Taste für Gänsefüßchen-Modus \[99-100\]

> Beim Editieren geschieht es oft, daß man anstelle einer Cursorbewegung ein reverses Feld erhält, auch wenn man das gar nicht wünscht. Der einzige Weg zurück zur normalen Cursorkontrolle führte bis jetzt über das Drücken der RETURN-Taste. Mit dieser Routine kommen Sie durch einfachen Druck auf die »F7«-Taste aus dem »Gänsefüßchen-Modus« heraus.

Vielleicht haben Sie sich auch schon über die etwas exotisch klingenden Ausdrücke im Titel gewundert, aber sie beziehen sich auf eine typische Eigenschaft des Commodore Basic-Editors. Wenn man Anführungszeichen oder die INSERTTaste getippt hat, wird jedes Drücken einer Cursortaste nicht durch eine direkte Bewegung des Cursors, sondern durch ein reverses Steuerzeichen quittiert. Nebenbei: dasselbe geschieht beim Drücken der Funktions-, der CLR/HOME- oder der CTRL-Taste zusammen mit den Farbentasten. Dieser Modus, in dem sich der Editor dann befindet, wird Quote-Modus, zu deutsch »Gänsefüßchen-Modus« oder programmierter Cursor genannt.

Manchmal ist das sehr erwünscht, wenn man zum Beispiel die Cursor- oder Farbsteuersequenzen ins Programm einbinden möchte. Oft ist es aber auch unerwünscht, und man überschreibt durch Unachtsamkeit eine halbe Programmzeile mit reversen »Q« oder sonstigen Steuerzeichen. Aus dem »Gänsefüßchen-Modus« heraus gelangt man nur, indem man noch einmal die Taste für Anführungsstriche oder RETURN drückt. Wie gut wäre es, wenn man mit einem einfachen Tastendruck aus dem störenden Quote-Modus herausgelangen könnte, ohne irgendein Zeichen überschreiben zu müssen.

Die Escape-Routine realisiert diese Möglichkeit vollständig. Durch simplen Druck auf die Funktionstaste »F7« werden alle Bits gelöscht, die verhindern, daß sich der Cursor normal steuern läßt. »F7«ermöglichtalsodas Entkommen (englisch: escape) aus diesem Modus.

Damit Sie auch immer genau wissen, wann welcher Modus aktiv ist, stehen in der rechten oberen Bildschirmecke die entsprechenden Buchstaben in weißer Farbe. Haben Sie Anführungsstriche geschrieben, dann erscheint ein »Q« als Zeichen dafür, daß der Quote-Modus eingschaltet ist. Das »Q« steht dort so lange, bis der Modus ausgeschaltet wird, das heißt, bis entweder RETURN, Schlußzeichen oder »F7« gedrückt wurde. Wollen Sie etwas in reverser Schrift erscheinen lassen, dann müssen Sie CTRL/RVS ON drücken und schon erscheint ein weißes »R« als Abkürzung für Revers-Modus in der Bildschirmecke. Als drittes Zeichen kann noch das »I« vorkommen, nämlich dann, wenn die INSERT-Taste benutzt wurde. Im lnsert-Modus kann man nicht einmal ein falsch eingetipptes Zeichen mit der DEL-Taste löschen, da nur reverse »T«s erzeugt werden, aber ein Druck auf »F7« genügt, und das Problem ist behoben.

Das Programm wird dann mit SYS49152 aufgerufen, und ab sofort ist die Routine »Escape-Taste« in den Systeminterrupt eingebunden. Das allerdings nur solange bis RUN/STOP-RESTORE gedrückt wird, dann wird der lnterruptvektorwieder direkt auf die normale Interruptroutine gelenkt und die neue Routine wird so lange übergangen, bis das Programm neu gestartet wird.

Da diese Routine für den Einsatz beim Programmieren gedacht ist, sollten dabei keine Probleme entstehen.

Als einzige Einschränkung muß gesagt werden, daß die Benutzer von Kassettengeräten bei einem Zugriff auf die Data-sette die Routine mit RUN/STOP-RESTORE ausschalten sollten, da Kassettenoperationen den Interruptvektor auf spezielle Kassettenroutinen umschreiben und sich ein schon verstellter IRQ-Vektor negativ auswirkt.

(Christian Spörri/aw)

### Eingabehinweise

Wer im Besitz eines Assembler ist, kann das Assemblerprogramm (Listing 1) abtippen, alle anderen verwenden bitte den Weg über den MSE (Listing 2).

Die Startadresse des Programmes liegt bei $C000 gleich 49152 dezimal, die Endadresse bei $C08F oder 49295.

Das Programm wird natürlich nach dem Abtippen und Speichern wieder mit der Sekundäradresse 1, das heißt absolut geladen. Nach dem Laden muß »NEW« eingegeben werden, damit die Basic-Zeiger, die in den Bereich $C000-$CFFF verstellt wurden, wieder »zurechtgebogen« werden.

# Daten komprimieren — Sparen Sie Speicherplatz und Ladezeit! \[100-101\]

> Schreiben Sie öfter Programme, bei denen Sie größere Datenmengen verwalten müssen? Mit dem »Daten-Packer« wird der Aufwand an Ladezeit und Speicherplatz auf Diskette um 25 Prozent reduziert.

Dieses Programm kürzt Strings auf % der normalen Länge. Wenn man zum Beispiel einen String mit 12 Zeichen Inhalt hat, und den »Daten-Packer« darauf losläßt, ist der String nur noch neun Zeichen lang, bei gleichem Inhalt!

Um ihn sich änsehen zu können, muß er natürlich erstwieder in eine lesbare Form gebracht, also »entpackt« werden.

Bei selbstgeschriebenen Adressenverwaltungen läßt sich das gut anwenden:

Bevor man die Adressen, die ja meist in Strings enthalten sind, auf der Diskette abspeichert, »packt« man sie mit dem Daten-Packer, und speichert sie dann. So spart man eine Menge wertvollen Diskettenplatz und Ladezeit.

Nach dem Einladen müssen die Adressen wieder »entpackt« werden, bevor man mit ihnen weiterarbeiten kann.

Das Programm (siehe Listing) wird mit dem MSE eingegeben und ist dann sofort einsatzbereit.

### Umgang mit dem Daten-Packer

Packen: SYS 49152, A$, B$

In A$ muß der zu packende String stehen. Danach enthält B$ die gepackte Version.

Entpacken: SYS 49339, C$, D$

In C$ muß der gepackte String stehen. In D$ ist dann der entpackte String zur Weiterverarbeitung bereit.

Natürlich kann an Stelle von A$, B$, und D$ jede andere Stringvariable stehen.

Das geht doch nicht mit rechten Dingen zu, wird der eine oder andere Leser jetzt vielleicht denken.

Nun, dieses Programm kürzt 4 Byte auf 3 Byte. Ein Byte hat bekannterweise 8 Bit, gebraucht werden aber nur 6 Bit, um die ASCII-Werte darzustellen, aus denen Datenstrings ja bestehen.

Mit diesen 6 Bit kann man alle alphanumerischen Zeichen und einige Sonderzeichen darstellen. Der Alogrithmus des Programms besteht nun darin, vom ASCII-Wert des zu packenden Byte 32 abzuziehen, um eine Darstellung mit 6 Bit zu ermöglichen. Dann wird jedes vierte Byte auf die vorhergehenden 3 Byte verteilt, bei denen die letzten 2 Bit nach unserer Subtraktion nun nicht mehr gebraucht werden. »Überhang-Bytes«, also die letzten Zeichen eines Strings, die keine vollen 4 Byte mehr ergeben, werden nicht gepackt, sondern nur an den gepackten String angehängt.

Beim Entpacken läuft der Vorgang in umgekehrter Reihenfolge ab.

(Joachim Matzner/gk)

# Der C 64 lernt sprechen \[101-102\]

> Dieses Programm ist wohl die billigste Sprachein^ausgabe, die es gibt. Man kann sie vielseitig einsetzen, zum Beispiel bei Spielen, sprechenden Menüs oder einfach als Spielerei.

Außer dem C 64 ist für dieses Programm eine Datasette erforderlich. Nachdem das Listing abgetippt und das Programm mitSYS49231 gestartetwurde, ändernsichdieBildschirmfar-ben, und eine Einschaltmeldung erscheint. Jetztstehen Ihnen 2045 Byte für Basic-Programme zur Verfügung. Der Grund dafür ist, daß die Aufzeichnung von Sprache äußerst speicherintensiv ist. Selbst der Bereich unter dem Basic-ROM ($ A000 bis $BFFF) wird ausgenutzt. Die Tonwiedergabe hat zwar keine Hi-Fi-Qualität, wenn man aber laut und deutlich spricht, kann man sich gut wiedererkennen. Während der Tonein-/ausgabe wird der Bildschirm abgeschaltet, damit der Prozessor nicht ständig vom Video-Controller unterbrochen wird.

Das Arbeiten mit diesem Programm ist denkbar einfach. Es stehen fünf neue Basic-Befehle zur Verfügung. Der Speicher des C 64 wird in verschiedene Abschnitte aufgeteilt (Bild 1), in denen Wörter gespeichert werden. Hinter allen Befehlen (außer ^R und —G) ist anzugeben, in welchen Bereich gespeichert werden soll.
x= 1 bis 16: Diese Abschnitte sind für ein- bis zweisilbige Wörter reserviert. Hier können zum Beispiel Zahlen oder kurze Wörter abgelegt werden.
x = 17: Dies ist ein Abschnitt für 4 Sekunden Sprechzeit.

Hier kann ein kleiner Satz abgelegt werden.
x = 255: Hier wird der gesamte Speicher beschrieben, also auch die Abschnitte 1 bis 17. Es stehen etwa 13 Sekunden Sprechzeit zur Verfügung.

Alle anderen Zahlen werden als 17 interpretiert.

## Befehle

Doch nun zu den Befehlen:
**←Lx**: »learn« — Nach Eingabe dieses Befehls wird der Bildschirm abgeschaltet. Die Tonsignale werden digitalisiert und im Speicher abgelegt, x entscheidet, in welchen Bereich die Sprache gespeichert wird.
**←Sx**: »say«—Bei diesem Befehl wird ebenfalls der Bildschirm gelöscht. Aus dem Lautsprecher des Fernsehgerätes ertönt nun Ihre eigene Stimme. Im Gegensatz zu dem Befehl »learn« benötigt dieser Befehl keinerlei Hardware. Er kann also ohne irgendwelchen Umbau benutzt werden, x entscheidet, aus welchem Bereich die Sprache entnommen wird.
**←P”Filename”x**: »put« — Mit diesem Befehl kann die Sprache, die sich im Speicher befindet, auf Diskette gespeichert werden. Da das Speichern von Sprache sehr aufwendig ist, belegen 13Sekunden Sprechzeit178 Blöcke, xgibtan, in welchem Bereich die Sprache gespeichert wird.
**←G”Filename”**: »get« — Dieser Befehl wird zum Laden der Sprache benutzt.
**←R**: »rate«—Mitdiesem Befehl läßtsich die Sprechgeschwindigkeit einstellen. Nach dem Befehl muß ein numerischer Ausdruck folgen, der die Geschwindigkeit angibt. Erlaubt sind Zahlen von 0 bis 19. Dabei entspricht 19 der schnellsten Sprechgeschwindigkeit und 0 der langsamsten. Alle anderen Zahlen werden mit einer Fehlermeldung quittiert. Die Grundeinstellung ist 13. Das ist etwa die normale Sprechgeschwindigkeit.

Jetzt werden Sie sich fragen, wie man in den Computer hineinspricht. Dazu ist natürlich ein Mikrofon erforderlich und somit auch ein wenig Umbau. Aber keine Angst, der Umbau hält sich in Grenzen. Es ist jedoch erforderlich, die Datasette zu öffnen. Lösen Sie dazu die vier Schrauben auf der Rückseite. Nachdem der Deckel abgenommen wurde, läßt sich auf einer Seite eine Platine erkennen, die mit einer Aluminiumfolie abgeschirmt ist. Auf der Seite, wo sich die Drucktasten befinden, ragt eine Anschlußleiste unter der Folie hervor (Bild 2). Löten Sie nun an die in Bild 2 gekennzeichneten Punkte eine Mikrofonbuchse an. Das war schon der ganze Umbau. Wollen Sie die Datasette wieder als Massenspeicher benutzen, darf das Mikrofon nicht mit der Buchse verbunden sein, da Geräusche im Raum den Datentransfer zwischen Datasette und Computer stören.

(Martin Klinger/ah)

# ON ERROR GOTO \[103\]

> Routinen, die bei einem auftretenden Programmfehler zu einer bestimmten Zeile verzweigen, sind inzwischen Standardausrüstung jeder guten Ba-sic-Erweiterung. Das vorliegende Maschinenprogramm ist nur 88 Byte lang.

Um einen Fehler während des Programmlaufs abzufangen, kennen viele Computer den Befehl ON ERROR GOTO. Mit diesem kurzen Maschinenprogramm kann auch Ihr C 64 auf Fehler im Programm reagieren.

Nachdem das Programm (Listing 1) im Speicher steht, kann es mit SYS 50000, ZL aktiviert werden. Dabei bedeutet ZL die Zeilennummer, zu der bei einem Fehler verzweigt werden soll. Die Fehlernummer wird dann in Speicherstelle 2 gespeichert und kann mit PEEK(2) abgefragt werden. Tabelle 1 zeigt, welche Nummer welcher Fehlermeldung entspricht. Die Zeile, in der der Fehler auftrat, wird in Speicherstelle 249 und 250 gespeichert. Damit Sie zu der fehlerhaften Zeile zurückspringen können, wurde noch die Routine »GOTO X« eingebaut. Damit läßt sich zu einer berechneten Zeile springen. Aufgerufen wird diese Routine mit SYS 50076, ZL. Schauen wir uns einmal das Beispiel ab Zeile 200 im Basic-Lader an. In Zeile 210 wird mit SYS 50000, 1000 die Fehlerbehandlungsroutine auf Zeile 1000 gelegt. In Zeile 220 wird der Benutzer aufgefordert, eine Zahl einzugeben. Solange diese Zahl positiv ist, wird in Zeile 230 die Wurzel aus dieser Zahl errechnet und ausgegeben. Bei einer negativen Zahl wird zur Zeile 1000 verzweigt. Hier wird die Fehlernummer ausgegeben. In diesem Falle 14. In Zeile 1010 wird nun die Zeile errechnet, in der der Fehler auftrat und ausgegeben. Zeile 1020 schließlich ruft die »GOTO X«-Routine auf und springt in die Zeile ZL —10.

Listing 2 zeigt den dokumentierten Assemblerteil der Routine.

(Kunz/tr)

# Übersichtliches Listing \[104\]

> Diese kleine Erweiterung spaltet beim Listen eine Programmzeile in mehrere Zeilen auf. Dadurch wird die Analyse auch komplizierter Programmteile zum Kinderspiel.

Die Idee zu dieser Erweiterung kam durch den Einzeiler-Wettbewerb im 64’er-Magazin, bei dem die abgedruckten Programme durch ihre gedrängte Darstellung schlecht lesbar waren. Damit ist nun Schluß. Wenn in einer Programmzeile ein Doppelpunkt vorkommt, so wird der darauf folgende Befehl in die nächste Zeile geschrieben.
Beispiel:
Aus
10 A=53280:POKE A,I:POKE A+1,I+1:I=PEEK(53248+ 18):GOTO 10
wird
10A= 53280
POKE A,I
POKEA+1,I+1
I=PEEK(53248+18)
GOTO 10

Die Erweiterung liegt in dem Bereich von 49152 bis 49239, nimmt also keinen Basic-Speicherplatz in Anspruch. Sie läßt sich aber beliebig verschieben, damit sie auch bei Basic-Erweiterungen funktioniert, die den Bereich ab 49152 benutzen (man muß nur den Wert der Variablen ADRESSE in Zeile 0 ändern). Die 87 Byte lange Erweiterung läßtsich mit POKE 2,0 einschalten und mit POKE 2,1 wieder ausschalten.

## So arbeitet die Routine

Das Maschinenprogramm liegt als Basic-Lader (Listing 1) und als Source-Code (Listing 2) vor. Zuerst wird der LIST-Vektor auf die neue Routine gePOKEt, dann erfolgt ein Rücksprung zum Basic. In der neuen LIST-Routine wird abgefragt, ob es sich bei dem zu listenden Zeichen um einen Befehl handelt. Ist dies der Fall, so wird zu der Routine gesprungen, die den Befehl ausgibt.

Anschließend erfolgt eine Überprüfung auf einen Doppelpunkt. Handelt es sich nicht um dieses Zeichen, so wird normal weitergelistet. Andernfalls findet eine Überprüfung der Speicherstelle 2 statt. Ist sie nicht 0, so wird der Doppelpunkt ausgegeben und mit dem normalen Listing weitergemacht. Steht in der Speicherstelle 2 eine 0, so wird ein CHR$(13) ausgegeben.

Im darauffolgenden Teil werden die untereinanderstehenden Teilprogrammzeilen linksbündig gemacht und ausgegeben. Danach wird wieder zum »normalen« Listing gesprungen.

Die Routine »Übersichtliches Listing« ist in erster Linie natürlich für das Arbeiten mit einem Drucker gedacht, denn eine Bildschirmausgabe mit einem Basic-Befehl pro Zeile würde den Vorteil der erhöhten Übersicht wohl bald zunichte machen, jedenfalls bei längeren Programmen. Der Einsatzschwerpunkt dieser Routine liegt damit bei der Analyse fremder, unübersichtlicher Programme mittels eines Druckers.

(Frank Barcikowski/ev)

# Programmieren Sie Ihre Tastatur! \[105-106\]

> Mit diesem Programm werden nicht nur die Funktionstasten, sondern die gesamte Tastatur frei programmierbar.

Wenn Sie das Programm KEY-PROGGER (Listing 1) eingegeben haben, können Sie es mit LOAD"KEY-PROGGER",1,1 oder, wenn Sie ein Diskettenlaufwerk besitzen, mit LOAD"KEY-PROGGER",8,1 laden. Nach dem Laden geben Sie am besten den Basic-Befehl NEW ein, da Sie sonst später eine OUT OF MEMORY-Meldung erhalten. Nun sind Sie soweit, daß Sie das Programm mit SYS 49152 starten können. Nach dem Starten istjedoch keine Veränderung zu bemerken. Durch den SYS-Befehl wird nur die Tastaturabfrage über eine neue Routine geleitet, welche die Tastenfunktionen aus einer Tabelle liest, die im RAM steht, und daher verändert werden kann. Wie aber ändert man nun die Tastenbelegung? Dazu ist der leistungsfähige #-Befehl implementiert. Damit KEY-PROGGER mit möglichst vielen Erweiterungen zusammenarbeitet, ist es möglich, diesen Befehl ein- und auszuschalten. Um also die Tastenbelegung zu ändern, muß dieser Befehl zuerst eingeschaltet werden. Dies geschieht mit SYS 49152+3. Ausgeschaltet wird er mit SYS 49152+6. Die Anwendung des # -Befehls ist sehr einfach. Sie geschieht in der Form: #nr,string

nr entspricht in den allermeisten Fällen dem ASCII-Wert eines Zeichens. Alle möglichen Tastaturzuordnungen sind in Bild 1 aufgeführt. Wo dies nicht so ist, kann die Nummer mit einem kleinen Programm festgestellt werden:
10 FORI=0TO255
20 #I,STR$(I)
30 NEXTI

Nachdem dieses kleine Programm mit RUN gestartet wird, erscheint beim Druck auf jede Taste eine Zahl auf dem Bildschirm. Diese Zahl ist die Nummer der Taste. Es sind jedoch nicht alle 256 Werte von der Tastatur aus erreichbar. Insgesamt erhält man jedoch 187 programmierbare Tastenfunktionen. Diese Zahl reduziert sich jedoch noch einmal, da es nicht sinnvoll ist, manche Tasten, wie zum Beispiel die RETURN-Taste umzudefinieren, da diese wichtige Funktionen erfüllen.

Mit dem # -Befehl können jeder Taste bis zu 10 Zeichen zugeordnet werden. Versuchen Sie es doch einmal, zum Beispiel mit:
\#12,"LIST"+CHR$(13)

Wenn Sie nun gleichzeitig CTRL und L drücken, erscheint der Befehl LIST auf dem Bildschirm und wird gleich ausgeführt. Haben Sie nach einer Zeit des Herumprobierens den Wunsch, die alte Tastaturbelegung wieder herzustellen, so ist dies ganz einfach mit dem Befehl SYS 49152+9 möglich.

Außerdem kann die Belegung der Tastatur gespeichert und wieder geladen werden. Die Befehle dazu sind:
Speichern: SYS 49152+12,"name",ga
Laden: SYS 49152+15,"name",ga
»ga« ist dabei die Geräteadresse, also 1 für Kassettenrecorder und 8 für Diskettenlaufwerk. So kann jeder seine »ideale« Lösung auf einfachste Weise festhalten.

## Tastatur-Generator

Die Anwendungsgebiete der programmierten Tastaturen sind nahezu unbegrenzt. So läßt sich der C 64 wie der SX 64 an ein Diskettenlaufwerk anpassen. Mit:
\#131, "LOAD"+CHR$(34)+ " * " +CHR$(34)+ ",8"
wird die RUN/STOP-Taste so umdefiniert, daß nicht mehr ein Kassettenprogramm, sondern das erste Programm von der Diskette geladen wird.

Da KEY-PROGGER auch ohne Probleme mit dem DOS 5.1 zusammenarbeitet, istjetztauch ein Directoryauf Knopfdruck möglich.

Will man gleichzeitig mit KEY-PROGGER und Hypra-Load arbeiten, so muß man erst Hypra-Load und dann KEY-PROGGER mitSYS 49152+18 statt mit SYS 49152 starten.

Am einfachsten ist die Belegung der Tastatur mit dem Tastatur-Generator. Nach Abtippen von Listing 2 speichern Sie den Tastatur-Generator zuerst ab. Nun laden Sie KEY-PROGGER wie oben beschrieben und geben anschließend NEW ein. Danach können Sie den Tastatur-Generator laden und mit RUN starten. Der Tastatur-Generator startet KEY-PROGGER automatisch. Nach zirka fünf Sekunden meldet sich der Tastatur-Generator mit der Frage, welche Taste umdefiniert werden soll. Sie brauchen nur diese Taste zu drücken. Der Computer zeigt dann, wie die Taste bisher belegt war. Danach können Sie Ihre neue Belegung in ein 10Zeichen breites Feld eingeben. Die Taste DEL löscht die Eingabe. Mit RETURN wird die Eingabe abgeschlossen. Haben Sie einen Befehl eingegeben, der sofort nach Drücken der Taste ausgeführt werden soll, zum Beispiel RUN, so schließen Sie die Eingabe mit SHIFT RETURN ab. Drücken Sie RETURN,'ohne eine neue Belegung eingegeben zu haben, so bleibt die alte Belegung erhalten.

Nach der Eingabe erscheint ein Menü, mit dem Sie die Definitionen fortsetzen können (1), die letzte Eingabe rückgängig machen (2), die neue Tastaturbelegung speichern (3), die ursprüngliche Belegung wieder herstellen (4) oder das Programm beenden können (5). Somit kann sich jeder auf einfachste Weise eine individuelle Tastaturbelegung gestalten.

(Markus Stecher/ah)

# Komfortable Menüsteuerung \[108\]

> Mit diesem Basic-Unterprogramm läßt sich durch einfache Parameterübergabe eine Menü-Zeile frei definieren, mit der Sie auf Tastendruck bis zu 19 weitere Routinen anwählen können.

Das zirka 800 Byte lange Unterprogramm (ohne REM) erspart bei der Erstellung eines menügesteuerten Programms die immer wiederkehrenden Abfragen nach gedrückten oder nichtgedrückten Tasten.

Man ruft im laufenden Programm nur das Unterprogramm (Listing) auf und die gewünschte Menüzeile erscheint zentriert in der vorletzten Zeile des Bildschirms.

Mit den Cursor-Tasten (links/rechts) verschiebt man ein re-vers erleuchtetes Feld, das auf das Menü-Wort positioniert werden kann. Mit RETURN übernimmt man das Menü-Wort und verläßt das Unterprogramm. Um mehrere Menüs zu erstellen, sind die Angaben aller Menüs am Anfang des Hauptprogramms den Variablen d$(1), d$(2) undsoweiterzuzuordnen.

Im laufenden Programm wird nun das Unterprogramm folgendermaßen aufgerufen:
AN=3:az=4:GOSUB 1000
AN=Anfang des Menü-Wortes (hier drittes Menü-Wort)
AZ=Anzahl der Menü-Worte (hier vier Worte)

Es werden also die Strings d$(3) bis d$(4) ausgegeben. Das Unterprogramm übergibt den Parameter kk in Abhängigkeit des gewählten Menü-Wortes und der Position der Menü-Zeile. Hat man also zum Beispiel das dritte Menü-Wort von links ausgewählt, so wird kk=3 übergeben.

Nach dem GOSUB ist eine Weiterbehandlung mit
ON kk GOSUB 11,22,33,44,...
am sinnvollsten.

Man erkennt sofort, welche Vorteile das Programm hat. Änderungen können sehr einfach durchgeführt werden und im laufenden Programm sind nur zwei Zeilen nötig, um eine Verzweigung zu bewirken.

Anmerkung: Die Menü-Zeile sollte nicht mehr als 38 Zeichen haben, sonst werden die Menü-Worte jeweils um ein Zeichen gekürzt dargestellt. Bei mehr als 38 Zeichen plus Anzahl der Menü-Worte erscheint eine Fehlermeldung.

(M. Schacht/ah)

# Anhalter — Programmstop auf Tastendruck \[109\]

> Mit dieser kleinen Maschinensprach-Routine können Sie jedes Programm anhalten. Der Computer stoppt so lange, bis Sie eine Taste drücken

Dieses kleine Maschinenprogramm kann Ihnen in vielerlei Hinsicht nützlich sein. Man kann sich beispielsweise folgende Anwendungsgebiete vorstellen: In einem selbstprogrammierten Spiel wird oft eine Pause-Taste benötigt, ähnlich, wie es sie auch in manchen kommerziellen Spielen gibt Auch das Auflisten von Programmen kann jederzeit angehalten werden und sogar der Datenfluß zur Floppy ist gegen eine Unterbrechung nicht gefeit Mit dem Programm »Anhalter« steht es Ihnen vollkommen frei, zu entscheiden, an welchen Stellen ein Programm angehalten werden soll.

Nach dem Starten des Programms (siehe Listing 1) werden Sie zunächst gefragt, wohin das Programm verschoben werden soll (bitte Dezimalzahlen eingeben). Da das Programm vollkommen frei verschiebbar ist, brauchen Sie keine weiteren Angaben zu machen. Danach brauchen Sie nur noch die Funktionstaste F1 zu drücken um Ihr Programm zu stoppen. Soll das Programm weiter laufen, so genügt es, eine beliebige Taste zu betätigen.

Falls Sie nicht die F1-Taste, sondern eine andere mit der An-halte-Funktion belegen möchten, so ist dies möglich. Dazu brauchen Sie nur in die Speicherstelle (Startadresse + 16) den Wert der neuen Taste hineinschreiben. Diesen Wert erhalten Sie, indem Sie folgende Zeile im Direktmodus eingeben, die gewünschte Taste drücken und sich die angezeigte Zahl merken.
FOR I=1 TO 10000 : PRINT PEEK(203): NEXT

Jetzt können Sie die Abfrage ändern:
POKE Startadresse + 16,X (X=neuer Wert)

Listing 2 erläutert die genaue Funktionsweise des Programmes.

(Georg Kramer/aw)

# Variable Funktionen \[109-110\]

> Normalerweise werden Formeln in Programmen fest definiert. Mit dieser kleinen Basic-Erweiterung können Sie Funktionen auch während des Programmablaufs eingeben und ändern.

Um in einem Basic-Programm Formeln zu definieren hatte man bislang nureine Möglichkeit: die Formel mitdem DEF FN-Befehl in einer Basic-Zeile zu definieren. Vom laufenden Programm aus war das nicht möglich. Dabei wird der Funktionswert zum Beispiel mit A=FNA(X) oder mit PRINT FNB(Y) aufgerufen.

Es geht aber auch anders, nämlich mit diesem kurzen Maschinenprogramm (Listing 1), das mit dem MSE einzugeben ist. Den Quell-Code dazu finden Sie in Listing 2. Das Programm wird mit LOAD"VARFUNKT",8,1 und nachfolgendem NEW geladen, sofern es nicht von einem anderen Programm nachgeladen wird. Das Einbinden in die Interpreter-Routine (=Initialisierung) wird mit SYS(49351) vorgenommen.

### Aufruf aus dem Programm

Die Übergabe der Variablen erfolgt in der denkbar einfachsten Art: die Formel steht in einer String-Variablen wie zum Beispiel X$. DaX$ ein normalerString ist, kann man die Formel natürlich auch über den INPUT-Befehl oder eine GET-Schleife eingeben, wobei man bei INPUT nicht über 80 Zeichen kommt undGET eine programmbedingte Längenbegrenzung von 127 Zeichen hat. Die Syntax ist dabei die des normalen Basic mit sämtlichen Basic-Funktionen. Das heißt, daß man zum Beispiel die Formel »5 SIN X« als »5 * SIN(X)« eingibt. Dabei bedeutet X wiederum eine Variable. Natürlich kann die Formel beliebig viele Variablen, beziehungsweise beliebig verschachtelte Basic-Funktionen enthalten.

Die Syntax des neuen Befehls ist

↑ Y=B$
Hier wird der Variablen Y der Wert des berechneten Strings X$ zugewiesen.

Hierzu noch ein Beispielprogramm, das das Programm »Var-funkt« auf Diskette erwartet:

10 IFA=0THENA=1 :PRINT"\[home\]" :LOAD"VARFUNKT",8,1
20 SYS 49351
30 INPUT " pown\] FUNKTION UEBER X " ;X$
40 INPUT " WERT FUER X " ;X
50 t Y=X$
60 PRINT " FUNKTIONSWERT = " ;Y
70 GOTO 30

In Zeile 10 wird beim Start die Maschinenroutine »Varfunkt« nachgeladen. Die IF-Abfrage ist nötig, da der Interpreter nach einem LOAD-Befehl das Programm erneut startet.

Der SYS-Aufruf in 20 bindet das nachgeladene Programm in das Betriebssystem ein.

In den Zeilen 30 und 40 werden Funktion und Wert für die Funktion eingegeben.

Zeile 50 schließlich übergibt den berechneten Wert aus X$ an die Variable Y, die in 60 ausgegeben wird.

Zeile 70schließt das Beispielprogramm ab, indem wieder in Zeile 30 zur Funktionseingabe gesprungen wird.

(Jens Weber/og)

# Cross-Ref 64 — Basic-Pro-gramme unter der Lupe \[111-116,118-121\]

> Wenn man zu einem Basic-Programm eine Liste aller Sprungadressen, Schleifen und Variablen hat, ist das eine sehr gute Hilfe Nicht nur während des Programmierens, sondern auch zur nachträglichen Dokumentation. Eine solche Liste erstellt dieses Maschi-nen-Programm.

Cross-Ref 64 durchsucht in zwei Durchgängen (Passes) ein Basic-Programm nach Sprungbefehlen und Variablen. Sämtliche Sprungziele und Variablennamen werden dann auf einem Drucker in Form einer Tabelle ausgegeben. Eine solche Tabelle nennt man Cross-Reference-List.

Das Basic-Programm kann dazu übrigens irgendwo im Basic-Speicher liegen. Es muß nicht bei Adresse $0801 beginnen. Das ist wichtig, denn häufig wird der untere Basic-Speicherteil für Sprites reserviert.

### 1.	Durchgang

Im ersten Durchlauf (Pass) werden Sprunganweisungen und FOR-NEXT-Schleifen gesucht und alle Zeilennummern der Zeilen ausgegeben, die eine Sprunganweisung enthalten oder angesprungen werden. Dabei werden alle Sprünge berücksichtigt, die das C 64-Basic 2.0 bietet. FOR-NEXT-Schleifen werden durch die Laufvariable gekennzeichnet. Eventuell vorhandene, noch nicht zu Ende geschriebene FOR-NEXT-Schleifen werden mit einem »*« markiert.

### 2.	Durchgang

Hier werden alle Variablen eines Basic-Programms gesucht und ausgegeben.

Die Ausgabe der Cross-Reference-Liste kann in beiden Durchgängen entweder auf Bildschirm oder Drucker erfolgen. Bei Bildschirmausgabe allerdings auch im Druckerformat mit 80 Zeichen/Zeile. Das bedeutet, daß zwei Bildschirmzeilen immer eine Druckerzeile darstellen. Doch wie sinnvoll ist überhaupt eine Dokumentation auf dem Bildschirm? Das Programm ist auf einen Epson-Drucker mit Görlitz-Interface angepaßt. Es kann aber leicht so verändert werden, daß es auch für andere Drucker geeignet ist. Es müssen nur vier Speicherzellen mit POKE-Befehlen verändert werden.

Einstellung der Geräteadresse:
POKE 50517, GA : POKE 50519, GA
Einstellung der Sekundäradresse:
POKE 50521, SA+96 : POKE 50529, SA+96

Mit einem Monitor wie dem SMON oder dem Einzeiler »Maschinenprogramme speichern« (Ausgabe 11/84) können Sie die auf Ihren Drucker angepaßte Programmversion speichern:

SYS57812a$,x:POKE193,ls:P0KE194,hs:P0KE174,le:POKE 175,he:SYS62957

Dadurch ersparen Sie sich die lästigen POKE-Befehle nach jedem Laden von Cross-Ref 64. Das Programm belegt den Speicherbereich von $C000 (49152) bis $CAB6 (51894). Um Ihnen eventuelle Berechnungen zu ersparen: Das Highbyte (hs) von 49152 ist 192 das Lowbyte (ls) 0. Das Highbyte von 51894 (he) ist 202, das Lowbyte (le) 182.

## Übersichtliches Ausgabeformat

Wie schon erwähnt, werden alle Zeilen, in denen ein Sprung erfolgt, ausgegeben. Die gezeigte Tabelle (Tabelle 1) bezieht sich auf das Beispielprogramm (Listing 1). Man kann sich auch eine Liste aller Sprungziele drucken lassen (Tabelle 2). Die Ausgabe erfolgt mit 80 Zeichen pro Zeile, dem üblichen Druckerformat.

Sollten offene FOR-NEXT-Schleifen (ohne NEXT) vorhanden sein, wird nach einem »*« die Anzahl der fehlenden NEXT-Befehle angezeigt. Sollte die Anzahl 255 betragen, heißt das, daß ein NEXT zuviel gefunden wurde.

Sollten in einer Basic-Zeile mehrere Sprünge auftreten, wird die mehrmalige Ausgabe der Zeilennummer unterdrückt.

Bei Sprungbefehlen der Form ON X GOSUB wird das Argument nach ON durch »—« ersetzt, da auch ganze Basic-Funk-tionen als Argument erlaubt sind. Um diese Funktionen zu berücksichtigen, wäre ein zu großer Programmieraufwand nötig. Treten nach einem THEN mehrere Sprünge auf, wird jedem Sprungziel ein THEN vorangestellt. Eine solche Befehlsfolge ist beispielsweise
IF X=1 THEN GOSUB 100:GOSUB 200:GOSUB 300.
Bei FOR-NEXT-Schleifen wird der ganze Variablenname angegeben.

Die Variablennamen werden in einer eigenen Tabelle ausgegeben (Tabelle 3). Hier werden die Namen allerdings auf zwei Zeichen gekürzt. In der Tabelle steht nach dem Namen der Variable der Variablentyp (Real, Integer oder String). Zwei Klammern »()« zeigen an, daß es sich um eine indizierte Variable handelt. Da eine Variable in einem Programmbereich sehr häufig benutzt werden kann, werden bei Mehrfachnennung einer Variablen nur noch die Zeilennummern angegeben; so lange, bis eine andere Variable aufgerufen wird. Wird einer Variablen ein anderer Wert zugeordnet (A=A+1), wird die Zeilennummer mit einem Stern »*« gekennzeichnet. Bei der sortierten Variablenausgabe (Tabelle 4), werden nach dem Variablenna-men alle Zeilen aufgeschlüsselt, in denen die Variable vorkommt. Das Sortieren geschieht nach den folgenden Kriterien:

1.	Typ: Real, integer, Strings, Felder
2.	Name alphabetisch
3.	Zeilennummern in aufsteigender Reihenfolge.

Die Ausgabe kann jederzeit durch Tastendruck gestoppt werden. Eine begonnene Druckzeile wird zu Ende gedruckt. Bei einem weiteren Tastendruck fährt das Programm fort. Mit RUN/STOP kann die Ausgabe abgebrochen werden.

### Tips zu Eingabe und Benutzung

Das Maschinen-Programm (Listing 2) sollten Sie mit dem MSE eingeben. Es wird durch »SYS 49152, Parameterliste, Bereich« gestartet. Die »Parameterliste« muß aus genau fünf Zeichen bestehen (Leerzeichen nicht mitgerechnet). Folgende Zeichen sind erlaubt:

1.	Steife: P — Ausgabe auf Drucker
2.	Stelle: S — Ausgabe der Zeilen mit Sprungbefehlen (Tabelle 1)
3.	Stelle: J — Ausgabe der angesprungenen Zeilen (nur zusammen mit »S« an zweiter Stelle möglich (Tabelle 2)
4.	Stelle: V — Ausgabe der benutzten Variablen in der Reihen-
folge des Auftretens (Tabelle 3)
5.	Stelle: J — Ausgabe der benutzten Variablen in sortierter Reihenfolge (Tabelle 4)

Werden andere Zeichen an der entsprechenden Stelle angegeben, dann wird der Programmpunkt nicht ausgeführt.

Die Bereichsangabe ist optional und hat die gleiche Syntax wie beim LIST-Befehl. Falls ein Zeilenbereich angegeben wird, analysiert das Programm auch nur den entsprechenden Abschnitt. Ein Beispiel:

Es sollen alle Sprungbefehle und alle Variablen im Zeilenbereich 100-200 gesucht werden. Die Ausgabe soll auf dem Drucker erfolgen. Der entsprechende SYS-Aufruf lautet dann: SYS 49152, PS..J,100-200

Anstelle der Punkte kann dabei jedes beliebige andere Zeichen mit Ausnahme des Kommas angegeben werden.

Zum Sortieren der Variablen und für die Ausgabe der angesprungenen Zeilen wird das »Bubblesort«-Verfahren verwendet, da es besonders einfach in Assembler (Listing 3, Quellcode) programmiert werden kann. Die Variablen- und Sprungtabelle wird im Bereich $A000 bis $BFFF, also »unter« dem Basic-ROM, abgelegt. Falls also eine Basic-Erweiterung verwendet wird, darf dieser Speicherbereich dadurch nicht verändert werden.

(Peter Rüschhoff-Nadermann/hm)

# Impressum \[122\]

**Herausgeber**: Carl-Franz von Quadt, Otmar Weber

---

**Chefredakteur**: Michael Scharfenberger Leitender Redakteur: Albert Absmeier Redaktion: Volker Everts, Achim Hübner, Georg Klinge, Harald Meyer, Markus Ohnesorg, Christian Rogge, Thomas Röder, Arnd Wängler.
**Fremdautoren**:
Barcikowski, Baumann, Blaumeiser, Brenschede, Bretthauer, Brunzema, Burmeister, Bödecker, Dietz, Diezmann, Feldmann, Frink, Gerlach, Golombek, Graves, Großauer, Hahn, lrkens, Klinger, Knipp, Kramer, Kunz, Kusch, Köhler, Köhne, Lang, Linsd, Lonczewski, Luhmann, Mann, Matzner, Mayer, Pflaum, Rest, Rüschhoff-Nadermann, Sauer, Schacht, Schneider, Sprehe, Spörri, Stecher, Stuke, Temme, Wagner, Weber, Weihe, Weinbrenner, Weineck.

---

**Layout**: Leo Eder (Ltg.)

---

**Herstellung**: Klaus Buck

---

**Auslandsrepräsentation**:
Schweiz:
Markt & Technik Vertriebs AG, Kollerstr. 3, CH-6300 Zug, Tel. 042-22 31 55, Telex: 862 329
USA:
M&T Publishing lnc.; 2464 Embarcadero
Way, Palo Alto, CA 94303

---

**Manuskripteinsendungen**: Manuskripte und Programmlistings werden gerne von der Redaktion angenommen. Sie müssen frei sein von Rechten Dritter. Sollten sie auch an anderer Stelle zur Veröffentlichung oder gewerblichen Nutzung angeboten werden, so muß dies angegeben werden. Mit der Einsendung von Manuskripten und Listings gibt der Verfasser die Zustimmung zum Abdruck in von der Markt & Technik Verlags AG herausgegebenen Publikationen und zur Vervielfältigung der Programmlistings auf Datenträger. Mit der Einsendung von Bauanleitungen gibt der Einsender die Zustimmung zum Abdruck in von Markt & Technik Verlag AG verlegten Publikationen und dazu, daß Markt & Technik Verlag AG Geräte und Bauteile nach der Bauanleitung herstellen läßt und vertreibt oder durch Dritte vertreiben läßt. Honorare nach Vereinbarung. Für unverlangt eingesandte Manuskripte und Listings wird keine Haftung übernommen.

---

**Vertriebsleitung**: Hans Hörl

---

**Anzeigenverwaltung und Disposition**: Michaela Hörl

---

**Verlagsleiter M&T-Buchverlag**: Günther Frank

---

**Druck**: Druckhaus München GmbH, Schellingstraße 39-43, 8000 München 40 Auch Anschrift für Beihefter und Beilagen.

---

**Preis**: Das Einzelheft kostet DM 14,—

---

**Vertrieb Handelsauflage**: Inland (Groß-, Einzel- und Bahnhofsbuchhandel) sowie Österreich und Schweiz: Pegasus Buch- und Zeitschriften-Vertriebs GmbH, Hauptstätter Straße 96, 7000 Stuttgart 1, Telefon (0711) 76 48 30

---

**Urheberrecht**: Alle in diesem Heft erschienenen Beiträge sind urheberrechtlich geschützt. Alle Rechte, auch Übersetzungen, vorbehalten. Reproduktionen gleich welcher Art, ob Fotokopie, Mikrofilm oder Erfassung in Datenverarbeitungsanlagen, nur mit schriftlicher Genehmigung des Verlages. Anfragen sind an Michael Scharfenberger zu richten. Für Schaltungen, Bauanleitungen und Programme, die als Beispiele veröffentlicht werden, können wir weder Gewähr noch irgendwelche Haftung übernehmen. Aus der Veröffentlichung kann nicht geschlossen werden, daß die beschriebenen Lösungen oder verwendeten Bezeichnungen frei von gewerblichen Schutzrechten sind. Anfragen für Sonderdrucke sind an Peter Wagstyl (185) zu richten.

---

**© 1985 Markt & Technik Verlag Aktiengesellschaft**

---

**Verantwortlich**:
Für redaktionellen Teil: Michael Scharfenberger Für Anzeigen: Brigitte Fiebig
**Redaktions-Direktor**: Michael M. Pauly

---

**Vorstand**: Carl-Franz von Quadt, Otmar Weber

---

**Anschrift für Verlag, Redaktion, Vertrieb, Anzeigenverwaltung und alle Verantwortlichen**:
Markt & Technik Verlag Aktiengesellschaft, Hans-Pinsel-Straße 2, 8013 Haar bei München, Telefon (0 89) 4613-0, Telex 5-22 052

---

Aktionäre, die mehr als 25% des Kapitals halten: Otmar Weber, Ingenieur, München; Carl-Franz von Quadt, Betriebswirt, München. Aufsichtsrat: Dr. Robert Dissmann (Vorsitzender), Karl-Heinz Fanselow, Eduard Heilmayr

---
