<!DOCTYPE html>
<html lang="de">

<head>
    <title>Der gläserne VC 20 – Teil 3</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Christoph Sauer, ev">
    <meta name="64er.issue" content="11/84">
    <meta name="64er.pages" content="126-132">
    <meta name="64er.head1" content="Kurs">
    <meta name="64er.head2" content="VC 20">
    <meta name="64er.toc_category" content="Kurse">
    <meta name="64er.toc_title" content="Der gläserne VC 20 (Teil 3)">
    <meta name="64er.index_category" content="Kurse|VC 20">
    <meta name="64er.id" content="vc20">
</head>

<body>
    <article>

        <h1>Der gläserne VC 20 – Teil 3</h1>

        <p class="intro">In der letzten Folge befaßten wir uns schwerpunktmäßig mit der Zeropage. Diesmal wird der sich daran anschließende Adreßbereich von $0100 bis $03FF unter die Lupe genommen.</p>

        <p>Dieser Bereich ist so interessant, daß sich die Betrachtungen darüber bis in die 4. Folge erstrecken werden. Übrigens ist dieser Teil auch auf den C 64 anwendbar, denn Betriebssytem und Basic-Interpreter dieser beiden Computer sind ja nahezu identisch.</p>

        <p>Wenn wir einen Basic-Befehl im Direktmodus (LIST, RUN, PRINT) oder eine Programmzeile mit Zeilennummer eingeben, werden die Informationen — wie bekannt — auf den Bildschirm geschrieben und gelangen gleichzeitig in den Basic-Eingabepuffer (Adresse 512-600/ $0200-$0258). Dort werden Programmzeilen oder direkte Befehle zunächst einmal im ASCII-Format gesammelt (Bild 1a). Dies geschieht solange, bis man die RETURN-Taste betätigt.</p>

        <figure>
            <img src="126-1a.png" alt="">
            <figcaption>Bild 1a. Die Basic-Befehle im Eingabepuffer vor der Umwandlung in Interpretercode</figcaption>
        </figure>

        <p>Dieser Puffer hat eine Kapazität von 88 Zeichen — also den bekannten vier Bildschirmzeilen.</p>

        <h2>Der Weg einer Eingabezeile</h2>

        <p>Drückt man die RETURN-Taste, so beginnt der Interpreter mit der Auswertung der Kommandos. Eingaben ohne Zeilennummer werden auf ihre Syntax hin überprüft und danach ausgeführt.</p>

        <p>Verfolgen wir nun einmal genauer den Weg einer Befehlszeile. Die einzelnen ASCII-Zeichen werden von der inzwischen hinreichend bekannten CHRGET-Routine aus dem Puffer gelesen und mit den Befehlswörtern aus dem ROM verglichen. War die Überprüfung positiv — ist der Befehl als identifiziert worden —, so verkürzt der Computer die Kommandozeile, indem er die Befehle in Token (siehe Teil 1, Tabelle 1) umwandelt. Diese Prozedur durchlaufen sowohl die Programmzeilen (mit Zeilennummer) als auch die direkten Kommandos (Bild 1b). An dieser Stelle trennen sich nun aber die Wege dieser beiden Zeilentypen.</p>

        <figure>
            <img src="126-1b.png" alt="">
            <figcaption>Bild 1b. Die Kommandos im Puffer nach der Übersetzung in Token</figcaption>
        </figure>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <th class="separator"><b>Dezimal</b></th>
                        <th class="separator"><b>Hexadezimal</b></th>
                        <th class="separator"><b>Bemerkung</b></th>
                    </tr>
                    <tr>
                        <td>255-266</td>
                        <td>00FF-010A</td>
                        <td>Arbeitsspeicher für Fließkomma nach ASCII</td>
                    </tr>
                    <tr>
                        <td>256-318</td>
                        <td>0100-013E</td>
                        <td>Korrekturpuffer für Bandbetrieb</td>
                    </tr>
                    <tr>
                        <td>256-511</td>
                        <td>0100-01FF</td>
                        <td>Prozessor Stack</td>
                    </tr>
                    <tr>
                        <td>512-600</td>
                        <td>0200-0258</td>
                        <td>Basic-Eingabepuffer</td>
                    </tr>
                    <tr>
                        <td>601-610</td>
                        <td>0259-0262</td>
                        <td>Tabelle der logischen Filenummern...</td>
                    </tr>
                    <tr>
                        <td>611-620</td>
                        <td>0263-026C</td>
                        <td>....sowie der dazugehörigen Gerätenummern....</td>
                    </tr>
                    <tr>
                        <td>621-630</td>
                        <td>026D-0276</td>
                        <td>...und der entsprechenden Sekundäradressen</td>
                    </tr>
                    <tr>
                        <td>631-640</td>
                        <td>0277-0280</td>
                        <td>Tastaturpuffer</td>
                    </tr>
                    <tr>
                        <td>641-642</td>
                        <td>0281-0282</td>
                        <td>Start des verfügbaren RAM-Bereichs</td>
                    </tr>
                    <tr>
                        <td>643-644</td>
                        <td>0283-0284</td>
                        <td>Ende des verfügbaren RAM-Bereichs</td>
                    </tr>
                    <tr>
                        <td>645</td>
                        <td>0285</td>
                        <td>Timeout-Flag für den seriellen Port</td>
                    </tr>
                    <tr>
                        <td>646</td>
                        <td>0286</td>
                        <td>Aktueller Farbcode</td>
                    </tr>
                    <tr>
                        <td>647</td>
                        <td>0287</td>
                        <td>Farbe unter dem Cursor</td>
                    </tr>
                    <tr>
                        <td>648</td>
                        <td>0288</td>
                        <td>High-Byte des Bildschirmspeichers (Information für das Betriebssystem)</td>
                    </tr>
                    <tr>
                        <td>649</td>
                        <td>0289</td>
                        <td>Größe des Tastaturpuffers (Maximum 10)</td>
                    </tr>
                    <tr>
                        <td>650</td>
                        <td>028A</td>
                        <td>Repeat-Flag (0: Cursor + Space/ 64: Keine Taste/ 128: Alle Tasten mit Repeat)</td>
                    </tr>
                    <tr>
                        <td>651</td>
                        <td>028B</td>
                        <td>Repeat-Zähler (bestimmt die Wartezeit bis die Taste wiederholt wird)</td>
                    </tr>
                    <tr>
                        <td>652</td>
                        <td>028C</td>
                        <td>Repeat-Verzögerung (bestimmt die Zeit, bis die Taste das erste mal wiederholt wird)</td>
                    </tr>
                    <tr>
                        <td>653</td>
                        <td>028D</td>
                        <td>Kontrolltasten-Flag (1: SHIFT/ 2: CBM/ 4: CTRL. Es können auch 2 Tasten erkannt werden zum Beispiel 5: SHIFT + CTRL)</td>
                    </tr>
                    <tr>
                        <td>654</td>
                        <td>028E</td>
                        <td>Letzte Kontrolltaste (Identisch mit 653)</td>
                    </tr>
                    <tr>
                        <td>655-656</td>
                        <td>028F-0290</td>
                        <td>Vektor für Tastaturdecodierung</td>
                    </tr>
                    <tr>
                        <td>657</td>
                        <td>0291</td>
                        <td>Flag für SHIFT + CBM gesperrt (keine Groß-Kleinschrift Umschaltung. 0: Normal/ 128: Sperre)</td>
                    </tr>
                    <tr>
                        <td>658</td>
                        <td>0292</td>
                        <td>Flag für Scrolling</td>
                    </tr>
                    <tr>
                        <td>659-670</td>
                        <td>0293-029E</td>
                        <td>RS 232 Register, Zeiger, ect.</td>
                    </tr>
                    <tr>
                        <td>671-672</td>
                        <td>029F-02A0</td>
                        <td>Zwischenspeicher für IRQ bei Bandbetrieb</td>
                    </tr>
                    <tr>
                        <td>673-676</td>
                        <td>02Al-02A4</td>
                        <td>Diverse VIA-Zeiger</td>
                    </tr>
                    <tr>
                        <td>677-767</td>
                        <td>02A5-02FF</td>
                        <td>Zwischenspeicher einer Bildschirmzeile</td>
                    </tr>
                    <tr>
                        <td>786-769</td>
                        <td>0300-0301</td>
                        <td>Vektor für Fehlermeldung (C43A)</td>
                    </tr>
                    <tr>
                        <td>770-771</td>
                        <td>0302-0303</td>
                        <td>Vektor für Basic-Warmstart (C483)</td>
                    </tr>
                    <tr>
                        <td>772-773</td>
                        <td>0304-0305</td>
                        <td>Vektor für Umwandlung von ASCII in Token (C579)</td>
                    </tr>
                    <tr>
                        <td>774-775</td>
                        <td>0306-0307</td>
                        <td>Vektor für Umwandlung von Token in ASCII (C717)</td>
                    </tr>
                    <tr>
                        <td>776-777</td>
                        <td>0308-0309</td>
                        <td>Vektor für Basic-Befehlsadresse (C7E1)</td>
                    </tr>
                    <tr>
                        <td>778-779</td>
                        <td>030A-030B</td>
                        <td>Vektor für arithmetisches Element (CE83)</td>
                    </tr>
                    <tr>
                        <td>780</td>
                        <td>030C</td>
                        <td>Akku für SYS-Befehl (Bei SYS wird 780 in den Akku geladen)</td>
                    </tr>
                    <tr>
                        <td>781</td>
                        <td>030D</td>
                        <td>X-Reg für SYS-Befehl</td>
                    </tr>
                    <tr>
                        <td>782</td>
                        <td>030E</td>
                        <td>Y-Reg für SYS-Befehl</td>
                    </tr>
                    <tr>
                        <td>783</td>
                        <td>030F</td>
                        <td>Speicher für Status Register für SYS-Befehl</td>
                    </tr>
                    <tr>
                        <td>788-789</td>
                        <td>0314-0315</td>
                        <td>IRQ-Vektor (EABF) *** Kernal-Vektoren</td>
                    </tr>
                    <tr>
                        <td>790-791</td>
                        <td>0316-0317</td>
                        <td>BRK-Vektor (FED2)</td>
                    </tr>
                    <tr>
                        <td>792-793</td>
                        <td>0318-0319</td>
                        <td>NMI-Vektor (FEAD)</td>
                    </tr>
                    <tr>
                        <td>794-795</td>
                        <td>031A-031B</td>
                        <td>OPEN-Vektor (F40A)</td>
                    </tr>
                    <tr>
                        <td>796-797</td>
                        <td>031C-031D</td>
                        <td>CLOSE-Vektor (F34A)</td>
                    </tr>
                    <tr>
                        <td>798-799</td>
                        <td>031E-031F</td>
                        <td>Kanal für Eingabe (CHKIN, F2C7)</td>
                    </tr>
                    <tr>
                        <td>800-801</td>
                        <td>0320-0321</td>
                        <td>Kanal für Ausgabe (CHOUT, F309)</td>
                    </tr>
                    <tr>
                        <td>802-803</td>
                        <td>0322-0323</td>
                        <td>Kanäle initialisieren (CLRCH, F3F3)</td>
                    </tr>
                    <tr>
                        <td>804-805</td>
                        <td>0324-0325</td>
                        <td>Eingabe-Vektor (F20E)</td>
                    </tr>
                    <tr>
                        <td>806-807</td>
                        <td>0326-0327</td>
                        <td>Ausgabe-Vektor (F27A)</td>
                    </tr>
                    <tr>
                        <td>808-809</td>
                        <td>0328-0329</td>
                        <td>Vektor für STOP-Taste prüfen (F770)</td>
                    </tr>
                    <tr>
                        <td>810-811</td>
                        <td>032A-032B</td>
                        <td>GET-Vektor (F1F5)</td>
                    </tr>
                    <tr>
                        <td>812-813</td>
                        <td>032C-032D</td>
                        <td>Alle Files schließen ((F3EF)</td>
                    </tr>
                    <tr>
                        <td>814-815</td>
                        <td>032E-032F</td>
                        <td>User-Vektor (FED2)</td>
                    </tr>
                    <tr>
                        <td>816-817</td>
                        <td>0330-0331</td>
                        <td>LOAD-Vektor (F549)</td>
                    </tr>
                    <tr>
                        <td>818-819</td>
                        <td>0332-0333</td>
                        <td>SAVE-Vektor (F685)</td>
                    </tr>
                    <tr>
                        <td>828-1019</td>
                        <td>033C-03FB</td>
                        <td>Kassettenpuffer</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 1. Die Adreßbelegung der Seiten 2 bis4 beim VC 20</figcaption>
        </figure>

        <p>Zunächst zu dem weiteren Weg einer Programmzeile. Die inzwischen komplett übersetzte Zeile im Basic-Puffer wird nun in einem zweiten Durchlauf vom Zwischenspeicher in den Programmspeicher übertragen, wobei sie auch gleich richtig eingeordnet wird (damit die Reihenfolge der Zeilennummern stimmt). Weil sich dadurch der Programmbereich im Basic-Speicher vergrößert, muß der Variablenbereich weiter oben angesiedelt werden. Die bis dahin gespeicherten Variablen werden dadurch natürlich überschrieben. Nach dem Übertragen der Programmzeile springt das Interpreterprogramm wieder in die Warteschleife zurück, damit weitere Befehle entgegen genommen werden können.</p>

        <p>Nun möchte ich den weiteren Weg einer Direktmoduszeile beschreiben, denn der verläuft anders. Nachdem die Zeile mit Hilfe der CHRGET-Routine in Interpretercode (also Token) umgewandelt worden ist, wird der 2-Byte-Zeiger ($7A-$7B) auf den Pufferanfang zurückgestellt und der Inhalt wie eine Programmzeile behandelt und abgearbeitet (wieder mit Hilfe der CHRGET-Routine).</p>

        <h2>Verbotenes</h2>

        <p>Die Befehle INPUT und GET dürfen im Direktmodus nicht verwendet werden. Der Grund liegt darin, daß diese Eingabebefehle ebenfalls den Basic-Eingabepuffer zur Zwischenspeicherung der Daten verwenden. Das »Direktmodusprogramm«, was sich zu dieser Zeit im Puffer befindet, würde dann überschrieben. Um das zu verhindern, sind diese Kommandos im Direktmodus verboten (Fehlermeldung »ILLEGAL DIRECT«).</p>

        <h2>Die Tastaturverwaltung</h2>

        <p>Die Schlüsselfunktionen für Basic wie beispielsweise die Umwandlung der ASCII-Zeichen in Token (wie eben beschrieben), Umwandlung der Token in Klartext (die Befehlswörter werden bei LIST wieder als ASCII-Zeichen sichtbar gemacht), werden durch indirekte Sprünge über Vektoren abgewickelt. Durch Zusatzroutinen besteht so die Möglichkeit, Klartextbefehle wie SOUND, KEY, OLD ect. in den Interpreter mit einzubinden. Dieses Verfahren besprechen wir später, zunächst aber schreiten wir in der Betrachtung des Adreßbereiches von $0277-$03FF fort (dieser ist in Tabelle 1 genauer aufgelistet).</p>

        <p>Der nächste, größere Komplex, den wir hier behandeln wollen, ist die Tastaturverwaltung. Wie sie bestimmt schon öfter bemerkt oder gelesen haben, wickelt der VC 20 (der C 64 übrigens auch) seine Tastaturoperationen ebenfalls über einen Puffer ab. Dies wird beim LISTen von Basic-Programmen deutlich, denn während der Computer ein Programm ausgibt, können sie alle Tasten (mit Ausnahme des STOP-Keys) drücken — diese erscheinen aber nicht auf dem Bildschirm. Erst wenn das Programm zu Ende gelistet ist, sieht man, daß keine Taste »vergessen« wurde, denn alle Eingaben wurden im Tastaturpuffer (Adresse 631-640/ $0277-$0280) zwischengespeichert .</p>

        <p>Dieser Puffer hat eine Kapazität von maximal zehn Zeichen. Wem dies zuviel ist, der kann die Länge des Puffers durch Adresse 649 einstellen. Ratsam kann dies bei relativ langsamen Basic-Spielen sein, wo es empfehlenswert ist, nur ein Zeichen im Tastaturpuffer zwischenzuspeichern (POKE 649,1). Anderenfalls »hinkt« die Tastatur immer den Ereignissen hinterher.</p>

        <p>Mit Hilfe des Tastaturpuffers kann aber auch — und das ist das interessante an diesen zehn Bytes — eine relativ unkonventionelle Art der Programmierung praktiziert werden.</p>

        <h2>Der »DATA-Erzeuger«</h2>

        <p>Um dies verständlich zu machen, habe ich ein Programm (Listing 1) geschrieben, welches DATA-Zeilen aus Maschinenprogrammen oder Sonderzeichen erzeugt. Die Problematik dabei ist folgende: Wenn ich DATA-Zeilen ins Programm schreiben möchte, so ist dies nur im Direktmodus möglich. Um dies automatisch zu tun, benötigen wir ein Programm. Also was tun? — Man bedient sich des Tastaturpuffers!</p>

        <p>Dazu nochmals die Durchleuchtung der Funktionsweise. Während des Systeminterrupts (was dort geschieht klären wir in einer der nächsten Folgen), der alle 60stel Sekunde durchlaufen wird, fragt der Computer die Tastatur ab. Ein eingegebenes Zeichen wird dabei im Tastaturpuffer abgelegt, wo es so lange verbleibt, bis ein Zeichen von der Tastatur benötigt wird. Dies ist zum Beispiel im Direktmodus der Fall (wenn der Cursor blinkt) oder im Programm — bei INPUT oder GET. Die Zeichen werden dann wieder aus dem Tastaturpuffer hervorgeholt und zwar nach dem Prinzip »First in, First out«. Bei unserem Programm werden zunächst einmal sechs Speicherzellen initialisiert. Die ersten zwei Adressen enthalten die Anfangsadresse der abzuspeichernden Daten aus dem Speicher. Dieser Zeiger wird solange inkrementiert, bis er den Wert der Endadresse — der in den zwei folgenden Bytes abgelegt ist — erreicht hat. In den letzten zwei Speicherstellen (Adresse 252, 253) steht die Zeilennummer in der Reihenfolge Low-/ High-Byte. Bequemer währe es natürlich, wenn man normale Variablen verwenden könnte. Dies ist jedoch nicht möglich, weil diese beim Einfügen einer DATA-Zeile gelöscht werden. Darum bleibt nur der Umweg über Speicherstellen, deren Inhalte durch Basic nicht überschrieben werden können.</p>

        <p>Als nächstes erzeugt das Programm — mit Hilfe der in 252/253 gespeicherten Zwei-Byte-Zahl — eine Zeilennummer, welche auf den Bildschirm gePRINTet wird. Dann schreibt es das Befehlswort »DATA« und druckt acht dreistellige Zahlen (die Daten aus dem zu verarbeitenden Maschinenprogramm) aus. Nun haben wir eine fertige Programmzeile auf dem Bildschirm stehen, die sich allerdings noch nicht im Speicher befindet. Dies erledigt jetzt unser Tastaturpuffer.</p>

        <p>Vorher müssen wir und jedoch genau überlegen, wie unser Bildschirm aussieht, denn dementsprechend muß der Cursor programmiert werden.</p>

        <h2>Cursorprogrammierung einmal anders</h2>

        <p>Bild 2 zeigt ein Bildschirmfoto dieser Situation. Zuerst wird der Cursor mit HOME (= CHR$ (19)) an die linke obere Ecke befördert. Dort wird durch einen Druck auf die RETURN-Taste (=CHR$(13)) die Basic-Zeile in den Speicher übernommen. Nun befindet sich der Cursor in der dritten Zeile. Durch ein »Cursor down« (=CHR$(17)) bewegt er sich eine Zeile nach unten und steht nun auf dem Befehlswort RUN 60. Ein weiteres RETURN bewirkt den erneuten Start des Hilfsprogramms.</p>

        <figure>
            <img src="126-2.png" alt="">
            <figcaption>Bild 2. Anhand dieses Bildschirmfotos muß der Cursor programmiert werden</figcaption>
        </figure>

        <p>Wir benötigen für die Cursorbewegung also vier Werte. Diese werden vor dem Ende des Programms mit »POKE 631,19: POKE 632, 13: POKE 633,17: POKE 634, 13: POKE 198,4« in den Tastaturpuffer geschrieben. Hierdurch simulieren wir eine gedrückte Tastenfolge: denn nachdem sich der Computer über den Befehl END wieder im Direktmodus befindet, wird zuerst der Tastaturpuffer geleert, wodurch der Cursor den vorbestimmten Weg nimmt. POKE 198,4 gibt an (das noch als Nachtrag) wieviele Zeichen sich momentan im Puffer befinden. Dieser POKE-Befehl darf bei der Manipulation des Tastaturspeichers nie vergessen werden. Ferner ist die Bereitschaftsmeldung »READY«, die beim Übergang in den Direktmodus ausgegeben wird, zu berücksichtigen. Man muß beachten, daß dadurch nicht die bereits auf dem Bildschirm befindlichen Zeichen überschrieben werden.</p>

        <p>Die Bedienung des Programms an sich ist ganz einfach. Nach Eingabe der Anfangs- und Endadresse werden die DATA-Zeilen mit jeweils acht Elementen in den Programmspeicher generiert; begonnen wird mit Zeilennummer 300, die in 10er-Schritten erhöht wird. Da sich das Listing selbst kommentiert, erübrigt sich alles Weitere. Der Vollständigkeit halber ist noch zu erwähnen, daß die REM-Zeilen nicht mit eingegeben werden müssen.</p>

        <p>Benutzt wurde der Tastaturpuffer bereits in einem Programm, das im ersten Teil dieser Serie abgedruckt wurde. Die Rede ist von der Autostartroutine, welche einen Basic-Programmstart (aus einem Maschinenprogramm heraus) durch Füllen des Puffers mit dem Kommando RUN (+ CHR$ (13)) realisierte.</p>

        <h2>Die Eckadressen</h2>

        <p>Als nächstes besprechen wir die Adressen 641-644/ $0281-$0284. Sie enthalten die Anfangs- beziehungsweise Endadresse des verfügbaren Speicherbereiches.</p>

        <p>Bei dem Systemreset ($FD22/ 64802) werden verschiedene Routinen wie beispielsweise Initialisierung der Zeropage, Setzen der Vektoren, RAM-Test ect. durchlaufen. Dabei wird unter anderem auch der verfügbare Speicherplatz festgestellt und die Eckadressen den obengenannten Registern übergeben. Diese Daten sind die Grundlage für alle weiteren Grundeinstellungen des Systems, also Basic-Beginn und -Ende, Beginn des Video- und Farbspeichers ect.</p>

        <p>Wird es nun nötig, eine Speicherkonfiguration zu simulieren, beispielsweise Grundversion bei eingesteckter 8-KByte-Erweiterung, so kann das über diese Zeiger geschehen:<br>
            POKE 642, 16: POKE 644, 30: SYS 64970: SYS 64821 bewirkt diese Simulation. Das Unterprogramm im Betriebssystem (Adresse 64970), das zur Reset-Routine gehört, hat die Aufgabe, die Seiten 0 (Zeropage), 2 und 3 zu löschen. Danach prüft der Computer seine Speicherzellen. Dieser Test hat die Aufgabe, das RAM auf seine Funktionsfähigkeit hin zu überprüfen, damit es nicht zu Fehlfunktionen durch einen beschädigten Speicher kommt. Bei dieser Gelegenheit wird die Ausbaustufe des Speichers festgestellt; das Ergebnis findet sich dann in den Registern für die Anfangs- beziehungsweise Endadresse. Hier steigen wir nun mit den entsprechend manipulierten Registern (642 auf 16 und 644 auf 30) in die ROM-Routine ein. Mit Hilfe dieser Werte richtet das Unterprogramm nun den Video- und Farbspeicher ein. Mit dem zweiten SYS-Befehl (SYS 64821) wird die Initialisierung fortgesetzt. Dabei richtet er den Speicher für Basic ein und gibt die Kaltstartmeldung
            <code>CBM BASIC V2
                3583 BYTES FREE
            </code>
            aus.
        </p>

        <p>Soweit ein kleiner Einblick ins Betriebssystem, eine ausführlichere Erläuterung erfolgt in einer der nächsten Folgen.</p>

        <h2>Die Speicherorganisation</h2>

        <p>Jetzt möchte ich noch einen kleinen Einblick in die Speicherorganisation geben, was auch im Hinblick auf Grafik von Bedeutung ist. Wie hinreichend bekannt sein dürfte, gibt es drei verschiedene Speichererweiterungen zu kaufen, nämlich 3 KByte, 8 KByte und 16 KByte. Die Sammelerweiterungen (also 27/32/64 KByte-Erweiterungen sollen hier gedanklich ebenfalls in diese drei verschiedenen Module zerlegt werden.</p>

        <p>Bei Erweiterungen von mehr als 8 KByte verändert sich die Lage des Bildschirm- und Farbspeichers (die Einstellung nimmt die Reset-Routine vor). Anhand von Bild 3 soll erläutert werden, warum eine Verschiebung notwendig ist.</p>

        <figure>
            <img src="126-3.png" alt="">
            <figcaption>Bild 3. Diese Grafik zeigt den Speicheraufbau des VC 20</figcaption>
        </figure>

        <p>Der <strong>V</strong>ideo-<strong>I</strong>nterface-<strong>C</strong>hip VIC (daher auch der Englische Name des VC 20), der vor allem für die Erzeugung des Fernsehsignals und den Aufbau des Bildschirmes verantwortlich ist, kann hardwaremäßig nur Videospeicherplätze zwischen 4096 und 8192 adressieren. Folglich muß das Bildschirm-RAM in diesem Bereich angesiedelt werden.</p>

        <p>In der Grundversion liegt es zwischen Adresse 7680 und 8191 — also am Ende des verfügbaren Speichers, damit der Speicherbereich für Basic auch bei eingesteckter 3 KByte-Erweiterung durchgängig ist (läge der Bildschirmspeicher sowie bei einer 8-KByte-Erweiterung, währe dies nicht der Fall).</p>

        <p>Ist ein Speichermodul von mehr als 8 KByte eingesteckt (egal ob der 3-KByte-Bereich zugeschaltet ist oder nicht), so legt das System den Videospeicher an die unterste adressierbare Stelle für den VIC, also Adresse 4096. Aus diesem Grund kann die eingesteckte 3-KByte-Erweiterung nicht mehr für Basic benutzt werden, denn sonst wäre der Speicher nicht mehr durchgängig.</p>

        <p>Programme sollten immer auf allen Erweiterungsversionen lauffähig sein. Wer also in Routinen mit dem Bildschirm- oder Farbspeicher arbeitet, kann sich mit Hilfe der Register 36866 und 86869 im VIC die momentanen Adressen beschaffen.</p>

        <ul class="plain">
            <li>Bildschirm: 4*(PEEK(36866)AND128) + 64*(PEEK(36869)AND120)</li>
            <li>Farbspeicher: 4*(PEEK(36866)AND128) + 37888</li>
        </ul>

        <h2>Gewußt wo — Die Bildschirmadressen</h2>

        <p>Mit Hilfe bestimmter Bits aus diesen Registern bildet der VIC die Adressen, die er benötigt, um — unabhängig vom Prozessor — Bild- und Farbspeicherstellen auszulesen, damit er mit diesen Informationen das Fernsehbild erzeugen kann.</p>

        <p>Das Betriebssystem hingegen bezieht seine Informationen über die Lage des Videospeichers nicht aus diesen VIC-internen Registern, sondern aus Adresse 648. Gibt man beispielsweise »POKE 648,28« ein, so liegt der Bildschirmspeicher zwischen 7168 und 7679. In Wirklickkeit stellt der Video-Interface-Chip — der, wie gesagt, unabhängig arbeitet — weiterhin den Speicherausschnitt zwischen Adresse 7680 und 8191 auf dem Bildschirm dar. Der Cursor schreibt also in einem ganz anderen Speicherabschnitt. Erst durch einen Warmstart (durch die Tastenkombination RUN/ STOP — RESTORE) werden die VIC-Register angepaßt.</p>

        <p>Vom Bildschirm nun wieder zur Tastatur. In unseren systematischen Betrachtungen der Seite 1 bis 3 im Speicher, kommen wir nun zu den Adressen $0280-$0291/649-656, die der Tastatur zugeordnet sind. Sie enthalten lediglich Parameter für die Arbeit mit der Tastatur wie zum Beispiel Repeat Flag, das Flag für Kontrolltasten ect. Näheres entnehmen sie bitte Tabelle 1.</p>

        <h2>Praktisches: Die Befehlseingabe über Funktionstasten</h2>

        <p>Zwei weithin unbekannte Adressen ($028F, $0290/ 655,656) sind vorzüglich dazu geeignet, eine Funktionstastenabfrage auf Interruptbasis zu realisieren. Besagte Adressen bilden einen Vektor für die Tastaturdecodierung, der meines Erachtens nur für den Zweck der Funktionstastenabfrage geschaffen wurde.</p>

        <p>Was sind überhaupt Vektoren? ROM, so sagt ja bereits der Name (<strong>R</strong>ead <strong>O</strong>nly <strong>M</strong>emory), ist grundsätzlich nicht überschreibbar. Wer dennoch das System ergänzen will (beispielsweise durch neue Basic-Befehle), ist gezwungen, das gesamte ROM auszutauschen, es sei denn, die Schöpfer des Computers haben mögliche Optionen — so wie beim VC 20 (oder C 64) — bereits eingeplant. Dies geschieht, indem aus dem ROM heraus ins RAM verzweigt wird.</p>

        <p>Normalerweise steht an der entsprechenden RAM-Adresse nur ein Zeiger auf eine ROM-Adresse, eben ein Vektor. Durch Änderung eines solchen Vektors kann man elegant bestehende Routinen umgehen und sie durch eigene ersetzen beziehungsweise ergänzen. Soweit, so gut.</p>

        <p>Wie im Handbuch zu lesen, gibt es Unterschiede zwischen den Bildschirmcodes eines Zeichens (»A« beispielsweise hat den Wert 1) und dem allgemein verbreiteten ASCII-Code (»A« hat hier den Wert 65). Gleiches gilt für die Tastatur. Hier unterscheidet man ebenfalls zwischen dem ASCII- und dem sogenannten Tastatur-Matrixcode. Diese VC 20-interne Codierung wird durch eine Betriebssystemroutine — die über einen Vektor verfügt (den oben erwähnten für die Tastaturdecodierung) — in ASCII-Zeichen umgewandelt. Das Maschinenprogramm in Listing 2 und 3 wird durch »verbiegen« des Vektors 655/656 in die Tastaturroutine mit eingebaut. Es fragt die Codes der Funktionstasten ab und druckt die Zeichen aus, mit denen sie belegt wurden.</p>

        <p>Das recht komfortable Programm liegt als Basic-Lader in Listing 2 vor. Nach dem Starten mit RUN wird das Maschinenprogramm automatisch ans Ende des verfügbaren Speichers geladen. Mit der SPACE-Taste aktiviert man diese Routine. Als erstes werden die Befehle gelistet, mit denen die Funktionstasten belegt sind. (Tabelle 2).</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td>Fl: LIST</td>
                        <td>- LIST-Befehl mit CHR$(13)</td>
                    </tr>
                    <tr>
                        <td>F2: RUN</td>
                        <td>- wie bei LIST</td>
                    </tr>
                    <tr>
                        <td>F3: INPUT</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>F4: GOSUB</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>F5: SYS0</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>F6: RETURN</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>F7: RESTORE</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>F8: LOAD’</td>
                        <td>— ’ entspricht dem Hochkomma (”)</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 2. Die Grundbelegung der Funktionstasten nach dem Laden des Maschinenprogramms</figcaption>
        </figure>

        <p>Auffällig ist bei den Kommandos LIST und RUN der Pfeil nach oben (↑). Er bewirkt ein sofortiges Ausführen des Befehls — entspricht also »LIST« und RETURN-Taste beziehungsweise »RUN« und RETURN-Taste. Das andere auffällige Zeichen ist der Apostroph (&lsquo;) bei dem Kommando LOAD, der dem Hochkomma (”) entspricht. Das echte Gänsefüßchen ist bereits für die Syntax des Änderungsbefehls (siehe unten) vergeben.</p>

        <p>Auf den Befehl π wie er beispielsweise beim Programm »Basic-Switch« (Folge 2) verwendet wurde, habe ich dieses Mal aus Platzgründen verzichtet, damit Lader und Maschinenprogramm in der Grundversion Platz finden. Die Kommandos werden statt dessen über den Befehl »SYS0« (oder F5) eingegeben. Dabei machen wir uns den USR-Vektor (Adresse 0-2) als Sprungzeiger zu Nutze. Damit zur Syntax bei der Funktionstastenprogrammierung:</p>

        <ul class="plain">
            <li>SYS0 L – Listen der Funktionstastenbelegungen</li>
            <li>SYS0 O – (Off) schaltet die Funktionstasten ab</li>
            <li>SYS0 R – (Restart) schaltet die Funktionstasten wieder ein.</li>
            <li>SYS0,X, »befehl« – belegt die X-te Funktionstaste mit einem Befehl.</li>
        </ul>

        <p>Zum Schluß kommen wir noch zu einem Thema, mit dem ich mich mehr an den fortgeschrittenen Maschinensprachenprogrammierer wenden möchte. Im ersten Teil dieser Serie wurde beschrieben, wie der Basic-Befehlssatz mit Hilfe der CHRGET-Routine und des Befehles »π« im beschränktem Umfang erweitert werden kann. Diese Methode hat allerdings viele Unzulässigkeiten; es sind beispielsweise keine verkürzten Befehle wie beim normalen Basic (LIST = L SHIFT I) möglich.</p>

        <p>Nun soll beschrieben werden, wie der Basic-Befehlssatz um richtige Klartextkommandos erweitert werden kann. Auch hierfür müssen wir bestehende Interpreterroutinen, die über Vektoren angesprungen werden, umgehen beziehungsweise ergänzen.</p>

        <p>Für das Verarbeiten von Basic-Programmen sind drei Schlüsselroutinen zu substituieren. Da ist zunächst das Unterprogramm »ASCII in Token wandeln«. ($C57C) welches — wie der Name bereits sagt — die Aufgabe hat, Eingabezeilen im Basic-Puffer (wie zu Anfang beschrieben) in Interpretercode zu wandeln. Das Gegenstück dazu ist die Unterroutine »Interpretercode in Klartext wandeln.« Will man Basic-Zeilen sichtbar machen, so benutzt man das Kommando LIST. Dazu wird eben diese ROM-Routine benötigt, die die Rückumwandlung der Token in ASCII-Zeichen vornimmt.</p>

        <p>Sämtliche Befehle sind in Form von ASCII-Zeichen im Basic-ROM enthalten, lediglich zum letzten Buchstaben jedes Befehlswortes wurde 128 ($80) addiert. Läßt man sich die Befehle durch
            <code>FOR T= 49310 TO 47565: PRINT CHR$(PEEK(T)):NEXT</code>
            ausdrucken, so sehen die Kommandos im Groß-/Kleinschrift-Modus folgendermaßen aus:
            <code>END = enD
                FOR = foR ect.
            </code>
        </p>

        <p>Ferner ist jedem Basic-Befehl eine Adresse zugeordnet, bei der eine Abarbeitung vorgenommen wird. Diese Adressen sind in einer Tabelle (von $C00C $C07F) zusammengefaßt. Eine spezielle Routine hat wiederum die Aufgabe, die Befehlsadresse für ein entsprechendes Token aus der Tabelle zu lesen, und einen Sprung nach dorthin durchzuführen. Auch dieses Unterprogramm kann man mittels eines Vektors umgehen.</p>

        <p>Damit haben wir das nötige Rüstzeug, um selbst Basic-Kommandos in den Interpreter mit aufzunehmen. In Listing 4 ist ein dafür geeignetes Programm abgedruckt, welches ich jetzt näher erläutern möchte. Es ist der Kopf für ein Utility, in das nach Belieben Befehlswörter und Sprungadressen eingesetzt werden können.</p>

        <p>Die Routine gliedert sich in vier Teile: Der erste Teil (von $2000 - $203A) ist eine Kopie der Reset-Routine. Dabei wird der Computer neu initialisiert und eine neue Kaltstartmeldung
            <code>**** 64’ER BASIC ****</code>
            ausgedruckt. Hier ist genügend Platz vorgesehen, damit der Text nach eigenen Wünschen gestaltet werden kann. Ferner wurden die ersten neun Bytes mit NOPs versehen, damit dort — falls das Programm im Modulbereich abgelegt wird — die obligate Autostartinformation (a0CBM) eingesetzt werden kann. Anderenfalls — wenn das Maschinenprogramm per SYS gestartet wird — muß der erste Mnemonic-Befehl ein SEI sein.
        </p>

        <p>Die sich jetzt anschließenden Programmteile sind die oben erwähnten Ergänzungen zu den Interpreterroutinen. Dies sind teilweise Kopien aus den alten ROM-Routinen mit Ergänzungen für die neuen Basic-Kommandos. Die Befehlswörter müssen jetzt nur noch eingetragen werden. Das geschieht folgendermaßen:</p>

        <p>Die Befehle werden mit Hilfe des Programms »Tokenerzeuger« (Listing 5) in den entsprechenden Adreßbereich geschrieben. Bei nachträglichen Eintragungen ist zu beachten, daß zum letzten Buchstaben jedes Befehlswortes der Wert $80 (=128) zu addieren ist. Die Ergänzungsbefehle beginnen mit Token 204. Das erste Befehlswort beginnt mit dieser Nummer, der zweite erhält automatisch die 205 und so weiter.</p>

        <p>Weiterhin ist für jedes Kommando die Sprungadresse in der Tabelle ($2208-$2268) zu vermerken. Dabei muß die Reihenfolge Low-/High Byte beachtet werden. Außerdem muß das LOW-Byte vor dem Eintrag um eines dekrementiert werden (LOW Byte -1). Auch diese Arbeit erledigt das Programm in Listing 5.</p>

        <p>Ein Befehl wurde bereits eingetragen. Der Befehl KILL führt einen Reset durch und damit ist das Programm abgeschaltet. Wer also seine Maschinenprogramme ins Basic einbinden möchte, kann dies mit der beschriebenen Methode tun. Beispielsweise könnte man die in Listing 2 abgedruckte Funktionstastenroutine mit dem KEY-Befehl belegen. Auch im Hinblick auf Grafik, Tonerzeugung oder Joystickabfrage bietet sich hier die Möglichkeit, die Unzulänglichkeiten des Basics zu überwinden. Auch die Besitzer eines C 64 können die beschriebene Routine benutzen, da die Basic-ROMs nahezu identisch sind (sie haben lediglich eine andere Adresse). Außerdem habe ich in Tabelle 3 eine Liste der wichtigsten Unterprogramme zusammengestellt, mit denen man unter anderem Parameter, Strings, Kommas oder ähnliches abfragen kann. Auf jeden Fall sollte man sich für diese Arbeit ein ROM-Listing (zum Beispiel »VC 20 Intern« von Data Becker) zulegen.</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td><b>Adresse</b></td>
                        <td><b>Funktionsbeschreibung</b></td>
                        <td><b>Bemerkung</b></td>
                        <td><b>Übergaberegister</b></td>
                    </tr>
                    <tr>
                        <td>C613</td>
                        <td>Startadresse einer Programmzeile berechnen</td>
                        <td></td>
                        <td>Eingabe: Zeile in $14,15 Ausgabe: Adresse in $5F, 60</td>
                    </tr>
                    <tr>
                        <td>C807</td>
                        <td>Prüft auf Doppelpunkt</td>
                        <td>Zur Syntaxkontrolle</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>CD8A</td>
                        <td>Ausdruck holen (z.B. Zeichen)</td>
                        <td>$D7FD wandelt Fließk. in Int.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>CAA0</td>
                        <td>PRINT-Befehl: Ausdruck oder String holen und ausdrucken</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>CEF7</td>
                        <td>Prüft auf Klammer zu »)«</td>
                        <td>Syntaxkontrolle</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>CEFA</td>
                        <td>Prüft auf Klammer auf »(«</td>
                        <td>Syntaxkontrolle</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>CEFD</td>
                        <td>Prüft auf Komma</td>
                        <td>Syntaxkontrolle</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>CF04</td>
                        <td>»SYNTAX ERROR« ausgeben</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>D113</td>
                        <td>Prüft auf Buchstabe (A-Z)</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>D248</td>
                        <td>»ILLEGAL QUANTITY« ausgeben</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>D79B</td>
                        <td>Byte-Wert (0-255) holen</td>
                        <td>Bei der Argumentabfrage</td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 3. Einige der wichtigsten Routinen, mit denen man für Basic-Befehle Argumente, Satzzeichen etc. abfragen kann.</figcaption>
        </figure>

        <p>Damit möchte ich für heute schließen. Das nächste Mal werden wir sehen, was man mit den Kernal-Vektoren anfangen kann und betrachten die Grafikmöglichkeiten beim VC 20.</p>

        <address class="author">(Christoph Sauer/ev)</address>

        <figure>
            <pre data-filename="data erzeuger" data-name=" DATA-Erzeuger"></pre>
            <figcaption>Listing 1. Der DATA-Erzeuger</figcaption>
        </figure>
        <figure>
            <pre data-filename="funktionstasten" data-name="Funktionstastenbelegung (Basic-Lader)"></pre>
            <figcaption>Listing 2. Funktionstastenbelegung (Basic-Lader)</figcaption>
        </figure>
        <figure>
            <!-- eingetippt von Endurion -->
            <pre>&gt;&gt; FUNKTIONSTASTEN &lt;&lt;

****************** INITIALSIERUNG
1C39  LDA #$EF
1C3B  STA $028F
1C3E  LDA #$1C   ; AENDERUNG DES
1C40  STA $0290  ; TASTATUR-VEKTORS
1C43  LDA #$CD
1C45  STA $0318
1C48  LDA #$1D
1C4A  STA $0319  ; NEUER NMI VEKTOR
1C4D  LDA #$4C
1C4F  STA $00
1C51  LDA #$5A
1C53  STA $01
1C55  LDA #$1C   ; SPRUNGZEIGER
1C57  STA $02    ; FUER 'SYS0'
1C59  RTS
****************** BEFEHLSAUSWERTUNG
1C5A  JSR $0079  ; CHRGOT, LFD. ZEICHEN
1C5D  CMP #$4C   ; 'SYS0 L'?
1C5F  BNE $1C95  ; NEIN, DANN WEITER
1C61  LDA #$31   ; SONST F1-F8 AUSLISTEN
1C63  STA $FA    ; ZAEHLER VORBEREITEN
1C65  LDX #$00
1C67  LDA #$10
1C69  STA $FB
1C6B  LDA #$0D   ; ZEILENVORSCHUB
1C6D  JSR $FFD2  ; AUSGEBEN
1C70  LDA #$46   ; 'F'
1C72  JSR $FFD2  ; AUSGEBEN
1C75  LDA $FA    ; LFD. NUMMER
1C77  JSR $FFD2  ; AUSGEBEN
1C7A  LDA #$20   ; ' '
1C7C  JSR $FFD2  ; AUSGEBEN
1C7F  LDA $1D4D,X; BEFEHLSSTRING
1C82  JSR $FFD2  ; AUSGEBEN
1C85  INX
1C86  DEC $FB
1C88  BNE $1C7F
1C8A  INC $FA
1C8C  LDA $FA
1C8E  CMP #$39   ; LETZTER STRING ?
1C90  BNE $1C67  ; NEIN, DANN WEITER
1C92  JMP $0073  ; SONST INS BASIC
1C95  JSR $0079  ; LFD. BEFEHL HOLEN
1C98  CMP #$4F   ; 'O' FUER 'SYS0 O' ?
1C9A  BNE $1C9F  ; NEIN, DANN WEITER
1C9C  JMP $FED2  ; SONST WARMSTART
1C9F  CMP #$52   ; 'R' FUER 'SYS0 R' ?
1CA1  BNE $1CA9  ; NEIN, DANN WEITER
1CA3  JSR $1C39  ; SONST PROGRAMMRESTART
1CA6  JMP $0073  ; UND ZURUECK ZU BASIC
1CA9  CMP #$2C   ; ',' FUER AENDERUNG ?
1CAB  BEQ $1CB0  ; JA, DANN WEITER
1CAD  JMP $CF08  ; SONST 'SYNTAX ERROR'
1CB0  JSR $D79B  ; TASTENNR. INS X-REG.
1CB3  CPX #$09   ; &gt;8 ?
1CB5  BCC $1CBA  ; NEIN, DANN WEITER
1CB7  JMP $D248  ; SONST FEHLERMELDUNG
1CBA  DEX
1CBB  STX $FA
1CBD  JSR $0079  ; CHRGOT, LFD. BEFEHL
1CC0  CMP #$2C   ; ',' KOMMA ?
1CC2  BNE $1CAD  ; NEIN, DANN FEHLER
1CC4  JSR $0073  ; NAECHSTES ZEICHEN ?
1CC7  CMP #$22   ; '"' HOCHKOMMA ?
1CC9  BNE $1CAD  ; NEIN, DANN FEHLER
1CCB  TXA
1CCC  ASL
1CCD  ASL
1CCE  ASL
1CCF  ASL
1CD0  TAX        ; X-REG. * 16
1CD1  LDY #$10   ; BEFEHLSSTRING HOLEN
1CD3  JSR $0073  ; NAECHSTES ZEICHEN
1CD6  CMP #$22   ; '"' ENDE DES STRINGS
1CD8  BEQ $1CE3  ; REST MIT 0 FUELLEN
1CDA  STA $1D4D,X; SONST STRING AB-
1CDD  INX        ; SPEICHERN
1CDE  DEY
1CDF  BNE $1CD3  ; WEITER
1CE1  BEQ $1CEC  ; ENDE: JMP $0073
1CE3  LDA #$00   ; REST MIT 0 FUELLEN
1CE5  STA $1D4D,
1CE8  INX
1CE9  DEY
1CEA  BNE $1CE5
1CEC  JMP $0073  ; ZURUECK INS BASIC
****************** FUNKTIONSTASTEN ABF.
1CEF  LDA $9D    ; RUN ODER DIREKTMODUS
1CF1  BEQ $1CFF  ; BEI RUN KEINE ABFR.
1CF3  LDA $CB    ; GEDRUECKTE TASTE
1CF5  LDX #$05
1CF7  CMP $1D01,X; MIT TASTATURCODE DER
1CFA  BEQ $1D06  ; FUNKTIONSTAS. VERGL.
1CFC  DEX
1CFD  BNE $1CF7  ; WEITER,TASTE ERKANNT
1CFF  JMP $EBDC  ; TEST NEGATIV
1D02  .BYTE $27  ; &lt; F1 &gt;
1D03  .BYTE $2F  ; &lt; F3 &gt;
1D04  .BYTE $37  ; &lt; F5 &gt;
1D05  .BYTE $3F  ; &lt; F7 &gt;
1D06  CMP $C5    ; ENTPRELLUNG
1D08  BEQ $1CFF
1D0A  STA $C5
1D0C  TXA
1D0D  CLC
1D0E  ASL
1D0F  STA $FA
1D11  LDA $028D  ; KONTROLLTASTE
1D14  CMP #$01   ; &lt;SHIFT&gt; GEDRUECKT ?
1D16  BEQ $1D1A  ; JA, DANN WEITER
1D18  DEC $FA    ; WERT UM 1 ERNIEDR.
1D1A  LDA $FA
1D1C  TAX
1D1D  DEX
1D1E  TXA
1D1F  ASL
1D20  ASL
1D21  ASL
1D22  ASL
1D23  STA $FB    ; ACCU * 16
1D25  TAY
1D26  LDA $1D4D,Y; BEFEHLSSTRING LADEN
1D29  BEQ $1D3B  ; ENDE ?
1D2B  CMP #$5E   ; '^' DIREKT AUSFUEHREN
1D2D  BEQ $1D3E  ; JA, DANN VERZWEIGEN
1D2F  CMP #$27   ; &gt;'&lt; HOCHKOMMAERSATZ?
1D31  BNE $1D35  ; NEIN, DANN WEITER
1D33  LDA #$22   ; HOCHKOMMA LADEN
1D35  JSR $FFD2  ; UND AUSGEBEN
1D38  INY
1D39  BNE $1D26
1D3B  LDA #$00   ; CURSOR ANSCHALTEN
1D3D  STA $CF
1D3F  BEQ $1D4A  ; UNBEDINGTER SPRUNG
1D41  LDA #$0D   ; &lt;RETURN&gt;
1D43  STA $0277  ; IN DEN PUFFER
1D46  LDA #$01   ; EIN ZEICHEN IM
1D48  STA $C6    ; TASTATURPUFFER
1D4A  JMP $EBD6  ; ZURUECK ZUM URSPRUNG
****************** BEFEHLSSPEICHER
1D4D  LIST^...........
1D5D  RUN^............
1D6D  INPUT...........
1D7D  GOSUB...........
1D8D  SYS0 ...........
1D9D  RETURN..........
1DAD  RESTORE.........
1DBD  LOAD'...........
****************** NEUE NMI ROUTINE
1DCD  SEI        ; KOPIE DER ALTEN
1DCE  PHA
1DCF  TXA
1DD0  PHA
1DD1  TYA
1DD2  PHA
1DD3  LDA $911D
1DD6  BPL $1DFD
1DD8  AND $911E
1DDB  TAX
1DDC  AND #$02   ; RS 232 AKTIV ?
1DDE  BEQ $1DFA  ; JA, DANN VERZWEIGEN
1DE0  BIT $9111
1DE3  JSR $F734  ; STOPTASTE ABFRAGEN
1DE6  JSR $FFE1  ; STOPTASTE GEDRUECKT ?
1DE9  BNE $1DFD  ; NEIN, DANN RTI
1DEA  JSR $FD52  ; VEKTOREN SETZEN
1DEE  JSR $FDF9  ; I/O REGISTER SETZEN
1DF1  JSR $E518  ; CLR SCREEN
1DF4  JSR $1C39  ; REGISTER AENDERN
1DF7  JMP ($C002); BASIC WARMSTART
1DFA  JMP $FEDE  ; NMI FUER RS 232
1DFD  JMP $FF56  ; RTI
</pre>
            <figcaption>Listing 3. Funktionstastenbelegung (Assembler-Darstellung)</figcaption>
        </figure>
        <figure>
            <pre data-filename="befehlskopf" data-name="Befehlskopf"></pre>
            <figcaption>Listing 4. Befehlskopf zur Definition eigener Basic-Befehle (BasicLader)</figcaption>
        </figure>
        <figure>
            <pre data-filename="token erzeuger" data-name="Tokenerzeuger"></pre>
            <figcaption>Listing 5. Der Tokenerzeuger</figcaption>
        </figure>

    </article>

</body>

</html>
