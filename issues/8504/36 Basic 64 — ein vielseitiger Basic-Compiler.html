<!DOCTYPE html>
<html lang="de">

<head>
    <title>Basic 64 — ein vielseitiger Basic-Compiler</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Karsten Schramm, gk">
    <meta name="64er.issue" content="4/85">
    <meta name="64er.pages" content="36-37">
    <!-- <meta name="64er.toc_category" content="XXX"> -->
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="XXX">
</head>

<body>
    <article>
        <h1>Basic 64 — ein vielseitiger Basic-Compiler</h1>
        <p class="intro">Die Stärken dieses neuen Compilers sind ohne Zweifel seine vielen Funktionen. Obwohl es einige Mühe macht, sie alle auszunutzen, kommt aber auch ein Anfänger ohne Probleme mit diesem Compiler zurecht.</p>

        <p>Basic 64 konnte in der Ausgabe 2/85 des 64'er nicht berücksichtigrt werden, da er zu der Zeit noch nicht in einer endgültigen Version vorlag. Wir testeten damals die Compiler Petspeed, Austro Speed, den BASS- sowie den Exbasic Level II-Compiler. Damit ein Vergleich zu diesen Compilern möglich ist, wurde dieser Test mit den gleichen Testprogrammen und unter den gleichen Voraussetzungen vorgenommen.</p>

        <p>Als Meßeinheit diente wieder das Programm EDDI aus der 64'er, Ausgabe 10/84, das eine Länge von 14 Blöcken hat. Wie schon einmal angesprochen, eignet sich dieses Programm deshalb so gut, weil es fast alle Bereiche der Programmierung abdeckt, nicht auf Compiler abgestimmt ist und außerdem einen Fehler aufweist. Dieser Fehler wird beim normalen Programmablauf nicht erreicht und hat auch sonst keinen nachteiligen Einfluß auf die Funktion von EDDI. Es dürfte jedoch interessant sein, wie Basic 64 auf diesen Fehler reagiert.</p>

        <p>Mit EDDI wurde die Dauer und Fehlerfreiheit des Compilierens getestet.</p>

        <p>Zur Messung der Geschwindigkeit verwenden wir die ebenfalls in Ausgabe 2/85 abgedruckten Benchmarks. Anhand der ermittelten Zeiten können Sie dann feststellen, auf welchen Teilgebieten der Compiler entweder besonders schnell oder langsamer arbeitet (Tabelle 1 und 2).</p>

        <h2>Der Basic 64-Compiler</h2>

        <p>Beginnen wir mit dem Lieferumfang des Compilers. Sie erhalten beim Kauf von Basic 64 einen Ringbuchordner, der ein Handbuch mittleren Umfangs und eine Diskette enthält.</p>

        <p>Die Dokumentation erwies sich als gut. Sie führt in alle Funktionen des Compilers ein und erläutert ausführlich die vielen Zusätze, die Basic 64 besitzt.</p>

        <p>Wie schon der Austro-Speed-Compiler, so ist auch der Basic 64 ein Zwerg in unserer Testreihe. Das Programm besteht aus ungefähr 90 Blöcken (22,5 KByte), in denen alle Funktionen untergebracht sind, auf die wir gleich noch zu sprechen kommen.</p>

        <p>Es handelt sich bei Basic 64 um einen 2-Pass-Compiler, der im gesamten Aufbau etwas an Austro-Speed erinnert.</p>

        <p>Die Bedienung erwies sich als sehr einfach und dürfte auch dem Neuling keine großen Schwierigkeiten machen. Wenn man Basic 64 mit den vier anderen Konkurrenten vergleicht, dann läßt sich eine Eigenschaft dieses Programms jedoch nicht verleugnen: Basic 64 ist mit Abstand der vielseitigste Compiler. Er bietet eine Fülle von Einstellmöglichkeiten und direkten Befehlen (Direktiven), so daß er sehr anpassungsfähig ist.</p>

        <p>Es ist mit ihm zum Beispiel möglich, zwischen Adreßcode- und Assemblercode-Compilierung zu wählen und beide Modi sogar miteinander zu verbinden.</p>

        <p>Weitere Möglichkeiten sind zum Beispiel freie Verschiebbarkeit des Compilats im Speicher, Nutzung von über 60 KByte Basic-Speicher, modifizierte Integer-Arithmetik und Simulation von »ON ERROR GOTO«-Befehlen.</p>

        <p>Eine Eigenschaft, die Basic 64 ebenfalls stark von seinen Konkurrenten abhebt, ist sicherlich die Behandlung von Programmen, die während eines Programmablaufs nachgeladen werden (Overlay).</p>

        <p>Für solche Overlay-Pakete besitzt Basic 64 einen speziellen Modus, der sogar Warm-Overlay, also Nachladen von Programmteilen ohne Löschen der Variablen erlaubt. Es wird so eine hohe Kompatibilität zum Basic V2.0 des Commodore 64 gewahrt.</p>

        <p>Der einzig einschränkende Faktor zum Interpreter besteht in der Tatsache der Dimensionierung. Auch Basic 64 erlaubt, wie die meisten anderen Compiler, keine variable Dimensionierung (DIM A(N)), was durch die spezielle Variablenbehandlung bei Compilern bedingt ist.</p>

        <p>Tritt eine solche Dimensionierung jedoch auf, wird der Benutzer nach der Größe des Feldes gefragt und diese eingesetzt. Hierbei ist zu beachten, daß auch der folgende Ausdruck</p>

        <p>A = 10000 : DIM N(A)</p>

        <p>eine variable Dimensionierung darstellt, obwohl A eindeutig definiert wurde.</p>

        <p>Es ergibt sich ein recht guter Gesamteindruck, was die vielseitige Einsetzbarkeit dieses Compilers angeht. Bei Basic 64 fehlt deshalb auch die Verarbeitung von Erweiterungen nicht, die hier sogar speziell angewählt werden können.</p>

        <p>Als Erweiterungen »versteht« Basic 64: Supergrafik 64 (und 64 + ), Simons Basic, Exbasic Level II und Basic 4.0.</p>

        <p>Befehle dieser Erweiterungen werden vom Compiler, wie schon von den anderen Testkandidaten, im Non-Compiled-Code angelegt und dem jeweiligen Interpreter dann zur Ausführung übergeben.</p>

        <h2>Basic 64 im Test</h2>

        <p>Nun kommen wir zu unseren Testergebnissen.</p>

        <p>Zum Compilieren von EDDI benötigte Basic 64 ungefähr 6,30 Minuten (5,55 im Adreßcode-Modus). Er ist damit nach Austro-Speed der zweitschnellste Compiler.</p>

        <p>Damit die Voraussetzungen für einen Vergleich zwischen Basic 64 und den anderen Compilern gegeben sind, wurde das Programm EDDI im Assemblercode-Modus compiliert.</p>

        <p>Die Länge des Compilats lag mit 40 Blöcken im Durchschnitt und bietet keinen Grund zur Beanstandung (im Adreßcode-Modus sind es wie beim Austro-Speed nur 32 Blöcke). Positiv fiel auch auf, daß während des Compilierens kein Diskettenwechsel notwendig ist.</p>

        <p>Der Fehler in Zeile 1070 wurde von Basic 64 in Pass 2 erkannt, ohne daß jedoch nachteilige Folgen für EDDI daraus entstanden wären. Der Compiler arbeitete weiter und lieferte ein vollkommen funktionsfähiges Compilat.</p>

        <p>In Tabelle 1 sind alle Testergebnisse noch einmal zusammengefaßt.</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <th>Hersteller</th>
                        <th>Austro-Speed</th>
                        <th>BASS</th>
                        <th>Exbasic Level H-Compiler</th>
                        <th>Petspeed</th>
                        <th>Basic 64</th>
                    </tr>
                    <tr>
                        <td>Preis (ca.)</td>
                        <td>298,—</td>
                        <td>198,—</td>
                        <td>298,—</td>
                        <td>149,—</td>
                        <td>99,—</td>
                    </tr>
                    <tr>
                        <td>Lieferumfang</td>
                        <td>1 Diskette<br>1 Handbuch</td>
                        <td>3 Disketten<br>2 dicke Handbücher</td>
                        <td>1 Diskette<br>1 Handbuch</td>
                        <td>1 Diskette<br>3 Seiten Einweisung</td>
                        <td>1 Diskette<br>1 Handbuch</td>
                    </tr>
                    <tr>
                        <td>Dokumentation</td>
                        <td>gut</td>
                        <td>ausgezeichnet</td>
                        <td>befriedigend</td>
                        <td>mangelhaft</td>
                        <td>gut</td>
                    </tr>
                    <tr>
                        <td>ungefähre Länge des Programms</td>
                        <td>63 Blocks</td>
                        <td>263 Blocks</td>
                        <td>290 Blocks</td>
                        <td>300 Blocks</td>
                        <td>90 Blocks</td>
                    </tr>
                    <tr>
                        <td>Anzahl PASSES</td>
                        <td>2</td>
                        <td>2 + 2 Assembler (wird nicht mitgeliefert)</td>
                        <td>2 + 2 Assembler (integriert)</td>
                        <td>4</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>Programmschutz möglich?</td>
                        <td>ja</td>
                        <td>nein</td>
                        <td>nein</td>
                        <td>nein</td>
                        <td>nein</td>
                    </tr>
                    <tr>
                        <td>Integer Arithmetik</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>ja</td>
                    </tr>
                    <tr>
                        <td>Erweiterungen möglich?</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>nein</td>
                        <td>ja</td>
                    </tr>
                    <tr>
                        <td>variables DIM möglich?</td>
                        <td>ja</td>
                        <td>nein</td>
                        <td>nein</td>
                        <td>nein</td>
                        <td>nein</td>
                    </tr>
                    <tr>
                        <td>Automatisches DIM auf 11 Elemente</td>
                        <td>ja</td>
                        <td>nein</td>
                        <td>nein</td>
                        <td>ja</td>
                        <td>ja</td>
                    </tr>
                    <tr>
                        <td>Compilierdauer<br>EDDI<br>(14 Blocks)</td>
                        <td>3 min</td>
                        <td>7,10 min + 9 min ASSI</td>
                        <td>12 min</td>
                        <td>7,30 min</td>
                        <td>6,24 min/sec</td>
                    </tr>
                    <tr>
                        <td>Diskettenwechsel beim Compilieren</td>
                        <td>nein</td>
                        <td>ja, 2mal</td>
                        <td>ja, 4mal</td>
                        <td>nein</td>
                        <td>nein</td>
                    </tr>
                    <tr>
                        <td>Anzahl der erzeugten Files</td>
                        <td>2</td>
                        <td>10</td>
                        <td>i</td>
                        <td>2</td>
                        <td>1 (2 nach Wunsch)</td>
                    </tr>
                    <tr>
                        <td>Länge des Compilats (EDDI)</td>
                        <td>32 Blöcke</td>
                        <td>39 Blöcke</td>
                        <td>39 Blöcke</td>
                        <td>42 Blöcke</td>
                        <td>40 m-code<br>32 P-code</td>
                    </tr>
                    <tr>
                        <td>Compilertyp</td>
                        <td>—</td>
                        <td>Adreßcode + Assemblercode</td>
                        <td>Assemblercode</td>
                        <td>Assemblercode</td>
                        <td>Assemblercode + Adreßcode</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 1. Fünf Compiler im Vergleich</figcaption>
        </figure>

        <p>In Tabelle 2 sehen Sie die Ergebnisse des Benchmark-Tests. Hier zeigt Basic 64 durchschnittliche Werte, die in etwa denen des Austro-Speed entsprechen.</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <th colspan="3" rowspan="2"></th>
                        <th rowspan="2">Basic</th>
                        <th rowspan="2">Exbasic + BASS</th>
                        <th rowspan="2">Petspeed</th>
                        <th rowspan="2">Austro-Speed</th>
                        <th colspan="2">Basic 64</th>
                    </tr>
                    <tr>
                        <th>P-Code</th>
                        <th>M-Code</th>
                    </tr>
                    <tr>
                        <td>Test</td>
                        <td>1a</td><td>Einlesen (100 Werte)</td>
                        <td>1,53</td>
                        <td>0,67</td>
                        <td>0,50</td>
                        <td>0,46</td>
                        <td>0,58</td>
                        <td>0,5</td>
                    </tr>
                    <tr>
                        <td>Test</td>
                        <td>1b</td><td>Sortieren</td>
                        <td>64,16</td>
                        <td>24,85</td>
                        <td>8,23</td>
                        <td>16,25</td>
                        <td>18,88</td>
                        <td>15,83</td>
                    </tr>
                    <tr>
                        <td>Test</td>
                        <td>1c</td><td>Anzeigen</td>
                        <td>0,55</td>
                        <td>0,67</td>
                        <td>0,10</td>
                        <td>0,33</td>
                        <td>0,37</td>
                        <td>0,33</td>
                    </tr>
                    <tr>
                        <td>Test</td>
                        <td>1</td><td>Gesamt (a + b + c)</td>
                        <td>66,25</td>
                        <td>26,18</td>
                        <td>8,83</td>
                        <td>17,05</td>
                        <td>19,83</td>
                        <td>16,67</td>
                    </tr>
                    <tr>
                        <td rowspan="8">Benchmark</td>
                        <td>1</td><td>FOR NEXT</td>
                        <td>1,83</td>
                        <td>1,01</td>
                        <td>0,28</td>
                        <td>1,10</td>
                        <td>1,05</td>
                        <td>1,05</td>
                    </tr>
                    <tr>
                        <td>2</td><td>430 K = K + 1<br>440 IFK &lt;1000 THEN 430</td>
                        <td>13,22</td>
                        <td>2,16</td>
                        <td>0,72</td>
                        <td>1,38</td>
                        <td>1,86</td>
                        <td>1,22</td>
                    </tr>
                    <tr>
                        <td>3</td><td>A = K/K x K + K - K</td>
                        <td>11,25</td>
                        <td>4,70</td>
                        <td>5,54</td>
                        <td>4,38</td>
                        <td>5,47</td>
                        <td>4,66</td>
                    </tr>
                    <tr>
                        <td>4</td><td>A = K/2 x 3 + 4 - 5</td>
                        <td>12,00</td>
                        <td>6,51</td>
                        <td>6,42</td>
                        <td>5,32</td>
                        <td>5,18</td>
                        <td>4,48</td>
                    </tr>
                    <tr>
                        <td>5</td><td>GOSUB RETURN</td>
                        <td>16,65</td>
                        <td>0,45</td>
                        <td>0,18</td>
                        <td>0,15</td>
                        <td>0,31</td>
                        <td>0,3</td>
                    </tr>
                    <tr>
                        <td>6</td><td>FOR L = 1 TO 5:NEXT L</td>
                        <td>14,47</td>
                        <td>6,34</td>
                        <td>1,93</td>
                        <td>6,50</td>
                        <td>6,65</td>
                        <td>6,27</td>
                    </tr>
                    <tr>
                        <td>7</td><td>FOR L = 1 TO 5:M(L) = A:NEXT</td>
                        <td>24,85</td>
                        <td>8,80</td>
                        <td>2,50</td>
                        <td>3,95</td>
                        <td>5,74</td>
                        <td>4,3</td>
                    </tr>
                    <tr>
                        <td>8</td><td>A - K↑2 B = LOG(K) C = SIN(K)</td>
                        <td>112,30</td>
                        <td>102,19</td>
                        <td>93,25</td>
                        <td>101,98</td>
                        <td>103,73</td>
                        <td>102,36</td>
                    </tr>
                    <tr>
                        <td colspan="3">Gesamtzeit (Test 1 + Bench 1 bis 8)</td>
                        <td>390,86 ≙100%</td>
                        <td>198,53<br>≙50,79%</td>
                        <td>145,52<br>≙37,23%</td>
                        <td>172,96 ≙44,25%</td>
                        <td>182,02<br>≙46,57%</td>
                        <td>167,72<br>≙42,91%</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 2. Die fünf Compiler im Zeitvergleich. Im Test 1 wurden mit der RND-Funktion 100 Zeichen ermittelt, sortiert und nebeneinander ausgegeben. Die Benchmark-Tests 1 bis 8 waren so aufgebaut, daß die Zeit für die angegebenen Befehle selbst ermittelt werden konnten. Deshalb ist die Gesamtzeit nicht identisch mit der Summe der einzelnen Testzeiten. Jeder Befehl (Benchmark 1 bis 8) wurde 1000mal durchgeführt.</figcaption>
        </figure>

        <p>Es muß an dieser Stelle der Vollständigkeit halber jedoch noch erwähnt werden, und das gilt auch für die Compiler-Tests in der Ausgabe 2/85, daß die Geschwindigkeiten des Benchmark-Tests unter Umständen ein unklares Bild liefern können. Die Testprogramme sind nämlich generell nicht an einen Compiler angepaßt und können demzufolge nicht dessen spezielle Eigenschaften ausnutzen. Durch optimierende Eingriffe in Programme und durch Anweisungen an die Compiler können deshalb in der Regel noch höhere Leistungen erzielt werden.</p>

        <h2>Basic 64 im Überblick</h2>

        <p>Basic 64 zeigte in diesem Test Eigenschaften, die durchweg als positiv zu sehen sind. Die Dokumentation ist sehr ausführlich und gibt dem Leser viele Informationen über die Arbeitsweise dieses Compilers.</p>

        <p>Der Compiler selbst ist sowohl für Anfänger (laden, starten, fertig) als auch für diejenigen mit viel Programmiererfahrung geeignet. Der Erfahrene wird viele Möglichkeiten finden, seine Programme auf die Stärken des Compilers hinzutrimmen. Dabei wird er unterstützt durch die vielen wählbaren und einstellbaren Funktionen des Basic 64.</p>

        <p>Die Geschwindigkeitstests ergaben durchschnittliche Werte, die in etwa denen des Austro-Speed entsprechen. Durch kleine Änderungen im Basic-Programm und durch Wahl anderer Basic 64 Funktionen kann die Geschwindigkeit jedoch noch gewaltig erhöht werden, so daß in günstigen Fällen sogar die Zeiten des Petspeed überboten werden können.</p>

        <p>Insgesamt gesehen also viel Leistung für 99 Mark.</p>

        <address class="author">(Karsten Schramm/gk)</address>
    </article>
</body>

</html>