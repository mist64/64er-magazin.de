<!DOCTYPE html>
<html lang="de">

<head>
    <title>Sprachen für Computer</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="ev">
    <meta name="64er.issue" content="4/85">
    <meta name="64er.pages" content="47-49">
    <meta name="64er.head1" content="Software">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_category" content="Software">
    <meta name="64er.index_title" content="Sprachen für Computer">
    <meta name="64er.index_category" content="Software-Grundlagen|Sprachen">
    <meta name="64er.id" content="sprachen">
</head>

<body>
    <article>
        <h1>Sprachen für Computer</h1>
        <p class="intro">Warum braucht man überhaupt eine Programmiersprache ? Welche Sprache ist tür welchen Zweck geeignet ? Welche Sprachen gibt es für Commodore-Computer ? Der folgende Artikel gibt Auskunft.</p>

        <figure>
            <img src="47-1.png" alt="">
            <figcaption>Der »Stammbaum« der höheren Programmiersprachen</figcaption>
        </figure>

        <p>Wer sich eine Stereo-Anlage oder einen Video-Recorder zulegt, muß in der Regel nur die Funktion einiger wichtiger Tasten kennenlernen, um damit umgehen zu können. Bei einem Computer sieht das schon etwas anders aus. Zwar muß der zukünftige Programmierer sich auch hier als erstes mit allen Tastenfunktionen vertraut machen, aber wenn er diese Phase mit Mühe und Not und schlechtem Handbuch hinter sich gebracht hat, beginnen erst die eigentlichen Probleme: Er muß eine Programmiersprache lernen, nämlich Basic.</p>

        <p>Doch in vielen Fällen bleibt es nicht dabei. Nach einer Zeit der Euphorie, in der man glaubt, alles in Basic programmieren zu können, stellt man schnell einige Schwächen dieser Sprache fest: Basic-Programme sind langsam, der Aufruf von Unterprogrammen über Zeilennummern statt über Namen führt ebenso wie das Fehlen von Strukturbefehlen zur schlechten Lesbarkeit, und schließlich macht die Vielfalt der verschiedenen Basic-Dialekte es fast unmöglich, Programme von anderen Computersystemen ohne großen Änderungsaufwand zu übernehmen. Es bleibt also nur der Umstieg auf eine andere Progammiersprache.</p>

        <p>Über diesem Punkt, beginnt die Programmierer-Gemeinde sich zu spalten: Die eine Gruppe fühlt sich vom Begriff »Maschinensprache« wie magisch angezogen und geht daran, die Schwächen von Basic in mühsamer Byte-für-Byte-Arbeit zu umgehen. Die andere Gruppe sieht sich nach echten Alternativen zu Basic um und stößt dabei mit einiger Sicherheit auf Begriffe wie »Pascal«, »Forth« oder »Logo«.</p>

        <h2>Wozu braucht man eine Programmiersprache?</h2>

        <p>Wenn wir uns mit anderen Menschen unterhalten wollen, benötigen wir eine Sprache. Genauso benötigt man auch für die Kommunikation mit — in einem gewissen Sinne — »intelligenten« Maschinen eine gemeinsame Basis, eine Sprache. Diese Sprache dient allerdings in erster Linie nicht zur Unterhaltung, sondern um dem Computer Anweisungen zu erteilen, um ihn zu programmieren.</p>

        <p>Man unterscheidet grob zwischen den maschinennahen Programmiersprachen (Assembler) und den höheren Programmiersprachen wie Basic, Pascal oder Fortran. Während die Assemblersprachen jeweils eng an eine bestimmte CPU (Central Processing Unit, oder Zentralprozessor) gebunden sind, zeichnen sich die höheren Programmiersprachen neben ihrer besseren Lesbarkeit vor allem durch ihre Prozessorunabhängigkeit aus. Im Idealfall sollte es so sein, daß zum Beispiel ein auf einem Apple geschriebenes Basic-Programm auch ohne Änderungen auf einem C 64 laufen sollte.</p>

        <p>Natürlich funktioniert das in der Praxis nicht — zumindest bei Basic. Hierfür gibt es zwei Gründe. Zum einen existiert eine Vielzahl verschiedener Basic-Dialekte, das heißt vom Standard abweichende Basic-Versionen. Zum anderen gibt es in Basic die Möglichkeit, mittels PEEK, POKE oder SYS direkt auf die Maschinenebene zuzugreifen, was wegen unterschiedlicher Hardware der einzelnen Computer auch unterschiedliche Folgen zeigt. Gerade dieser Zugriff auf die Maschinenebene wird aber von den auch im engeren Sinne höheren Programmiersprachen tunlichst vermieden, damit die Programme »portabel«, also auf andere Computer übertragbar bleiben. Insofern ist Basic um einiges näher an der Maschinenebene als die meisten anderen Sprachen.</p>

        <h2>Compiler und Interpreter</h2>

        <p>Jeder Computer hat eine Maschinensprache, das ist die Sprache, die sein Zentralprozessor direkt versteht. Diese »Sprache« besteht unglücklicherweise nur aus Folgen von »0« und »1«, ist also für einen Menschen einigermaßen schwer verständlich. Eine Ebene höher stehen da schon die Assemblersprachen, bei denen es für jeden Befehl der Maschinensprache eine Klartext-Abkürzung gibt. Spezielle Programme, selbst auch »Assembler« genannt, übersetzen diese mit »Mnemonics« bezeichneten Abkürzungen in die Maschinensprache.</p>

        <p>Doch auch in dieser Form ist das Programmieren noch ein sehr mühseliges Geschäft. Außerdem sind solche Assembler-Programme nicht oder nur sehr schwer auf andere Computersysteme übertragbar.</p>

        <p>Anfang der fünfziger Jahre kam daher folgerichtig das Konzept der »höheren Programmiersprachen« (siehe Bild) auf. Eine Hochsprache unterscheidet sich in wesentlichen Punkten von der Assembler-Sprache. Die Programme sind maschinenunabhängig, können also problemlos auf den verschiedensten Computern laufen. Außerdem sind sie für einen Menschen wesentlich besser nachzuvollziehen und zu lesen, was die Fehleranfälligkeit drastisch senkt. Allerdings werden diese Vorteile mit einem Nachteil erkauft: Es gibt keinen Prozessor, der eine solche Hochsprache direkt ausführen könnte; die Sprache ist der Maschine einfach »zu hoch«.</p>

        <p>Doch dieses Problem läßt sich leicht lösen. Alles was man braucht, ist ein Übersetzer, der die Hochsprache in die Maschinensprache übersetzt, und damit dem Computer zur Verarbeitung zugänglich macht. Der Übersetzungsvorgang selbst folgt dabei festen Regeln, was nichts anderes bedeutet, daß es einen Algorithmus (vereinfacht gesagt eine Rechenanleitung) dafür gibt. Jeder Algorithmus kann aber programmiert werden, und somit ist der Vorgang der Übersetzung automatisierbar. Die entsprechenden Übersetzungsprogramme heißen »Compiler«. Natürlich benötigt man für unterschiedliche Computersysteme (mit verschiedener Maschinensprache) auch unterschiedliche Compiler. Das Compiler-Programm selbst wie auch der erzeugte Maschinencode sind je nach CPU unterschiedlich, das übersetzte Programm tut jedoch völlig unabhängig vom Computersystem immer das gleiche, nämlich genau das, was durch das Hochsprachen-Programm vorgegeben ist.</p>

        <p>Daneben gibt es, besonders auf Mikrocomputern verbreitet, eine zweite Art der Bearbeitung einer höheren Programmiersprache. Der C 64 beispielsweise hat als CPU einen 6510-Prozessor, der an sich weit davon entfernt ist, auch nur ein paar Brocken Basic zu beherrschen. Dennoch kann man mit dem Computer ganz normal in Basic arbeiten. Das Programm muß nicht erst übersetzt werden, sondern es wird so, wie es ist, einfach interpretiert. Damit ist nichts anderes gemeint, als daß der Basic-Interpreter des C 64 einfach einen Super-Prozessor simuliert, der Basic als Maschinensprache hat. Bei dieser Simulation wird fortwährend Zeichen für Zeichen so interpretiert, wie es der hypothetische Basic-Prozessor tun würde.</p>

        <p>Natürlich ist dieses Vorgehen nicht besonders ökonomisch. Bei jedem Programmlauf muß der Interpreter ja wieder Zeichen für Zeichen durchsehen, was er damit anfangen kann. Der Compiler hingegen übersetzt das Programm nur einmal und wird anschließend nicht mehr gebraucht, da nun reiner Maschinencode vorhanden ist.</p>

        <p>Zu Anfang des Computerzeitalters war Rechenzeit kostbar, und so ist es kein Wunder, wenn in den fünfziger Jahren ausschließlich Compiler entwickelt wurden. Interpreter kamen erst mit höheren Prozessorleistungen in Mode.</p>

        <h2>Der erste Schritt — Fortran</h2>

        <p>Aus dem Bedürfnis nach einfacher Programmierung und Übertragbarkeit der Programme entstand 1952 die erste höhere Programmiersprache der Welt, nämlich Fortran. 1954 gab es bereits eine in wesentlichen Punkten verbesserte und ausgereifte Version, Fortran II, das über lange Jahre Standardsprache auf Großrechenanlagen war und sich auch heute noch — inzwischen als Fortran V — regen Zuspruchs erfreut.</p>

        <p>Der Name Fortran steht für <strong>FOR</strong>mula <strong>TRAN</strong>slator (Formelübersetzer), und genau dafür ist die Sprache auch entwickelt worden. Ihre Stärke liegt damit in der Programmierung mathematischer und naturwissenschaftlicher Formeln. Neben den bekannten Zahlentypen Integer (ganzzahlig) und Real (Fließkommazahlen) gibt es in Fortran daher noch den Typ Double Precision für das Rechnen mit doppelter Genauigkeit, sowie den vor allem in der Elektrotechnik sehr wichtigen Typ der »komplexen Zahlen« (Complex). Letzterer Datentyp steht aber wegen des intern zu treibenden Aufwands für komplexe Berechnungen in den meisten Mikrocomputer-Versionen nicht zur Verfügung.</p>

        <p>Fortran ist eine streng zeilen- und formatorientierte Sprache und erlaubt in der Regel nur einen Befehl pro Zeile. Wie in Basic, das übrigens im Jahre 1965 aus Fortran hervorgegangen ist, muß viel mit dem Befehl GOTO hin- und hergesprungen werden, jedenfalls beim weitverbreiteten Fortran IV. Die neueste Version, Fortran V nimmt der Sprache mit Strukturen wie IF&hellip;THEN&hellip;ELSE&hellip;ENDIF etwas von ihrer Ursprünglichkeit.</p>

        <p>Fortran gibt es unter CP/M für fast alle Mikrocomputer mit Z80-CPU. Für den C 64 ist die Sprache derzeit noch nicht erhältlich.</p>

        <p>Nur wenige Jahre nach der Entwicklung von Fortran kamen zwei weitere wichtige Programmiersprachen auf, Algol und Cobol.</p>

        <p>Mit Algol (<strong>ALGO</strong>rythmic <strong>L</strong>anguage) sollte in erster Linie mathematisch-theoretische Probleme angegangen werden. Die Sprache hat nie auch nur im entferntesten die Verbreitung von Fortran gefunden, ist aber dennoch sehr bedeutsam als »Stammvater« einer ganzen Generation von hochentwickelten, blockorientierten Sprachen, deren vorläufige Krönung die Sprache Ada darstellt.</p>

        <p>Cobol (<strong>CO</strong>mmon <strong>B</strong>usiness <strong>O</strong>riented <strong>L</strong>anguage) wurde im Jahre 1959 für kaufmännische Anwendungen entwickelt. Eine der Zielsetzungen für die Entwicklung war der Wunsch (oder besser die Fiktion), daß auch Nicht-EDV-Fachleute in der Lage sein sollten, die Programme wirklich lesen zu können.</p>

        <p>Aus dieser Zielsetzung entstand die wahrscheinlich schlechteste Programmiersprache aller Zeiten, die zu allem Unglück auch noch die am meisten verbreitete für den kommerziellen Einsatz wurde, und der erst in neuester Zeit mit der Verbreitung der Heimcomputer in Basic ein Konkurrent erwuchs.</p>

        <p>Cobol-Programme simulieren natürliche (englische) Sprache. Die Basic-Zeile »IF X>0 THEN A = B/X« sieht in Cobol folgendermaßen aus: IF X GREATER THAN 0 DIVIDE B BY X GIVING A</p>

        <p>Bei so einer Sprache wird natürlich aus jeder mathematischen Formel ein völlig unüberschaubares Gebilde. Hinzu kommt noch die merkwürdige Eigenschaft von Cobol, den Programmierer als Precompiler einzusetzen. Da gibt es als Vorspann zum eigentlichen Programm, der »Procedure Division«, eine sogenannte »Data Division«, in der vom Programmierer (!) festgelegt werden muß, wieviel Speicherplatz für eine Variable verwendet werden soll. Auch das Umcodieren von der internen Darstellung einer Variablen zur Ausgabe auf Bildschirm oder Drucker muß hier genau bestimmt werden.</p>

        <p>Wenn Cobol dennoch eine so weite Verbreitung gefunden hat, dann liegt das in erster Linie an der ausgeprägten Fähigkeit, große Datenmengen in Dateien zu organisieren und zu verwalten, eine im kaufmännischen Bereich sehr wichtige Aufgabe. Für alle anderen Anwendungsbereiche muß die Sprache allerdings als hoffnungslos ungeeignet bezeichnet werden.</p>

        <p>Wer trotz aller Warnungen in Cobol einsteigen möchte, der hat im Kleincomputerbereich derzeit nur unter CP/M die Möglichkeit dazu.</p>

        <p>Aus dem Bestreben, eine einheitliche Sprache zu entwickeln, welche alle Vorzüge der damals wichtigsten Sprachen Fortran, Algol und Cobol in sich vereinen sollte, entstand Mitte der sechziger Jahre die Sprache PL/1 (Programming Language 1). Leider wurde das Ziel nicht vollständig erreicht. Zwar vereinigt PL/1 Eigenschaften aller drei Sprachen in sich, aber nicht unbedingt die besten. PL/1-Programme wirken in der Regel aufgebläht und dennoch merkwürdig unzusammenhängend und unstrukturiert. Je nach persönlichem Programmierstil kann ein PL/1-Programm wie in Fortran, Algol oder Cobol geschrieben aussehen — im schlimmsten Falle auch wie ein Gemisch aus allen dreien. Eine fast unüberschaubare Anzahl an Schlüsselworten trägt zur Verwirrung jedes Programmierers bei. Böse Zungen ordnen die Sprache denn auch eher den Problemen als den Lösungen zu. PL/1 ist unter dem Betriebssystem CP/M für Heimcomputer verfügbar.</p>

        <h2>Pascal</h2>

        <p>Nach der Vorstellung dieser altehrwürdigen, aber immer noch weitverbreiteten Sprachen kommen wir nun zu einem modernen Klassiker unter den Programmiersprachen. Die Rede ist von Pascal, das 1971 von Niklaus Wirth an der ETH Zürich auf der Grundlage von Algol entwickelt worden ist. Pascal ist übrigens ausnahmsweise keine Abkürzung, sondern die Sprache erhielt ihren Namen zu Ehren des französischen Mathematikers und Philosophen Blaise Pascal, der im 18. Jahrhundert lebte.</p>

        <p>Wie der Vorgänger Algol ist auch Pascal eine stark standardisierte Sprache. Der ursprüngliche »Wirth-Standard«, der noch immer den meisten Pascal-Versionen zugrunde liegt, regelt sehr genau, welche Sprachelemente erlaubt sind, und was sie bewirken.</p>

        <p>Als Alternative existiert seit einiger Zeit das sogenannte USCD-Pascal, entwickelt in Kalifornien, das den im Wirth-Standard nicht vorgesehenen Datentyp »String« sowie entsprechende Funktionen dazu vorsieht. Der Unterschied zwischen Wirth- und USCD-Pascal ist ansonsten minimal. Die Übertragbarkeit von Pascal-Programmen wird dadurch jedenfalls kaum berührt, weil man sich in Pascal bei Bedarf einfach neue Datentypen definieren kann. Hat man keinen Datentyp »String« zur Verfügung, dann schreibt man einfach:
            <code>TYPE STRING = ARRAY[1..80] OF CHAR;</code>
            Der Typ »Char« ist in Pascal vordefiniert und repräsentiert jeweils ein einzelnes Zeichen. Mit der obigen Pascal-Zeile wurde der (neue) Datentyp »String« als Feld aus maximal 80 »Char«-Elementen definiert. Man kann jetzt in diesem Sinne weitermachen und mit Stringvariablen arbeiten. Das geht über die — in Pascal immer obligatorische — Variablenvereinbarung:
            <code>VAR ALPHA: STRING;</code>
            Damit wurde eine Variable Alpha vereinbart, die vom Typ String sein soll.
        </p>

        <p>Auf diese Art und Weise kann der Vorrat an Datentypen fast beliebig erweitert werden, ein Konzept, das in Pascal zum ersten Mal konsequent realisiert wurde und seither aus modernen Programmiersprachen nicht mehr wegzudenken ist.</p>

        <p>Pascal ist wegen seiner Leistungsfähigkeit und wegen seines logischen und konsistenten Aufbaus als Ausbildungssprache für angehende Programmierer oder Informatiker sehr beliebt.</p>

        <p>Die Sprache erzieht zum strukturierten Programmieren und, mehr noch, zum strukturierten Denkansatz bei der Problemlösung. Ein solcher Ansatz ist bei der Entwicklung größerer Programme ein nicht zu unterschätzender Vorteil.</p>

        <p>Pascal gibt es in mehreren Versionen für den C 64 und unter CP/M.</p>

        <p>Eine Marktübersicht finden Sie in einer der nächsten Ausgaben.</p>

        <address class="author">(ev)</address>
    </article>
</body>

</html>