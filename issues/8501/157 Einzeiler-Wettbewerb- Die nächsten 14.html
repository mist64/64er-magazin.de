<!DOCTYPE html>
<html lang="de">

<head>
    <title>Einzeiler-Wettbewerb: Die nächsten 14</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Heinz Bauschke, Marco Gleiter, Hans-Peter Harmann, Manfred Hedtke, Markus Hillebrand, Reinhard Jurk, Detlef Marks, Gerd Pickard, Volker Ritzhaupt, Hartmut Sprave, Martin Sprave, Klaus Vorwalter, Thomas Werner, Peter Zankl">
    <meta name="64er.issue" content="1/85">
    <meta name="64er.pages" content="157-158,160-162">
    <meta name="64er.head1" content="Einzeiler">
    <meta name="64er.head2" content="C 64/VC 20">
    <meta name="64er.toc_title" content="Einzeiler — die nächsten 14">
    <meta name="64er.toc_category" content="Wettbewerbe">
    <meta name="64er.index_title" content="Einzeiler-Wettbewerb: Die nächsten 14">
    <meta name="64er.index_category" content="Wettbewerbe|Einzeiler">
    <meta name="64er.id" content="einzeiler">
</head>

<body>
    <article>

        <h1>Einzeiler-Wettbewerb: Die nächsten 14</h1>

        <p>Wieder haben wir die interessantesten Einzeiler für Sie herausgesucht. Darunter sind sowohl nützliche als auch witzige oder lehrreiche. Sogar ein Adventure ist darunter. Alle Veröffentlichungen werden mit 50 Mark und einer Diskette mit allen Programmen dieser Ausgabe belohnt.</p>

        <p>Wenn man einigen Einsendern Glauben schenken will — und es besteht kein Grund, das nicht zu tun — , so sind ihre Einzeiler keineswegs schnell dahingeschriebene Programme, sondern oft das Ergebnis von tage-, ja wochenlangen Experimenten und Versuchen. Bei manchen anderen allerdings ist die programmiertechnische Umsetzung einer Idee nicht das Entscheidungskriterium gewesen, sondern vielmehr die Idee selbst. Sie werden auch sehen, daß bei einem Einzeiler weder das Programm noch die Idee besonders originell ist. Aber seine Programmbeschreibung ist so überzeugend, daß sie Ihnen nicht vorenthalten sein soll. Doch nun viel Spaß und hoffentlich einige »Aha«-Erlebnisse.</p>

        <h2>Umwandlung beliebiger Zahlensysteme (VC 20/C 64)</h2>

        <p>Die beiden Einzeiler dienen zum Umrechnen zwischen Dezimalzahlen und Zahlen beliebiger Basis. Kombiniert bilden beide eine Umwandlung zwischen verschiedensten Zahlensystemen. Beide Zeilen können sowohl als Unterroutine (mit RETURN) wie auch als Teil eines größeren Programms stehen.</p>

        <ol type="a">
            <li><strong>Umwandlung dezimal/beliebig</strong>
                <p>Die Routine wandelt eine Dezimalzahl beliebiger Größe in der Variablen D in eine Zahl der Basis um, die in der Variablen B angegeben ist. Das Ergebnis steht in Z$. Zuerst wird Z$ gelöscht. Dann wird eine Dummy-Schleife eröffnet, die nur einen einzigen Durchlauf zu haben scheint (0 bis 0). Der Befehl wird dazu genutzt, später wieder mitten in die Zeile einspringen zu können. Bei jeder Stelle wird D durch die Basis B geteilt und dadurch die unterste Ziffer abgeschnitten. Die jeweils niederwertigste Stelle ist der ganzzahlige Rest dieser Division und steht in S. S wird nun in den ASCII-Code umgerechnet, indem zur Zahl S 45 addiert wird. Ist S eine Ziffer von 0 bis 9, so nimmt der Term (S &lt; 10) den Wert —1 an und es wird 7 subtrahiert (siehe ASCII-Tabellen). Der Code wird durch den CHR$-Befehl in einen String gewandelt und vorne an Z$ angehängt. Die letzte (höchstwertige) Ziffer ist erreicht, wenn D &lt; 1 ist (nächste Stelle = 0). Die Schleifenvariable P wird auf —D gesetzt. Beim darauffolgenden NEXT-Kommando wird P um den STEP (hier 1) erhöht und mit dem Endwert des FOR-Befehls (hier 0) verglichen. Wenn D noch > = 1 ist, ist P + I &lt; = 0, die Endbedingung ist noch nicht erreicht und es wird zu dem Statement nach dem FOR-Befehl gesprungen.</p>
            </li>
            <li><strong>Umwandlung beliebig/dezimal</strong>
                <p>Diese Routine wandelt eine beliebige große Zahl der von der Variablen B angegebenen Basis in eine Dezimalzahl. Die zu wandelnde Zahl muß in Z$ stehen; die Variable D enthält das Ergebnis. Am Anfang wird die Variable D auf Null gesetzt. Die Schleifenvariable S des darauffolgenden FOR-Befehls dient als Zeiger auf die einzelnen Stellen von Z$. Diese werden nun in den ASCII-Code gewandelt, der Code für Null (48) wird subtrahiert und das Ergebnis in H zwischengespeichert. Die schon umgewandelten Stellen (in D) werden zunächst durch Multiplikation mit B um eine Potenz dieser Basis erhöht, um dann die aktuelle Stelle (H) zu addieren. Ist H>9 (Darstellung durch einen Buchstaben) müssen aufgrund des ASCII-Codes noch sieben abgezogen werden (Term (H>9) wird —1). Nach der niederwertigsten Stelle ist die Schleife beendet.</p>
            </li>
        </ol>

        <address class="author">(Martin + Hartmut Sprave)</address>

        <figure>
            <pre data-filename="einzeiler1" data-name="Umwandlung beliebiger Zahlensysteme"></pre>
        </figure>

        <h2>Scrollen in x-Richtung (C 64)</h2>

        <p>FORG=0TO3:NEXT ist eine Verzögerungsschleife; hier kann die Geschwindigkeit des Scrollers eingestellt werden. Zu beachten ist, daß alle Befehle in abgekürzter Schreibweise eingegeben werden müssen.</p>

        <address class="author">(Hans-Peter Harmann)</address>

        <figure>
            <pre data-filename="einzeiler2" data-name="Scrollen in x-Richtung"></pre>
        </figure>

        <h2>Das abwechslungsreiche Programm (C 64)</h2>

        <p>Liebe Redaktionäre, endlich ein Wettbewerb, an dem auch ich als Novize mich beteiligen kann. Meine Computer- und Programmierkenntnisse sind mittlerweile schon weit fortgeschritten (die l-Prozent-Hürde werde ich demnächst überspringen), so daß ich mich berufen glaube, auch etwas zum Besten zu geben.</p>

        <p>Ich stellte mir selbst hohe Anforderungen:</p>

        <ol>
            <li>Das Programm sollte abwechslungsreich sein</li>
            <li>Es sollte Bewegung im Spiel sein</li>
            <li>Die Farbe durfte nicht fehlen.</li>
        </ol>


        <p>Bitte das Programm sorgfältig abschreiben, um eine langwierige Fehlersuche zu vermeiden.</p>

        <p class="noindent">Variablenliste:</p>

        <ul class="plain">
            <li>A$ = Stunden von TI$</li>
            <li>B$ = Minuten von TI$</li>
            <li>C$ = Sekunden von TI$</li>
        </ul>

        <p>Vor Eingabe des Programms muß selbstverständlich TI$ auf die aktuelle Uhrzeit eingestellt werden. Die Zeilennummer 11 fristet für gewöhnlich ein Schattendasein hinter der 10. Deshalb habe ich aus Mitleid die 11 gewählt. Nachdem Sie den Bildschirm durch CLR/Home gereinigt haben, starten Sie das Programm. Sie sehen, daß meine Anforderungen erfüllt wurden.</p>

        <ol>
            <li>Das Programm ist abwechslungsreich (Wiederholungen treten höchstens nach 24 Stunden auf)</li>
            <li>Es bewegt sich was</li>
            <li>Es ist Farbe im Spiel</li>
        </ol>


        <p>Zu 3. Das Programm wurde so gestaltet, daß der Anwender leicht die Farbe ändern kann.</p>
        
        <p class="noindent">PS: Das Ausschalten des Computers bringt das Programm zum Abstürzen!!</p>
        
        <p class="noindent">PPS: Freundlich zugedachte Geldspenden werden nur auf Antrag angenommen.</p>

        <address class="author">(Gerd Pickard)</address>

        <figure>
            <pre data-filename="einzeiler3" data-name="Das abwechslungsreiche Programm"></pre>
        </figure>

        <h2>Ein RENEW, das funktioniert (C 64/VC 20)</h2>

        <p>Routinen, die nach einem Reset oder NEW das Basic-Programm zurückholen, sind zwar schon oft veröffentlicht worden, doch waren die meisten entweder nicht lauffähig oder das Abtippen wurde durch die Länge zu einer umständlichen und unsicheren Prozedur. Dieser Einzeiler ist natürlich im Direktmodus, also ohne Zeilennummer, einzugeben. Vorher dürfen jedoch keine Variablen definiert oder Basic-Zeilen eingetippt werden, da sonst das gelöschte aber noch im Speicher befindliche Programm zerstört werden würde. Das Prinzip des UNNEW-Programms beruht auf dem Aufruf einer System-Routine, die die Basic-Zeilen neu bindet und das Ende des gelöschten Programms herausfindet. Der erste POKE dient nur dazu, der Routine vorzutäuschen, daß sich noch ein ungelöschtes Basic-Programm im Speicher befindet, da sie sonst nicht arbeitet. Die Endadresse des Basic-Programms wird um zwei erhöht und in den Zeiger auf den Start der Variablen (45/46) übertragen. Der CLR-Befehl gleicht alle weiteren Basic-Zeiger diesem Wert an.</p>

        <p>SYS-Adresse für VC 20: 50483. Da beim VC 20 die Startadresse des Basic-Programms je nach Speicherausbau verschieden ist, muß man die Zahl »2050« durch das Ergebnis des folgenden Terms ersetzen« PRINT/PEEK(43) + 256 * PEEK(44) + 1.</p>

        <address class="author">(Hartmut + Martin Sprave)</address>

        <figure>
            <pre data-filename="einzeiler4" data-name="Ein RENEW, das funktioniert"></pre>
        </figure>

        <h2>Eine Zeile - kompletter Datenschutz (C 64)</h2>

        <p>Dieses Programm verhindert das Auflisten des Inhaltsverzeichnisses jeder beliebigen Diskette. Nebenbei stellen sich noch einige sehr brauchbare Effekte ein. Das Löschen und Überschreiben der auf der Diskette befindlichen Programme ist nicht mehr möglich. Außerdem kann nichts mehr auf die Disk geschrieben werden. Ebenso werden Diskettenbefehle wie VALIDATE oder INITIALIZE ignoriert. Sogar ein Headern der Diskette ohne neue ID ist nicht möglich. Das einzige, was den Inhalt der Diskette noch manipulieren kann, ist das Headern (Diskettenbefehl »NEW«) mit einer neuen ID-Nummer.</p>

        <p>Das Laden der bereits auf der Disk befindlichen Programme funktioniert hingegen ganz normal. Allerdings sollte man sich die Namen der gespeicherten Files merken, denn das Suchen mit Jokerzeichen ist bestenfalls ein netter Zeitvertreib, aber nicht unbedingt immer erfolgreich. Hat man beispielsweise zwei Programme, die mit A anfangen, auf der Diskette, so muß man von dem zweiten Programm ja mindestens die ersten beiden Buchstaben angeben, um es laden zu können.</p>

        <p>Daß das Directory nicht mehr gelistet werden kann liegt daran, daß es als Basic-Programm geladen wird und in dem veränderten Directory drei Nullen am Anfang erscheinen. Dies ist für den Interpreter jedoch das Zeichen für das Programmende. Das »Directory-Programm« endet also bereits nach zehn Bytes. Die ersten fünf Bytes stellen den Zeilenanfang und die Zeilennummer dar. Darauf folgen ein Leerzeichen und ein Anführungszeichen, die ja immer am Anfang eines Inhaltsverzeichnisses stehen. Um diese drei Zeichen beim Auslisten verschwinden zu lassen, folgen nun drei chr$(20), die jeweils ein Delete darstellen. Dies bewirkt, daß das Directory beim Auslisten nun völlig verschwindet. Das Listen wird hier abgebrochen, da nun unmittelbar die drei Nullen folgen, die das Programmende markieren. So erfolgt auf den List-Befehl nur die Meldung »READY«.</p>

        <p>Die reversen »t« werden am einfachsten eingegeben, wenn man zuerst zwei Anführungszeichen hintereinander schreibt, dann den Cursor zurück auf das zweite Anführungszeichen bewegt, dreimal die Taste »INST«( = Insert) und danach dreimal die Tasten »SHIFT« und »INST« (= Delete) betätigt. Die Zeile kann natürlich genauso im Direktmodus abgeschickt werden.</p>

        <address class="author">(Volker Ritzhaupt)</address>

        <figure>
            <pre data-filename="einzeiler5" data-name="Eine Zeile - kompletter Datenschutz"></pre>
        </figure>

        <h2>Geänderter Zeichensatz (C 64)</h2>

        <p>Das Programm enthält eine Variable, sechs POKE-Befehle, einen PEEK-Befehl und eine FOR-NEXT-Schleife. In der Variablen R wird die Adresse des Interrupt-Registers definiert (# 56334/$DC0E). Nun wird die Position des Zeichengenerators geändert, indem Bit 3 der Adresse 53272 ($D018) gesetzt und Bit 1 gelöscht wird. So wird der Bereich ab # 8192 beziehungsweise $2000 ausgewählt. Um den alten Zeichensatz lesen zu können, muß der Interrupt ausgeschaltet werden (Bit 0 in Adresse 56334 gelöscht), ebenso der Video-Chip (Bit 2 in Adresse 1 gelöscht). Die folgende Schleife würde in einem übersichtlichen Programm so aussehen            
            <code>FOR I = 0 TO 4095
                POKE 8192 + 1,
                PEEK(I + 53248) AND 60
                NEXT
            </code>
        </p>

        <p>Es wird also der Zeichensatz von Adresse # 53248 beziehungsweise $D000 an nach #8192 übertragen, wobeijedes Byte durch die AND-Funktion geändert wird. Diese bewirkt, daß die Bits 0, 1, 6 und 7 in jedem Byte gelöscht werden, also ganz einfach jedem Zeichen der rechte und der linke Rand abgeschnitten wird. In meinem Programm überdeckt die Schleife einen etwas größeren Bereich als eigentlich nötig wäre, nämlich von 6hoch5 = 7776 bis R/5 = 11267, was dem Resultat jedoch keinen Abbruch tut.</p>

        <p>Schließlich werden Video-Chip und Interrupt wieder eingeschaltet (Bit 2 in Adresse 1 und Bit 1 in Adresse 56334 gesetzt).</p>

        <p>Bemerkenswert ist vielleicht, daß ich nach der Realisierung meiner Idee ein einziges Zeichen zuviel im Programm hatte. Nach drei Stunden angestrengten Tüftelns kam mir die erlösende Idee. Ursprünglich hatte ich den Video-Chip durch POKEl,55 wieder eingeschaltet. Es genügt aber auch POKEl,7, da die übrigen Bits vom Prozessor automatisch gesetzt werden.</p>

        <address class="author">(Klaus Vorwalter)</address>

        <figure>
            <pre data-filename="einzeiler6" data-name="Geänderter Zeichensatz"></pre>
        </figure>

        <h2>Trick 17 mit ON&hellip;GOTO (C 64/VC 20)</h2>

        <p>Eine sehr interessante Version einer ON&hellip;GOTO-Anweisung. Zur Erklärung braucht eigentlich nur gesagt werden, daß der Ausdruck (A$ = "A") den Wert —1 hat, wenn ein »A« eingegeben wurde, sonst den Wert 0. Rechnen Sie nach oder probieren Sie es aus: Es funktioniert einwandfrei.</p>

        <address class="author">(Peter Zankl)</address>

        <figure>
            <pre data-filename="einzeiler7" data-name="Trick 17 mit ON...GOTO"></pre>
        </figure>

        <h2>Das kürzeste Abenteuerspiel der Welt (C 64/VC 20)</h2>

        <p>Das Spiel heißt »Nosferatu«. Im Spiel selbst stehen Sie einem Vampir gegenüber und müssen herausfinden, wie Sie ihn besiegen. Erlaubt sind deutsche Zweiwortkommandos. Eine Alternative für die Lösung besteht, indem Sie anstatt »WIRF KNOBLAUCH« »ZEIGE KREUZ« eintippen. Sie können sich auch andere Situationen überlegen, was das Programm noch zum kürzesten Adventure-Generator macht Cursorsteuerzeichen: Reverses Q = Cursor hoch, Reverses q = Cursor runter. Bitte achten Sie auf mein Copyright (für einen Vermerk war leider kein Platz) DARUM HIER: &copy;Copyright 1984, by me. Und noch etwas: Mogeln Sie beim Abtippen bitte nicht! Es wäre schade, wenn Sie schon beim Eintippen die Lösung kennen würden.</p>

        <p>Vampirische Grüße</p>

        <address class="author">(Thomas Werner)</address>

        <figure>
            <pre data-filename="einzeiler8" data-name="Das kürzeste Abenteuerspiel der Welt"></pre>
        </figure>

        <h2>Dividieren mit beliebig vielen Stellen hinter dem Komma (V 64)</h2>

        <p>Das Programm muß mit den bekannten Abkürzungen eingegeben werden, damit es in das 80-Zeichenformat paßt.</p>

        <h4>Variablenliste</h4>

        <ul class="plain">
            <li>Z = Zahl (mathematisch korrekt : DIVISOR)</li>
            <li>D = Dividend</li>
            <li>N = Anzahl der gewünschten Stellen hinter dem Komma</li>
            <li>E% = Ergebnis ohne Rest (wird ausgegeben)</li>
            <li>R = Rest</li>
            <li>Q% = Quotient beschränkt auf Vorkommazahl</li>
        </ul>

        <h4>Beschreibung:</h4>

        <p>Um die Vorkommazahl zu erhalten, benötigt man Q = INT(Z/D), was ich durch Q% = Z/D vereinfacht habe. Q% wird als Vorkommazahl ausgegeben. Es wird der Rest, nämlich die Differenz aus Z und Q% * D gebildet. Der Rest dient als Ausgangspunkt für die folgende Berechnung. Die Schleife wird Nmal durchlaufen, um exakt N Stellen hinter dem Komma zu ermitteln.</p>

        <p>Analog zum Vorschleifenteil wird E% = R * 10/D gebildet. E% wird ausgegeben als I.te Stelle.</p>

        <p>Der neue Rest wird durch R<sub>(neu)</sub> = 10 * R<sub>(alt)</sub> — D * E% (vergleiche Vorkommateil) gebildet.</p>

        <p>Und wiederum kann die Schleife durchlaufen werden, bis alle Stellen ausgegeben sind.</p>

        <h4>Beispiel:</h4>

        <p>Wie lautet die 85. Stelle hinter dem Komma von 116/113? (also: Z = 116, D = 13, N = 85) Programmlauf....</p>

        <p class="noindent">Ergebnis:</p>

        <p>Die 85. Stelle hinter dem Komma ist 9. (Selbstverständlich werden auch alle übrigen Stellen ausgegeben).</p>

        <address class="author">(Heinz Bauschke)</address>

        <figure>
            <pre data-filename="einzeiler9" data-name="Dividieren mit beliebig vielen Stellen
hinter dem Komma"></pre>
        </figure>

        <h2>Simulation - GOTO X (C 64)</h2>

        <p>Das Programm simuliert den im Commodore-Basic nicht vorhandenen Befehl GOTO X.</p>

        <p>Zu dem etwas seltsamen Aussehen der Zeile läßt sich folgendes sagen: In den Anführungszeichen steht ein Maschinenprogramm, dessen Opcodes im Listing des Basic-Interpreters diese merkwürdigen Zeichen erzeugen. Das disassemblierte Maschinenprogramm finden Sie in Listing 2, wobei die absoluten Adressen keine Bedeutung haben, das Programm adressiert nur relativ. Der mit der Materie etwas vertrautere Leser wird feststellen können, daß das Programm etwas umständlich geschrieben ist. Das liegt daran, daß nicht alle Character, die ein Opcode darstellen, eindeutig einer Zahl zugeordnet sind. So gäbe zum Beispiel die Zahl 255 im Maschinenprogramm das Zeichen (Commodore &amp; K), wenn die Zeile aber dann editiert würde, interpretiert das Basic dieses Zeichen aber mit 161. So ließe sich die Zeile nicht editieren, wäre also keine Basic-Zeile. Aus diesem Grund wurden alle solchen »doppeldeutigen« Codes umgangen, was die Umständlichkeit des Maschinenprogramms zur Folge hatte. Die SYS-Anweisung stellt die Lage des Maschinenprogramms mit Hilfe zweier Zeiger des Interpreters fest und startet das Programm.</p>

        <p>Nun zur Benutzung der GOTO X-Zeile und wie man sie eingibt: Es ist zwar möglich, die Zeile mit der in Ausgabe 7/84 beschriebenen »Finkel«-Methode einzugeben, was jedoch umständlich, zeitaufwendig und fehleranfällig wäre. Deshalb ist in Listing 3 ein Generierungsprogramm abgebildet. Dieses wird eingegeben und gestartet.</p>

        <p>Wenn der Checksum-Test positiv ausgefallen ist und man sich vergewissert hat, daß das Programm genauso eingegeben wurde, wie es ausgelistet ist, gibt man LIST ein, gefolgt von NEW. Dann fährt man mit dem Cursor auf Zeile 10 und drückt RETURN. GOTO X steht nun im Speicher und kann gelistet, editiert und abgeSAVEt werden.</p>

        <p>Selbstverständlich kann die Zeilennummer zwecks der Einbindung in eigene Programme geändert werden. Dazu weist man der Variablen LL% den Wert der anzuspringenden Zeile zu und springt mit GOTO zur Zeile, in der GOTO X steht.</p>

        <address class="author">(Reinhard Jurk)</address>

        <figure>
            <img src="157-1.png" alt="">
            <figcaption>Listing 1</figcaption>
        </figure>
        <figure>
            <pre>C*
    PC   IRQ  NV-BDIZC AC XR YR SP
.;  E147 EA31 00110001 08 08 02 F6
.
.,  081A  A9 CC      LDA #$CC
.,  081C  85 45      STA $45
.,  081E  85 46      STA $46
.,  0820  A5 9D      LDA $9D
.,  0822  85 55      STA $55
.,  0824  85 56      STA $56
.,  0826  A0 0C      LDY #$0C
.,  0828  C8         INY
.,  0829  91 55      STA ($55),Y
.,  082B  A2 81      LDX #$81
.,  082D  CA         DEX
.,  082E  C8         INY
.,  082F  8A         TXA
.,  0830  91 55      STA ($55),Y
.,  0832  AC 80 A3   LDY $A380
.,  0835  A6 2E      LDX $2E
.,  0837  A5 2D      LDA $2D
.,  0839  20 11 B1   JSR $B111
.,  083C  20 2B AF   JSR $AF2B
.,  083F  20 01 B8   JSR $B801
.,  0842  4C A3 A8   JMP $A8A3
.
.

READY.</pre>
            <figcaption>Listing 2</figcaption>
        </figure>
        <figure>
            <p>G O T O &nbsp;&nbsp; X<br>
                BITTE UNBEDINGT GENAUSO EINGEBEN !!!<br>
                43 KLAMMERAFFEN (@)</p>
            <pre data-filename="einzeiler10" data-name="Simulation - GOTO X (Basic Lader)"></pre>
            <figcaption>Listing 3. Der Basic-Lader für GOTO X</figcaption>
        </figure>

        <h2>Irrgarten (VC 20/C 64)</h2>

        <p>Das Programm belegt nur 40 Bytes Speicherplatz. Es erzeugt einen zufallsbedingten Irrgarten und läuft auf einem C 64 oder VC 20:</p>

        <p>Zum Programm: X ist eine durch die RND-Funktion ermittelte Zufallszahl. Sie ist nicht gerundet und liegt zwischen 0 und 2. Der Computer druckt hierauf den CHR$-Code von 164 plus der Zufallszahl x aus, wobei er von sich aus X auf 0 oder 1 rundet. Es erscheint also auf dem Bildschirm je nach X das CHR$-Zeichen von 164 oder 165.</p>

        <p>Der nach dem PRINT-Befehl folgende Strichpunkt bewirkt, daß das nächste Zeichen nicht erst in der nächsten Reihe, sondern gleich neben dem Zeichen davor erscheint.</p>

        <p>Die Variable Q, welche durch den RUN-Befehl automatisch gleich Null gesetzt wurde, wird nun um 1 erhöht. Ist sie noch kleiner als 880, so wird die Schleife erneut durchlaufen. Das entstehende horizontale und vertikale Muster ist ein Labyrinth — aufgebaut aus nur diesen beiden Zeichen.</p>

        <p>Durch Verwendung anderer CHR$-Zeichen (zum Beispiel 176 bis 179) läßt sich das Programm gut variieren.</p>

        <p>Jedenfalls: Es ist nicht immer einfach den richtigen Weg zu finden!</p>

        <address class="author">(Marco Gleiter)</address>

        <figure>
            <pre data-filename="einzeiler11" data-name="Irrgarten"></pre>
        </figure>

        <h2>Clevere Idee: Grafikbildschirm löschen mit dem DIM-Befehl (C 64)</h2>

        <p class="noindent">Programmbeschreibung:</p>

        <ol>
            <li>a = 0:b = 0
                <p>Im weiteren Verlauf wird das Variablenfeld beeinflußt. Die Variablen a und b müssen deshalb vor der DIM-Anweisung angelegt sein.</p>
            </li>
            <li>a = peek(49):b = peek(50)
                <p>Die Werte für das Variablenende werden gesichert.</p>
            </li>
            <li>dim f((16191-a-b*256) / 5)
                <p>Durch das Dimensionieren einer Variablen wird ein entsprechend großer Platz hinter dem Variablenende freigemacht beziehungsweise mit dem Wert 0 gefüllt. Nun muß der Platz nur noch mit der Adresse des Bildschirms übereinstimmen.</p>
                <p class="noindent">Zur Formel (16191-a-b*256) / 5 :</p>
                <p>Der Bildschirmspeicher liegt von 8192 bis 16191. Die Variable f wird hinter dem bisherigen Variablenende angelegt.</p>
                <ul class="plain">
                    <li>Adresse des Variablenendes: a + b*256</li>
                    <li>also: 16191-a-b*256</li>
                    <li>Pro indizierte Variable werden 5 Byte freigemacht,</li>
                    <li>also: (16191-a-b*256) / 5</li>
                </ul>
                <p>Die mit 0 indizierte Variable ist nicht berücksichtigt, ebenso die ersten 7 Byte für Variablenname und Dimension.</p>
            </li>
            <li>poke 49,a : poke 50,b
                <p>Die alten Werte werden wieder hergestellt. Die Variable f ist jetzt nicht mehr dimensioniert.</p>
            </li>
        </ol>

        <p>Zum ordnungsgemäßen Verlauf müssen zwei Punkte beachtet werden.</p>

        <ol>
            <li>Das Variablenende muß kleiner als 8186 sein, das heißt das Programm darf einschließlich Variablenfeld nicht größer als 6 KByte sein. Mit 6 KByte stehtjedoch ein ausreichend großer Platz zur Verfügung.
                <p>Ist dies nicht der Fall, wird lediglich der Bildschirm nicht ganz gelöscht. Das Programm kann in keinem Fall Schaden nehmen.</p>
            </li>
            <li>Soll das Grafikprogramm zum Abspeichern von Bildern benutzt werden, darf man nicht vergessen, den Zeiger für Speichergrenze (peek(55) + peek(56)*256) auf eine Adresse kurz hinter den Bildschirmspeicher zu setzen.</li>
        </ol>

        <p>In meinem Grafikprogramm rufe ich die Zeile 10 immer dann auf, wenn über die Tastatur »shift + clr home« eingegeben wird (entsprechend »freier Bildschirm im Textmodus«).</p>

        <address class="author">(Manfred Hedtke)</address>

        <figure>
            <pre data-filename="einzeiler12" data-name="Grafikbildschirm löschen mit dem DIM-
Befehl"></pre>
        </figure>

        <h2>Zweifarbiger Rahmen (C 64)</h2>

        <p>Wie jeder weiß, ist der Bildaußenrahmen des C 64 immer einfarbig. Ich habe nun einen kleinen Einzeiler geschrieben, der einen zweifarbigen Außenrahmen simuliert. Die beiden Farben sind: 0 = schwarz und 1 = weiß. Es ist darauf zu achten, daß die Basic-Zeile genauso eingetippt wird, wie sie abgebildet ist. Ich meine damit die Anzahl der Spaces und Doppelpunkte. Erklärung: Ich wollte die Grenze zwischen den beiden Farben möglichst ruhig auf dem Bildschirm haben und mußte dazu die genaue Farbwechselperiode finden. Der Interpreter arbeitet Doppelpunkte und Spaces unterschiedlich schnell ab; so konnte ich mit den Spaces eine Feineinstellung vornehmen. Aber vorsichtig: Sobald während des Programmlaufs eine Taste gedrückt wird, tritt die Raster-Interrupt Tastaturabfrage in Kraft und das Bild fängt an zu »laufen«.</p>

        <p>Hilfe zum Abtippen:</p>

        <p class="noindent">Zwischen den beiden POKEs, und den Doppelpunkten befinden sich je fünf Spaces. Es folgen dann 17 beziehungsweise 15 Doppelpunkte.</p>

        <p>So einfach es auch immer ist: Es verblüfft einen doch!</p>

        <address class="author">(Markus Hillebrand)</address>

        <figure>
            <pre data-filename="einzeiler13" data-name="Zweifarbiger Rahmen"></pre>
        </figure>

        <h2>Fakultät (C 64)</h2>

        <p>Das Programm berechnet Fakultäten, ist also sehr nützlich für einige mathematische Funktionen, da der C 64 keinen derartigen Befehl besitzt.</p>

        <p class="noindent">Variablen:</p>

        <ul class="plain">
            <li>A = Eingabevariable,</li>
            <li>B = Zählvariable,</li>
            <li>C = Rechen- und Ausgabevariable.</li>
        </ul>

        <p>Das Programm berechnet sogar Fakultäten, die größer als »69« sind. Es ist also besser als ein Taschenrechner.</p>

        <address class="author">(Detlef Marks)</address>

        <figure>
            <pre data-filename="einzeiler14" data-name="Fakultät"></pre>
        </figure>

    </article>

</body>

</html>