<!DOCTYPE html>
<html lang="de">

<head>
    <title>Assembler ist keine Alchimie: Teil 5</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Heimo Ponnath, gk">
    <meta name="64er.issue" content="1/85">
    <meta name="64er.pages" content="142-147">
    <meta name="64er.head1" content="Assembler-Kurs">
    <meta name="64er.head2" content="C 64/VC 20">
    <meta name="64er.toc_title" content="Assembler ist keine Alchimie (Teil 5)">
    <meta name="64er.toc_category" content="Kurse">
    <meta name="64er.index_title" content="Assembler ist keine Alchimie (Teil 5)">
    <meta name="64er.index_category" content="Kurse|Assembler">
    <meta name="64er.id" content="assembler">
</head>

<body>
    <article>

        <h1>Assembler ist keine Alchimie: Teil 5</h1>

        <p class="intro">In dieser Folge des Assembler-Kurses wird die relative Adressierung erklärt. Damit verbunden sind auch die wichtigen Vergleichsoperationen. Anhand einer sehr häufig verwendeten Betriebssystem-Routine können Sie Ihr neu erworbenes Wissen testen.</p>

        <p>In der letzten Ausgabe haben wir die Branch-Befehle kennengelernt. Heute wollen wir uns mit der relativen Adressierung dieser Befehle und noch einer anderen Art der Adressierung befassen. Weiterhin werden Sie einige neue Assembler-Worte lernen, nämlich die Vergleichsbefehle. Wie ganze Zahlen im Computer gespeichert sind, wissen wir bereits. Heute untersuchen wir die Speicherung von Zeichen. Schließlich werden wir unsere Nase noch ein wenig in die eingebaute Software des C 64 stecken.</p>

        <h3>Die relative Adressierung</h3>

        <p>Als wir den BNE-Befehl das erstemal verwendet haben, stellten wir fest, daß zum Beispiel BNE 1200 nicht — wie eigentlich zu erwarten war — ein 3-Byte-Befehl, sondern ein 2-Byte-Befehl ist. Damals mußten wir uns mit der Bemerkung zufrieden geben, es läge an der besonderen Art der Adressierung, nämlich der relativen Adressierung. Relativ bedeutet ja »bezogen auf etwas«. Wenn wir also beispielsweise BNE 1200 schreiben, liegt es nur an der Benutzerfreundlichkeit des SMON und vieler anderer Assembler, daß dieser die so geschriebene absolute Adresse 1200 in die richtige Form, nämlich die relative umrechnet. In Wahrheit verlangt der 6502 (und natürlich ebenso der 6510) eine Angabe darüber, wieviele Bytes nach vorne oder hinten im Programm er zur weiteren Programmverarbeitung springen (verzweigen) soll. Es gilt nun also, zwei Fragen zu klären:</p>

        <ol>
            <li>Relativ wozu wird gesprungen und</li>
            <li>Wie berechnet sich die Angabe, um wieviele Bytes nach vorne oder hinten im Programm der Sprung vollzogen werden soll.</li>
        </ol>


        <p>Zur Klärung verwenden wir ein hypothetisches Programmsegment mit einem Sprungbefehl und sehen uns das Disassembler-Listing an:</p>

        <table class="plain">
            <tr>
                <td>2000</td>
                <td>AD 00 30</td>
                <td>LDA 3000</td>
            </tr>
            <tr>
                <td>2003</td>
                <td>F0 05</td>
                <td>BEQ 200A</td>
            </tr>
            <tr>
                <td>2005</td>
                <td>A9 00</td>
                <td>LDA #00</td>
            </tr>
            <tr>
                <td>2007</td>
                <td>8D 00 30</td>
                <td>STA 3000</td>
            </tr>
            <tr>
                <td>200A</td>
                <td>60</td>
                <td>RTS</td>
            </tr>
        </table>

        <p>Dieses Programm-Teilchen lädt den Inhalt der Speicherstelle 3000 in den Akku, überprüft dann, ob dieser Inhalt null ist und verzweigt beim Vorliegen der Null zum Rücksprung (RTS). Ist der Inhalt von 3000 nicht Null, dann wird 3000 auf Null gesetzt. 3000 könnte zum Beispiel eine Flagge sein.</p>

        <p>Der Pfad, dem der Computer bei der Abarbeitung des Programmes folgt, wird durch den Programmzähler vorbereitet. Dieser ist dann, wenn der BEQ-Befehl an der Reihe ist, schon einen Schritt weiter, nämlich im Programmzähler steht dann die Adresse 2005.</p>

        <p>Relativ zu dieser Adresse hat dann der Sprung zu erfolgen. Zum Inhalt des Programmzählers muß also die Sprungweite (auch häufig Offset genannt) addiert werden. Soweit zur Frage 1.</p>

        <p>Zur Klärung von Frage 2 listen wir uns mal Byte für Byte unser Programm auf:</p>

        <table class="plain">
            <tr>
                <td>Byte</td>
                <td></td>
                <td>Inhalt</td>
                <td>Bedeutung</td>
            </tr>
            <tr>
                <td>2000</td>
                <td></td>
                <td>AD</td>
                <td>LDA</td>
            </tr>
            <tr>
                <td>2001</td>
                <td></td>
                <td>00</td>
                <td>LSB von 3000</td>
            </tr>
            <tr>
                <td>2002</td>
                <td></td>
                <td>30</td>
                <td>MSB von 3000</td>
            </tr>
            <tr>
                <td>2003</td>
                <td></td>
                <td>F0</td>
                <td>BEQ</td>
            </tr>
            <tr>
                <td>2004</td>
                <td></td>
                <td>05</td>
                <td>Offset</td>
            </tr>
            <tr>
                <td>2005</td>
                <td></td>
                <td>A9</td>
                <td>LDA #</td>
            </tr>
            <tr>
                <td>2006</td>
                <td>1</td>
                <td>00</td>
            </tr>
        </table>

        <table class="plain">
            <tr>
                <td>Byte</td>
                <td></td>
                <td>Inhalt</td>
                <td>Bedeutung</td>
            </tr>
            <tr>
                <td>2007</td>
                <td>2</td>
                <td>8D</td>
                <td>STA</td>
            </tr>
            <tr>
                <td>2008</td>
                <td>3</td>
                <td>00</td>
                <td>LSB von 3000</td>
            </tr>
            <tr>
                <td>2009</td>
                <td>4</td>
                <td>30</td>
                <td>MSB von 3000</td>
            </tr>
            <tr>
                <td>200A</td>
                <td>5</td>
                <td>60</td>
                <td>RTS</td>
            </tr>
        </table>

        <p>Neben der Byte-Nummer ist noch die Entfernung zu 2005 geschrieben. Daraus ist deutlich zu erkennen, daß die Sprungweite, die zum Programmzähler addiert wird, 05 sein muß, wenn der Sprung zum RTS erfolgen soll. Für Vorwärts-Verzweigungen gilt also: Von der Adresse des Befehls an, der auf den Branch-Befehl folgt, zählt man die Byte-Anzahl bis zum Sprungziel. Das Ergebnis ist der Offset.</p>

        <p>Nun gibt es genauso häufig Rückwärts-Sprünge. In den bisher gezeigten Programmen sind sie mehrmals aufgetreten. Wie berechnet man den Offset in diesen Fällen? Sehen wir uns wieder das Disassembler-Listing eines solchen Programmsegmentes an:</p>

        <table class="plain">
            <tr>
                <td>1000</td>
                <td>A2 00</td>
                <td>LDX #00</td>
            </tr>
            <tr>
                <td>1002</td>
                <td>E8</td>
                <td>INX</td>
            </tr>
            <tr>
                <td>1003</td>
                <td>D0FD</td>
                <td>BNE 1002</td>
            </tr>
            <tr>
                <td>1005</td>
                <td>00</td>
                <td>BRK</td>
            </tr>
            <tr>
                <td>...</td>
            </tr>
        </table>

        <p>Dieses Progrämmchen tut nichts anderes, als das vorher auf Null gesetzte X-Register hochzuzählen, bis es über 255 läuft (dann tritt ja wieder 0 auf!). Solange der Inhalt des X-Registers ungleich Null ist, erfolgt ein Sprung zurück bis zur INX-Anweisung in Zeile 1002. Erst wenn die Null durch den Überlauf aufgetreten ist, endet das Programm mit einem BRK in Zeile 1005.</p>

        <p>Wir wissen schon, daß der Programmzähler beim Verarbeiten des BNE-Befehls auf 1005 steht. Sehen wir uns auch dieses Programm Byte für Byte an:</p>

        <table class="plain">
            <tr>
                <td>Byte</td>
                <td></td>
                <td>Inhalt</td>
                <td>Bedeutung</td>
            </tr>
            <tr>
                <td>1000</td>
                <td></td>
                <td>A2</td>
                <td>LDX #</td>
            </tr>
            <tr>
                <td>1001</td>
                <td></td>
                <td>00</td>
            </tr>
            <tr>
                <td>1002</td>
                <td>3</td>
                <td>E8</td>
                <td>INX</td>
            </tr>
            <tr>
                <td>1003</td>
                <td>2</td>
                <td>D0</td>
                <td>BNE</td>
            </tr>
            <tr>
                <td>1004</td>
                <td>1</td>
                <td>FD</td>
                <td>Offset</td>
            </tr>
            <tr>
                <td>1005</td>
                <td>00</td>
                <td>BRK</td>
            </tr>
        </table>

        <p>Wieder ist neben der Bytenummer die Entfernung vom aktuellen Programmzählerstand angegeben. Wir müssen also vom Inhalt des Programmzählers 3 abziehen, um zum INX-Befehl in Byte 1002 zu gelangen. Das kennen wir aber schon aus den vergangenen Ausgaben: Wenn der Computer eine Zahl abzieht, dann addiert er das Zweierkomplement dieser Zahl. Hier soll nun 3 subtrahiert werden. Wir berechnen das Zweierkomplement:<br>
            3 = 0000 0011 (binär)<br>
            Das Einerkomplement davon ist:<br>
            1111 1100<br>
            Dann wird eine 1 addiert<br>
            1111 1101</p>

        <p>Dies ist das Zweierkomplement. In hexadezimal ausgedrückt heißt diese Zahl $FD und ist unser Offset. Für Rückwärts-Verzweigungen gilt also: Von der auf die Branch-Anweisung folgenden Speicherstelle an zählt man die Bytes zurück bis zum Sprungziel. Das Zweierkomplement der sich dadurch ergebenden Byte-Anzahl ist der Offset.</p>

        <p>Das sieht reichlich kompliziert aus, aber zum einen haben Sie ja einen ganz freundlichen Assembler und nur in seltenen Notfällen müssen Sie den Offset berechnen. Zum anderen gibt es noch eine Faustregel, mit der man sich das ganze vereinfachen kann. Die soll durch folgendes Schema erläutert werden:</p>

        <table class="plain">
            <tbody>
                <tr>
                    <td>Byte</td>
                    <td>Inhalt</td>
                    <td>Offset</td>
                </tr>
                <tr>
                    <td>...</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>1995</td>
                    <td></td>
                    <td>F9</td>
                </tr>
                <tr>
                    <td>1996</td>
                    <td></td>
                    <td>FA</td>
                </tr>
                <tr>
                    <td>1997</td>
                    <td></td>
                    <td>FB</td>
                </tr>
                <tr>
                    <td>1998</td>
                    <td></td>
                    <td>FC</td>
                </tr>
                <tr>
                    <td>1999</td>
                    <td></td>
                    <td>FD</td>
                </tr>
                <tr>
                    <td>2000</td>
                    <td>BNE</td>
                    <td>FE</td>
                </tr>
                <tr>
                    <td>2001</td>
                    <td>Offset</td>
                    <td>FF</td>
                </tr>
                <tr>
                    <td>2002</td>
                    <td>Programmzählerstand</td>
                    <td></td>
                </tr>
                <tr>
                    <td>2003</td>
                    <td></td>
                    <td>01</td>
                </tr>
                <tr>
                    <td>2004</td>
                    <td></td>
                    <td>02</td>
                </tr>
                <tr>
                    <td>2005</td>
                    <td></td>
                    <td>03</td>
                </tr>
            </tbody>
        </table>

        <p>Bei Vorwärtssprüngen ist ohnehin alles klar: Bei einem Sprung nach Adresse 2005 müßte man in vorliegendem Fall einen Offset von 03 eingeben. Bei Rückwärts-Verzweigungen zählt man einfach von $FF an rückwärts bis zur Zieladresse. Eine Verzweigung nach 1996 würde im vorliegenden Fall also einen Offset von $FA erfordern.</p>

        <p>Eine Einschränkung der relativen Adressierung können Sie nun auch sofort verstehen, wenn Sie an Zweierkomplementzahlen denken: Der Offset belegt ein Byte. Die größte positive Zahl in einem Byte ist<br>
            0111 1111 = +127 = $7F<br>
            und die kleinste negative Zahl ist<br>
            1000 0000 = -128 = ($80)</p>

        <p>Es sind keine größeren Vorwärts-Verzweigungen als um 127 Bytes möglich, weil in diesem Fall ein Offset größer als $7F, also mit einem Bit 7 gleich 1 nötig wäre, was aber wieder als negative Zweierkomplementzahl verstanden und einen Rückwärtssprung verursachen würde. Ähnliches gilt anders herum: Es ist kein weiterer Rücksprung als um 128 Bytes möglich, weil das im Offset zum gelöschten Bit 7 führen würde, also zu einem Offset kleiner als $80, was wiederum anstelle des Rücksprunges eine Vorwärts-Verzweigung herbeiführen würde.</p>

        <p>Darauf sollte man achten beim Erstellen eines Assembler-Programmes, daß man nie weitere Rückwärtssprünge als um 128, beziehungsweise Vorwärtssprünge um 127 Bytes verlangt. Auch wenn man im Assembler gar nicht auf relative Adressierung Rücksicht nehmen muß, weil der Assembler sich mit den Absolutadressen begnügt, sollte man wissen, daß zum Beispiel folgende Zeile aufgrund dieser Einschränkung nicht möglich ist:<br>
            3000 BNE 1000</p>

        <p>Die meisten Assembler reagieren auf solch eine Zeile mit einer Fehlermeldung oder so wie der SMON, der klammheimlich die Programmstartadresse statt 1000 einsetzt. Aber es ist doch ärgerlich, wenn man auf dem Papier ein Programm fertig hat und erst beim Eintippen feststellt, daß der Computer das so nicht haben will.</p>

        <h3>Zeropage-Adressierung</h3>

        <p>Weil wir nun gerade mit der Adressierung so schön in Schwung sind, stelle ich Ihnen noch eine andere vor: Die Adressierung der Zeropage. Was ist die Zeropage? Auf deutsch heißt das Nullseite. Am besten versteht man das, wenn man sich in Erinnerung ruft, wie Adressen in unserem Computer verwaltet werden. Da haben wir doch ein LSB (Least Significant Byte) und ein MSB (Most Significant Byte), zum Beispiel $lF 04 (mit lF als MSB und 04 als LSB). Nun hat unser C 64 65535 Adressen von $0000 bis $FFFF. Bei den ersten 256 Adressen von $0000 bis $00FF ist das MSB $00. Man nennt so einen 256-Byte-Block eine Seite (engl. page). Weil hier für alle Adressen dieser ersten Seite des MSB Null ist heißt sie Nullseite = Zeropage. Messerscharf werden Sie schließen, daß man die Seite mit den MSBs $01 als erste Seite bezeichnet, die mit den MSBs $02 als 2. Seite und so weiter.</p>

        <p>Wenn wir nun zum Beispiel den Akku mit dem Inhalt der Zeropage-Adresse $00FA laden wollen, dann könnten wir schreiben:<br>
            3000 LDA 00FA</p>

        <p>Unser Mikroprozessor versteht uns aber auch, wenn wir nur schreiben:<br>
            3000 LDA FA</p>

        <p>Das ist sie, die Zeropage-Adressierung. Anstelle eines 3-Byte-Befehls ist das jetzt ein 2-Byte-Befehl, was Speicherplatz und vor allem Rechenzeit einspart. Auf diese Weise kann man von den bisher kennengelernten Befehlen folgende adressieren:<br>
            LDA, LDX, LDY, STA, STX, STY, INC, DEC, ADC und SBC</p>

        <p>Sie können sich merken, daß man (bis auf zwei Ausnahmen, die wir noch kennenlernen werden) alle absolut adressierbaren Befehle auch Zeropage-absolut anwenden kann. Genauere Angaben über die Codes, die Ausführungszeiten und die Beeinflussung der Flaggen (letztere ist identisch mit der absoluten Adressierung) entnehmen Sie bitte der angefügten Tabelle 1.</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td rowspan="2">Befehlswort</td>
                        <td rowspan="2">Adressierung</td>
                        <td rowspan="2">Byteanzahl</td>
                        <td colspan="2">Code</td>
                        <td rowspan="2">Dauer in Taktzyklen</td>
                        <td rowspan="2">Beeinflussung von Flaggen</td>
                    </tr>
                    <tr>
                        <td>Hex</td>
                        <td>Dez</td>
                    </tr>
                    <tr>
                        <td>LDA</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>A5</td>
                        <td>165</td>
                        <td>3</td>
                        <td>N,Z</td>
                    </tr>
                    <tr>
                        <td>LDX</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>A6</td>
                        <td>166</td>
                        <td>3</td>
                        <td>N,Z</td>
                    </tr>
                    <tr>
                        <td>LDY</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>A4</td>
                        <td>164</td>
                        <td>3</td>
                        <td>N,Z</td>
                    </tr>
                    <tr>
                        <td>STA</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>85</td>
                        <td>133</td>
                        <td>3</td>
                        <td>–</td>
                    </tr>
                    <tr>
                        <td>STX</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>86</td>
                        <td>134</td>
                        <td>3</td>
                        <td>–</td>
                    </tr>
                    <tr>
                        <td>STY</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>84</td>
                        <td>132</td>
                        <td>3</td>
                        <td>–</td>
                    </tr>
                    <tr>
                        <td>INC</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>E6</td>
                        <td>230</td>
                        <td>5</td>
                        <td>N,Z</td>
                    </tr>
                    <tr>
                        <td>DEC</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>C6</td>
                        <td>198</td>
                        <td>5</td>
                        <td>N,Z</td>
                    </tr>
                    <tr>
                        <td>ADC</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>65</td>
                        <td>101</td>
                        <td>3</td>
                        <td>N,V,Z,C</td>
                    </tr>
                    <tr>
                        <td>SBC</td>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>E5</td>
                        <td>229</td>
                        <td>3</td>
                        <td>N,V,Z,C</td>
                    </tr>
                    <tr>
                        <td rowspan="3">CMP</td>
                        <td>Unmittelbar</td>
                        <td>2</td>
                        <td>C9</td>
                        <td>201</td>
                        <td>2</td>
                        <td rowspan="9">N,Z,C</td>
                    </tr>
                    <tr>
                        <td>absolut</td>
                        <td>3</td>
                        <td>CD</td>
                        <td>205</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>C5</td>
                        <td>197</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td rowspan="3">CPX</td>
                        <td>unmittelbar</td>
                        <td>2</td>
                        <td>E0</td>
                        <td>224</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>absolut</td>
                        <td>3</td>
                        <td>EC</td>
                        <td>236</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>E4</td>
                        <td>228</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td rowspan="3">CPY</td>
                        <td>unmittelbar</td>
                        <td>2</td>
                        <td>C0</td>
                        <td>192</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>absolut</td>
                        <td>3</td>
                        <td>CC</td>
                        <td>204</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>0-Page, abs.</td>
                        <td>2</td>
                        <td>C4</td>
                        <td>196</td>
                        <td>3</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 1: Kenndaten der neuen Befehle und Adressierungen</figcaption>
        </figure>

        <p>Zum Thema Geschwindigkeit: Wenn Sie die benötigten Taktzyklen von absolut und von 0-absolut adressierten Befehlen in den Tabellen miteinander vergleichen, werden Sie jeweils einen Unterschied von einem Zyklus feststellen. Das mag Ihnen läppisch vorkommen. Bedenken Sie aber, daß Sie sehr häufig Schleifen programmieren müssen, die mehrere 100 Mal durchlaufen werden, die vielleicht als oft zu verwendende Unterprogramme dienen&hellip; Sie werden bald feststellen, daß da schnell beachtliche Zeitunterschiede auftreten können: Für zeitkritische Programme ist die Verwendung der Zeropage-Adressierung dringend geboten.</p>

        <p>Dieser Tatsache waren sich leider auch die Schöpfer unseres Betriebssystems und des Basic-Interpreters voll bewußt. Die Zeropage ist nahezu randvoll mit Speicherstellen, in denen sich beide Programmkomplexe tummeln. Fast jede Kernal- und Interpreter-Routine notiert sich irgendwelche Werte auf der Seite Null. Das macht es uns als Assembler-Programmierer nicht gerade leicht, die Zeropage-Adressierung zu verwenden, wenn wir außerdem den Interpreter oder das Betriebssystem benutzen wollen. Es kann geradezu katastrophale Folgen haben, einige Zeropage-Adressen zu überschreiben. Andere werden ständig neu beschrieben durch das Betriebssystem oder den Interpreter, was unseren eigenen — vielleicht gerade in so einer Speicherzelle gelagerten — Zwischenwerten den Garaus machen würde. Man sollte sich also die ersten 256 Speicherstellen ganz genau ansehen, bevor man sie adressiert oder aber auf das Betriebssystem und den Basic-Interpreter verzichten. Ersteres erleichtern uns Tabellen der Speicherbelegung (zum Beispiel Babel, Krause, Dripke »Das Interface Age Systemhandbuch zum Commodore 64«, Interface Age Verlag, oder »Das Commodore 64 Buch, Band 4, Ein Leitfaden für Systemprogrammierer«, Markt und Technik Verlag) und auch die Serie von Dr. Helmut Hauck »Memory Map mit Wandervorschlägen«, die seit Ausgabe 11/84 erscheint.</p>

        <p>Ohne Hemmungen nutzen dürfen wir nur die Speicherstellen (jedenfalls beim C 64) $02 und $FB bis $FE. Weil das doch recht mikrig ist, hat jeder Assembler-Programmierer spezielle Tips, welche Zellen er noch mit welchen Vorsichtsmaßnahmen benutzt. Wenn man bestimmte Routinen aus dem Betriebssystem oder dem Interpreter nicht aufruft, bleiben dazugehörige Zeropage-Adressen unbeeinflußt und sind dann für eigene Zwecke nutzbar. Manchmal ist es notwendig, den alten Zustand einer Adresse nach Beendigung eigener Programme wieder herzustellen, manchmal nicht. Interessant und viel beschrieben in allen möglichen Zeitschriften, Büchern etc. ist die Möglichkeit, die Notizen, die sich das Betriebssystem oder der Interpreter auf der Zeropage macht, zu verändern. Im Prinzip schreibt man damit kleine Teile dieser Großprogramme um oder variiert Tabellenteile davon. Wie schon Dr. Hauck in seiner Serie sagt, geschieht das im Rahmen der »Tricks« mit irgendwelchen POKEs mehr oder weniger blind, weshalb auch bevorzugt Abstürze des Computers dabei festzustellen sind. Warum Abstürze? Na, stellen Sie sich mal ein von Ihnen geschriebenes Programm vor — zum Beispiel das aus der letzten Ausgabe, zur Berechnung der Summe einer arithmetischen Reihe — und POKEn Sie dann anstelle irgendeines Befehlscodes, der dorthin gehört, jetzt eine 0 (also ein BRK) hinein. Die Wirkung dürfte ähnlich sein. Wenn man allerdings die Funktion der betreffenden Speicherstelle genau kennt, lassen sich recht nützliche Änderungen hervorrufen, wie zum Beispiel die SchutzPO-KEs für den Basic-Speicher durch Verändern der Adressen $33, $34, $37 und $38.</p>

        <p>Wir werden im folgenden immer dann, wenn wir mit Zeropage-Ädressierung arbeiten oder Routinen des Betriebssystems oder Interpreters untersuchen, spezielle Stellen der Nullseite kennenlernen.</p>

        <p>Vorhin hatte ich noch angedeutet, daß man dann die Zeropage fast vollständig nutzen könne, wenn man auf den Basic-Interpreter und das Betriebssystem verzichtet. Das ist tatsächlich möglich. Nur wird man dann erstaunt feststellen, wieviel Arbeit uns die computerinterne Software abnimmt oder anders herum: Viele bislang selbstverständliche Dinge werden wir dann plötzlich selbst programmieren müssen, und das kann ein hartes Brot sein!</p>

        <p>Als Beispiel für ein Programm, das nicht nur die Zeropageadressierung verwendet, sondern sogar selbst komplett in der Zeropage steht, werden wir uns die CHRGET-Routine ansehen. Eine Klasse von Befehlen, die dort angewendet wird, die Vergleichsbefehle, soll zuvor noch gezeigt werden.</p>

        <h3>Die Vergleichsbefehle: CMP, CPX, CPY</h3>

        <p>Vergleichen heißt in englischer Sprache »to compare«, woraus Sie unschwer erkennen können, woher die Bezeichnung CMP und die CPs in CPX beziehungsweise CPY kommen. Verglichen wird jeweils der Akku-Inhalt (bei CMP), der Inhalt des X- (bei CPX) oder des Y-Registers (bei CPY) mit Daten, die der Compare-Befehl adressiert. Einige Beispiele werden Ihnen das klarer machen:<br>
            CMP #FF<br>
            vergleicht den Akku-Inhalt mit der Zahl $FF. Hier liegt die unmittelbare Adressierung vor, die ebenso für CPX und CPY verwendbar ist. Außerdem ist das dann ein 2-Byte-Befehl.<br>
            CPX 3000<br>
            vergleicht den Inhalt des X-Registers mit dem Inhalt der Speicherstelle $3000. Die absolute Adressierung ist also auch anwendbar (natürlich auch für CMP und CPY). Der Compare-Befehl besteht so aus 3 Bytes.<br>
            CPY A8<br>
            vergleicht den Inhalt des Y-Registers mit dem Inhalt der Zeropage-Stelle $A8. Diese soeben frisch gelernte Zeropage-Adressierung ist bei allen drei Vergleichsbefehlen möglich und macht aus ihnen 2-Byte-Befehle.</p>

        <p>Für CPX und CPY sind das alle Möglichkeiten der Adressierung. CMP erlaubt weitere, die wir noch kennenlernen werden. Nun interessiert uns natürlich noch, wie das Vergleichsergebnis zu erhalten ist! Bei diesen Befehlen geschieht merkwürdiges: Die Vergleichsdaten werden vom Inhalt des Akkus (beziehungsweise X- oder Y-Registers) abgezogen, aber: Weder wird dieser Inhalt noch werden die adressierten Daten verändert! Der Trick ist, daß drei Flaggen das Ergebnis anzeigen: Die Negativ-Flagge N, die Null-Flage Z und das Carry-Bit C. Diese Anzeige geschieht so:</p>

        <p>1) Der Registerinhalt (Akku, X-, Y-Register) ist größer als die Vergleichsdaten:<br>Dann ist das Carry-Bit = 1, die N- und die Z-Flagge = 0.<br>
            2) Der Registerinhalt ist gleich den Vergleichsdaten:<br>Dann sind Carry- und Z-Flagge = 1, die N-Flagge = 0.<br>
            3) Der Registerinhalt ist kleiner als die Vergleichsdaten:<br>Die N-Flagge ist dann = 1, Carry- und Zero-Flagge sind 0.</p>

        <p>Damit Sie die Übersicht behalten können, ist in Bild 1 das ganze als Schema gezeigt.</p>

        <p>Sie werden sich vermutlich schon denken können, wie der Hase weiterläuft: Mit den Verzweigungsbefehlen prüfen wir die Flaggen und springen die gewünschten weiteren Programm-Routinen an.</p>

        <p>Die Kombination der Compare-Befehle mit den Verzweigungsoperationen wird Ihnen im weiteren Verlauf dieses Kurses noch ganz geläufig werden. Ein Beispiel sehen Sie nachher ebenfalls in der CHRGET-Routine. Leider muß ich Sie immer noch etwas vertrösten, denn mit Verstand begreifen läßt sich diese Routine nur dann, wenn man etwas mehr über die Codierung von Zeichen weiß. Deswegen werden wir uns nun noch mit dem ASCII-Code und dem Commodore-ASCII herumschlagen.</p>

        <h3>Zeichencodierung mit dem ASCII- und dem Commodore-ASCII-Code</h3>

        <p>ASCII ist die Abkürzung von »American Standard Code for Information Interchange« und das heißt auf deutsch »amerikanischer Standard-Code zum Informations-Austausch«. Diese Zeichenverschlüsselungsart ist international als ISO-7-Bit-Code genormt, und es wäre wirklich nett, wenn alle sich daran halten würden. Tatsächlich aber finden wir zum Beispiel bei unserem C 64 eine Abart des Normcodes, den Commodore-ASCII-Code. Über die damit erzwungenen Umrechnungen können alle diejenigen Dramen erzählen, die zum erstenmal einen (Nicht-Commodore-)Drucker an ihr Gerät anschließen oder aber blauäugig in den Online-Betrieb mit anderen Computern eintreten wollten.</p>

        <p>Sehen wir uns zunächst einmal den ASCII-Code an. Es handelt sich um einen 7-Bit-Code, das heißt 128 Zeichen können in nur 7 Bits untergebracht werden (0000 0000 bis 01111111). Das achte Bit dient bei manchen Operationen mit Computer-Peripherie als Paritäts-Bit. Bei dieser Gelegenheit soll auch gleich erklärt werden, was Parität in diesem Zusammenhang bedeutet. Werden Daten übertragen, muß immer mit Übermittlungsfehlern gerechnet werden. Das Paritätsbit dient dazu festzustellen, ob ein Byte korrekt angekommen ist. Bei der sogenannten geraden Parität zählt man die Einser im Byte zusammen und setzt Bit 7 auf 1 wenn sich eine ungerade Zahl ergibt. Mit dem Paritätsbit haben wir dann eine gerade Zahl. Ist die Quersumme des Byte schon gerade, bleibt Bit 7 eine Null. Ebensogut kann man die ungerade Parität verwenden, indem dann Bit 7 so gewählt wird, daß sich immer eine ungerade Zahl ergibt. Welche Art der Parität zur Anwendung kommt, ist Vereinbarungssache. Nehmen wir mal an, es sei gerade Parität gefordert und ein Byte mit der Information 00010110 soll übermittelt werden. Die Quersumme ist 3, also ungerade. Das Paritätsbit muß auf 1 gesetzt werden. Wir senden das Byte 10010110. Der Empfänger überprüft zunächst auf gerade Parität und verwendet dann nur die Bits 0 bis 6. Doppelfehler, die mittels des Paritätsverfahrens nicht festgestellt werden können, sind sehr selten. Leider kann auf diese Weise nur bemerkt werden, daß ein Übertragungsfehler aufgetreten sein muß, aber nicht welcher. Die Information muß dann neu angefordert werden.</p>

        <p>Sehen wir uns nun den Commodore-ASCII-Code an. Durch die Einbindung der Grafikzeichen brauchen wir mehr als die 128 Kombinationen. Commodore benutzt deswegen einen 8-Bit-Code. Mit dem Basic-Befehl CHR$(x) können Sie sich alle 256 Möglichkeiten ansehen. Erschwerend kommt aber noch hinzu, daß wir nicht nur einen Zeichensatz, sondern deren vier zur Verfügung haben, die durch den jeweiligen Schreibmodus ansprechbar sind (Klein-/Großschriftmodus, Großschriftmodus, beide Modi mit Reverse-ON oder OFF). Im Zeichen-ROM liegen insgesamt 512 Muster abrufbereit. Zu diesen kommen beim CHR$-Befehl noch eine ganze Reihe von Steuerzeichen hinzu&hellip; die Verwirrung ist perfekt! Wir wollen an dieser Stelle keine Entwirrung vornehmen, sondern wir durchschlagen den Gordischen Knoten, indem wir nur die ersten 128 Zeichen mit den ASCII-Zeichen vergleichen. In Bild 2 und 3 finden Sie unsere Gegenüberstellung.</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td>msn</td>
                        <td>lsn</td>
                        <td>$</td>
                        <td>0</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                        <td>7</td>
                    </tr>
                    <tr>
                        <td colspan="2">$</td>
                        <td>binär</td>
                        <td>0000
                        </td>
                        <td>0001
                        </td>
                        <td>0010
                        </td>
                        <td>0011
                        </td>
                        <td>0100
                        </td>
                        <td>0101
                        </td>
                        <td>0110
                        </td>
                        <td>0111
                        </td>
                    </tr>
                    <tr>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">000
                        </td>
                        <td>NUL</td>
                        <td>DLE</td>
                        <td>SP</td>
                        <td>0</td>
                        <td>@</td>
                        <td>P</td>
                        <td><br></td>
                        <td>P</td>
                    </tr>
                    <tr>
                        <td>NULL</td>
                        <td>DLE</td>
                        <td>SP</td>
                        <td>0</td>
                        <td>@</td>
                        <td>P</td>
                        <td>CHR$(96)</td>
                        <td>CHR$(112)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">001
                        </td>
                        <td>SOH</td>
                        <td>DC1</td>
                        <td>!</td>
                        <td>1</td>
                        <td>A</td>
                        <td>Q</td>
                        <td>a</td>
                        <td>q</td>
                    </tr>
                    <tr>
                        <td>SOH</td>
                        <td>DC1</td>
                        <td>!</td>
                        <td>1</td>
                        <td>A</td>
                        <td>Q</td>
                        <td>CHR$(97)</td>
                        <td>CHR$(113)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">2
                        </td>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">010
                        </td>
                        <td>STX</td>
                        <td>DC2</td>
                        <td>"</td>
                        <td>2</td>
                        <td>B</td>
                        <td>R</td>
                        <td>b</td>
                        <td>r</td>
                    </tr>
                    <tr>
                        <td>STX</td>
                        <td>DC2</td>
                        <td>"</td>
                        <td>2</td>
                        <td>B</td>
                        <td>R</td>
                        <td>CHR$(98)</td>
                        <td>CHR$(114)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">3
                        </td>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">011
                        </td>
                        <td>ETX</td>
                        <td>DC3</td>
                        <td>#</td>
                        <td>3</td>
                        <td>C</td>
                        <td>S</td>
                        <td>c</td>
                        <td>s</td>
                    </tr>
                    <tr>
                        <td>ETX</td>
                        <td>DC3</td>
                        <td>#</td>
                        <td>3</td>
                        <td>C</td>
                        <td>S</td>
                        <td>CHR$(99)</td>
                        <td>CHR$(115)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">4
                        </td>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">100
                        </td>
                        <td>EOT</td>
                        <td>DC4</td>
                        <td>$</td>
                        <td>4</td>
                        <td>D</td>
                        <td>T</td>
                        <td>d</td>
                        <td>t</td>
                    </tr>
                    <tr>
                        <td>EOT</td>
                        <td>DC4</td>
                        <td>$</td>
                        <td>4</td>
                        <td>D</td>
                        <td>T</td>
                        <td>CHR$(100)</td>
                        <td>CHR$(116)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">5
                        </td>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">101
                        </td>
                        <td>ENQ</td>
                        <td>NAK</td>
                        <td>%</td>
                        <td>5</td>
                        <td>E</td>
                        <td>U</td>
                        <td>e</td>
                        <td>u</td>
                    </tr>
                    <tr>
                        <td>ENQ</td>
                        <td>NAK</td>
                        <td>%</td>
                        <td>5</td>
                        <td>E</td>
                        <td>U</td>
                        <td>CHR$(101)</td>
                        <td>CHR$(117)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">6
                        </td>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">110
                        </td>
                        <td>ACK</td>
                        <td>SYN</td>
                        <td>&amp;</td>
                        <td>6</td>
                        <td>F</td>
                        <td>V</td>
                        <td>f</td>
                        <td>v</td>
                    </tr>
                    <tr>
                        <td>ACK</td>
                        <td>SYN</td>
                        <td>&amp;</td>
                        <td>6</td>
                        <td>F</td>
                        <td>V</td>
                        <td>CHR$(102)</td>
                        <td>CHR$(118)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">7
                        </td>
                        <td rowspan="2">0
                        </td>
                        <td rowspan="2">111
                        </td>
                        <td>BEL</td>
                        <td>ETB</td>
                        <td>'</td>
                        <td>7</td>
                        <td>G</td>
                        <td>W</td>
                        <td>g</td>
                        <td>w</td>
                    </tr>
                    <tr>
                        <td>BEL</td>
                        <td>ETB</td>
                        <td>'</td>
                        <td>7</td>
                        <td>G</td>
                        <td>W</td>
                        <td>CHR$(103)</td>
                        <td>CHR$(119)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">8
                        </td>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">000
                        </td>
                        <td>BS</td>
                        <td>CAN</td>
                        <td>(</td>
                        <td>8</td>
                        <td>H</td>
                        <td>X</td>
                        <td>h</td>
                        <td>x</td>
                    </tr>
                    <tr>
                        <td>BS</td>
                        <td>CAN</td>
                        <td>(</td>
                        <td>8</td>
                        <td>H</td>
                        <td>X</td>
                        <td>CHR$(104)</td>
                        <td>CHR$(120)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">9
                        </td>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">001
                        </td>
                        <td>HT</td>
                        <td>EM</td>
                        <td>)</td>
                        <td>9</td>
                        <td>I</td>
                        <td>Y</td>
                        <td>i</td>
                        <td>y</td>
                    </tr>
                    <tr>
                        <td>HT</td>
                        <td>EM</td>
                        <td>)</td>
                        <td>9</td>
                        <td>I</td>
                        <td>Y</td>
                        <td>CHR$(105)</td>
                        <td>CHR$(121)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">A
                        </td>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">010
                        </td>
                        <td>LF</td>
                        <td>SUB</td>
                        <td>*</td>
                        <td>:</td>
                        <td>J</td>
                        <td>Z</td>
                        <td>j</td>
                        <td>z</td>
                    </tr>
                    <tr>
                        <td>LF</td>
                        <td>SUB</td>
                        <td>*</td>
                        <td>:</td>
                        <td>J</td>
                        <td>Z</td>
                        <td>CHR$(106)</td>
                        <td>CHR$(122)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">B
                        </td>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">011
                        </td>
                        <td>VT</td>
                        <td>ESC</td>
                        <td>+</td>
                        <td>;</td>
                        <td>K</td>
                        <td>[</td>
                        <td>k</td>
                        <td>{</td>
                    </tr>
                    <tr>
                        <td>VT</td>
                        <td>ESC</td>
                        <td>+</td>
                        <td>;</td>
                        <td>K</td>
                        <td>[</td>
                        <td>CHR$(107)</td>
                        <td>CHR$(123)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">C
                        </td>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">100
                        </td>
                        <td>FF</td>
                        <td>FS</td>
                        <td>,</td>
                        <td>&lt;</td>
                        <td>L</td>
                        <td>\</td>
                        <td>l</td>
                        <td>|</td>
                    </tr>
                    <tr>
                        <td>FF</td>
                        <td>FS</td>
                        <td>,</td>
                        <td>&lt;</td>
                        <td>L</td>
                        <td>£</td>
                        <td>CHR$(108)</td>
                        <td>CHR$(124)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">D
                        </td>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">101
                        </td>
                        <td>CR</td>
                        <td>GS</td>
                        <td>—</td>
                        <td>=</td>
                        <td>M</td>
                        <td>]</td>
                        <td>m</td>
                        <td>}</td>
                    </tr>
                    <tr>
                        <td>CR</td>
                        <td>GS</td>
                        <td>—</td>
                        <td>=</td>
                        <td>M</td>
                        <td>1</td>
                        <td>CHR$(109)</td>
                        <td>CHR$(125)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">E
                        </td>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">110
                        </td>
                        <td>SO</td>
                        <td>RS</td>
                        <td>.</td>
                        <td>&gt;</td>
                        <td>N</td>
                        <td>↑</td>
                        <td>n</td>
                        <td>~</td>
                    </tr>
                    <tr>
                        <td>SO</td>
                        <td>RS</td>
                        <td>.</td>
                        <td>&gt;</td>
                        <td>N</td>
                        <td>↑</td>
                        <td>CHR$(110)</td>
                        <td>CHR$(126)</td>
                    </tr>
                    <tr>
                        <td rowspan="2">F
                        </td>
                        <td rowspan="2">1
                        </td>
                        <td rowspan="2">111
                        </td>
                        <td>SI</td>
                        <td>US</td>
                        <td>/</td>
                        <td>?</td>
                        <td>O</td>
                        <td>_</td>
                        <td>o</td>
                        <td>DEL</td>
                    </tr>
                    <tr>
                        <td>SI</td>
                        <td>US</td>
                        <td>/</td>
                        <td>?</td>
                        <td>O</td>
                        <td>←</td>
                        <td>CHR$(111)</td>
                        <td>CHR$(127)</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Bild 2: ASCII-Code (jeweils oben) und Commodore ASCII-Code jeweils unten) (msn = most significant nibble; lsn = least significant nibble)</figcaption>
        </figure>

        <figure>
            <img src="142-3.png" alt="">
            <figcaption>Bild 3. Die Grafikzeichen zu den entsprechenden CHRS-Codes</figcaption>
        </figure>

        <p>Einige Kombinationen dienen als Steuer-Codes. (Die Bedeutung der dabei verwendeten Abkürzungen sehen Sie unten.</p>

        <p>Nur ein Teil dieser Codes wird tatsächlich genutzt. Andere haben — je nach Gerät an das sie gesandt werden — unterschiedliche Bedeutungen. Denken Sie dabei nur mal an die verschiedenen Betriebssysteme des Commodore-Druckers 1526, wo man bei dem einen mit CHR$(1), bei dem anderen mit CHR$(14) den Breitschrift-Modus anschaltet. Innerhalb unseres Computers werden offensichtlich bestimmte Codes anders genutzt. Das sind:</p>

        <table>
            <tbody>
                <tr>
                    <td>Anstelle von</td>
                    <td>geschieht folgendes:</td>
                </tr>
                <tr>
                    <td>ENQ</td>
                    <td>Zeichen weiß</td>
                </tr>
                <tr>
                    <td>BS</td>
                    <td>Blockieren der Umschaltung Klein-/Großschrift</td>
                </tr>
                <tr>
                    <td>HT</td>
                    <td>Zulassen der obigen Umschalt.</td>
                </tr>
                <tr>
                    <td>DC1</td>
                    <td>Cursor abwärts</td>
                </tr>
                <tr>
                    <td>DC2</td>
                    <td>Reverse-Modus an</td>
                </tr>
                <tr>
                    <td>DC3</td>
                    <td>Cursor in HOME-Position</td>
                </tr>
                <tr>
                    <td>DC4</td>
                    <td>INST/DEL</td>
                </tr>
                <tr>
                    <td>FS</td>
                    <td>Zeichen rot</td>
                </tr>
                <tr>
                    <td>GS</td>
                    <td>Cursor rechts</td>
                </tr>
                <tr>
                    <td>RS</td>
                    <td>Zeichen grün</td>
                </tr>
                <tr>
                    <td>US</td>
                    <td>Zeichen blau</td>
                </tr>
            </tbody>
        </table>

        <p>Der auffälligste Unterschied ist der, daß beim CommodoreASCII anstelle der Kleinbuchstaben Grafikzeichen liegen. Sollte anstelle des Normalmodus der Klein-/Großschriftmodus eingeschaltet sein, findet man anstelle der Großbuchstaben die kleinen.</p>

        <p>Jetzt haben wir alle nötigen Kenntnisse, um die CHRGET-Routine in unserem Computer zu verstehen.</p>

        <h3>Die CHRGET-Routine</h3>

        <p>Das Kürzel CHRGET kommt von »Get a character«, was bei uns heißt: »Hole ein Zeichen«. Es handelt sich um eine sehr häufig benutzte Routine unseres Basic-Interpreters, die — wie schon vorhin erwähnt — komplett in der Zeropage steht. Wenn Sie mit dem SMON mal nachsehen wollen, dann geben Sie den Befehl<br>
            D 0073 008B<br>
            ein. Sie haben dann die komplette Routine vor sich:</p>

        <table class="plain">
            <tr>
                <td>0073</td>
                <td>E6 7A</td>
                <td>INC 7A</td>
            </tr>
            <tr>
                <td>0075</td>
                <td>D0 02</td>
                <td>BNE 0079</td>
            </tr>
            <tr>
                <td>0077</td>
                <td>E6 7B</td>
                <td>INC 7B</td>
            </tr>
            <tr>
                <td>0079</td>
                <td>AD 2502</td>
                <td>LDA 0225</td>
            </tr>
            <tr>
                <td>007C</td>
                <td>C9 3A</td>
                <td>CMP #3A</td>
            </tr>
            <tr>
                <td>007E</td>
                <td>B0 0A</td>
                <td>BCS 008A</td>
            </tr>
            <tr>
                <td>0080</td>
                <td>C9 20</td>
                <td>CMP #20</td>
            </tr>
            <tr>
                <td>0082</td>
                <td>F0 EF</td>
                <td>BEQ 0073</td>
            </tr>
            <tr>
                <td>0084</td>
                <td>38</td>
                <td>SEC</td>
            </tr>
            <tr>
                <td>0085</td>
                <td>E9 30</td>
                <td>SBC #30</td>
            </tr>
            <tr>
                <td>0087</td>
                <td>38</td>
                <td>SEC</td>
            </tr>
            <tr>
                <td>0088</td>
                <td>E9 D0</td>
                <td>SBC #D0</td>
            </tr>
            <tr>
                <td>008A</td>
                <td>60</td>
                <td>RTS</td>
            </tr>
        </table>


        <p>Eventuell sieht die Zeile 0079 bei Ihnen anders aus. Das liegt dann an den Speicherstellen 7A und 7B, welche einen Zeiger darstellen (LSB = 7A und MSB = 7B), der bei Ihnen gerade auf einen anderen Platz zeigt als auf $0225.</p>

        <p>Diese CHRGET-Routine besteht aus drei Teilen:<br>
            Zeilen 0073 bis 0079</p>

        <p>Weiterstellen des CHRGET-Zeigers und Einladen des dadurch angezeigten Speicherzelleninhaltes in den Akku.<br>
            Zeilen 007G bis 0082 Prüfroutinen<br>
            Zeilen 0084 bis 008A Flaggen-Routinen</p>

        <p>Im ersten Teil haben wir schon gleich etwas neues vor uns: Ein sich selbst veränderndes Programm. Die Speicherstelle (aus dem Basic-Eingabepuffer), aus der der Akku ein Zeichen holt, wird um 1 weitergezählt mit INC 7A.</p>

        <p>Dabei handelt es sich um das LSB der Adresse und die nächste Zeile prüft, ob ein Überlauf (255 + 1) stattgefunden hat: BNE 0079.</p>

        <p>Diese Technik kennen wir schon aus den letzten Folgen: Bei Überlauf wird die Z-Flagge auf 1 gesetzt und der BNE-Befehl führt keinen Sprung herbei, Den Offset von 02 können wir leicht nachrechnen: Der Programmzähler steht schon auf 0077. Die Zieladresse 0079 ist also noch 2 Bytes entfernt. Hat eine Überschreitung des Höchstwertes 255 stattgefunden, dann muß das dazugehörige MSB um 1 erhöht werden. Dies tut die nächste Zeile: INC 7B</p>

        <p>In beiden Fällen ist nun der Zeiger 7A/7B um eine Stelle weitergerückt und der Inhalt der dadurch angezeigten Speicherstelle wird in den Akku geladen. Zwei Dinge können wir uns aus diesem kurzen Programmteil merken:</p>

        <p>1) Wie man eine 16-Bit-Zahl hoch-(oder auch herunter-) zählt und<br>
            2) eine Möglichkeit, Zeiger einzusetzen. Wir werden noch eine Reihe anderer Zeigertypen kennenlernen und sehen, daß es nicht immer so direkt zugeht wie hier.</p>

        <p>Im zweiten Teil finden wir die Prüfroutinen. Die Vergleichsbefehle beschränken sich auf den Akkuinhalt, also CMP.<br>
            CMP # 3A testet, in welcher Beziehung das im Akku befindliche Zeichen zum Wert $3A = dezimal 58 steht. Erinnern wir uns an das Schema in Bild 1:</p>

        <p>1) Commodore-ASCII-Code im Akku größer als 58, also Zeichen hinter dem Doppelpunkt (Buchstaben, Grafikzeichen, einige Sonderzeichen). Dann ist die Carry-Flagge = 1, N- und Z-Flagge sind 0.<br>
            2) Im Akku steht genau der Code 58, also der Doppelpunkt. Dann sind Carry-Bit und Z-Flagge = 1, nur die N-Flagge = 0.<br>
            3) Der Code des Zeichens im Akku ist kleiner als 58 (das wären alle Zahlen, einige Sonderzeichen und Steuerzeichen). In diesem Fall ist die N-Flagge = 1. Die beiden anderen Flaggen zeigen Null.</p>

        <p>Der nun folgende Befehl BCS 008A überprüft die Carry-Flagge. Wenn sie gesetzt ist, wenn also der Code im Akku größer oder gleich dem eines Doppelpunktes (58) ist, springt der Programmzähler zum RTS. Der Code (und auch die Flaggen) wird unverändert zum aufrufenden Hauptprogramm weitergegeben. Zur Übung können Sie ja nochmal den Offset nachrechnen. Der Rest des Programms wird nur noch durchlaufen, wenn Codes kleiner als 58 im Akku stehen.</p>

        <p>Die nächste Zeile CMP #20 dient zum Vergleich des Space-Codes $20 = dezimal 32 (Leertaste). Die Flaggen treten dann, wie schon oben beim ersten Vergleich gezeigt, je nach Akku-Inhalt auf. Durch die Verzweigung BEQ 0073 erfolgt ein Rücksprung zum Beginn der CHRGET-Routine dann, wenn die Z-Flagge gesetzt ist, also ein Space-Code im Akku liegt. Somit werden die Leerzeichen einfach übersprungen und das nächste Zeichen geholt. Alle anderen Zeichen, die bis hierher durchgehalten haben, werden nun im letzten Teil der CHRGET-Routine einer Prozedur unterworfen, die ich Flaggen-Routine genannt habe.</p>

        <p>Durch zwei aufeinanderfolgende Subtraktionen, die insgesamt den Wert im Akku unverändert lassen (es wird 256 abgezogen), wird die Carry-Flagge beeinflußt. Verfolgen wir, was da passiert:</p>

        <p>SEC dient als Vorbereitung für die folgende Subtraktion.<br>
            SBC # 30 zieht vom Akku-Inhalt $30 = dezimal 48 ab. Wir wissen inzwischen, daß das der Addition des Zweierkomplementes entspricht. Dieses ist (rechnen Sie mal nach!) 1101 0000.<br>
            Nehmen wir mal an, wir hätten den Code der Zahl 4 (also dezimal 52 oder $34) im Akku stehen. Die Rechnung sieht dann so aus:</p>

        <p>TODO</p>

        <p>Das Ergebnis ist also 4, der Übertrag wird vernachlässigt.</p>

        <p>Als anderes Beispiel sei nun der Code für das Ausrufungszeichen im Akku (dezimal 33 = $21 = binär 0010 0001). Die Rechnung ist dann:</p>

        <p>TODO</p>

        <p>Das Ergebnis ist —15.</p>

        <p>Alle Codes, die nicht für Zahlen stehen, haben nach dieser Subtraktion ein negatives Ergebnis im Akku hinterlassen und durch das »Borgen« das Carry-Bit gelöscht.</p>

        <p>Nun machen wir weiter ab Zeile 0087:<br>
            SEC<br>
            SBC #D0</p>

        <p>Wir ziehen $D0 = dezimal 208 ab. Das Zweierkomplement ist: &hellip;Doch da kommen wir ins Stocken! Denn dieses Zweierkomplement ist nicht mehr mit 8-Bit-Zahlen darzustellen. Schon die Zahl 208 im Binärformat (1101 0000) würde als negative Zahl angesehen werden, weil Bit 7 gleich 1 ist. Wir machen es uns einfach und sagen, daß sich das Zweierkomplement wie bisher bilden läßt, aber dabei das Carry-Bit mit einbezogen wird. Unser Zweierkomplement ist dann also: 0011 0000 und das Carry-Bit ist gelöscht. Nun nehmen wir unser erstes Beispiel. Dort war nach der Subtraktion im Akku eine 4 verblieben:</p>

        <p>TODO</p>

        <p>Das ist wieder unser ursprünglicher Wert dezimal 52 = $34 = Code für die Zahl 4. Das Carry-Bit bleibt gelöscht.</p>

        <p>Im zweiten Beispiel mit dem Ausrufungszeichen stand noch im Akku eine —15:</p>

        <p>TODO</p>

        <p>Da haben wir wieder den Code für das Ausrufungszeichen ($21 = dezimal 33) im Akku und ein gesetztes Carry-Bit. Was kommt also bei der CHRGET-Routine heraus?</p>

        <p>1) Alle Zeichen außer dem Space werden unverändert an das aufrufende Programm über den Akku weitergegeben. Space wird unterdrückt.<br>
            2) Bei allen Zeichen außer bei den Zahlen ist das Carry-Bit gesetzt.<br>
            3) Manche der aufrufenden Routinen überprüfen außer dem Zustand der Carry-Flagge auch den der Z- oder N-Flagge, die ja beim ersten CMP-Befehl ebenfalls gesetzt werden. So liefert die CHRGET-Routine noch weitere Informationen.</p>

        <p>In der einschlägigen Literatur stoßen Sie auch auf eine Routine, die CHRGOT genannt wird. Es handelt sich dabei ebenfalls um die hier beschriebene CHRGET-Routine, nur erfolgt der Einsprung nicht bei $0073, sondern bei $0079.</p>

        <p>Der Zeiger $007A/7B wird in diesem Fall nicht weitergestellt. Das vorher schon einmal in den Akku geladene Zeichen wird damit noch einmal angesprochen (got ist die Vergangenheitsform von get).</p>

        <p>Mit dem CHRGET-Programm haben wir eines der wichtigsten Unterprogramme unserer computerinternen Software kennengelernt. Will man sich Interpreter-Routinen zunutze machen, stolpert man ständig darüber. Außerdem aber liegt die CHRGET-Routine im RAM. Das bedeutet, daß wir sie ohne weiteres für unsere Zwecke verändern können.</p>

        <p>Ein Beispiel für so eine Änderung hat Christoph Sauer in seiner Serie über den »gläsernen VC 20« in der Ausgabe 9 (Seite 158) gezeigt. Dort wird die CHRGET-Routine nach dem LDA angezapft und auf das Pi-Zeichen geprüft, das neuen Befehlen vorangestellt wurde. Sehen Sie sich das Programm dort (auf Seite 160f.) mal genau an, viel kann man durch Nachvollziehen fremder Programme für die eigene Programmiertechnik lernen. Wir werden im Verlauf dieser Serie noch andere Möglichkeiten behandeln, die CHRGET-Routine zu verändern.</p>

        <p>Damit sei es für diesmal genug. Als Assembler-Alchimisten gehören Sie jetzt zu den fortgeschrittenen Eleven, denn Sie können immerhin schon so trickreiche Programme wie die CHRGET-Routine nachvollziehen.</p>

        <address class="author">(Heimo Ponnath/gk)</address>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td>NUL</td>
                        <td>Null</td>
                        <td><br></td>
                    </tr>
                    <tr>
                        <td>SOH</td>
                        <td>Start of heading</td>
                        <td>Beginn des Kopfes</td>
                    </tr>
                    <tr>
                        <td>STX</td>
                        <td>Start of text</td>
                        <td>Textbeginn</td>
                    </tr>
                    <tr>
                        <td>ETX</td>
                        <td>End of text</td>
                        <td>Textende</td>
                    </tr>
                    <tr>
                        <td>EOT</td>
                        <td>End of transmission</td>
                        <td>Übertragungsende</td>
                    </tr>
                    <tr>
                        <td>ENQ</td>
                        <td>Inquiry</td>
                        <td>Anfrage</td>
                    </tr>
                    <tr>
                        <td>ACK</td>
                        <td>Acknowledge</td>
                        <td>Bestätigung</td>
                    </tr>
                    <tr>
                        <td>BEL</td>
                        <td>Bell</td>
                        <td>Klingel</td>
                    </tr>
                    <tr>
                        <td>BS</td>
                        <td>Backspace</td>
                        <td>Zurücksetzen</td>
                    </tr>
                    <tr>
                        <td>HT</td>
                        <td>Horizontal tabul.</td>
                        <td>Horizontaltabulator</td>
                    </tr>
                    <tr>
                        <td>LF</td>
                        <td>Line feed</td>
                        <td>Zeilenvorschub</td>
                    </tr>
                    <tr>
                        <td>VT</td>
                        <td>Vertical tabulator</td>
                        <td>Vertikaltabulator</td>
                    </tr>
                    <tr>
                        <td>FF</td>
                        <td>Form feed</td>
                        <td>Formatvorschub</td>
                    </tr>
                    <tr>
                        <td>CR</td>
                        <td>Carriage return</td>
                        <td>Wagenrücklauf/Zeilenwechsel</td>
                    </tr>
                    <tr>
                        <td>SO</td>
                        <td>Shift out</td>
                        <td>Rückschaltung</td>
                    </tr>
                    <tr>
                        <td>SI</td>
                        <td>Shift in</td>
                        <td>Dauerumschaltung</td>
                    </tr>
                    <tr>
                        <td>DLE</td>
                        <td>Data link escape</td>
                        <td>Datenverbindungsumschaltung</td>
                    </tr>
                    <tr>
                        <td>DC1-4</td>
                        <td>Device control</td>
                        <td>Gerätesteuerung</td>
                    </tr>
                    <tr>
                        <td>NAK</td>
                        <td>Negative acknowl.</td>
                        <td>Negativ-Bestätigung</td>
                    </tr>
                    <tr>
                        <td>SYN</td>
                        <td>Synchronous idle</td>
                        <td>Synchronisations-Leerlauf</td>
                    </tr>
                    <tr>
                        <td>ETB</td>
                        <td>End of transmission block</td>
                        <td>Ende des Übertragungsblockes</td>
                    </tr>
                    <tr>
                        <td>CAN</td>
                        <td>Cancel</td>
                        <td>Annullieren</td>
                    </tr>
                    <tr>
                        <td>EM</td>
                        <td>End of medium</td>
                        <td>Datenträgerende</td>
                    </tr>
                    <tr>
                        <td>SUB</td>
                        <td>Substitute</td>
                        <td>Ersetzen</td>
                    </tr>
                    <tr>
                        <td>ESC</td>
                        <td>Escape</td>
                        <td>Umschaltung</td>
                    </tr>
                    <tr>
                        <td>FS</td>
                        <td>File separator</td>
                        <td>Dateitrennzeichen</td>
                    </tr>
                    <tr>
                        <td>GS</td>
                        <td>Group separator</td>
                        <td>Gruppentrennzeichen</td>
                    </tr>
                    <tr>
                        <td>RS</td>
                        <td>Record separator</td>
                        <td>Satztrennzeichen</td>
                    </tr>
                    <tr>
                        <td>US</td>
                        <td>Unit separator</td>
                        <td>Einheiten-Trennz.</td>
                    </tr>
                    <tr>
                        <td>SP</td>
                        <td>Space</td>
                        <td>Leerzeichen</td>
                    </tr>
                    <tr>
                        <td>DEL</td>
                        <td>Delete</td>
                        <td>Löschzeichen</td>
                    </tr>
                </tbody>
            </table>

            <figcaption>Bild 4. Die Bedeutung der Abkürzungen im ASCII-Code</figcaption>
        </figure>

    </article>

</body>

</html>