<!DOCTYPE html>
<html lang="de">

<head>
    <title>Basic-Programm auf Trab gebracht – Compiler im Test</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Karsten Schramm, gk">
    <meta name="64er.issue" content="2/85">
    <meta name="64er.pages" content="34-38">
    <meta name="64er.head1" content="Software-Test">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="<b>Basic-Programme beschleunigen – Die besten Compiler im Vergleich</b>">
    <meta name="64er.toc_category" content="Vergleichstest">
    <meta name="64er.index_title" content="Basic-Programme auf Trab gebracht: Austro-Speed, BASS, Exbasic, Petspeed">
    <meta name="64er.index_category" content="Software-Test|Compiler">
    <meta name="64er.id" content="compiler_test">
</head>

<body>
    <article>

        <h1>Basic-Programm auf Trab gebracht – Compiler im Test</h1>

        <p class="intro">Haben Sie schon einmal daran gedacht, sich eventuell einen Compiler zuzulegen, um Basic-Programme schneller zu machen? Sie wissen aber vielleicht noch zuwenig über Compiler, um sich den richtigen auszusuchen. Wir stellen Ihnen deshalb vier Typen vor.</p>

        <p>Wir haben vier der bekanntesten Compiler getestet: Petspeed, Austro-Speed, BASS- und Ex-Basic Level II-Compiler. Bevor wir uns jedoch mit den »Prüflingen« genauer beschäftigen, wollen wir erst ein wenig auf die praktischen Grundlagen der Compiler eingehen.</p>

        <p>Wenn man Compiler hört, denkt man unwillkürlich immer zuerst an den Geschwindigkeitsgewinn, den diese Programme bringen sollen. In der Tat ist der Hauptzweck von Compilern in der zeitlichen Optimierung eines Programmlaufs zu sehen, damit die Ausführungszeit verkürzt wird. So gibt es demnach viele Compiler, deren Hauptkonzept in der Geschwindigkeitserhöhung liegt.</p>

        <p>Uber diese Tatsachen darf man aber auch andere Eigenschaften von Compilern nicht vergessen. Compiler erhöhen zwar in der Regel die Geschwindigkeit der Basic-Programme, sie vertragen aber unter Umständen gewisse syntaktische Konstruktionen nicht, die beim Interpreter ohne weiteres funktionieren. Außerdem werden kleinere Programme in der Regel durch das Compilieren um einiges länger als sie ursprünglich waren.</p>

        <p>Da wir gerade bei der Programmlänge sind, soll an dieser Stelle auch gleich auf die zwei verschiedenen Arten von Compilern eingegangen werden. Die erste Art ist der Assemblercode-Compiler, der echten Maschinencode erzeugt und damit maximalen Geschwindigkeitsgewinn bringt. Der Nachteil dieser Methode ist, daß das compilierte Programm (Compilat) in der Regel um einiges länger wird als das ursprüngliche Basic-Programm.</p>

        <p>Bei der zweiten Art von Compilern (sogenannte Adreßcode-Compilern) geht man deshalb einen anderen Weg. Hier wird der Basic-Text in eine Liste von Sprungadressen umgewandelt, was Speicherplatz spart, aber andererseits wieder auf Kosten der Geschwindigkeit geht.</p>

        <p>Wie Sie sehen, gibt es den perfekten Compiler nicht. Entweder ist ein Programm sehr schnell, dann ist es länger, oder ein Programm ist nicht ganz so schnell, dafür wird es kürzer. Einen guten Compiler erkennt man also am richtigen Kompromiß zwischen Geschwindigkeit und Länge des Compilats. Ein weiteres Qualitätsmerkmal für Compiler ist die Dauer des Compilierens. Dieser Vorgang ist zwar in der Regel einmalig, da man nur ein wirklich fertiges Programm compilieren wird, er sollte sich dennoch in vernünftigen Grenzen bewegen.</p>

        <p>Wenn wir uns jetzt gleich einmal mit den speziellen Eigenschaften der Testkandidaten vertraut machen, sollten Sie immer an diese Merkmale denken. Das interessante an den getesteten Compilern ist nämlich, daß sie fast alle nach unterschiedlichen Kriterien entwickelt wurden.</p>

        <h2>Der Austro-Speed-Compiler</h2>

        <p>Der erste Compiler, mit dem wir uns beschäftigen wollen, ist der Austro-Speed von Commodore. Austro-Speed ist eine verbesserte Version des Austro-Comp für die CBM-Systeme. Im Lieferumfang sind eine Diskette mit dem Programm, ein Handbuch mittleren Umfangs und ein Dongle enthalten. Ein Dongle ist ein programmschutztechnischer Hardwarezusatz, dessen Vorhandensein abgefragt wird und ohne das der Compiler nicht läuft, (in diesem Fall ein Stecker für den User-Port). Als ich mir das Inhaltsverzeichnis der Diskette ansehen wollte, erlebte ich sofort eine Überraschung. Der ganze Compiler besteht aus einem einzigen Programm mit einer Länge von 63 Blöcken (15,75 KByte).</p>

        <p>Als Testprogramm für den Compiliervorgang diente der Disk-Monitor EDDI aus der 64'er, Ausgabe 10/1984. Dieses Programm hat den Vorteil, daß es nicht zu kurz ist. Außerdem ist der Programmierstil an vielen Stellen alles andere als sauber. Haben Sie übrigens bemerkt, daß sich bei EDDI ein Fehler eingeschlichen hat? In der Zeile 1070 ist die IF-Abfrage überflüssig und zeigt außerdem auf eine nicht vorhandene Zeile (1090). Diese Abfrage stört den Programmablauf nicht im geringsten, wir können jedoch gespannt auf die Reaktionen der Compiler sein, wenn sie diese Zeile abarbeiten. Jetzt aber wieder zurück zu Austro-Speed.</p>

        <p>Bevor man den Compiler in den Computer lädt, muß man darauf achten, daß das Dongle auf den User-Port des C 64 gesteckt ist. Für den Vorgang des Compilierens ist es in der Regel notwendig, daß viel Platz auf der Diskette mit dem Basic-Programm vorhanden ist, da die Compiler eine Menge Dateien erstellen, die jedoch nach dem Compilieren normalerweise wieder gelöscht werden. Das ist besonders bei langen Programmen zu beachten.</p>

        <p>Nachdem wir auch diese letzte Vorbereitung ausgeführt haben, starten wir den Compiler. EDDI besteht aus 14 Blöcken auf Diskette. Nach genau drei Minuten ist Austro-Speed mit der Arbeit fertig, und das Compilat steht zur Verfügung.</p>

        <p>Während des Compilierens hat Austro-Speed sogar den Programmfehler entdeckt und angezeigt, jedoch seine Arbeit nicht unterbrochen.</p>

        <p>Wenn wir uns die Diskette betrachten, so sehen wir, daß unser Programm an Länge ganz erheblich zugenommen hat. Es besteht jetzt aus 32 Blöcken und ist damit mehr als doppelt so lang geworden.</p>

        <p>Zur Erleichterung einer eventuell noch folgenden Korrektur bei einem Fehler, legt Austro-Speed noch ein weiteres File ab, das die neuen Speicheradressen sämtlicher Programmzeilen enthält.</p>

        <p>Da ein Compiler ein Basic-Programm nicht auf einmal übersetzt, sondern dafür mehrere Durchläufe benötigt, kann man auch anhand der Anzahl dieser Durchläufe (Durchlauf = Pass) einen Compiler charakterisieren. Austro-Speed benötigt für seine Arbeit zwei dieser Durchläufe; man bezeichnet ihn deshalb auch als 2-Pass-Compiler.</p>

        <p>Unser nächstes Programm heißt BASS und kommt von gmbsoft. Der Unterschied zu Austro-Speed wird sofort deutlich, wenn man sich den Lieferumfang betrachtet. Er besteht aus drei Disketten und zwei dicken Handbüchern. Bei einer der Disketten handelt es sich um eine Demodiskette, die unter anderem ein Sortierprogramm enthält, um die Geschwindigkeit eines Compilats zu demonstrieren.</p>

        <h2>Der BASS-Compiler</h2>

        <p>Wie bei Austro-Speed habe ich auch hier erst einmal das Directory gelistet. Hat man die Länge der Austro-Speed noch vor Augen, so trifft einen hier fast der Schlag. Bei BASS handelt es sich um den reinsten »Mammutcompiler«. Er arbeitet zwar auch nur mit zwei Durchläufen, jedoch besteht hier allein schon der Pass 1 aus einem über 100 Blöcken langen Programm, der von Pass 2 noch übertroffen wird.</p>

        <p>Da es bei einer solchen Komplexität kaum möglich ist, einfach »drauflos« zu arbeiten, sollte man sich erst einmal eines der beiden Handbücher vornehmen (das dünnere, versteht sich). Und hier erlebt man auch gleich die erste Überraschung. Der Compiler erzeugt bei seiner Arbeit kein lauffähiges Programm, sondern nur eine stattliche Anzahl von Dateien (insgesamt 10), die editierfähig sind und noch einen Assemblierlauf benötigen, bevor ein fertiges Programm daraus entsteht.</p>

        <p>Diese Konzipierung hat aber natürlich einen Sinn. Bei gmbsoft hat man versucht, einen Compiler herzustellen, der so offen wie möglich arbeitet; das heißt der Programmierer soll auch nach dem Compilieren noch die Möglichkeit haben, optimierende Eingriffe und Änderungen an seinem Programm vorzunehmen. Zu diesem Zweck eignet sich ein editierfähiger Code natürlich eher, als der »Spaghetticode« in einem fertig compilierten Programm.</p>

        <p>Durch diese sehr positive Eigenschaft des Programms angeregt, geht man erneut an die Arbeit, aber — wo ist der Assembler?</p>

        <p>Es stellt sich heraus, daß der Assembler nicht im Lieferumfang des BASS enthalten ist; er muß extra besorgt werden. Wie im Handbuch empfohlen, beschafft man sich also das Assemblerpaket ASSI von Dirk Zabel (siehe Assembler-Test in Ausgabe 1/85), um endlich ein fertiges Compilat zu erhalten.</p>

        <p>Den gewohnten Richtlinien folgend kopiert man das Testprogramm EDDI auf eine leere Diskette. Aber es müssen noch einige Handgriffe ausgeführt werden, bis das Programm endlich fertig compiliert sein wird. Zuerst muß noch eine Bibliothek auf die Programmdiskette kopiert werden, die der Assembler benötigt, und dann kann es endlich losgehen. Da BASS, wie schon erwähnt, ziemliche Ausmaße besitzt, lag es natürlich nahe, einmal Hypra-Load heranzuziehen, und siehe da — BASS arbeitet mit Hypra-Load einwandfrei zusammen, was die Compilierzeit insgesamt erheblich verkürzt.</p>

        <p>Trotz aller dieser »Vorabhandgriffe« entpuppt sich der BASS als Langweiler. Für das reine Compilieren von EDDI benötigte er 7,10 Minuten. Das nachfolgende Assemblieren benötigt noch einmal neun Minuten, so daß man insgesamt mindestens eine halbe Stunde beschäftigt ist (alles eingerechnet).</p>

        <p>EDDI wird von BASS einwandfrei verarbeitet; der Fehler in Zeile 1070 wurde jedoch während der Compilation nicht entdeckt. Er wurde erst vom Assembler registriert und äußerte sich in einem »UNDEFINED SYMBOL ERROR«. Auch in diesem Fall wurde die Arbeit jedoch ordnungsgemäß zu Ende geführt.</p>

        <h2>Der Exbasic Level II-Compiler</h2>

        <p>Der Exbasic Level II-Compiler von Interface Age machte bei Erhalt der Lieferung wieder einen ganz anderen Eindruck als der BASS. Diese beiden Compiler sind dabei fast identisch. Was den Namen dieses Compilers betrifft, so erscheint er vielleicht etwas irreführend. Der Exbasic Level II-Compiler hat mit Exbasic Level II ebensoviel oder ebensowenigzu tun, wie fast alle anderen Compiler dieses Tests auch.</p>

        <p>Der Name soll eine Eigenschaft dieses Compilers verdeutlichen, die Austro-Speed und BASS jedoch ebenso besitzen: die Verarbeitung von Erweiterungen (sogenannte Extensions).</p>

        <p>Das heißt nichts weiter, als daß diese Programme in der Lage sind, auch Befehle, die im Standard-Basic V 2.0von Commodore nicht vorkommen, zu verarbeiten. Wenn diese Compiler zum Beispiel auf einen Befehl des Exbasic Level II stoßen, so wird dieser Befehl nicht compiliert, sondern im non-compiled-Code angelegt. Wird ein so compiliertes Programm jetzt zum Beispiel unter Exbasic gestartet, so übergibt das Steuerprogramm, das jedes Compilat enthält, den entsprechenden Befehl einfach dem Interpreter zur Ausführung und macht anschließend weiter.</p>

        <p>Der Unterschied zwischen dem Exbasic Level II-Compiler und BASS besteht lediglich in der Dicke des Handbuchs, im Preis und in der Tatsache, daß der Exbasic-Compiler um den notwendigen Assembler erweitert wurde. Auf der Diskette erkennt man das an Pass 3 und Pass 4, die der BASS nicht besitzt.</p>

        <p>Im Test zeigte der Exbasic-Compiler demzufolge auch die gleichen Eigenschaften wie der BASS, auf die ich gleich noch zu sprechen komme.</p>

        <p>Das Compilieren und Assemblieren wird vom Exbasic Level II-Compiler um einiges schneller erledigt, als von BASS. Außerdem spart man sich das Kopieren der Bibliothek. Für EDDI wurde eine Zeit von 12 Minuten gemessen, was jedoch immer noch viermal so lang ist, wie beim Austro-Speed. Durch das jeweilige Nachladen der einzelnen Programmteile ergibt sich außerdem noch zusätzlich ein viermaliger Diskettenwechsel.</p>

        <p>Da der BASS- und Exbasic Level II-Compiler nahezu identisch sind, soll auch gleich einmal auf die negativen Seiten der beiden Programme eingegangen werden.</p>

        <p>Wie Sie vielleicht wissen, kann man im Commodore-Basic sowohl mit Fließkomma- als auch mit Integerwerten rechnen. Der Unterschied zeigt sich in den Variablennamen, wobei die Integervariablen durch ein »%« am Ende gekennzeichnet sind. Die Integerarithmetik läßt nur Zahlenbereiche von —32 768 bis 32 767 zu; hat aber dadurch den Vorteil, daß weniger Speicherplatz und geringerer Zeitaufwand beim Rechnen mit diesen Werten erforderlich ist. Im Gegensatz zu Fließkommawerten benötigen Integerzahlen normalerweise nur 2 Byte Speicherplatz pro Wert; das sind 3 Byte weniger als bei Fließkommaberechnungen.</p>

        <p>Das Commodore-Basic hat jetzt den Nachteil, daß keine Integerroutinen existieren, die die Berechnungen durchführen. Alle Zahlen werden deshalb zuerst ins Fließkommaformat umgewandelt und dann verrechnet. Anschließend konvertiert der Interpreter diese Werte wieder zurück.</p>

        <p>Alle Vorteile, die die Integerzahlen also haben, werden durch den Interpreter zunichte gemacht. Die Entwickler von Compilern haben dieses Manko sehr wohl erkannt, und deshalb sind alle getesteten Produkte auch mit eigenen Integerroutinen ausgestattet, die einen enormen Zeitgewinn versprechen. Es ist somit möglich, auch beim Interpreter verbotene Konstruktionen, wie eine Integerschleife, zu verwenden. FOR X% = 0 TO 1000 : NEXT X% ist zum Beispiel beim Interpreter nicht gestattet und wird mit einem »SYNTAX ERROR« quittiert.</p>

        <p>Oben wurde schon auf Nachteile vom BASS- und Exbasic Level II-Compiler hingewiesen. Bei diesen beiden Produkten gibt es eine solche Konstruktion ebenfalls nicht. Hier muß man alle Variablen, die man als Integer verwenden möchte, mit direkten Befehlen an den Compiler als solche vordefinieren.</p>

        <p>Als weiterer Minuspunkt zeigte sich bei diesen beiden Produkten die »Intoleranz« gegenüber der Syntax von Programmen.</p>

        <p>Bei Basic-Programmen ist es üblich, eine Dimensionierung von Variablen, sofern das Feld nicht mehr als elf Elemente benötigt, zu unterlassen. Der Interpreter übernimmt diese Dimensionierung automatisch. Bei besagten beiden Compilern ist dies jedoch nicht der Fall und führt während des Compilierens zu einer Fehlermeldung in Form einer Nummer. Da diese beiden Compiler jedoch mit einer Fülle an Fehlermeldungen ausgestattet sind, erwies es sich bei dem Exbasic-Compiler als äußerst nachteilig, daß er keinen Fehlertext, sondern nur die Nummer der Meldung ausgibt. Wie es sich zeigte, enthält das Handbuch zwar eine Aufstellung aller Fehlermeldungen; diese aber wiederum ohne Nummer (im Gegensatz zum BASS), so daß man spekulativ schon sehr auf Zack sein muß, um zu erfahren, was für ein Fehler denn nun beanstandet wurde.</p>

        <p>Auch das oft übliche Belegen einer Zeile mit einem Doppelpunkt »:«, um ein Programm lesbarer zu gestalten, wurde nicht toleriert und führte zu einer Fehlermeldung.</p>

        <p>Insgesamt also eine Reihe von Nachteilen, die einem die Arbeit mit einem Compiler sicherlich schwerer machen, zumal wir an den anderen Testkandidaten feststellen konnten, daß es auch anders geht. Austro-Speed ist syntaktisch sehr großzügig. Das einzige, was er und Petspeed nicht vertragen, sind verschachtelte MID$-Statements, die man aber generell bei der Arbeit mit Compilern vermeiden sollte.</p>

        <p>Was angenehm überrascht, ist die Tatsache, daß Austro-Speed sogar die variable Dimensionierung (zum Beispiel DIM A (B), zuläßt. Eine eigentlich gar nicht selbstverständliche Eigenschaft, da Compiler auf das feste Anlegen von Variablenfeldern angewiesen sind und somit deren Ausmaße beim Compilieren feststehen müssen.</p>

        <p>Doch nun zum Petspeed, dessen Lieferumfang aus drei Blättern Druckerpapier und einer Diskette bestand. Das »3-Blatt-Handbuch« strotzt nur so von Fehlern und macht einen gleich einmal auf eine nette Überraschung gefaßt. Das Directory der beigefügten Diskette ist nur über Spezialprogramme zu listen. Dieser (unnötige) »Scherz« hätte unter normalen Umständen sicher nichts ausgemacht. Das Sonderbare an Petspeed ist nur, daß man sein Basic-Programm auf die Systemdiskette kopieren muß, damit der Compiler arbeiten kann. Aus diesem Grund hat mich dieser »Gag« ziemlich verärgert, da er die Möglichkeit eines Bedienungsfehlers geradezu herausfordert.</p>

        <p>Hat man auch hier EDDI in die compilierfähige Form gebracht, so kann es losgehen. Der Petspeed ist ein 4-Pass-Compiler, was schon einmal gewisse Erwartungen bezüglich der Leistung weckt.</p>

        <p>Nach 7 ½ Minuten ist die Arbeit an EDDI abgeschlossen, und wir erhalten, wie schon bei Austro-Speed, zwei Programm-Files zurück. Eines der beiden Programme ist dabei wieder eine Korrekturerleichterung, die alle vorhandenen Zeilennummern mit deren neuen Adressen enthält.</p>

        <h2>Der Petspeed-Compiler</h2>

        <p>Petspeed ist also beim Compilieren hinter Austro-Speed der zweitschnellste Compiler dieses Tests. Der einzige Nachteil besteht in der Tatsache, daß das zu compilierende Programm auf die Systemdiskette kopiert werden muß. Erstens ist damit die Wahrscheinlichkeit einer Panne mit der Originaldiskette größer, und zweitens wird der Platz zum Compilieren ganz erheblich eingeschränkt, da Petspeed schon über 200 Blöcke für sich beansprucht. So darf das zu übersetzende Basic-Programm auch nicht länger als 80 Blocks sein.</p>

        <p>Sieht man sich die Gesamtlänge der vier Compilate aller Compiler an, so erkennt man, daß sich BÄSS-, Exbasic Level II-Compiler und Austro-Speed in etwa entsprechen. Petspeed hat mit Abstand das längste File hinterlassen, was sich auch bei der weiteren Arbeit mit diesem Compiler immer wieder zeigen wird.</p>

        <p>Sie werden jetzt natürlich gespannt auf die Ergebnisse des Compilierens sein. Was ist eigentlich aus dem einstmals so langsamen Basic-Programm geworden?</p>

        <p>Nun, ich will Sie nicht länger auf die Folter spannen. Allerdings habe ich zum Zeitvergleich nicht EDDI herangezogen, obwohl sich das Ergebnis (bei rückblickender Betrachtung) nicht verändert hätte. Es wurde ein Programm erstellt, in dem systematisch ein paar Befehlsgruppen abgefragt wurden, um die Geschwindigkeit in verschiedenen Bereichen vergleichen zu können.</p>

        <p>Das Ergebnis der Messungen sehen Sie in der Zusammenfassung in Tabelle 1 und 2. Es zeigt sich ganz deutlich, daß Petspeed (obwohl der »Oldtimer« dieses Tests) der eigentliche Testsieger ist. Er hat in fast allen Bereichen die Nase vorne und erreicht Geschwindigkeiten, von denen seine Konkurrenten nur träumen können.</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td><b>Hersteller</b></td>
                        <td><b>Austro-Speed</b></td>
                        <td><b>BASS</b></td>
                        <td><b>Exbasic Level II-Compiler</b></td>
                        <td><b>Petspeed</b></td>
                    </tr>
                    <tr>
                        <td>Preis (ca.)</td>
                        <td>298,—</td>
                        <td>198,—</td>
                        <td>298,-</td>
                        <td>149,-</td>
                    </tr>
                    <tr>
                        <td>Lieferumfang</td>
                        <td>1 Diskette</p>1 Handbuch</td>
                        <td>3 Disketten</p>2 dicke Handbücher</td>
                        <td>1 Diskette</p>1 Handbuch</td>
                        <td>1 Diskette</p>3 Seiten Einweisung</td>
                    </tr>
                    <tr>
                        <td>Dokumentation</td>
                        <td>gut</td>
                        <td>ausgezeichnet</td>
                        <td>befriedigend</td>
                        <td>mangelhaft</td>
                    </tr>
                    <tr>
                        <td>ungefähre Länge des Programms</td>
                        <td>63 Blocks</td>
                        <td>263 Blocks</td>
                        <td>290 Blocks</td>
                        <td>300 Blocks</td>
                    </tr>
                    <tr>
                        <td>Anzahl PASSES</td>
                        <td>2</td>
                        <td>2 + 2 Assembler (wird nicht mitgeliefert)</td>
                        <td>2 + 2 Assembler (integriert)</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>Programmschutz möglich?</td>
                        <td>ja</td>
                        <td>nein</td>
                        <td>nein</td>
                        <td>nein</td>
                    </tr>
                    <tr>
                        <td>Integer Arithmetik</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>ja</td>
                    </tr>
                    <tr>
                        <td>Erweiterungen möglich?</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>ja</td>
                        <td>nein</td>
                    </tr>
                    <tr>
                        <td>variables DIM möglich?</td>
                        <td>ja</td>
                        <td>nein</td>
                        <td>nein</td>
                        <td>nein</td>
                    </tr>
                    <tr>
                        <td>Automatisches DIM auf 11 Elemente</td>
                        <td>ja</td>
                        <td>nein</td>
                        <td>nein</td>
                        <td>ja</td>
                    </tr>
                    <tr>
                        <td>Compilierdauer EDDI</p>(14 Blocks)</td>
                        <td>3 min</td>
                        <td>7,10 min</p>+ 9 min ASSI</td>
                        <td>12 min</td>
                        <td>7,30 min</td>
                    </tr>
                    <tr>
                        <td>Diskettenwechsel beim Compilieren</td>
                        <td>nein</td>
                        <td>ja, 2mal</td>
                        <td>ja, 4mal</td>
                        <td>nein</td>
                    </tr>
                    <tr>
                        <td>Anzahl der erzeugten Files</td>
                        <td>2</td>
                        <td>10</td>
                        <td>1</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>Länge des Compi- lats (EDDI)</td>
                        <td>32 Blöcke</td>
                        <td>39 Blöcke</td>
                        <td>39 Blöcke</td>
                        <td>42 Blöcke</td>
                    </tr>
                    <tr>
                        <td>Compilertyp</td>
                        <td>—</td>
                        <td>Adreßcode + Assemblercode</td>
                        <td>Assemblercode</td>
                        <td>Assemblercode</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 1. Vier Compiler im Vergleich</figcaption>
        </figure>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td colspan="3"></td>
                        <td>Basic</td>
                        <td>Ex-+ BASS</td>
                        <td>Petspeed</td>
                        <td>Austro-Speed</td>
                    </tr>
                    <tr>
                        <td>Test</td>
                        <td>1a</td>
                        <td>Einlesen (100 Werte)</td>
                        <td>1,53</td>
                        <td>0,67</td>
                        <td>0,50</td>
                        <td>0,46</td>
                    </tr>
                    <tr>
                        <td>Test</td>
                        <td>1b</td>
                        <td>Sortieren</td>
                        <td>64,16</td>
                        <td>24,85</td>
                        <td>8,23</td>
                        <td>16,25</td>
                    </tr>
                    <tr>
                        <td>Test</td>
                        <td>1c</td>
                        <td>Anzeigen</td>
                        <td>0,55</td>
                        <td>0,67</td>
                        <td>0,10</td>
                        <td>0,33</td>
                    </tr>
                    <tr>
                        <td>Test</td>
                        <td>1</td>
                        <td>Gesamt (a + b + c)</td>
                        <td>66,25</td>
                        <td>26,18</td>
                        <td>8,83</td>
                        <td>17,05</td>
                    </tr>
                    <tr>
                        <td>Benchmark</td>
                        <td>1</td>
                        <td>FOR NEXT</td>
                        <td>1,83</td>
                        <td>1,01</td>
                        <td>0,28</td>
                        <td>1,10</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>2</td>
                        <td>430 K = K + 1<br>440 IFK &lt;1000 THEN 430</td>
                        <td>13,22</td>
                        <td>2,16</td>
                        <td>0,72</td>
                        <td>1,38</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>3</td>
                        <td>A = K/K x K + K - K</td>
                        <td>11,25</td>
                        <td>4,70</td>
                        <td>5,54</td>
                        <td>4,38</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>4</td>
                        <td>A = K/2 x 3 + 4 - 5</td>
                        <td>12,00</td>
                        <td>6,51</td>
                        <td>6,42</td>
                        <td>5,32</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>5</td>
                        <td>GOSUB RETURN</td>
                        <td>16,65</td>
                        <td>0,45</td>
                        <td>0,18</td>
                        <td>0,15</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>6</td>
                        <td>FOR L = 1 TO 5:NEXT L</td>
                        <td>14,47</td>
                        <td>6,34</td>
                        <td>1,93</td>
                        <td>6,50</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>7</td>
                        <td>FOR L = 1 TO 5:M(L) = A:NEXT</td>
                        <td>24,85</td>
                        <td>8,80</td>
                        <td>2,50</td>
                        <td>3,95</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>8</td>
                        <td>A = K↑2<br>B = LOG(K)<br>C = SIN(K)</td>
                        <td>112,30</td>
                        <td>102,19</td>
                        <td>93,25</td>
                        <td>101,98</td>
                    </tr>
                    <tr>
                        <td colspan="3">Gesamtzeit (Test 1 + Bench 1 bis 8)</td>
                        <td>390,86<br>≙ 100%</td>
                        <td>198,53<br>≙ 50,79%</td>
                        <td>145,52<br>≙ 37,23%</td>
                        <td>172,96<br>≙ 44,25%</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 2. Die vier Compiler im Zeitvergleich. Im Test 1 wurden mit der RND-Funktion 100 Zeichen ermittelt, sortiert und nebeneinander ausgegeben. Die Benchmark-Tests 1 bis 8 waren so aufgebaut, daß die Zeit für die angegebenen Befehle selbst ermittelt werden konnten. Deshalb ist die Gesamtzeit nicht identisch mit der Summe der einzelnen Testzeiten. Jeder Befehl (Benchmark 1 bis 8) wurde 1000mal durchgeführt (siehe Listing 1).</figcaption>
        </figure>

        <figure>
            <pre data-filename="benchmark-test" data-name="Benchmark für Compiler"></pre>
            <figcaption>Listing 1. Die in Tabelle 2 zusammengefaßten Ergebnisse wurden mit diesem Programm ermittelt. Die Zeit für zum Beispiel 1000 GOSUB-RETURN erhält man, indem die Zeit für Benchmark 4 von der Zeit für Benchmark 5 abgezogen wird.</figcaption>
        </figure>

        <p>Unser Testprogramm absolvierte er beispielsweise in 145 Sekunden. Das Original unter dem Interpreter benötigt noch 391 Sekunden. Mit großem Abstand folgt dann erst einmal das Compilat von Austro-Speed. Es erreicht immerhin eine Zeit von 173 Sekunden und ist damit um fast 20 Prozent langsamer als Petspeed.</p>

        <p>Enttäuscht hat in diesem Test der Exbasic Level II-Compiler. Einmal davon abgesehen, daß er schon eine Reihe anderer Schwächen aufzuweisen hatte, bildete er noch zusätzlich in diesem Geschwindigkeitstest das Schlußlicht mit einer Zeit von 198 Sekunden.</p>

        <p>Der BASS-Compiler ist zwar genauso schnell oder langsam wie der Exbasic-Compiler (198 Sekunden), er hat aber immer noch den Vorteil seines positiven Konzepts, des bedienerfreundlichen Compilats, was zumindest Maschinensprach-Spezialisten zu schätzen wissen dürften.</p>

        <p>BASS überholt Austro-Speed lediglich bei der Übersetzung von PO-KEs und PEEKs. Dieser Unterschied ist jedoch sehr gering und kann an dem Gesamtergebnis nichts ändern.</p>

        <h2>Fazit</h2>

        <p>Fangen wir mit dem Exbasic Level II-Compiler an. Dieses Produkt konnte in wesentlichen Punkten nicht überzeugen. Einige dieser Gründe sind mit Sicherheit darin zu sehen, daß dieser Compiler nur die um einen Assembler erweiterte Version des BASS ist, wobei jedoch die relativ schwache Leistung des BASS noch durch die verlorengegangenen positiven Eigenschaften dieses Programms verstärkt wurde. Der BASS ist zwar langsam, aber sein Vorteil liegt im offenen Konzept des erzeugten Codes. Damit hat der Benutzer die Möglichkeit,, auch beim Compilat noch leicht Anderungen vorzunehmen. Zu diesem Zweck ist BASS sehr umfassend dokumentiert, im Gegensatz zum Exbasic Level II-Compiler.</p>

        <p>Die Nachteile beider Compiler waren aber die »pingeligen« Ansprüche an die Syntax des zu compilierenden Programms. Ein Anwender, der mit Compilern arbeitet, möchte in der Regel ein älteres Programm ohne große Änderungen am Original schnell compilieren können. Das ist aber ohne große Änderungen bei diesen beiden Compilern fast nicht möglich.</p>

        <p>Als Kaufempfehlung kann hier also höchstens BASS gelten (198 Mark). Dieser Compiler ist jedoch nichts für Anfänger und für Anwender, die sich einen Compiler nur zum bequemen »Hochpuschen« von Basic-Programmen zulegen. Der Exbasic Level II-Compiler ist allein schon seines hohen Preises wegen (298 Mark) gemessen an den Leistungen, nicht ohne Vorbehalt zu empfehlen. Er besitzt keine herausragenden Vorzüge und könnte bei weniger erfahrenen Programmierern schnell ein falsches Bild von Compilern hervorrufen.</p>

        <p>Das Nachladen von Programmen, sogenanntes Overlay, machte bei allen Compilern dieses Tests (infolge der Variablenorganisation) Schwierigkeiten. Das im Interpretermodus mögliche Nachladen von Programmen mit Variablenübergabe (Warm-Overlay) ist in der Regel mit den Compilern nicht möglich. Hier muß man normalerweise eine Speicherstelle als Flag (beim Nachladen mehrere Programme) benutzen, da die Variablen durch das Nachladen gelöscht werden (Kalt-Overlay).</p>

        <p>Am großzügigsten bei der Analyse von Programmen zeigte sich der Austro-Speed. Er war beim Compilieren mit Abstand der Schnellste. Die Endgeschwindigkeit des Compilats ist zwar nicht mit der des Petspeed vergleichbar; es zeigt sich jedoch deutlich, daß dieser Compiler die wenigsten Probleme aufwirft, zumal seine Bedienung ein wahres Kinderspiel ist. Er »verdaut« die meisten Programme ohne Schwierigkeiten und zeigt sich auch in der Anwendung sehr vielseitig, da er sowohl mit einem, als auch mit mehreren Floppy-Laufwerken zusammenarbeitet. Der Preis vom Austro-Speed ist mit dem von Exbasic Level II-Compiler identisch (298 Mark); hätte man also die Wahl zwischen beiden, so dürfte die Entscheidung nicht allzu schwer fallen.</p>

        <p>Sehr viel fürs Geld bekommt man mit Petspeed ins Haus geschickt (149 Mark). Dieser Compiler übertraf alle Erwartungen und zeigte sich auch in der Bedienung recht einfach. Die zwei negativen Aspekte dürften hier wohl die unzureichende Literatur und das notwendige Kopieren des Basic-Programms auf die Systemdiskette sein. Wenn man aber einmal die 149 Mark sieht, die der Petspeed kostet, so zeigt sich dennoch ein hervorragendes Preis/Leistungsverhältnis, das von keinem Compiler des Tests erreicht wurde. In den Tabellen finden Sie zur besseren Orientierung noch einmal alle Test-Ergebnisse zusammengefaßt.</p>

        <address class="author">(Karsten Schramm/gk)</address>

        <p>Bezugsadressen und Info:<br>
            BASS: gmbsoft, Kaiser-Friedrich Ring 55, 6200 Wiesbaden<br>
            Austro-Speed (Austro-Comp): Commodore, Lyoner Str. 38, 6000 Frankfurt/Main und für Österreich: Digimat, Arbeitergasse 48, 1050 Wien<br>
            Ex-Basic-Compiler II: Interface Age, Vohburger Str. 1, 8000 München 21<br>
            Petspeed: Infotronik, Birkenstr. 40, 4100 Duisburg</p>
    </article>

</body>

</html>