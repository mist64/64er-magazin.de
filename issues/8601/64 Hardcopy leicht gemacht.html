<!DOCTYPE html>
<html lang="de">

<head>
    <title>Hardcopy leicht gemacht</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="hm">
    <meta name="64er.issue" content="1/86">
    <meta name="64er.pages" content="64-67,177">
    <!-- <meta name="64er.toc_category" content="XXX"> -->
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="XXX">
</head>

<body>
    <article>
        <h1>Hardcopy leicht gemacht</h1>
        <p class="intro">Jetzt bekommt Ihr Drucker was zu tun! Wir zeigen Ihnen, wie Sie die Basic-Hardcopy-Routine aus der Ausgabe 9/85 in Maschinensprache umsetzen können. Ein gedrucktes »Foto« des Textbildschirms auf Tastendruck.</p>

        <p>Eine Hardcopy vom Textbildschirm des C 64 wird häufig gebraucht. Die Dokumentation eines selbstgeschriebenen Programms oder ein Beispielausdruck für eine Programmanleitung sind nur zwei Beispiele.</p>

        <p>In der letzten Folge war die Hardcopy-Routine auf Commodore-Drucker zugeschnitten. Diesmal sind alle 8-Nadel-Druk-ker an der Reihe. Das Programm ist auf die Epson-Drucker FX und RX zugeschnitten. Ein verwendetes Interface muß sich durch die Sekundäradresse 1 im OPEN-Befehl in den Linearmodus schalten lassen. Lassen Sie sich davon aber nicht abschrecken, falls Ihr Interface oder Drucker auf andere Weise angesteuert wird. Wenn Sie Grundkenntnisse in der Assembler-Programmierung haben, sind Sie in der Lage, das Programm auch an Ihren Drucker anzupassen. Voraussetzung für das Gelingen der Anpassung ist nur, daß Ihr Drucker über einen Bitmustermodus mit acht ansteuerbaren Nadeln verfügt.</p>

        <p>Wenn Sie keine Änderungen am Programm vornehmen möchten, sollten Sie den MSE-Lader (Listing 1) abtippen. Wollen Sie aber Änderungen und Verbesserungen daran vornehmen, verwenden Sie besser das Quellisting (Listing 2) und einen Assembler. Aber das werden Sie dann sowieso machen. Da in jeder Zeile nur ein einziger Befehl vorkommt, sollte das Quellisting ohne weiteres auf jeden Assembler, beispielsweise dem Hypra-Ass, übertragen werden können. Es müssen ja prinzipiell nur die Assembler-Anweisungen in den Zeilen 1000, 1010, 1100, 1110, 4070 und 4080 geändert werden. Die Bedeutung dieser Zeilen:</p>

        <p>1000 Programmdatei für Maschinen-Code öffnen<br>
            1010 Starten des Assemblers<br>
            1100 Maschinen-Code in offene Datei schreiben<br>
            1110 Startadresse des Programms<br>
            4070 Ende des Quell-Codes<br>
            4080 Initialisierung der Hardcopy-Routine (nur sinnvoll, wenn der Maschinen-Code in den Speicher geschrieben wird und nicht auf Diskette gespeichert wird).</p>

        <h2>Hardcopy des Text-Bildschirms</h2>

        <p>Aber nun Schluß mit den allgemeinen Hinweisen. Im folgenden wird das Source-Listing anhand der Zeilennummern erklärt. Ab Zeile 1150 im Sourcelisting (Quellisting), werden den benötigten Betriebssystem-Routinen und Speicherzellen Labels (Namen) zugeordnet. Was die einzelnen Routinen leisten, entnehmen Sie bitte den Kommentaren im Quellisting.</p>

        <p>Eine Hardcopy-Funktion für Textbildschirme wird erst dann so richtig interessant, wenn sie durch einfachen Tastendruck gestartet werden kann. Unabhängig davon, was der Computer gerade macht. Denn nur so kann man sich Beispiele von Bildschirmmasken etc. drucken lassen. Aus diesem Grund wurde dieser Hardcopy-Routine eine Tastenabfrage vorgeschaltet. So wird erreicht, daß durch kurzes Drücken der F1-Taste das Hardcopy-Programm startet. Wie man eine solche Tastenabfrage realisieren kann, sehen Sie ab Zeile 1460 im Quellisting. Dort wird die Abfrage-Routine in den Systeminterrupt des C 64 eingebunden. Danach wird die Taste pro Sekunde etwa 60mal abgefragt. Ist sie nicht gedrückt, wird der normale Sy-steminterruptfortgesetzt. Zum Einbinden einer Routine in den Systeminterrupt (IRQ) muß der Interruptvektor in den Speicherzellen $314 und $315 auf die Routine »umgeleitet« werden. Im Normalfall zeigt der IRQ-Vektor auf den Beginn der Systeminterrupt-Routine bei $EA31. In diesem Fall wird er so verändert, daß er auf die Tastenabfrage, also auf $C00D zeigt. Genaueres zu diesem Thema können Sie beispielsweise im 64’er Sonderheft 4/85 nachlesen.</p>

        <p>Die Veränderung des IRQ-Vektors wird in den Zeilen 1470 bis 1550vorgenommen. BevoraberderVektorverändertwer-den kann, ist ein SEI(set-interrupt-disable-flag)-Befehl nötig. Dieser Befehl setzt das IRQ (interrupt-request)-Flag. Das bewirkt, daß der Prozessor keinen Interrupt mehr annimmt. Es ist ja eigentlich einleuchtend, daß kein Interrupt stattfinden darf, wenn man gerade die IRQ-Sprungadresse verändert. Das wäre so, als ob Sie auf einer Kreuzung ein Umleitungsschild aufstellen wollen, wenn dort gerade ein Lastzug fährt. Sie müssen vorher schon den Verkehr anhalten. Die Umstellung des IRQ* Vektors geschieht in diesem Programm durch SYS 49152. Dadurch wird die ganze Hardcopy-Routine initialisiert. Von nun an springt der Prozessor bei jedem Interrupt in die Tastenabfrage ab Zeile 1570. Dort wird der Inhalt der Speicherzelle $C5 geladen und mit »4« verglichen. »4« ist der Tastencode der F1-Taste. Fällt der Vergleich negativ aus, erfolgt sofort ein Sprung zur Adresse $EA31, der Systeminterrupt-Routine des C 64 (Zeile 1640). Fällt der Vergleich dagegen positiv aus (F1 gedrückt), verzweigt die Abfrage-Routine ins eigentliche Hardcopy-Programm ab Zeile 1700.</p>

        <h2>Start auf Tastendruck</h2>

        <p>Am Anfang der Hardcopy-Routine wird als erstes die gesamte Zeropage (Speicherzellen 0-255) zwischengespeichert. Dieses Verfahren ist zwar alles andere als elegant, erspart aber sehr viel Denkarbeit. Der Zeitbedarf dafür ist so gering, daß er bei einer Hardcopy-Routine vernachlässigt werden kann.</p>

        <p>Nach dem »Retten« der Zeropage wird der Druckerkanal eröffnet und der Drucker normiert (Zeile 1670 bis 2000). Der Druckerkanal hat die Filenummer 126 und die Sekundäradresse 1. Die Geräteadresse ist 4. Die File-Nummer wurde so hoch gewählt, damit es keine Schwierigkeiten mit eventuell schon vorhandenen offenen Dateien gibt. Wer verwendet in Programmen schon die File-Nummer 126? Achtung: Eine File-Nummer größer als 127 sendet ein Linefeed (Zeilenvorschub) »CHR$(10)« nach jedem Carriage Return.</p>

        <p>Ist der Druckerkanal offen, wird der Zeilenabstand des Druckers so eingestellt, daß alle Zeilen dicht aneinander liegen. Beim Epson RX/FX geschieht das mit der Steuersequenz CHR$(27)”3”CHR$(24). Mit der PRINT-Routine wird ein Zeichen an das, durch die CHKOUT-Routine festgelegte, Gerät geschickt. In diesem Fall eben an den Drucker.</p>

        <p>Ab Zeile 2040 wird die Anfangsadresse des Bildschirms geholt und in VIRAM und VIRAM+1 übergeben. Das Programm mußja wissen, wo die zu druckenden Daten stehen. Nach dieser Vorarbeit steht der eigentlichen Hardcopy-Routine nichts mehr im Weg.</p>

        <p>In Zeile 2140 wird das x-Register mit der Zeilenzahl (25) des Bildschirms geladen. Danach wird die STOP-Taste abgefragt, um die Hardcopy vorzeitig beenden zu können. Die Abfrage findet übrigens zu Beginn jeder neu zu druckenden Bildschirmzeile statt. Ist die STOP-Taste gedrückt, wird die Hardcopy-Routine beendet und die normale Interrupt-Routine abgearbeitet. Wie die Hardcopy-Routine beendet wird, soll später erklärt werden. Vorläufig wird erstmal gedruckt!</p>

        <p>Damit der richtige Zeichensatz aufs Papier kommt, wird ab Zeile 2390 bei jeder neuen Zeile ein Prüfprogramm (ab Zeile 3820, CHRTEST) aufgerufen, das den momentanen Schriftmodus überprüft. Groß-/Klein oder Groß-/Grafik-Zeichensatz. Die Startadresse des Zeichensatzes im Character-ROM wird dann in ZROM, ZROM+1 abgelegt. DerGroß/Klein-Zeichen-satz hat die Startadresse $D800, der Groß/Grafik-Zeichen-satz steht ab Adresse $D000. Welcher Zeichensatz gewählt ist, steht in Speicherzelle $D018 des Videochips. Ergibt der Inhalt von $D018 AND 2 das Ergebnis 2, ist der Groß/Grafik-Modus eingeschaltet. In Zeile 3890 finden Sie den BIT-Befehl $2C. Dieser Befehl vergleicht normalerweise den Akkuinhalt mit der angegebenen 2-Byte-Adresse und verändert entsprechend das Z-Flag. Diese Funktion ist aber hier nur Mittel zum Zweck. In diesem Fall soll der Prozessor nur die auf $2C folgenden 2 Bytes ignorieren. Genauer: Wird der Akku mit dem High-Byte der Startadresse des Zeichensatzes 1 geladen (Zeile 3870), wird der 2-Byte-Ladebefehl LDA # >CHRGEN2 (StartadresseZeichensatz #2) einfach ignoriert. Man erspart sich dadurch eine zusätzliche Abfrage und einen Branch-Befehl.</p>

        <p>Nachdem der aktuelle Zeichensatz bekannt ist, wird der Drucker in den Bitmustermodus (Grafikmodus) geschaltet. Dazu werden aus der Tabelle GRAFIK sieben Steuercodes geholt und zeichenweise an den Drucker geschickt. Die Steuer-sequenzist24,13, 27, ”*”, 4, 64,1. »1«und»64«istdasHighbeziehungsweise das Low-Byte von 320, der Anzahl der Grafikpunkte des C 64 in einer Zeile. Der Code »13« bewirkt nur einen Wagenrücklauf (Carriage Return), damit der Druckkopf am Zeilenanfang steht. CHR$(24) löst einen Drucker-Reset aus.</p>

        <p>In zwei Schleifen wird nun der ganze Bildschirm »abgetastet« und die einzelnen Zeichen am Bildschirm in Bitmusterdaten übersetzt. Den Anfang der übergeordneten »Zeilenschleife« lernten Sie bereits kennen: LDX #25, STOP-Taste abfragen, Druckerzeile initialisieren (in Grafikmodus schalten). Die untergeordnete »Spaltenschleife« (Zeilen 2530 bis 2650) holt nacheinander den Bildschirmcode der Zeichen einer Zeile. Der Zeichencode wird in der Speicherzelle ZEICHEN abgelegt. Als Zählvariable für diese untergeordnete Schleife, die von 0 bis 39 zählt, wird das y-Register hergenommen. Der Abschnitt von Zeile 2250 bis 2330 überprüft, ob in einer Zeile überhaupt etwas steht. Wenn nicht, wird ein Zeilenvorschub ausgelöst und die nächste Zeile »abgetastet«.</p>

        <p>Ist ein Zeichen-Code ermittelt, wird mit JRS AUSWERT in Zeile 2620 ein Unterprogramm aufgerufen, das aus dem Zeichensatz-ROM die Punktmuster der Zeichen liest. Dazu werden nacheinander die acht senkrechten Punktspalten eines Zeichens aus den Daten des Zeichensatz-ROMs zusammengesetzt. Jede fertige Punktspalte wird an den Drucker geschickt. Aus acht dieser Spalten entsteht dann ein Zeichen auf dem Papier, aus 320 solcher Spalten eine ganze Druckzeile. Das Lesen des Zeichensatz-ROMs und der Zusammenbau der Punktspalten ist für den Anfänger in Maschinensprache nicht ganz einfach zu verstehen und soll deshalb kurz erklärt werden.</p>

        <p>Das Unterprogramm AUSWERT beginnt ab Zeile 3060 mit drei PHA (push akku)- und zwei Transferbefehlen, die den Inhalt des Akkus und des x-,y-Registers auf den Prozessorstack legen. Das ist nötig, da im Unterprogramm der Akku und das x- und y-Register verändert werden. Danach wird in den Zeilen 3160 bis 3290 die Startadresse des momentanen Zeichens im Zeichensatz-ROM berechnet. Die Startadresse berechnet Anfangsadresse + Offset (Speicherstelle im ZeichensatzROM). Offset = Bildschirm-Code x 8.</p>

        <p>Wie schon erwähnt, wird ab Zeile 2530 der »Spaltenschleife« der Bildschirmcode eines jeden Zeichens am Bildschirm geholt (LDA (VRAM,Y)) und in ZEICHEN gespeichert. Der Inhalt von ZEICHEN wird in Zeile 3170 in die Speicherzelle ADRESSE kopiert. Dann wird durch drei ASL-Befehle der Inhalt Speicherzelle ADRESSE und ADRESSE+1 (Grundwert immer »0«) mit 8 multipliziert. Ein ASL (arithmical shift left) verdoppelt den Inhalt einer Speicherzelle. Tritt dabei ein Übertrag auf (Ergebnis > 255) wird das Carry-Flag gesetzt. Das Carry-Flag wird in der Speicherzelle ADRESSE+1 berücksichtigt. Ein ROL-Befehl schiebt das Carry-Bit »von rechts in die Speicherzelle ADR+1«. Fand kein Übertrag statt, schiebt der ROL-Befehl einfach eine »0« nach. Der ROL-Befehl hat die gleiche Wirkung, wie eine Verdopplung eines Speicherzelleninhalts mit ASL, nur wird anschließend noch das Carry-Bit addiert. Nach der Multiplikation mit 8 steht in ADRESSE und ADRESSE+1 in Low-/High-Bytedarstellung der Offset. Um die absolute Adresse zu erhalten, wird ab Zeile 3110 der Offset zur Anfangsadresse des Zeichensatz-ROMs addiert. Es steht dann die absolute Zeichenadresse in ADRESSE (Low-Byte) undADRESSE+1 (High-Byte).</p>

        <p>Der Clear-Carry (CLC)-Befehl ist grundsätzlich vorjeder Addition notwendig, um ein eventuell gesetztes Carry-Flag zu löschen. Nur so kann ein Übertrag sicher festgestellt werden.</p>

        <p>Ist die Anfangsadresse eines Bildschirmzeichens im Zeichensatz-ROM bekannt, fängt aber die Arbeit erst richtig an.</p>

        <p>Ein Bildschirmzeichen setzt sich aus einer 8x8-Punktmatrix zusammen. Die Punktmatrix wird beim C 64 aus acht 8-Bit-Zahlen zusammengesetzt:</p>

        <p>TODO TABLE</p>

        <p>Adresse Adresse<br>
            $D000 &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.. $D005 &hellip;&hellip; . .<br>
            $D001 &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.. $D006 &hellip;&hellip; . .<br>
            $D00'2 &hellip;&hellip;&hellip;.. $D007 &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.<br>
            $D003 &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.. $D008 &hellip;&hellip;&hellip;.<br>
            $D004 &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.. $D009 &hellip;&hellip;&hellip;.</p>

        <p>Mit einer 8-Bit-Zahl pro Punktzeile. Dabei bestimmt die erste Zahl im ROM das Punktmuster der obersten Punktzeile eines Zeichens. Stellen Sie sich eine 8-Bit-Zahl einmal in Binärform vor. Eine »1« ist dann ein gesetzter Punkt und eine »0« kein Punkt. So könnte die Zahl 0000 1000 (dez. 8) einen i-Punkt wiedergeben. Wie Sie sehen, sind die Bildschirmzeichen aus Punktzeilen aufgebaut; im Gegensatz zu den Druckerzeichen, die aus Punktspalten zusammengesetzt werden. Die beiden Formate bringen ein Problem mit sich, denn die Bitmusterdaten des Bildschirms müssen in die des Druckers übersetzt werden. Diese Konvertierung wird in den Zeilen 3330 bis 3660 vorgenommen.</p>

        <p>Doch bevor man die Bitmusterdaten konvertiert, muß erstmal eine Punktzeile aus dem Zeichensatz-ROM gelesen werden. Wie Sie vielleicht wissen, liegt das Zeichensatz-ROM im $D000-Bereich, dem kompliziertesten Speicherteil des C 64. Im Bereich von $D000 bis $DFFF arbeiten nämlich noch alle I/O-Bausteine. Man spricht in diesem Zusammenhang von Speicherebenen, diesich einen Speicherbereich teilen. Damit derZeichensatz gelesen werden kann, muß also noch die richtige Speicherebene selektiert werden. Doch dazu später mehr. Zuerst soll die Konvertierung der Bitmusterdaten geklärt werden.</p>

        <p>Zur Konvertierung der Zeilenwerte in Spaltenwerte liest man nacheinander acht mal die Zeilenwerte des Zeichensatz-ROMs und vergleicht die Werte mit einer »Bit-Maske«. Die acht Bit-Masken sind:</p>

        <p>TODO TABLE<br>
            Maske bin. Wertigkeit<br>
            1000 0000 128<br>
            0100 0000 64<br>
            0010 0000 32<br>
            0001 0000 16<br>
            0000 1000 8<br>
            0000 0100 4<br>
            0000 0010 2<br>
            0000 0001 1</p>

        <p>Beim ersten Durchgang hat die Bitmaske die Wertigkeit 128 (Zeile 3360). Mit dieser Maske werden nun nacheinander alle acht Punktzeilen eines Bildschirmzeichens AND-verknüpft. Ist beispielsweise in der Zeilenzahl das achte Bit gesetzt (Zahl >127), ist das Ergebnis der Verknüpfung 128, also größer 0. Liefert die Verknüpfung »0«, wird der nächste der acht Zeilenwerte mit der Maske verglichen. Ist das Ergebnis einer Verknüpfung größer als 0, muß an dieser Stelle eine Druckernadel anschlagen.</p>

        <p>Bei einem 8-Nadeldrucker haben die Nadeln die binären Werte 1,2,4,8,16,32,64,128. Die unterste Nadel hat die Wertigkeit 1, die oberste die Wertigkeit 128. Ausnahmen bestätigen aber auch hier die Regel (Seikosha 550A: Die untere Nadel hat die Wertigkeit 128). Damit der Drucker die richtige Nadel anschlägt, muß die Wertigkeit der Nadel, oder die Summe der Wertigkeiten, dem Drucker geschickt werden. Dazu ordnet man den acht Punktzeilen eines Bildschirmzeichens die binären Wertigkeiten 1 bis 128 zu; entsprechend der Nadel-anordung des Druckers. Bei jedem positiv ausgefallenen Maskenvergleich, addiert man die entsprechenden Nadelwertigkeiten. Wurden alle acht Zeichenzeilen auf diese Weise »abgetastet«, wird die Summe an den Drucker geschickt, der daraufhin eine senkrechte Punktreihe druckt.</p>

        <p>Um die nächste Punktspalte drucken zu können, dividiert man die Maske mit »2«. Am einfachsten mit einem LSR (logical shift right)-Befehl. Dieser Befehl verschiebt die »1« in der »Binärmaske« um eine Stelle nach links, was eben einer Division mit 2 gleichkommt. Nun vergleicht man wieder die acht Zeilenwerte mit der neuen Maske und addiert die Nadelwertigkeiten. Nach acht Vergleichen ist der Druckercode für die zweite Druckspalte addiert und kann zu Papier gebracht werden. Dieses Spielchen wiederholt man, bis alle acht Punktspalten eines Zeichens gedruckt sind. Für ein einziges Zeichen sind insgesamt 64 Vergleiche nötig.</p>

        <p>Als Basic-Programm wäre die Konvertierung der Bitmusterdaten des C 64 in die eines Druckers viel zu langsam. Es sind schließlich 64x40x25=64000 Konvertierungen pro Bildschirm nötig. Ebenso ist die »Bit-Schieberei« mit LSR, OR und AND in Basic einProblem für sich.</p>

        <p>Die Speicherebenenumschaltung auf das ZeichensatzROM findet in Zeile 3450 statt, nachdem zuvor das Interrupt-Flag gesetzt wurde. Denn solange Speicherzelle 1 den Wert $33 enthält, dürfen keine I/O-Operationen des Prozessors, wie Tastenabfrage und Cursor-Blinken, erfolgen. Der Prozessor würde unweigerlich abstürzen, wenn er auf das</p>

        <p>Zeichensatz-ROM zugreift, anstelle auf einer der beiden CIAs oder dem VIC-Chip.</p>

        <p>In Zeile 3480 wird das Zeichensatz-ROM ausgelesen und in Zeile 5335 mit der aktuellen Maske verglichen. Danach wird der ursprüngliche Inhalt von Speicherzelle 1 zurückgelassen und ein Interrupt wieder erlaubt.</p>

        <p>Die Addition der Nadelwertigkeiten der Punktzeilen findet in Zeile 3590 mit einem ADC-Befehl statt. Die Wertigkeiten der Nadeln stehen in der Tabelle NWERT am Schluß des Programms. Nachdem alle acht Werte im Akku summiert sind, positive Maskenvergleiche vorausgesetzt, wird der Akkuinhalt an den Drucker geschickt. Der Befehl JSR PRINT schickt das Punktmuster der Druckzeichenspalte an den Drucker. Sind die acht Punktreihen gedruckt, werden sämtliche Register wieder hergestellt und die Unterroutine AUSWERT wird beendet. Der RTS-Befehl führt dann wieder in die Spaltenschleife zu Zeile 2510.</p>

        <p>Sind auf diese Weise 40 Zeichen gedruckt, wird in der Zeilenschleife das y-Register wieder auf »0« gesetzt, der Drucker auf eine neue Druckzeile mit Bitmusterdaten eingestellt und eine neue Druckzeile abgearbeitet.</p>

        <p>Ist der ganze Bildschirm ausgedruckt (oder die STOP-Taste gedrückt), wird ab Zeile 2980 das Programm beendet. Im einzelnen heißt das, daß der Druckerkanal geschlossen, die Zeropage zurückgeschrieben und die normale Interruptroutine bearbeitet wird.</p>

        <p>Danach läuft Ihr Programm weiter als wenn nichts geschehen wäre.</p>

        <address class="author">(hm)</address>
    </article>
</body>

</html>