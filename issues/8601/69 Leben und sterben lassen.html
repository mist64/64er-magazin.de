<!DOCTYPE html>
<html lang="de">

<head>
    <title>Leben und sterben lassen</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Jürgen Engbring, tr">
    <meta name="64er.issue" content="1/86">
    <meta name="64er.pages" content="69-71">
    <meta name="64er.head1" content="Spiel">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="Leben und Sterben lassen">
    <meta name="64er.toc_category" content="Listings zum Abtippen|Simulation">
    <meta name="64er.index_title" content="Leben und Sterben lassen (Life)">
    <meta name="64er.index_category" content="Listings zum Abtippen|Spiel Simulation">
    <meta name="64er.id" content="life">
</head>

<body>
    <article>
        <h1>Leben und sterben lassen</h1>
        <p class="intro">»Life« ist wohl eine der faszinierendsten Simulationen von biologischen Vorgängen auf Computern. Mit »Life« lassen sich evolutionäre Abläufe spielerisch verstehen lernen.</p>

        <p>Obwohl den Lesern der Inhalt des »Spiels« geläufig sein mag, hier die »Regeln«:</p>

        <p>Es existiert ein zweidimensionales Feld und an jedem Punkt ist eine lebende oder eine tote Zelle. Jede Zelle hat acht Nachbarn.</p>

        <p>An einem Punkt wird eine Zelle dann und nur dann lebendig, falls sie genau drei lebende Nachbarn hat.</p>

        <h2>Fast wie im richtigen Leben</h2>

        <p>Eine Zelle stirbt, wenn sie weniger als zwei (Vereinsamung) oder mehr als drei (Überbevölkerung) lebende Nachbarn hat.</p>

        <p>So ändert sich das Feld von Generation zu Generation, mit einer meist faszinierenden Entwicklung. Das Spiel, erfunden von dem Mathematiker John Horton Conway (Cambridge), stellt sich als höchst komplex und reizvoll heraus.</p>

        <p>Um es gleich zu sagen: Life ist kein Spiel, das man selber spielt. Life spielt sich selbst. Man kann die »Anfangswelt« festlegen und dann beobachten, wie sie sich entwickelt. Das Spiel wird sicher dem einen oder anderen Computer-Fan bekannt sein, da es ein ideales Problem für den Computer ist: Sehr einfache Regeln, aber viel Rechnerei.</p>

        <p>In dem Beispiel (Rotor, siehe Bild 1) sind die Verhältnisse noch sehr einfach, weil die kleine Life-Welt nur zwischen zwei Zuständen hin und her pendelt. Dieser Dreier ist eine der Strukturen, die stabil sind. Meistens dauert es viele Generationen, bis eine Population ausstirbt oder in stabile Strukturen übergeht. Am besten, man experimentiert einfach etwas. Bild 2 zeigt noch einige interessante Strukturen.</p>

        <figure>
            <img src="69-1.png" alt="">
            <figcaption>Bild 1. Ein einfaches Beispiel erläutert die Funktionsweise von »Life«</figcaption>
        </figure>
        <figure>
            <img src="69-2.png" alt="">
            <figcaption>Bild 2. Anhand einfacher Strukturen wird die Faszination von »Life« deutlich</figcaption>
        </figure>

        <h3>Zum Programm:</h3>

        <p>Wie würde man das Problem normalerweise angehen? Nun, man legt sich ein zweidimensionales Feld an und speichert für jede lebende Zelle eine Eins, für jedes unbesetzte Kästchen eine Null. Dann geht man alle Felder durch, prüft die acht Nachbarfelder und speichert das Ergebnis, tot oder lebendig in der nächsten Generation, in einem zweiten Feld. Der Computer hat dann (bei 80 mal 50) 32 000 Felder zu überprüfen, und das bedeutet: warten&hellip;</p>

        <p>Aber Moment! Ist es denn nötig, auch die Bereiche zu bearbeiten, in denen es ohnehin kein Leben gibt?</p>

        <p>Besser, man bearbeitetjeweils nur die relevanten (belebten) Bereiche: Es kann nur in dem Bereich etwas passieren, der direkt an lebende Zellen angrenzt. Man speichert die Koordinaten aller lebenden Zellen und ihrer Nachbarn, sorgt dafür, daß keine Felder doppelt gezählt werden und braucht dann jeweils nur noch die Liste der Koordinaten durchzugehen. Dafür benötigt man ein weiteres Variablen-Feld, in dem bereits vermerkte Zellen gekennzeichnet werden. Nach dieser Vorbereitung werden zur Berechnung der nächsten Generation die Koordinaten des relevanten Bereichs durchgegangen. Ein zweites Mal durchläuft man die Koordinaten, um den neuen relevanten Bereich festzustellen. Wenn also eine Struktur auf dem Bildschirm wandert, so wandert auch der relevante Bereich mit.</p>

        <h3>Bedienungshinweise:</h3>

        <p>Man hat eine 78 x 48-Auflösung (der äußerste Rand ist eine Todeszone«; hier ist grundsätzlich kein Leben möglich) zur Verfügung. Startet man das Programm, so befindet man sich in einem Editor.</p>

        <p>Eine Zelle wird mit der SPACE-Taste lebendig.</p>

        <p>Eine Zelle wird mit der DEL-Taste getötet.</p>

        <p>Der Cursor schreitet nach SPACE und DEL in die Richtung fort, die die letzte gedrückte Cursortaste angab.</p>

        <p>Mit »L« wird Life dann gestartet. In dem jetzigen Zustand gibt es folgende Befehle:</p>

        <table class="plain">
            <tr>
                <td>S</td>
                <td>Stop</td>
            </tr>
            <tr>
                <td>F1-F8</td>
                <td>Verzögerung</td>
            </tr>
            <tr>
                <td>N</td>
                <td>Neue Eingabe</td>
            </tr>
            <tr>
                <td>E</td>
                <td>Ergänzung, Veränderung</td>
            </tr>
            <tr>
                <td>Q</td>
                <td>Quit, Programmende</td>
            </tr>
            <tr>
                <td>P</td>
                <td>Power, maximale Geschwindigkeit<br>(nur mit RUN-STOP/RESTORE zu lösen)</td>
            </tr>
        </table>
        <h3>Erweiterungsmöglichkeiten:</h3>

        <p>Man könnte natürlich die Auflösung weiter erhöhen. Da böte sich dann die Bitmap-Auflösung an (HiRes-Grafik). Hier müßte man allerdings mit dem Speicherplatz sehr vorsichtig umgehen, da der Bildschirm 64000 Bildpunkte hat. Die zusätzlichen Berechnungen würden das Programm auf jeden Fall langsamer machen. Außerdem wird, wenn die relevanten Bereiche zu groß werden, ein Speichern derselben unmöglich (Speicherplatz) und der Generationswechsel dauert zu lange. Eine andere interessante Veränderung wäre mit dem Rand durchzuführen. Mit dem »Todesrand« wurde das Problem der Bildschirm-Bereichsüberschreitung zwar recht elegant gelöst, denn es sind durch das Prinzip der relevanten Bereiche keine Abfragen notwendig. Interessanter jedoch wäre eine offene Wand oder gar eine ganz in sich geschlossene Welt. Unten (rechts) heraustretende Formen würden dann oben (links) wieder auftauchen. Wegen der Abfragen würde jedoch auch dies die Geschwindigkeit verringern.</p>

        <h3>Hinweise zum Abtippen:</h3>

        <p>Als erstes geben Sie die Maschinenroutine (Listing 2) mit dem MSE ein (Speichern nicht vergessen). Zur Eingabe des Hauptprogramms (Listing 1) verwenden Sie bitte den Checksummer.</p>

        <p>Interessierte Leser finden in der Tabelle 1 die Beschreibung des Maschinenprogramms.</p>

        <p>Wer will, kann das Programm noch wesentlich erweitern: Zum Beispiel könnten Hungersnöte, Naturkatastrophen oder Seuchen in bestimmten Gebieten die Bevölkerung wesentlich dezimieren. Ich glaube nicht, daß man das Spiel »Life« auf dem C 64 noch wesentlich schneller programmieren kann, jedoch soll diese Behauptung ruhig dazu provozieren, das Gegenteil zu beweisen.</p>

        <address class="author">(Jürgen Engbring/tr)</address>

        <figure>
            <table class="plain">
                <tr>
                    <td colspan="2"><b>Routinen des Maschinenprogramms</b></td>
                </tr>
                <tr>
                    <td>$C000-C023</td>
                    <td>16-Bit-Multiplikation (Listing 2)</td>
                </tr>
                <tr>
                    <td>$C024-C067</td>
                    <td>Rechnung: 6000+3 (X+40 Y)→SP(16B)</td>
                </tr>
                <tr>
                    <td>$C068-C079</td>
                    <td>Rechnung: 4 S(16B)→SP1(16B)</td>
                </tr>
                <tr>
                    <td>$C080-C097</td>
                    <td>Rechnung: 4 M(16B)→SP1(16B)</td>
                </tr>
                <tr>
                    <td>$C098-C0A5</td>
                    <td>Inkrement X</td>
                    <td rowspan="4">Verändert SP(16B) entsprechend, so daß es dem Ergebnis der Routine $C024 entspricht.</td>
                </tr>
                <tr>
                    <td>$C0A6-C0B3</td>
                    <td>Inkrement Y</td>
                </tr>
                <tr>
                    <td>$C0B4-C0C1</td>
                    <td>Dekrement X</td>
                </tr>
                <tr>
                    <td>$C0C2-C0CF</td>
                    <td>Dekrement Y</td>
                </tr>
                <tr>
                    <td>$C0D0-C0DC</td>
                    <td>erhöht M, falls Zelle bei X,Y lebt</td>
                </tr>
                <tr>
                    <td>$C0DD-C104</td>
                    <td>relevanter Bereich, speichert Koordinaten</td>
                </tr>
                <tr>
                    <td>$C105-C15C</td>
                    <td>relevanter Bereich, geht neun Umgebungszellen durch, ruft $C0DD auf</td>
                </tr>
                <tr>
                    <td>$C15D-C2A4</td>
                    <td>nächste Generation, läuft zweimal durch alle Koordinaten des relevanten Bereichs</td>
                </tr>
                <tr>
                    <td>$C2A5-C332</td>
                    <td>Plot: setzt, löscht und prüft Punkte im 80 x 50-Bild</td>
                </tr>
                <tr>
                    <td>$C333-C3A6</td>
                    <td>Initialisierungsroutine</td>
                </tr>
                <tr>
                    <td>$C3A7-C3C4</td>
                    <td>Aufruf relevanter Bereich, setzt A%(X,Y)=1, trägt Koordinaten der Umgebungsfelder ein (SYS C3A7,X,Y)</td>
                </tr>
                <tr>
                    <td>$C3C5-C3F6</td>
                    <td>Aufruf Plot, SYS C3C5,X,Y,Z, löscht, setzt (Z30 = oder 1) oder kontrolliert (Z=2) Punkte</td>
                </tr>
                <tr>
                    <td>$C3F7-C3FC</td>
                    <td>Aufruf nächste Generation, ruft $C15D auf, setzt zwecks Beschleunigung Interrupt-Flag</td>
                </tr>
                <tr>
                    <td>$C3FD-C403</td>
                    <td>Aufruf maximale Geschwindigkeit, setzt I-Flag, ruft in Endlosschleife $C15D</td>
                </tr>
                <tr>
                    <td colspan="2"><b>Variablen des Maschinenprogramms</b></td>
                </tr>
                <tr>
                    <td>$C404-C413</td>
                    <td>Tabelle Binärzahlen→ASCII-Code (der Grafikzeichen für Plot)</td>
                </tr>
                <tr>
                    <td>$C414</td>
                    <td>Z (siehe $C3C5), enthält wegen logischen Verknüpfungen 00 für setzen und $0F für löschen</td>
                </tr>
                <tr>
                    <td>$C415</td>
                    <td>L gibt an, welches Bit des Grafikzeichens angesprochen wird</td>
                </tr>
                <tr>
                    <td>$C416</td>
                    <td>QQ liefert Ergebnis des Tests</td>
                </tr>
                <tr>
                    <td>$C417/8</td>
                    <td>X/Y</td>
                </tr>
                <tr>
                    <td>$C419/B</td>
                    <td>Zwischenspeicher1/2</td>
                </tr>
                <tr>
                    <td>$C41A</td>
                    <td>E gibt an, welcher A%() Speicherbedarf angesprochen wird</td>
                </tr>
                <tr>
                    <td>$C41C/D</td>
                    <td>M(16B)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zahl der Koordinaten be-</td>
                </tr>
                <tr>
                    <td>$C41E/F</td>
                    <td>S(16B)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ziehungsweise Schleifenindex</td>
                </tr>
                <tr>
                    <td>$C420</td>
                    <td>M Zahl der lebenden Zellen in jeweiliger Umgebung</td>
                </tr>
                <tr>
                    <td>$C421</td>
                    <td>J gibt an, welcher X%,Y% Speicherbetrieb angesprochen wird</td>
                </tr>
                <tr>
                    <td>$C422-C521</td>
                    <td>Tabelle ASCII-Code→Binärzahlen (wird erzeugt)</td>
                </tr>
                <tr>
                    <td>$57-5B</td>
                    <td>für 16-Bit-Multiplikation (5B)x(59/5A)=(57/58)</td>
                </tr>
                <tr>
                    <td>$57/58</td>
                    <td>SP(16B) (lokal)</td>
                </tr>
                <tr>
                    <td>$59/5A</td>
                    <td>SP1(16B) (lokal)</td>
                </tr>
            </table>
            <S(16B) bedeutet Speicher S mit der Länge von 16 Bit. X und Y haben nichts mit den Registern zu tun, die Namen der Variablen beziehen sich auf das Basic-Programm (Listing 1)

                <figcaption>Tabelle 1. Der Aufbau des Maschinenprogramms (Listing 2)</figcaption>
        </figure>
        <figure>
            <pre data-filename="life" data-name="Life (Basic-Teil)"></pre>
            <figcaption>Listing 1. Der Basic-Teil von »Life« ist am besten mit dem Checksummer einzugeben</figcaption>
        </figure>
        <figure>
            <pre data-filename="maschlife.prg" data-name="Life (Maschinensprache-Teil)" data-mse=mse1></pre>
            <figcaption>Listing 2. Benutzen Sie zur Eingabe des Maschinensprache-Teils von »Life« bitte den MSE</figcaption>
        </figure>
        <div class="binary_download" data-filename="maschlife.prg" data-name="Life (Maschinensprache-Teil)"></div>
    </article>
</body>

</html>