<!DOCTYPE html>
<html lang="de">

<head>
    <title>Tips &amp; Tricks für Anfänger und Fortgeschrittene</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Karsten Bluhm, Peter Ehlert, Anton Ernst, Sven Heemeyer, Jürgen Hüsgen, Frank Jahnke, Herbert Kunz, Andreas Meyer, Matthias Möller, Michael Patra, Gerhard Reul, Helmut Skolaut, Günther Stangl, Oliver Stengelin, Roland Wolff, Julian Ziersch, aw, tr">
    <meta name="64er.issue" content="1/86">
    <meta name="64er.pages" content="74-78,80-81">
    <meta name="64er.head1" content="Tips und Tricks">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="<b>Tips & Tricks</b>">
    <meta name="64er.toc_category" content="Listings zum Abtippen">
    <!-- <meta name="64er.toc_title" content="Primzahlen-Einzeiler"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Etiketten drucken mit dem MPS 801"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Verbessertes Print Using zu Simons Basic"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Hilfe für/gegen Turbo-Tape"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Hilfe für Datasettenbesitzer"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="INPUT ohne Fragezeichen"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Schachuhr"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Geräusche von A bis Z"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="POKE oder nicht POKE"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="?VERIFY ERROR"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="INT-Funktion fehlerhaft"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Software-Hex-Tastatur"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Die unmögliche Uhr"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Riesenbildschirm"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <!-- <meta name="64er.toc_title" content="Commander-Datasette streikt nie wieder"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Tips & Tricks"> -->
    <meta name="64er.id" content="tips_tricks">
</head>

<body>
    <article>
        <h1>Tips &amp; Tricks für Anfänger und Fortgeschrittene</h1>
        <p class="intro">Wiedereinmal können wir Ihnen eine Auswahl aus unserer Tips &amp; Tricks-Kiste anbieten. Für fast jeden Leser dürften einige interessante Programmiertricks dabei sein.</p>

        <h2>Primzahlen-Einzeiler</h2>

        <p>Bei folgendem Einzeiler handelt es sich um ein Programm zur Errechnung und Ausgabe aller Primzahlen bis 1000. Es benötigt hierfür zirka 27 Sekunden.<br>
            10DIMA(2000):FORI=2TO1000:IFA(I)=0THENPRINTI:FORJ=I+ITO1000STEPI:A(J)=1:NEXTJ,I:01100 NEXT</p>

        <p>Der Einzeiler ist zu lang, um mit ausgeschriebenen Basic-Befehlen eingegeben werden zu können. Man muß ihn also wie folgt eingeben:</p>

        <p>10DIMA(2000):F<u>O</u>I=2TO1000:IFA(I)=0T<u>H</u>?I:F<u>O</u>J=I+ITO1000STEPI:A(J)=1:N<u>E</u>J,I:01100 N<u>E</u></p>

        <p>Das Programm ist in dieser Form noch nicht lauffähig. Man muß erst noch einen Befehl im Direktmodus eingeben, nämlich: POKE2109,0</p>

        <p>Das Programm kann jetzt mit »RUN« gestartet und mit »SAVE« gespeichert werden. Es arbeitet nach dem »Sieb des Eratosthenes«, bei dem die Vielfachen einer Primzahl aus einer Liste gestrichen werden.</p>

        <p>Im Programm steht 01100. Die erste 0 wird durch den POKE-Befehl überschrieben, dadurch denkt der Computer, daß die Zeile nach dem NEXTJ,I zu Ende ist. Die 1100 sind Pseudo-Zeilennummer und Koppeladresse, dadurch springt der Computer, wenn die IF/THEN-Bedingung nicht erfüllt ist, nicht zur nächsten Zeile, sondern zum zweiten NEXT Sie können natürlich auch zwei oder drei Zeilen machen, um sich die Arbeit zu erleichtern.</p>

        <address class="author">(Michael Patra/tr)</address>

        <h2>Etiketten drucken mit dem MPS-801</h2>

        <p>Durch folgende Änderungen läßt sich das Programm »ETIKETTEN 64« im 4. Sonderheft, Seite 15, das in der Originalversion für einen Commodore-Drucker 1526 (MPS-802) geschrieben worden ist, auch miteinem MPS-801 (1525) betreiben. Das Problem bestand lediglich darin, den fest eingestellten Zeilenabstand des MPS-801 auf Null zu reduzieren, denn sonst hat der Ausdruck nicht viel Ähnlichkeit mit der erstellten Etikette auf dem Bildschirm.</p>

        <p>Zeile 6930 wird gelöscht<br>
            7040 IFA$&lt;>”-”THENPRINT#3,CHR$(15);A$;CHR$(8);:GOTO 7080<br>
            7050 PRINT#3,CHR$(14):<br>
            7060 J=J+1:A$=MID$(T$,J,1)<br>
            7070 PRINT#3,A$;CHR$(15)CHR$(8);</p>

        <p>Die eigentlichen Veränderungen stehen nur in den Zeilen 7040 und 7070.<br>
            CHR$(15): Einschalten Standardzeichen<br>
            CHR$(8) : Einschalten des Bit-Modus</p>

        <p>Der Trick besteht darin, daß, wenn sich der Drucker im Bit-Modus befindet, ein Zeilenvorschub dazu führt, daß die folgende Zeile ohne Zeilenabstand gedruckt wird und so der standardmäßige zirka 3-Pixelabstand entfällt. Dieses Prinzip ist allgemein anwendbar, zum Beispiel wenn man ein Bild der Grafik (mit Commodore-Grafikzeichen), so wie auf dem Bildschirm zu sehen, zu Papier bringen will. Die PRINT-AT-Zeilen für den Drucker müssen dann folgendes Format haben: 1000 print #lf,chr$(15);”&hellip;.”chr$(8) -lf=logische Filenummer des OPEN-Befehls.</p>

        <address class="author">(Karsten Bluhm/tr)</address>

        <h2>Verbessertes PRINT USING mit Simons Basic</h2>

        <p>Die USE-Routine in Simons Basic vermag Zahlen mit einer definierten Anzahl an Vor- und Nachkommastellen auszugeben. So gibt zum Beispiel die Festlegung »USE ” # # # #. # # # # #”, STR$(A)« die Zahl A, die in einen String umgewandelt wird, mit vier Stellen vor und fünf Stellen hinter dem Dezimalpunkt aus. Im allgemeinen ein sehr nützlicher Befehl, wenn nicht folgender Nachteil auftreten würde:</p>

        <p>Diese Förmatierungsroutine macht selbst vor Exponentialzahlen nicht Halt. So wird die Zahl 1.12345678E-05 mit der obigen Festlegung ausgegeben als ”1.12345”! Sämtliche Dezimalen nach der fünften Stelle werden mitsamt dem Exponenten abgeschnitten! Selbstder Exponent wird wie Dezimalziffern nach dem Komma behandelt; es wird nicht nur die Mantisse formatiert!</p>

        <p>Dieses Mißgeschick beseitigt die folgende Routine. Die zu formatierende Zahl wird als Variable A dem Unterprogramm übergeben. Das Unterprogramm ermittelt die Mantisse MA und den Zehnerexponenten EA der Zahl A.</p>

        <p>50000 PROC FORMAT<br>
            50010 REM ZU FORMATIERENDE ZAHL : A<br>
            50030 LA=LOG(ABS(A))/LOG(10) : REM ZEHNERLOGARITHMUS<br>
            50040 EA=INT((LA*10+.5)/10) : REM ZEHNEREXPONENT<br>
            50050 MA=A/10tEA:REMMANTISSE<br>
            50100 END PROC</p>

        <p>Aufgerufen wird die Routine mit »CALL FORMAT«. Die Mantisse MA und der Exponent EA können im Hauptprogramm an andere Variablen übergeben werden. Eine Möglichkeit wäre zum Beispiel bei vielen zu formatierenden Zahlen MA und EA in einem Feld (Matrix) zu speichern und nach Programmdurchlauf in einer Tabelle (mit Hilfe von USE) auszugeben.</p>

        <p>Der Exponent EA der Zahl A kann in die wissenschaftliche Notation gebracht werden, in dem man ihn in ein Vielfaches von 3 umwandelt. Entsprechend muß die Mantisse MA umgerechnet werden (Multiplikation mit 10 beziehungsweise 100).</p>

        <p>Dies geschieht wie folgt: Man dividiert EA durch 3 und erhält den Quotienten Q=EA/3. Der ganzzahlige Anteil (INT) mit 3 multipliziertergibtden neuen Exponenten: EA=INT(Q)*3; der rationale Anteil (FRAC) multipliziert mit 3 ergibt den Faktor für die Mantisse: F=FRAC(Q)*3: MA=MA*1EF.<br>
            Beispiel: EA=11, angestrebt: EA=-9.<br>
            Q=EA/3=-3.666666666,<br>
            EA=INT(Q)*3=-3*3=-9,<br>
            F=FRAC(Q)*3=.666666666*3 = 2,<br>
            MA=MA*1EF=MA*1E2 = MA*100.</p>

        <p>Um Rundungsfehler zu vermeiden, sollte man bei der Berechnung des Faktors F auf ganzzahlige Werte runden (INT oder eigene Rundungsroutine, siehe weiter unten). Die Mantisse muß immer mindestens drei Stellen vor dem Komma besitzen, ein Vorzeichen und zwei Ziffern!</p>

        <p>Um die Mantisse nicht einfach nach der kten Dezimalstelle abzuschneiden, sondern gerundet auszugeben, kann folgender Algorithmus verwendet werden: INT((MA*1EK+.5)/1EK).</p>

        <p>Liegt der Exponent EA als Vielfaches von 3 vor, so kann bei Meßergebnissen die Vorsilbe der Einheit (Kilo, Milli, Piko, etc.) ermittelt werden. Die entsprechende Vorsilbe kann dann als V$ der Maßeinheit (M$) vorangestellt werden (V$+M$). Die möglichen Vorsilben mit den dazugehörigen Zehnerexponenten sind:</p>

        <table class="plain">
            <tr>
                <td>Exa</td>
                <td>E</td>
                <td>10<sup>18</sup>,</td>
                <td>Atto</td>
                <td>a</td>
                <td>10<sup>-18</sup>,</td>
            </tr>
            <tr>
                <td>Peta</td>
                <td>P</td>
                <td>10<sup>15</sup>,</td>
                <td>Femto</td>
                <td>f</td>
                <td>10<sup>-15</sup>,</td>
            </tr>
            <tr>
                <td>Tera</td>
                <td>T</td>
                <td>10<sup>12</sup>,</td>
                <td>Pico</td>
                <td>p</td>
                <td>10<sup>-12</sup>,</td>
            </tr>
            <tr>
                <td>Giga</td>
                <td>G</td>
                <td>10<sup>9</sup>,</td>
                <td>Nano</td>
                <td>n</td>
                <td>10<sup>-9</sup>,</td>
            </tr>
            <tr>
                <td>Mega</td>
                <td>M</td>
                <td>10<sup>6</sup>,</td>
                <td>Mikro</td>
                <td>&mu;</td>
                <td>10<sup>-6</sup>,</td>
            </tr>
            <tr>
                <td>Kilo</td>
                <td>k</td>
                <td>10<sup>3</sup>,</td>
                <td>Milli</td>
                <td>m</td>
                <td>10<sup>-3</sup>,</td>
            </tr>
            <tr>
                <td>Hekto</td>
                <td>h</td>
                <td>10<sup>2</sup>,</td>
                <td>Zenti</td>
                <td>c</td>
                <td>10<sup>-2</sup>,</td>
            </tr>
            <tr>
                <td>Deka</td>
                <td>d</td>
                <td>10<sup>1</sup>,</td>
                <td>Dezi</td>
                <td>d</td>
                <td>10<sup>-1</sup>.</td>
            </tr>
        </table>

        <p>Wie man sieht, sind die Potenzen zu den Vorsilben Hekto, Deka, Zenti und Dezi keine Vielfachen von 3. Diese können mit Hilfe eines IF-THEN-Statements ausgesondert werden.<br>
            IF ABS(EA)>2THEN EXEC VORSILBE,<br>
            wobei durch »VORSILBE« ein Unterprogramm aufgerufen wird, welches die Vorsilben zu den Exponenten, die Vielfache von 3 sind, ermittelt. Statt »EXEC« ist natürlich auch ein Sprung zu einer Marke (PROC&hellip;) mittels »CALL« möglich.</p>

        <address class="author">(Roland Wolff/tr)</address>

        <h2>Hilfe für/gegen Turbo-Tape</h2>

        <p>Wenn sie mit Turbo-Tape geladen wurden, stürzen manche Programme, die den Speicher von 50000 bis 51000 benutzen, plötzlich ab. Das liegt daran, daß Turbo-Tape den Vektor zum Holen eines Befehls auf eine eigene Routine richtet. Wird nun diese Routine überschrieben, steigt der Computer wenn er den nächsten (Basic-)Befehl sucht, aus, da das Programm, auf das der Vektor $308 zeigt, nicht mehr existiert. Die Veränderung dieses Vektors ist von Basic aus nicht möglich, aber durch »SYS 58451« (Standard Basic Vektoren $0300 bis $030B laden) wird er wieder »geradegebogen«.</p>

        <address class="author">(Julian Ziersch/tr)</address>

        <aside>
            <h2>Hilfe für Datasettenbesitzer</h2>

            <p>Kürzere Maschinenprogramme werden vom Programmierer gerne im Kassettenpuffer abgelegt. Den Floppy-Besitzer stört dies nicht. Er kann Programme laden und das Maschinenprogramm bleibtihm erhalten. Nichtso beim Benutzer einer Datasette. Lädt er ein Programm von Kassette in den Bereich ab 828 ($033C), so wird es zerstört. Es gibt aber einen Trick, den Kassettenpuffer an einen anderen Speicherbereich zu legen. In den Speicherstellen 178 und 179 steht der Beginn des Kassettenpuffers. Normalerweise beginnt dieser bei 828. Durch Verändern dieses Vektors können wir den Kassettenpuffer beim Laden von Programmen schonen. Um ihn ans Ende des Speicherbereichs zu legen, schreiben Sie: POKE 179, PEEK (56)-2.</p>

            <address class="author">(Herbert Kunz/tr)</address>
        </aside>

        <h2>INPUT ohne Fragezeichen</h2>

        <p>Das manchmal lästige Fragezeichen beim Basic-Befehl »INPUT« kann man durch ein »POKE 19,1« verschwinden lassen. Allerdings sollte diese Manipulation sofort nach der INPUT-Anweisung durch »POKE 19,0« wieder rückgängig gemacht werden.</p>

        <address class="author">(Günther Stangl/tr)</address>

        <h2>Schachuhr</h2>

        <p>2 S=1—S:TI$=A$(S):FORI=1TO1:GETI:A$(S)=TI$:PRINT” {CLR,3SPACE}?”A$(1),„A$(0):IFA$(S) &lt; E$THENNEXT: GOTO2</p>

        <p>Nachdem ich für ein Schachuhrprogramm eine Bildschirmseite verbraucht hatte, beschloß ich, dreses Programm ordentlich zu kürzen. Schließlich wurde es dann zu dem vorliegenden Einzeiler, der aus Ihrem Computer eine richtige Schachuhr macht.<br>
            A$(0)=”000000”:A$(1)=”000000”:E$=”000020”: PRINT”{CLR}”:GOTO 2</p>

        <p>Zuerst müssen die Anfangszeiten der beiden Spieler definiert werden, die wohl jeweils Null sein dürften, wenn man nicht gerade gegen einen weitaus stärkeren Spieler spielt. (Jeweils A$(0) und A$C(1) im bekannten sechsstelligen Format der internen Uhr TI$). Danach definiert man die Endzeit E$ (wie oben), bei der das Programm stoppen soll und startet den Einzeiler nach einem SHIFT/CLR-HOME mit GOTO2 (nicht mit RUN, um die Stringvariablen nicht zu löschen).</p>

        <p>Auf Druck der Zahlen 1-9 läuft jeweils die Uhr des Gegenspielers weiter. Will man eine Pause machen, drückt man irgendeinen Buchstaben.</p>

        <p>Mit GOTO 2 kann das Programm dann fortgesetzt werden (ohne sich an dem »Syntax Error« zu stören), worauf die jeweils andere Uhr, als die, die vor Abbruch lief, weiterläuft.</p>

        <h3>Zur Erklärung des Einzeilers</h3>

        <p>S=1—S« ändert S jeweils von 0 auf 1 oder von 1 auf 0 (es läuft dann jeweils die Uhr von Spieler 1 oder 0). Nun wird die Uhr TI$ gestellt. Danach folgt eine For-Next-Schleife, die nur verlassen werden kann, wenn I eine der Zahlen von 1-9 annimmt, was nur bei Drücken irgendeinerZahl geschehen kann. Sonst ist I durch die »GETI«-Abfrage immer Null. In der Schleife wird die jeweilige Zeit der beiden Spieler ausgegeben. Außerdem wird untersucht, ob die Endzeit erreicht ist.</p>

        <address class="author">(Oliver Stengelin/tr)</address>

        <h2>Der Hypra-Listschutz</h2>

        <p>Ich habe schon öfters im Leserforum gelesen, daß bei Aktivierung des Befehls »POKE 808,225« ein verstümmeltes Listing erscheint. Ich habe da eine Lösung gefunden: Nach Eingabe der Zahlenkombination 35072120 ist das Listing wieder normal sichtbar. Unglaublich, aber wahr!</p>

        <p>Hier nun unsere Preisfrage an die Profis:<br>
            Was geschieht hier?</p>

        <p>Der erste Leser, der uns die richtige Lösung schickt, bekommt einen 64’er-Aufkleber!</p>

        <address class="author">(Helmut Skolaut/tr)</address>

        <h2>Maschinenprogramme kopieren</h2>

        <p>Wenn man nicht zu den glücklichen Besitzern eines Kopierprogramms gehört, kann man Maschinenprogramme mit Hilfe des MSE kopieren: M8E laden — M8E starten — Programm laden — andere Diskette/Kassette einlegen — Programm mit CTRL-S wieder speichern. Basic-Programme lassen sich mit dieser Methode übrigens genauso kopieren.</p>

        <address class="author">(tr)</address>

        <h2>Geräusche von A bis Z</h2>

        <p>Durch Veränderung der Filterfrequenz und durch verschiedene Filter lassen sich einfache Geräusche erzeugen.<br>
            Zeile 10 S=54272:Rem Basisregister<br>
            Zeile 20 FORL=OTO24:POKES+L,0:NEXT</p>

        <p>Zum Beispiel:<br>
            Um einen Schuß zu erzeugen, muß das Programm wie folgt aussehen:<br>
            10 S=54272<br>
            20 FORL=OTO24:POKE S + L,0: NEXT<br>
            30 POKE S + 0,0 : POKE S + 1,18<br>
            40 POKE S + 5,1 * 16 + 11<br>
            50 POKES + 22,110<br>
            60 POKE S + 23, 15 * 16 + 3<br>
            70 POKE S + 24, 5 * 16 + 15<br>
            80 POKE S + 4, 0 : POKE S + 4, 129<br>
            90 FORJ = 1 TO 255 : POKE S + 0,J : NEXT<br>
            100 FORA = 1 T 1000 : NEXT : GOTO 80</p>

        <figure>
            <table>
                <tr>
                    <td></td>
                    <td>Zeile 30</td>
                    <td>Zeile 40</td>
                    <td>Zeile 50</td>
                    <td>Zeile 60</td>
                    <td>Zeile 70</td>
                    <td>Zeile 80</td>
                    <td>Zeile 90</td>
                    <td>Zeile 100</td>
                </tr>
                <tr>
                    <td><b>Geräusch:</b></td>
                    <td>Frequenz</td>
                    <td>Hall</td>
                    <td>Grenzfre-<br>quenz</td>
                    <td>Resonanz</td>
                    <td>Pass</td>
                    <td>Wellenform</td>
                    <td>Schleife und<br>POKE</td>
                    <td>Warteschleife<br>und GOTO</td>
                </tr>
                <tr>
                    <td><b>Schuß</b></td>
                    <td>POKE S+0,0:<br>POKE S+1,18</td>
                    <td>POKE<br>S+5,1*16+<br>11</td>
                    <td>POKE<br>S+22,110</td>
                    <td>POKE<br>S+23,15*16<br>+3</td>
                    <td>POKE<br>S+24,5*16<br>+15</td>
                    <td>POKE S+4,0:<br>POKE<br>S+4,129</td>
                    <td>FORJ=1TO<br>255:<br>POKE S+0,J:<br>NEXT</td>
                    <td>FORA=1TO<br>1000:<br>NEXT:GOTO80</td>
                </tr>
                <tr>
                    <td><b>Explosion</b></td>
                    <td>POKE S+0,0:<br>POKE S+1,6</td>
                    <td>POKE<br>S+5,2*16+<br>13</td>
                    <td>POKE<br>S+22,100</td>
                    <td>POKE<br>S+23,15*16<br>+3</td>
                    <td>POKE<br>S+24,3*16<br>+15</td>
                    <td>POKE S+4,0:<br>POKE<br>S+4,129</td>
                    <td>FORJ=1TO<br>100:<br>POKE S+0,J:<br>NEXT</td>
                    <td>FORA=1TO<br>4000:<br>NEXT:GOTO80</td>
                </tr>
                <tr>
                    <td><b>Uhrenschlag</b></td>
                    <td>POKE S+0,0:<br>POKE S+1,6</td>
                    <td>POKE<br>S+5,1*16+<br>10</td>
                    <td>POKE<br>S+22,110</td>
                    <td>POKE<br>S+23,15*16<br>+3</td>
                    <td>POKE<br>S+24,1*16+<br>15</td>
                    <td>POKE S+4,0:<br>POKE S+4,17</td>
                    <td>FORJ=1TO<br>255:<br>POKE S+0,7:<br>NEXT</td>
                    <td>FORA=1TO<br>500:<br>NEXT:GOTO80</td>
                </tr>
                <tr>
                    <td><b>Brandung</b></td>
                    <td>POKE S+0,0:<br>POKE<br>S+1,40</td>
                    <td>POKE<br>S+5,10*16+<br>12</td>
                    <td>POKE<br>S+22,0</td>
                    <td>POKE<br>S+23,0</td>
                    <td>POKE<br>S+24,0*16<br>+15</td>
                    <td>POKE S+4,0:<br>POKE<br>S+4,129</td>
                    <td>FORJ=1TO<br>255:<br>POKE S+0,J:<br>NEXT</td>
                    <td>FORA=1TO<br>3500:<br>NEXT:GOTO80</td>
                </tr>
            </table>
        </figure>

        <address class="author">(Jürgen Hüsgen/tr)</address>

        <h2>POKE oder nicht POKE</h2>

        <p>Vielleicht ist manchen Computer-Fans, die öfters an unterschiedlichen C 64 arbeiten, schon folgendes aufgefallen: Bei einigen älteren Modellen bewirkt ein »POKE 1024,1« überhaupt nichts, bei den neueren hingegen erscheint in der oberen linken Bildschirmecke ein »A«. Warum erscheint bei den älteren Modellen das »A« nicht auf dem Bildschirm, obwohl doch alles korrekt gemacht wurde? Das liegt daran, daß das alte Betriebssystem des C 64 die Zeichen nicht in der Zeichen-, sondern in der Hintergrundfarbe in den Bildschirm schreibt Sie sind also zwar vorhanden, aber nicht sichtbar. Dies werden sie erst, wenn durch einen entsprechenden Eintrag in den Farbspeicher ab Adresse 55296 die Farbe des Zeichens extra gesetzt wird. In unserem Fall mit dem »POKE 1024,1« müßte also noch ein »POKE 55296,14« (für ein hellblaues »A«) folgen. Deswegen sollten auch Besitzer eines neueren C 64, die uns Listings schicken, diese Farb-POKEs hinzufügen. Die Programme könnten sonst auf den älteren Computern merkwürdige Bildschirmdarstellungen haben. Für Besitzer eines EPROM-Brenners, die sich ein neues Kernel brennen wollen, sei noch kurz angemerkt, wie das Kernel »richtig« lauten muß, um den Farb-POKE automatisch zu setzen:<br>
            alt: $E4DA LDA $D021 (=Zeichen in Hintergrundfarbe)<br>
            neu: $E4DA LDA $0286 (=Zeichen in Zeichenfarbe)</p>

        <address class="author">(Frank Jahnke/tr)</address>

        <h2>?VERIFY ERROR</h2>

        <p>Da hat man ein gutes Basic-Programm geschrieben, und dann tritt beim obligatorischen VERIFY dieser Fehler auf. Aber in welcher Programmzeile steckt der Fehler? Dieses Programm (Listing 1) gibt die fehlerhafte Zeilen-Nummer an. Beide Programme müssen auf einer Diskette sein.</p>

        <p>Folgende Fehleraussagen sind möglich:</p>

        <ol>
            <li>Ungleiche Zeilenlänge</li>
            <li>Zeichenfehler bei gleicher Zeilenlänge (oder ein Basic-Befehl ist anders)</li>
            <li>Ungleiche Zeilennummer</li>
            <li>Fehlen einer Zeile</li>
        </ol>


        <p>Bei Fehlen einer Zeile beziehungsweise ungleicher Zeilennummer wird der Vergleich mit der Aussage »Bitte überprüfen« abgebrochen.</p>

        <address class="author">(Gerhard Reul/tr)</address>

        <figure>
            <pre data-filename="vergl.von prg." data-name="Vergleichen von Programmen"></pre>
            <figcaption>Listing 1. »Vergleichen von Programmen«. Bitte benutzen Sie zur Eingabe den Checksummer.</figcaption>
        </figure>

        <h2>INT-Funktion fehlerhaft</h2>

        <p>Wie mir neulich auffiel, ist die »INT&lt;-Funktion beim C 64 keineswegs die definitionsgemäße Integer-Funktion, wie man aus der Abkürzung entnehmen könnte, sondern die Gaussklammerfunktion. Glücklicherweise ist die Funktion im Handbuch richtig erklärt, nur stimmt nicht, daß »negative Zahlen dem Betrag nach größer werden«, wenn man die Nachkommastellen abschneidet. Die im Betriebssystem definierte Funktion rundet alle Zahlen ab, anstatt die Nachkommastellen abzuschneiden. Das heißt: f(x) = [x] (Gaussklammer), und nicht: f(x) = [ixi] • sgn(x)(lnteger).AuslNT(—1.23)wirdnämlich—2 und nicht, wie es richtig heißen müßte, —1! Es ist also Vorsicht geboten bei Programmen oder Rechnungen, die die Integer-Funktion verlangen und bei denen x negativ ist. Bei kaufmännischen oder sonstigen Anwendungen des C 64, von denen nicht nur das Erfolgserlebnis des Programmierers abhängt, wäre es nötig, die Funktion im Programm neu zu definieren:</p>

        <p>DEF FN INT(x) = INT (ABS(x)) * SGN(x)</p>

        <address class="author">(Matthias Möller/tr)</address>

        <h2>Software-Hex-Tastatur</h2>

        <p>Das Programm (Listing 2) wird normal geladen und mit »RUN« gestartet. Es kopiert dann mit der schon im 64’er, Ausgabe 3/85, Seite 68 vorgestellten ROM-Routine das KernelROM in das darunterliegende RAM (Zeilen 30 bis 40) und verändert dort die Tastatur-Decodiertabellen (Zeilen 50 bis 70). Wenn sich der Computer wieder mit »READY.« meldet (nach zirka 0,5 Sekunden), lädt man wie gewohnt den MSE, gibt »POKE 2096,53« ein und startet ihn mit »RUN«. Durch die Änderung der Speicherstelle 2096 wird beim MSE-Start der Wert 53 in die Speicherstelle 1 der Zeropage geschrieben. Deshalb holt sich der Computer seine Informationen im Kernel-Bereich nicht mehr aus dem ROM, sondern aus dem RAM, wo die geänderte Tastaturdecodiertabelle steht. Die neue Tastenbelegung wird wie folgt aktiviert: Die normalen Funktionen bleiben bestehen, mit »Shift« ergeben sich aber folgende Umbelegungen:</p>

        <ul>
            <li>auf M bis / liegen 0 bis 3</li>
            <li>auf K bis ; liegen 4 bis 7</li>
            <li>auf I bis @ liegen 8 bis B</li>
            <li>auf 9 bis — liegen C bis F.</li>
        </ul>


        <p>Auch die Belegung der INST-DEL-Taste wurde verändert (Zeile 70): ohne Shift wird jetzt INST, mit Shift DEL ausgeführt. Es empfiehlt sich also, bei der Eingabe von MSE-Programmen die Shift-Lock-Taste zu drücken und dann mit den neuen Tasten zu arbeiten. Als Merkhilfe kann man seitlich auf die Tasten kleine Aufkleber mit der neuen Belegung kleben.</p>

        <address class="author">(Sven Heemeyer/Andreas Meyer/tr)</address>

        <figure>
            <pre data-filename="mse hex-tastatur" data-name="Hex-Tastatur"></pre>
            <figcaption>Listing 2. »Hex-Tastatur«.</figcaption>
        </figure>

        <h2>Die unmögliche Uhr</h2>

        <p>Dieses Programm stellt während des Editierens oder Ablaufs von Basic- oder Maschinenspracheprogrammen im unteren Rand des Bildschirms eine absolut genaue Uhr mit Stunden-, Minuten und Sekundenanzeige dar. Es verbraucht keinen Basic-Speicherplatz, da das Steuerprogramm von $C000 bis $C2D7 und die Spritedaten unter dem KernelROM liegen. Es verfügt über einen minutengenau einstellbaren Wecker. Zur Funktionsweise des Programmes:</p>

        <p>Der VIC II-Chip wird in der IRQ-Routine veranlaßt, an zwei Bildschirmstellen einen Interrupt auszulösen. Die erste dieser Stellen liegt am unteren Bildschirmrand. Hier wird durch Ändern der Speicherstelle 53265 der Bildschirm »verlängert«. Da die Uhr unabhängig von Programmen laufen soll, in denen auch Sprites vorkommen, werden die aktuellen Spritedaten gerettet und erst dann die Daten für die Uhr in die entsprechenden VIC-Register geschrieben. Zusätzlich wird die Bank-select-Speicherstelle 56576 »umgeschaltet«, um die Uhr-Sprite-Daten unter dem Kernel-ROM lesen zu können. Anschließend werden die Spritezeiger nach der exakten, weil durch Netzfrequenz getakteten Tageszeituhr des CIA 2-Chip korrigiert und bei Erreichen der Alarmzeit ein optisches und akustisches Signal ausgegeben.</p>

        <p>Die zweite Bildschirmstelle, an der ein Interrupt ausgelöst wird, liegt im unteren, nicht mehr sichtbaren Bildschirmbereich. Hier erhalten die VIC-Register und die Bank-select-Speicherstelle wieder ihre ursprünglichen Werte.<br>
            Nun zur Bedienung des Programms:</p>

        <p>Nachdem Sie das Listing 3, »BORDER-CLOCK«, das Sie mit dem MSE abgetippt und gespeichert, gestartet haben, erzeugt dieses erst das eigentliche Programm »UHR« auf der Diskette. Dies hat folgenden Grund: Das endgültige Programm »UHR« enthält die vollständigen Daten für die Sprite-Ziffern 0 bis 9 und den Doppelpunkt. Diese Daten werden in »BORDERCLOCK« erst aus den sieben Segmenten einer Digital-Uhr zusammengesetzt. Dies bewirkt, daß »BORDER-CLOCK« etwa 200 Byte kürzer ist als »UHR«. Nach dem Laden und Starten des »UHR«-Programms müssen Zeit und Weckzeit in TI$-Schreibweise (je zwei Stellen für Stunden, Minuten und Sekunden) eingegeben werden.</p>

        <p>Nach Drücken von RUN/STOP-RESTORE muß die Anzeige mit»SYS 49756« neu aktiviert werden, die Uhr läuft jedoch intern weiter. Vor der Arbeit mit Peripheriegeräten (Floppy, Drucker, etc.) muß die Anzeige ausgeschaltet werden. Dies kann durch die Tastenkombination CTRL-RESTORE erfolgen. Danach kann sie durch Commodore-Taste und RESTORE wieder eingeschaltet werden. Am Programm können Sie natürlich selbst einiges verändern.</p>

        <p>Die Sprite-Daten der Ziffern 0 bis 9 und des Doppelpunktes liegen von 3270 bis 3974. Die Farbe des Uhrenhintergrundes ist in 2974 enthalten, die Farben der einzelnen Sprites von 2980 bis einschließlich 2987. Es können auch einzelne Ziffern ausgeschaltet bleiben, und zwar durch POKE 2962, PEEK(2962)AND(255-2↑1), wobei I zwischen 0 und 7 die auszuschaltende Stelle angibt. Schließlich kann noch die Frequenz des Alarmgongs mittels POKE 3072,INT(F/256): POKE 3067,F-256*PEEK(3072) mit F als Frequenz geändert werden.</p>

        <address class="author">(Anton Ernst/tr)</address>

        <figure>
            <pre data-filename="b-clock-heft.prg" data-name="Unmögliche Uhr" data-mse=mse1></pre>
            <figcaption>Listing 3. Die »unmögliche Uhr« müssen Sie mit dem MSE eingeben.</figcaption>
        </figure>
        <div class="binary_download" data-filename="b-clock-heft.prg" data-name="Unmögliche Uhr (Heftversion)"></div>
        <div class="binary_download" data-filename="b-clock-fertig.prg" data-name="Unmögliche Uhr (fertige Version)"></div>


        <h2>Das 64’er EPROM-Programmiergerät</h2>

        <p>In der Testphase unseres Programmiergerätes haben sich zwei Veränderungen am Schaltplan des 64’er EPROM-Programmiergerätes ergeben (Ausgabe 12/85, Seite 47, Bild 5).</p>

        <ol>
            <li>Auf der PGM-Leitung muß ein 7404-Inverter zwischengeschaltet werden.</li>
            <li>Die vom 74LS139 (Pin 7) ausgehende Leitung muß zwischen dem Treiber und dem Invertierer abgezweigt und über eine Diode (1N4148) mit der Leitung zum Umschalter verbunden werden.</li>
        </ol>


        <address class="author">(aw)</address>

        <!-- TODO das ist ein Fehlerteufelchen!! -->

        <h2>EPROM-Trans</h2>

        <h3>Ausgabe 10/85, Seite 45, Bild 4</h3>

        <p>Bei der Zusatzplatine müssen die beiden ICs 74LS00 und 74LS04 vertauscht werden. Taster T1 und T2 müssen noch mit zwei Widerständen (1k5) bestückt werden (siehe Bild).</p>

        <figure>
            <img src="74-0.png" alt="">
        </figure>

        <!-- TODO das ist ein Fehlerteufelchen!! -->

        <h2>Der Riesen-Bildschirm</h2>

        <p>Dieses Hilfsprogramm (Listing 4) können Sie beim Schreiben eigener Programme verwenden, um Sprites auch über den oberen und unteren Rand hinaus zu bewegen. Das Programm kann von Basic oder Maschinensprache aus benutzt werden, da es im Kassettenpuffer von dezimal 828 bis 929 liegt und so den freien Speicherbereich nicht einschränkt. Die Funktionsweise des Programms:</p>

        <p>Der VIC II-Chip löst an drei Bildschirmstellen einen Interrupt aus. Die erste liegt am unteren Bildschirmrand, hier wird durch einen Programmiertrick der Bildschirm »verlängert«. Die zweite Stelle liegt sieben Rasterzeilen unterhalb der ersten. Hier wird durch Auswertung der Speicherstelle 931 entschieden, ob und welche Sprites im unteren Randbereich sichtbar sein sollen. Die dritte Stelle liegt im unteren, nicht mehr sichtbaren Bildbereich, wo abhängig vom Inhalt der Speicherstelle 930 Sprites vom Anfang des oberen bis zum Anfang des unteren Randbereichs sichtbar gemacht werden.<br>
            Zur Bedienung des Programms:</p>

        <p>Nach der Initialisierung mittels SYS 828 werden Sprites nicht mehr durch POKE 53269,X ein- oder ausgeschaltet, sondern durch POKE 930,X1 und POKE 931,X2. Das Bitmuster (!) von X1 gibt an, welche Sprites Y-Koordinaten von 0 bis 255 haben, X2 enthält das Bitmuster der Sprites mit Y-Koordinaten über 255. Ansonsten werden die Y-Koordinaten in den normalen Registern von 53249 bis 53263 eingetragen. Auf diese Weise sind Y-Koordinaten von 0 bis 511 möglich, wobei die Sichtbarkeit der Sprites je nach vorhandenem Monitor oder Fernsehgerät variiert.</p>

        <p>Normalerweise sind Sprites mit Y-Koordinaten von 290 gerade noch sichtbar.<br>
            Hierzu einige Beispiele:</p>

        <p>POKE 930,PEEK(930)OR2↑3:POKE 931,PEEK(931)AND(255-2↑3):<br>
            POKE 53249 + 2*3,5 — Sprite 4 hat die Y-Koordinate 5<br>
            POKE 930,PEEK(930)AND(255-2↑7):POKE 931 ,PEEK(931) OR 2↑7:<br>
            POKE 53249 + 7*2,7 — Sprite 8 hat die Y-Koordinate 262<br>
            POKE 930,PEEK(930)OR2↑O:POKE 931,PEEK(931)OR2↑O:<br>
            POKE 53249,3 — Sprite 1 hat die Y-Koordinaten 3 und 258, ist also zweimal auf dem Bildschirm sichtbar.</p>

        <p>So ist eine Darstellung von 16 Sprites möglich. Das Demoprogramm im Listing 5 bewegt ein Sprite über den erweiterten Bildschirm.<br>
            Noch ein Tip zur Verwendung dieses Utilitys:</p>

        <p>Beim Einbau in eigene Programme sollten Sie darauf achten, daß die letzte vom VIC ll-Chip addressierbare Speicherstelle, also im Normalfall 16383, den Wert 0 besitzt, da sonst schwarze Streifen Ihren Bildrand verunstalten.</p>

        <address class="author">(Anton Ernst/tr)</address>

        <figure>
            <pre data-filename="screenenlarger.prg" data-name="Riesen-Bildschirm" data-mse=mse1></pre>
            <figcaption>Listing 4. Der »Riesen-Bildschirm«</figcaption>
        </figure>
        <div class="binary_download" data-filename="screenenlarger.prg" data-name="Riesen-Bildschirm"></div>
        <figure>
            <pre data-filename="demo enlarger" data-name="Demo Enlarger"></pre>
            <figcaption>Listing 5. »Demo Enlarger«. Bitte verwenden Sie zur Eingabe den Checksummer.</figcaption>
        </figure>

        <h2>Die Commander-Datasette streikt nie wieder</h2>

        <p>Der Artikel über die Datasettenverbesserung hat bei mir und auch bekannten Computer-Fans Anklang gefunden. Leider mußte ich bald darauf feststellen, daß die Einbauanleitung des Komperators nur für die neue Datasette ausgelegt war. Ein Computerkollege, der leider nur eine Datasette des Typs »Commander — Computer Datasette Model NO: PM-4401C« hat, und den Komperator einbauen wollte, stieß dabei auf diese Schwierigkeiten und bat mich als Elektroniker um Abhilfe. Nach detaillierten Messungen mit dem Oszilloskop fand ich dabei die Anschlüsse heraus und baute den Komperator in seiner Datasette ein. Um auch anderen Computerfans die Möglichkeit zu geben, sich die Schaltung in ihre Commander-Datasette einzubauen, zeigen die beiden Pfeile in Bild 1 den Anschluß an die Platine.</p>

        <address class="author">(Peter Ehlert/tr)</address>

        <figure>
            <img src="74-1.png" alt="">
            <figcaption>Bild 1. So schließt man den »Komperator« an die Commander-Datasette an.</figcaption>
        </figure>

    </article>
</body>

</html>