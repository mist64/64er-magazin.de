<!DOCTYPE html>
<html lang="de">

<head>
    <title>Ascompiler 64</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Stephan Bartosch, ev">
    <meta name="64er.issue" content="1/86">
    <meta name="64er.pages" content="50,58-64">
    <meta name="64er.head1" content="Listing des Monats">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="<b>Listing des Monats: Ascompiler 64</b>">
    <meta name="64er.toc_category" content="Wettbewerbe">
    <!-- <meta name="64er.toc_title" content="<b>Superschneller Tiny-Basic-Compiler</b>"> -->
    <!-- <meta name="64er.toc_category" content="Listings zum Abtippen|Listing des Monats"> -->
    <meta name="64er.index_title" content="Ascompiler 64">
    <meta name="64er.index_category" content="Listings zum Abtippen|Sprachen">
    <meta name="64er.id" content="ascompiler64">
</head>

<body>
    <article>
        <h1>Ascompiler 64</h1>
        <p class="intro">Ascompiler 64 ist ein sehr schneller Compiler. Es ist das ideale Werkzeug für alle C 64-Besitzer, denen Basic zu langsam und Maschinensprache zu kompliziert ist.</p>

        <p>Die Bezeichnung für diesen Compiler ist eine Wortbildung aus Assembler und Compiler. Ascompiler 64 ist keiner der bekannten Compiler, mit dem Sie Ihre Basic-Programme praktisch unverändert übersetzen können und dadurch etwa die dreifache Geschwindigkeit erreichen. Nein, der Ascompiler 64 ist gleichzeitig mehr und weniger: Er übersetzt nur einen sehr stark eingeschränkten Basic-Befehlssatz mit recht vielen Restriktionen, aber er übersetzt dafür in einen derart effizienten Code, daß praktisch kaum noch ein Unterschied zu Assembler besteht. Da Ascompiler 64 wirklich reinen Maschinencode erzeugt, ist er hervorragend dazu geeignet, zeitkritische Routinen zu compilieren, um sie dann in andere Basic-Programme einzusetzen. Ein kleines Beispiel soll die Leistungsfähigkeit dieses Compilers zeigen. Geben Sie doch einmal die folgenden Basic-Zeilen in Ihren Computer ein:</p>

<pre><code>10 let a=0
20 let a=a+1
30 if a&lt; 60000 then 20
40 print"fertig"</code></pre>

        <p>Schauen Sie jetzt auf Ihre Uhr und tippen Sie »RUN«. Es passiert zunächst sehr lange Zeit gar nichts &hellip; die Minuten ziehen sich dahin &hellip; dann endlich, nach ungefähr elf Minuten kommt die Meldung »Fertig«.</p>

        <p>Was schätzen Sie, wie lange braucht das gleiche Programm nach der (blitzschnellen) Übersetzung? Eine Minute, eine halbe Minute, etwa nur 10 Sekunden? Weit gefehlt, dieses Programm läuft in compilierter Form in knapp drei Sekunden ab! Das bedeutet eine Geschwindigkeitserhöhung um den Faktor 200, vergleichbar mit der Programmierung in Assembler.</p>

        <p>Diese auch für einen Compiler enorme Geschwindigkeit konnte nur durch eine sehr stark optimierende Übersetzung erreicht werden. Der Compiler kennt daher leider recht viele Einschränkungen: Als Variable sind nur »A« bis »Z« erlaubt, sämtliche Rechenoperationen sind in 16-Bit-Arithmetik ausgeführt, Fließkommarechnungen und mathematische Funktionen wie SIN, COS, SQR etc. sind unmöglich. Weiter können Operationen nicht geschachtelt werden, Klammerrechnung ist nicht möglich.</p>

        <p>Folgende Basic-Befehle können bearbeitet werden: REM, CLR, END, GOTO, GOSUB, RETURN, SYS, LET (muß verwendet werden!), PRINT, POKE, PEEK, IF&hellip;THEN und STOP.</p>

        <p>Ascompiler 64 ist nicht zur Übersetzung normaler Basic-Programme geeignet. Vielmehr ist Ascompiler 64 der ideale Ersatz zur Programmierung in Maschinensprache. Die übersetzten Programme können in beliebige Speicherbereiche gelegt und mit SYS aufgerufen werden. Insbesondere schnelle Spielprogramme lassen sich mit dem Ascompiler 64 sehr bequem schreiben.</p>

        <p>Der Ascompiler 64 ist keine Eintagsfliege — wir werden laufend neue Programme, Tips &amp; Tricks und Erweiterungen dafür vorstellen, sofern Sie, unsere Leser, uns bei diesem Projekt unterstützen.</p>

        <p>Also frisch ans Werk! Tippen Sie den Ascompiler 64 ab und schreiben Sie anschließend die schnellsten Basic-Programme Ihres Lebens!</p>

        <address class="author">(ev)</address>

        <aside>
            <h2>Gesucht: Die besten Programme für den Ascompiler 64</h2>

            <p>Der Ascompiler 64 ist ideal für eine Vielzahl von zeitkritischen Anwendungen. Grafik, Dienstprogramme, vor allem aber auch komplette Action-Spiele sind seine Domäne. Hier ist die Chance für alle Basic-Programmierer: Wir suchen die interessantesten Programme und Routinen, die mit dem Ascompiler 64 entwickelt wurden.</p>

            <p>Eingeschickt werden kann jede Art von Programmen, egal ob kurz oder lang. Einzige Bedingung: Das Programm muß vollständig im Ascompiler-Format geschrieben sein, Mischprogramme aus normalem und compiliertem Basic sind nicht erlaubt.</p>

            <p>Damit es auch richtig interessant wird, erhalten die besten Einsendungen das Prädikat »64’er Top-Listing« und eine Top-Prämie von 300, 500 oder gar 1000 Mark, je nach Qualität und Länge. Alle Programme für den Ascompiler 64, die bis zum 1.2.1986 bei uns eingehen, nehmen an diesem Wettbewerb teil. Aber auch wenn Sie nicht unter den Gewinnern der Top-Prämie sein sollten, die Teilnahme lohnt sich trotzdem. Denn selbstverständlich hat jedes Ascompiler-Listing nicht nur die Chance, auch außerhalb des Wettbewerbs für ein vernünftiges Honorar abgedruckt zu werden, sondern nimmt automatisch auch an unserem Wettbewerb zum »Listing des Monats« teil.</p>

            <p>Schicken Sie Ihre Programme auf Diskette oder Kassette (nur das Basic-Programm, compilieren tun wir’s selber) mit einer ausreichenden Beschreibung an:<br>
                Markt &amp; Technik Verlag AG<br>
                Redaktion 64’er<br>
                Stichwort: Ascompiler-Wettbewerb<br>
                Hans-Pinsel-Str. 2<br>
                8013 Haar bei München</p>
        </aside>

        <aside>
            <h2>Der Autor des »Ascompiler 64« stellt sich vor:</h2>

            <img src="50-0.png" alt="" class="inline">

            <p>Ich bin 18 Jahre alt und besuche zur Zeit die 12. Klasse des Gymnasiums Gernsheim.</p>

            <p>Meine ersten Erfahrungen mit dem Computer machte ich im Informatikunterricht der Mittelstufe. Bald darauf kaufte ich mir einen VC 20, um später dann auf den C 64 umzusteigen.</p>

            <p>Der Ascompiler 64 entstand aus der Idee heraus, Routinen, die in Assembler zu kompliziert und in Basic zu langsam sind, in einfachem Basic schreiben zu können, die Programme anschließend zu compilieren und die nun sehr viel schnelleren Programme in andere Basic-Programme einzubauen. Daher habe ich großen Wert darauf gelegt, daß der vom Compiler erzeugte Code extrem kurz und schnell ist, so daß der Ascompiler 64 ein ideales Hilfsmittel für den Basic-Programmierer darstellt, der sich nicht unbedingt mit Maschinensprache herumschlagen will.</p>

            <address class="author">(Stephan Bartosch)</address>
        </aside>

        <p class="intro">Ascompiler 64 ist ein kurzer und schnell arbeitender 3-Pass<sup>Compiler</sup>, der ein vereinfachtes, sogenanntes »Tiny Basic« in reinen Maschinencode übersetzen kann. Dadurch lassen sich zeitkritische Routinen in Basic-Programmen, ohne Kenntnis von Assembler, erheblich beschleunigen.</p>

        <p>Aus einem Quellprogramm, das unter Beachtung des eingeschränkten Befehlssatzes und der teilweise vereinfachten Befehlssyntax geschrieben ist, wird in Sekundenschnelle ein sehr effizienter Maschinencode erzeugt. Die Länge des erzeugten Codes entspricht in der Regel ungefähr der Länge des ursprünglichen Basic-Programms. Die Startadresse des Maschinenprogramms ist frei wählbar, die Ausführungsgeschwindigkeit liegt je nach konkretem Programm bis zu 200mal höher als beim Basic-Text. Im Durchschnitt laufen die mit dem Ascompiler 64 übersetzten Programme etwa 50- bis 120mal so schnell wie im normalen Basic. Dafür muß allerdings ein beschränkter Befehlssatz in Kauf genommen werden.</p>

        <p>Der Ascompiler 64 belegt im Speicher den Bereich von $C000 bis $D000 und $E000 bis $F000; dazu kommen noch die Bereiche $A000 bis $B000 und $F000 bis $FFFF für Tabellen, die während des Compilierens angelegt werden. Die Compilierung eines Programms erfolgt direkt im Speicher und ist daher sehr schnell. Während Übersetzungszeiten von mehreren Stunden bei »großen« Basic-Compilern für den C 64 nicht ungewöhnlich sind, erfolgt die Übersetzung beim Ascompiler 64 bei kleineren Programmen (bis zu hundert Zeilen etwa) ohne merklichen Zeitverlust, bei längeren Programmen können es dann schon ein paar Sekunden werden.</p>

        <p>Ein besonderer Vorteil dieses Compilers liegt in der Tatsache, daß die erzeugten Programme ganz einfach mit SYS aufgerufen werden können und nicht an bestimmte Speicheradressen gebunden sind. Es ist sogar möglich, bereits übersetzte Programmteile von einem weiteren Tiny-Basic-Programm aus per SYS aufzurufen. Da die Adressen der 26 möglichen Variablen (»A« bis »Z«) im Speicher festliegen (A: 828/ 829, B: 830/831,&hellip;Z: 878/879), ist es sogar möglich, Parameter von einem solchen Tiny-Basic-Programm an ein anderes zu übergeben.</p>

        <p>Mit dem Ascompiler 64 ist es auch dem in der Maschinensprache nicht so bewanderten Basic-Programmierer endlich möglich, zeitkritische Unterroutinen ohne Problem schreiben zu können, um sie dann per SYS-Befehl vom eigentlichen Basic-Programm aus aufzurufen.</p>

        <p>Wegen des Fehlens aller Fließkomma- und String-Operationen und wegen des insgesamt doch recht eingeschränkten Befehlssatzes ist der Ascompiler 64 nicht für größere Anwenderprogramme wie Dateiverwaltungen etc. gedacht. Ideale Anwendungen dürften Grafik-Unterroutinen für hochauflösende Grafik und natürlich Action-Spiele aller Art sein — kurz, alle Programme, die im Wesentlichen aus PEEKs und POKEs und SYS-Aufrufen bestehen, sind für die Übersetzung mit dem Ascompiler 64 geradezu prädestiniert.</p>

        <h2>Der Umgang mit dem Compiler</h2>

        <p>Zunächst muß der Compiler natürlich in den Computer, was bei der allerersten Eingabe entweder durch Laden von der 64’er Leserservice-Diskette (geringster Aufwand) oder durch Eintippen von Listing 1 mittels MSE-Programm (geringste Kosten) möglich ist. Haben Sie sich für die zweite Methode entschieden, dann lesen Sie bitte zunächst die Eingabehinweise auf Seite 54, ehe Sie sich an die Arbeit machen.</p>

        <p>Die in Listing 1 abgedruckte Version des Ascompilers liegt nicht im Original-Adreßbereich, sondern ist mit einem Basic-Header und einer nach »RUN« automatisch anlaufenden Verschieberoutine versehen. Wenn Sie das gesamte Listing mittels MSE richtig abgetippt und gespeichert haben, können Sie den Ascompiler 64 ganz einfach mit »LOAD« wie ein normales Basic-Programm laden. Nach »LIST« erscheint die Header-Zeile »10 SYS 2077 ASCOMPILER 64«.</p>

        <p>Initialisiert wird der Ascompiler 64 mit »RUN«. Lassen Sie sich nicht irritieren, wenn danach der Bildschirm gelöscht wird und die READY-Meldung kommt. Der Ascompiler 64 befindet sich jetzt an der richtigen Adresse im Speicher und kann jederzeit mittels »SYS 49152« aktiviert werden. Das allerdings sollten Sie nur tun, wenn Sie ein entsprechendes Tiny-Basic-Programm im Speicher stehen haben.</p>

        <p>Als ersten Test könnten Sie eingeben:</p>

<pre><code>10 LET A=0
20 LET A=A+1
30 IF A&lt; 60000 THEN 20
40 PRINT A</code></pre>

        <p>Lassen Sie dieses Programm einmal im normalen Basic laufen, um sich von der Richtigkeit zu überzeugen. Wenn Sie keine elf Minuten warten wollen, brechen Sie es einfach nach einer gewissen Zeit mit der STOP-Taste ab.</p>

        <p>Rufen Sie jetzt den Compiler mit »SYS 49152« auf. Es erscheint eine Einschalt-Meldung des Compilers und die Abfrage auf die Startadresse des Maschinenprogramms, die hexadezimal angegeben werden muß. Wird ein unzulässiger Speicherbereich angegeben (zulässig ist alles vom Ende des Basic-Programms bis zum Ende des Basic-Speichers), so wird »NO MEMORY« ausgegeben und der Compilationsvorgang abgebrochen. Wird keine Adresse angegeben, dann wird das erzeugte Programm direkt hinter das Basic-Quellprogramm compiliert.</p>

        <p>Ascompiler 64 ist ein Drei-Pass-Compiler, das heißt der Compiler führt intern drei verschiedene Durchläufe aus: □ lm ersten Durchgang (Pass 1) wird der Basic-Quelltext Befehl für Befehl direkt in Maschinencode umgesetzt. Dabei werden Texte aus PRINT-Anweisungen zunächst in einer vom Compiler angelegten Tabelle abgespeichert, von wo aus sie später an das fertige Compilat (das übersetzte Programm) angehängt werden. Außerdem legt der Compiler während dieses ersten Durchlaufs eine Tabelle der Zeilennummern und dazugehörigen effektiven Adressen an.</p>

        <ul>
            <li>In Pass 2 werden die Sprungadressen (GOTO, GOSUB und IF&hellip;THEN) im erzeugten Maschinenprogramm angepaßt, wobei auf die in Pass 1 erzeugte Zeilennummern-Tabelle zurückgegriffen wird.</li>
            <li>Im dritten Durchgang schließlich wird die in Pass 1 erzeugte Tabelle der PRINT-Texte an das Ende des compilierten Programms verschoben und die entsprechenden Zeiger innerhalb des Programms angepaßt.</li>
        </ul>


        <p>Die Anfangs- und Endadresse des so erzeugten kompakten Maschinenprogramms wird nun vom Compiler in hexadezimaler Form ausgegeben und es erfolgt automatisch eine Rückkehr ins Basic. Das compilierte Programm kann nun mit SYS (Anfangsadresse) gestartet werden oder auch mit Hilfe eines Maschinensprache-Monitors abgespeichert werden. Natürlich muß zum Aufruf mit SYS die hexadezimal angegebene Startadresse in dezimale Form umgerechnet werden. Empfehlenswert ist daher die Wahl von »runden« hexadezimalen Startadressen: $1OOO entspricht beispielsweise dezimal 4096 und ein Maschinenprogramm mit Startadresse $4000 kann mit »SYS 4*4096« gestartet werden. Zum Speichern ohne Monitor muß man zunächst die Anfangs- und die Endadresse in High- und Low-Byte aufteilen und diese dann als Dezimalwerte notieren. Mit der Befehlsfolge »POKE 43, (Start Low): POKE 44, (Start High) : POKE 45, (Ende Low) : POKE 46, (Ende High): SAVE "Name",8« kann das Maschinenprogramm auf Diskette gespeichert werden. Geladen wird es mit »LOAD"Name",8,1«. Datasettenbesitzer müssen die Geräteadresse 8 durch 1 ersetzen. Um weiter in Basic arbeiten zu können, muß der Befehl »NEW« sowohl nach dem Laden als auch nach dem Speichern gegeben werden, um die »verbogenen« Zeropage-Zeiger wieder zurechtzubiegen.</p>

        <p>Ein zugegebenermaßen etwas umständliches Verfahren, aber das magere Commodore-Basic kann es nicht besser.</p>

        <p>Eleganter geht es ohne Zweifel mit einem Maschinensprachemonitor, den aber wohl nicht jeder C 64-Besitzer zur Verfügung hat. In der nächsten Ausgabe bringen wir daher einen kleinen Mini-Monitor. Er ist natürlich in Tiny Basic geschrieben und mit dem Ascompiler 64 zu übersetzen. Damit wird es dann möglich sein, Maschinenprogramme mit einfachen Befehlen zu laden und zu speichern.</p>

        <h2>Tiny Basic und Commodore Basic</h2>

        <p>Programme, die vom Ascompiler übersetzt werden sollen, unterliegen gegenüber dem gewohnten Basic des C 64 einer Reihe von Einschränkungen:</p>

        <ul>
            <li>Pro Zeile darf nur ein einziger Befehl benutzt werden</li>
            <li>Zulässige Befehle sind LET, REM, CLR, END, GOTO, GOSUB, RETURN, SYS, PRINT, POKE, IF&hellip;THEN, STOP</li>
            <li>Der LET-Befehl ist nicht optional, sondern muß bei jeder Wertzuweisung an eine Variable ausgeschrieben werden</li>
            <li>In einem LET-Befehl darf nur eine Rechenoperation vorkommen. Kettenrechnungen oder Klammern sind nicht möglich. Beispielsweise muß die Zeile »10 LET A=4*X+1« ersetzt werden durch »10 LET A=4*X« und »11 LET A=A+1«</li>
            <li>In allen anderen Befehlen dürfen keine Rechenoperationen vorkommen. Es sind nur Variable oder positive Zahlen erlaubt.</li>
            <li>Erlaubte Rechenoperationen sind »+«, »-«, »*«, »/«, »AND« und »OR«</li>
            <li>Erlaubte Variablennamen sind nur die Buchstaben »A« bis »Z«. Alle Variablen sind ganzzahlig (16 Bit)</li>
            <li>Als Funktionen sind nur PEEK und RND vorhanden. Bei der RND-Funktion muß als Argument immer 255 angegeben werden. Es werden Zufallszahlen zwischen 0 und 255 geliefert. Beide Funktionen dürfen nicht in Rechnungen vorkommen. Beispiel: In »10 LETR=PEEK(X) + 1«wird das »+1«vom Compiler ignoriert</li>
            <li>Hinter PRINT darf entweder ein Variablenname oder ein beliebiger Text in Anführungszeichen folgen. Rechnungen, Funktionen und Konstanten sind nicht zulässig</li>
            <li>In der IF-Anweisung sind die Vergleichsoperatoren »=«, » &lt; « oder» > « zulässig. Der erste Vergleichsoperand muß eine Variable sein, die entweder mit einer anderen Variablen oder mit einem Zahlenwert verglichen werden kann</li>
            <li>Hinter THEN darf nur eine Zeilennummer folgen, weitere Befehle sind unzulässig<br>
                Der Ascompiler 64 kennt fünf Fehlermeldungen:</li>
            <li>NO-COMPILE ERROR: Ein Befehl konnte nicht übersetzt werden (tritt beispielsweise bei einem vergessenen LET auf) - SPRUNG NACH UNDEF. ZEILE: Ein GOTO oder GOSUB zeigt auf eine nicht vorhandene Zeilennummer</li>
            <li>UNZUL. VARIABLE: Es wurde eine unzulässige Variable verwendet (der Compiler faßt auch Funktionen wie SIN etc. als unzulässige Variablen auf)</li>
            <li>SYNTAX ERROR: Allgemeiner Fehler im Aufbau einer Zeile — NO-MEMORY ERROR: Der für Basic-Programme zulässige Speicherbereich wurde infolge einer falschen Speicherbereichsangabe überschritten.</li>
        </ul>


        <p>Soviel zur Programmierung und Übersetzung von Tiny-Basic-Programmen für den Ascompiler 64.</p>

        <p>Um Sie nach soviel Theorie noch ein bißchen auf den Geschmack am Ascompiler 64 zu bringen, zum Schluß noch ein paar Demo-Listings:</p>

        <p>Listing 2 ist ein Beispiel für die Programmierung hochauflösender Grafik. Es handelt sich um einen einfachen Funktionenplotter für die hochauflösende Grafik. Die zu plottende Funktion wird in den Zeile 63000 bis 63020 definiert und in den für hochauflösende Grafik am C 64 zulässigen Wertebereich gebracht. Das Programm löscht zunächst das FarbRAM, anschließend der HiRes Bit-Map. Wenn Sie viel Zeit haben, können Sie das Programm ja mal im normalen Basic in uncompilierter Form laufen lassen. In compilierter Form braucht es jedenfalls nur wenige Augenblicke &hellip;</p>

        <p>Ein weiteres eindrucksvolles Beispiel für die Geschwindigkeit des erzeugten Compilats ist in Listing 3 abgedruckt. Es handelt sich um eine Routine, die genau abgestimmt dann die Bildschirmfarben wechselt, wenn der Elektronenstrahl eine bestimmte Stelle am Bildschirm erreicht hat. Der Effekt: Der Bildschirm erscheint horizontal in zwei Farben geteilt.</p>

        <p>Listing 4 schließlich stellt drei beim Ascompiler leider nicht vorhandene wichtige Funktionen in Form von kurzen Unterprogrammen zur Verfügung:</p>

        <ul>
            <li>GET Z (Aufruf mit GOSUB 10): Speichert den ASCII-Code der gerade gedrückten Taste in der Variablen Z. Wurde keine Taste gedrückt, enthält Z den Wert Null. Die Routine arbeitet über eine Abfrage des Tastaturpuffers</li>
            <li>PRINT CHR$(Z) (Aufruf mit GOSUB 20): Gibt das ASCII-Zeichen, das dem Wert von Z entspricht, auf dem Bildschirm aus. Diese Routine arbeitet mit einem speziellen Trick: Der Befehl »POKE 2,Z« in Zeile 20 wird vom Compiler nämlich übersetzt in die Befehlsfolge »LDA Z, STA 2«. Der Akku enthält also nach diesem Befehl noch das Low-Byte von Z, das durch Aufruf der Kernel-Routine BSOUT auf den Bildschirm kommt.</li>
            <li>INPUT(Z) (Aufruf mit GOSUB 30): Liest eine ganze Zeile von der Tastatur und legt sie in einem reservierten Speicherbereich ab. Die Anfangsadresse der Zeile wird in der Variablen Z an das aufrufende Programm zurückgegeben. Das Ende der Zeile ist durch ein Null-Byte markiert.</li>
        </ul>


        <p>Damit sind zugleich einige Beispiele gegeben, wie man durch geschickte Ausnutzung von geeigneten Systemadressen auch eigentlich nicht vorgesehene Fähigkeiten wie eine einigermaßen komfortable Tastaturabfrage erreichen kann.</p>

        <p>Zugegeben, die Programmierung für den Ascompiler 64 ist gewöhnungsbedürftig und im Vergleich zum normalen Basic umständlich und wenig komfortabel. Im Vergleich zur Programmierung in Assembler, die von der erreichbaren Geschwindigkeit her die einzige Alternative wäre, ist der Ascompiler 64 jedoch der reinste Luxus. Es liegt nur noch an Ihnen, ob Sie die dadurch gegebenen Möglichkeiten nutzen wollen. Sie haben jetzt auf jeden Fall ein System an der Hand, mit dem schnelle Action-Spiele und andere ehedem typische Assembler-Anwendungen in Basic programmiert werden können.</p>

        <address class="author">(Stephan Bartosch/ev)</address>

        <figure>
            <pre data-filename="ascompiler.prg" data-name="Ascompiler 64" data-mse=mse1></pre>
            <figcaption>Listing 1. »Ascompiler 64«. Bitte mit dem MSE eingeben.</figcaption>
        </figure>
        <div class="binary_download" data-filename="ascompiler.prg" data-name="Ascompiler 64"></div>
    </article>
</body>

</html>