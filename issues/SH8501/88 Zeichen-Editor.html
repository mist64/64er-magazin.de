<!DOCTYPE html>
<html lang="de">

<head>
    <title>Zeichen-Editor</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Volker Bühn, gk">
    <meta name="64er.issue" content="Sonderheft 1/85">
    <meta name="64er.pages" content="88-91">
    <meta name="64er.head1" content="Zeichen-Editor">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="Zeichen-Editor (C 64)">
    <meta name="64er.toc_category" content="">
    <meta name="64er.index_category" content="Listings zum Abtippen|Grafik">
    <meta name="64er.id" content="zeicheneditor">
</head>

<body>
    <article>
        <h1>Zeichen-Editor</h1>

        <p class="intro">Bei vielen Anwendungen ist es sinnvoll mit zwei verschiedenen Zeichensätzen zu arbeiten. Dieses Programm ermöglicht Ihnen, einen eigenen Zeichensatz zu erstellen, ohne den Original-Zeichensatz zu zerstören.</p>

        <p>Programmiert man ein Videospiel, ein Textverarbeitungsprogramm oder will man einfach nur die üblichen Bildschirmzeichen etwas interessanter gestalten, bleibt einem nichts anderes übrig, als den normalen Zeichensatz aus dem ROM herauszuholen, ins RAM zu kopieren und dann in diesem kopierten Zeichensatz »herumzuPOKEn«.</p>

        <p>Diese Tätigkeit ist aber — ähnlich wie bei der Konstruktion von Sprites — immer wieder eine mühsame Rechnerei. Deshalb habe ich mit einen komfortablen Zeichen-Editor zusammengestellt, der jede Rechnerei abnimmt. Mit seiner Hilfe ist das Definieren eigener Grafik-Zeichen ein Kinderspiel.</p>

        <p>Nach dem Eintippen (und Abspeichern!) läßt man das Programm mit RUN starten. Nach einer kurzen Wartezeit, während der Großbuchstaben-Zeichensatz aus dem ROM ins RAM kopiert wird (und zwar in die Speicherzellen 51200 bis 53248, der Bildschirm beginnt dann bei Adresse 50176), erscheint das Menü mit einem Zeichenfeld links unten. (Wen es interessiert: das Maschinenprogramm, das den Zeichensatz ins RAM kopiert, beginnt bei der Adresse 828, also dem Anfang des Kassettenpuffers).</p>

        <p>In diesem Zeichenfeld kann man nun mit den Cursortasten herumwandern, Sternchen (*) malen und gegebenenfalls mit der Space-Taste wieder löschen. Ein Sternchen im Zeichenfeld bedeutet einfach, daß hier ein Bit gesetzt wird, das dann später zur Berechnung des Zeichens dient. Jedes Graphik-Zeichen besteht ja aus 8 Bytes — und genau diese 8 Bytes stellt das Zeichenfeld symbolisch dar.</p>

        <h3>Taste 1: Berechnung des selbsterstellten Zeichens</h3>

        <p>Sobald man sein Zeichen gemalt hat, muß es berechnet werden. Hierfür ist im Menü der Programmpunkt 1 vorgesehen. Drückt man diese Taste, so wird gefragt: »Welche Taste?« Man drückt nun die Taste, der man das soeben erstellte Zeichen zuordnen möchte, und genau das Zeichen, das zu der gedrückten Taste gehört, wird nun durch das im Zeichenfeld definierte Zeichen ersetzt.</p>

        <p>Ein Beispiel: Füllt man das Zeichenfeld ganz mit Sternchen aus, läßt das Feld berechnen und drückt dann die Taste »A«, so wird überall auf dem Bildschirm dort, wo eben noch ein »A« gestanden hat, ein reverses Quadrat erscheinen. Nette Spielchen kann man zum Beispiel mit der Space-Taste machen: dann wird nämlich überall da, wo ein Space auf dem Bildschirm ist (und das sind ja üblicherweise eine ganze Menge), das eben definierte Zeichen gedruckt. Auf diese Weise kann man den Bildschirm etwas interessanter gestalten.</p>

        <h3>Taste 2:</h3>

        <p>Sobald das neue Zeichen berechnet und ausgedruckt ist, kann man wieder beliebig im Zeichenfeld herumhantieren. Will man jedoch ein ganz anderes Zeichen konstruieren, so drückt man einfach Taste 2, und flugs ist das Zeichenfeld wieder »sauber« — das gerade definierte Zeichen wird dabei natürlich nicht gelöscht. Zusätzlich zum reinen Konstruieren von Grafik-Zeichen gibt es jedoch auch noch andere Programmfunktionen:</p>

        <h3>Taste 3: ROM-Zeichen auslesen</h3>

        <p>Mit Hilfe dieses Programmpunktes kann man sich ein beliebiges Zeichen aus dem ROM-Zeichensatz herholen. Hierbei wird das gewünschte Zeichen in das Zeichenfeld hineingePOKEt und die Daten dieses Zeichens rechts daneben ausgegeben. Selbst wenn Sie also den Buchstaben »A« als ein reverses Quadrat definiert haben sollten, so erscheint — sofern Sie Taste 3 und danach »A« drücken — auf dem Zeichenfeld das gute, alte »A« wieder (denn im ROM-Zeichensatz bleibt natürlich alles beim alten).</p>

        <h3>Taste 4: Eigene Zeichen auslesen</h3>

        <p>Natürlich können Sie nicht nur Zeichen aus dem ROM holen, sondern auch aus dem kopierten Zeichensatz, in dem Sie bisher munter herummanipuliert haben. Sie haben zum Beispiel aus dem »O« ein Smiley-Gesicht gemacht und wollen er gerne in vergrößerte Form wiedersehen, um etwa Korrekturen oder ähnliches vorzunehmen — bitte sehr! Drücken Sie die Taste 4, dann ein »O« und Ihr eigenes Zeichen steht im Zeichenfeld — samt den dazugehörigen Daten rechts nebenan.</p>

        <h3>Taste 8: Restore</h3>

        <p>Nun kann es vorkommen, daß Sie genug haben von Ihren eigenen Zeichen. Eigentlich wollten Sie jetzt ganz gern wieder die alten, »normalen« Zeichen anstelle der vielen Smiley-Gesichter und reversen Quadrate sehen.</p>

        <p>Wenn Sie Taste 8 drücken, wird einfach der ROM-Zeichensatz wieder ins RAM kopiert; und da dieser Teil in Maschinensprache geschrieben ist, geht das ziemlich schnell vonstatten.</p>

        <p>Will man übrigens nur ein einziges Zeichen wieder in den Ursprungszustand versetzen, so geht man am besten so vor: Man holt sich das (alte) Zeichen aus dem ROM (mit Taste 3) und läßt es mit Taste 1 wieder in den neuen Zeichensatz hineinkopieren. Mit dieser Methode kann man zum Beispiel auch einen Art Geheimcode entwickeln: Man tauscht einfach die Zeichen im ROM untereinander aus (statt eines A ein B, statt eines U ein X und so weiter). Nach einigem Umdefinieren bekommt man einen ganz eigenartigen Buchstabensalat auf dem Bildschirm.</p>

        <h3>Taste 9: Bild zeichnen</h3>

        <p>Nehmen wir an, Sie haben aus den etwas eintönigen Grafikzeichen des C 64 interessantere Zeichen zusammengebastelt: Leitern, Mauerwerke, Treppen und ähnliches. Sie würden aber ganz gerne sehen, wie diese Zeichen im Zusammenhang wirken; wie es etwa aussieht, wenn ein Leiterstück unter dem anderen steht, daneben ein Mauerwerk und so weiter. Dazu drücken Sie Taste 9 und können jetzt mit Ihren selbsterstellten Zeichen den ganzen Bildschirm vollmalen. Wenn Sie wieder ins Menü zurückwollen, drücken Sie einfach »Cursor Home« (steht auch auf dem Bildschirm).</p>

        <p>Ein Hinweis zu diesem Programmpunkt: Der Cursor ist beim Bildmalen aus Gründen der Programmiervereinfachung nicht immer sehr gut sichtbar, manchmal »legt« er sich sogar ab, wenn er schnell über den Bildschirm bewegt wird. Das sollte Sie aber nicht weiter stören, schließlich ist diese Programmfunktion nur als Hilfe gedacht für einen schnellen Überblick.</p>

        <h3>Tasten 6 und 7: Abspeichern und Laden</h3>

        <p>Wenn Sie eigene Zeichen definiert haben, möchten Sie diesen Zeichensatz vielleicht abspeichern, um ihn später noch einmal verwenden zu können. Drücken Sie einfach Taste 6 und geben einen Dateinamen ein — der kopierte Zeichensatz mit Ihren selbsterstellten Zeichen wird nun auf Diskette gespeichert (nur der Großbuchstaben-Zeichensatz). Er nimmt dabei genau 44 Blöcke auf der Diskette ein. Mit Taste 7 können Sie schließlich einen abgespeicherten Zeichensatz wieder laden (der aktuelle Zeichensatz wird dabei überschrieben).</p>

        <p>Sollten Sie einmal versehentlich 6 oder 7 gedrückt haben, so kommen Sie wieder ins Menü zurück, wenn Sie »N« + »RETURN« eingeben!</p>

        <h3>Taste 5: Daten eingeben</h3>

        <p>Eine letzte Programmfunktion bietet die Eingabe von Daten, die ein Zeichen definieren. Dies ist eine Alternative zum Konstruieren eines Zeichens im Zeichenfeld. Zu beachten ist, daß nur Zahlen von 0 bis 255 eingegeben werden können (dies wird allerdings vom Programm sichergestellt; negative und Zahlen größer als 255 werden vom Programm nicht angenommen). Nach Eingabe des 8. Bytes erscheint dann die übliche Frage »Welche Taste!« und nach Eingabe dieser Taste das bekannte Sternchenbild auf dem Zeichenfeld.</p>

        <p>Die Erklärung der Taste 0 (Programmende) erübrigt sich wohl. Zu erwähnen ist hierbei nur, daß der kopierte Zeichensatz auch nach Beendigung des Programms weiterhin zur Bildschirmgestaltung benutzt wird; auch der Bildschirm selbst sitzt weiterhin an der Adresse 50176 (und nicht wie üblich, bei 1024). Wollen Sie also wieder einen ganz gewöhnlichen Bildschirm mit ganz gewöhnlichen Grafik-Zeichen haben, so geht das am einfachsten nur durch Aus- und Anschalten des Computers (auch die Run/Stop-Restore-Taste wurde im Programm blockiert).</p>

        <p>Eine kleine Bemerkung am Rande zum eigenen Programmieren: Sehr oft kommt es ja vor, daß man einen Satz von einem Programm aus mitten in dem Bildschirm hineinschreiben will. Üblicherweise geht man so vor, daß man die Cursor-Steuerzeichen in die Print-Zeile so oft einfügt, bis der gesuchte Platz gefunden ist. Für Programmlistings ist das etwas unübersichtlich. Es gibt aber noch eine andere Methode, die ich in diesem Programm benutzt habe (und zwar am Anfang fast jedes Programmpunktes): will man zum Beispiel einen Buchstaben in die 14. Zeile, 5. Spalte schreiben, so gibt man zunächst POKE 214,13<br>
            ein, danach ein PRINT-Kommando und dann PRINTTAB(4)»X«.</p>

        <p>In Adresse 214 steht nämlich die Zeilenposition des Cursors. Um diese richtig einzusetzen, muß man allerdings noch einen PRINT-Befehl nachschicken: Cursor in Zeile 13 + PRINT-Befehl ergibt dann Zeile 14!</p>

        <address class="author">(Volker Bühn / gk)</address>

        <figure>
            <p>Programmablauf-Plan:</p>
            <table>
                <tr>
                    <td>Zeile</td>
                    <td>Beschreibung</td>
                </tr>
                <tr>
                    <td>1-7</td>
                    <td>Programmname und Adresse des Autors</td>
                </tr>
                <tr>
                    <td>10-30</td>
                    <td>Einlesen und Aufruf der Maschinenroutine, die den Zeichensatz vom ROM ins RAM an die Adresse 51200 kopiert</td>
                </tr>
                <tr>
                    <td>40-140</td>
                    <td>Menü und Zeichenfeld werden gezeichnet</td>
                </tr>
                <tr>
                    <td>300-460</td>
                    <td>Abfrage der Tastatur:<br>
                        1. Zeichnen im Zeichenfeld<br>
                        2. Aufruf der einzelnen Programmfunktionen</td>
                </tr>
                <tr>
                    <td>500-520</td>
                    <td>Unterprogramm zum Printen des Zeichenfeldes</td>
                </tr>
                <tr>
                    <td>1000-1530</td>
                    <td>Die einzelnen Unterprogramme zur Steuerung des Cursors, der Space-Taste und des Sternchens, um im Zeichenfeld ein Zeichen zu erzeugen.</td>
                </tr>
                <tr>
                    <td>2000-8040</td>
                    <td><b>Einzelne Programmfunktionen:</b></td>
                </tr>
                <tr>
                    <td>2000-2120</td>
                    <td>Berechnung eines erstellten Zeichens; Zuordnung dieses neuen Zeichens in den Zeichensatz; Printen der Daten des Zeichens</td>
                </tr>
                <tr>
                    <td>3000-3150</td>
                    <td>Ausgabe eines Zeichens aus dem ROM- Zeichensatz; Printen der Daten dieses Zeichens</td>
                </tr>
                <tr>
                    <td>4000-4150</td>
                    <td>Ausgabe eines Zeichens aus dem kopierten Zeichensatz, Printen der Daten dieses Zeichens</td>
                </tr>
                <tr>
                    <td>5000-5050</td>
                    <td>Neuer Bildschirm zum Zeichen mit dem selbsterstellten Zeichensatz<br>Die Zeile 5050 dient zur Cursor- Steuerung und Ausdrucken eines Zeichens auf dem Bildschirm</td>
                </tr>
                <tr>
                    <td>6000-6120</td>
                    <td>Abspeichern eines selbsterstellten Zeichensatzes auf Diskette</td>
                </tr>
                <tr>
                    <td>7000-7120</td>
                    <td>Laden eines Zeichensatzes von Diskette</td>
                </tr>
                <tr>
                    <td>8000-8040</td>
                    <td>Eingabe von 8 Bytes zur Definition eines Zeichens<br>In 8030 wird sichergestellt, daß keine Zahl größer als 8 Bit ist</td>
                </tr>
                <tr>
                    <td>10000-10040</td>
                    <td>POKEn des Maschinenprogramms nach 828</td>
                </tr>
                <tr>
                    <td>10100-10150</td>
                    <td>DATA-Zeilen des Maschinenprogramms (in Hexcodes)</td>
                </tr>
            </table>
        </figure>
        <figure>
            <p><b>Wichtige Programmzeilen:</b></p>
            <p>Erstellung eines eigenen Zeichens:</p>
            <table>
                <tr>
                    <td>2050-2070</td>
                    <td>Hier werden die Bytes des selbsterstellten Zeichens aus dem Zeichenfeld gelesen, berechnet und in B(1) bis B(8) abgelegt.</td>
                </tr>
                <tr>
                    <td>2080</td>
                    <td>Die Bytes des Zeichens werden nun in die Stelle des Zeichensatzes gePOKEt, die der Benutzer durch die Tastenabfrage definiert hat.<br>ROM-Zeichen:</td>
                </tr>
                <tr>
                    <td>3050</td>
                    <td>Verhindern von Interrupts</td>
                </tr>
                <tr>
                    <td>3060-3070</td>
                    <td>Im ROM-Zeichensatz wird das vom Benutzer festgelegte Zeichen in B(1) bis B(8) sowie C(1) bis C(8) abgelegt</td>
                </tr>
                <tr>
                    <td>3080</td>
                    <td>Zulassen von Interrupts</td>
                </tr>
                <tr>
                    <td>3090-3110</td>
                    <td>Die Bytes B(1) bis B(8) werden in das Zeichenfeld in Form von Sternchen (*) hinein gePOKEt</td>
                </tr>
                <tr>
                    <td>Eigenes Zeichen holen:</td>
                </tr>
                <tr>
                    <td>4060-4070</td>
                    <td>wie 3060-3070, nur daß im kopierten Zei chensatz gesucht wird</td>
                </tr>
                <tr>
                    <td>4080-4100</td>
                    <td>wie 3090-3110<br>Bild zeichnen:</td>
                </tr>
                <tr>
                    <td>5050</td>
                    <td>In den Adressen 209,210 und 211 steht die aktuelle Cursorposition. Dies verhindert, daß der Cursur auf den Bildschirm wie ein normales Zeichen gePRINTet wird.</td>
                </tr>
            </table>
        </figure>
        <figure>
            <p>Liste der wichtigsten Variablen</p>
            <table>
                <tr>
                    <td>Z</td>
                    <td>Position des anfänglichen Cursors im Zeichenfeld (ist immer 50776)</td>
                </tr>
                <tr>
                    <td>PU$<br>NO$</td>
                    <td>Strings, um Punkte beziehungsweise Leerstellen zu PRINTen</td>
                </tr>
                <tr>
                    <td>A</td>
                    <td>Variable, die die aktuelle Cursorposition im Zeichenfeld angibt</td>
                </tr>
                <tr>
                    <td>G$</td>
                    <td>Stringvariable zur Tastaturabfrage</td>
                </tr>
                <tr>
                    <td>B(1) bis B(8)<br>
                        C(1) bis C(8)</td>
                    <td>Arrays, die die 8 Bytes eines Zeichens enthalten</td>
                </tr>
                <tr>
                    <td>G</td>
                    <td>Bildschirmcode eines Zeichens</td>
                </tr>
                <tr>
                    <td>C</td>
                    <td>Cursorposition beim Bildzeichnen</td>
                </tr>
                <tr>
                    <td>N$</td>
                    <td>Name einer einzulesenden beziehungsweise abzuspeichernden Datei</td>
                </tr>
                <tr>
                    <td>A$</td>
                    <td>Hexcode aus den DATA-Zeilen</td>
                </tr>
                <tr>
                    <td>HN,LN</td>
                    <td>Hi-Nibble beziehungsweise Lo-Nibble von A$</td>
                </tr>
                <tr>
                    <td>I,J,K</td>
                    <td>Schleifenvariable</td>
                </tr>
            </table>
        </figure>

        <figure>
            <pre data-filename="zeichen-editor" data-name="Zeichen-Editor" data-checksummer="1"></pre>
            <figcaption>Listing »Zeichen-Editor«</figcaption>
        </figure>

        <aside class="fehlerteufelchen" id="fehlerteufelchen">
            <h2>Fehlerteufelchen</h2>
            <p>In der Zeile 5020 muß die PRINT-Anweisung genauso, also mit der eckigen Klammer, eingegeben werden.</p>
            <!-- 64'er 2/1985 -->
        </aside>

    </article>

</body>

</html>
