<!DOCTYPE html>
<html lang="de">

<head>
    <title>64'er Extra</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="64er.issue" content="3/86">
    <meta name="64er.pages" content="88-89">
    <meta name="64er.head1" content="64'er Extra">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="Kernel-Routinen und interessante PEEKs und POKEs">
    <meta name="64er.toc_category" content="64'er Extra">
    <meta name="64er.index_title" content="ROM-Kernel-Routinen (Teil 3) + nützliche PEEKS & POKES">
    <meta name="64er.index_category" content="64'er Extra|Kernel">
    <meta name="64er.id" content="extra">
</head>

<body>
    <article>
        <h1>64'er Extra</h1>
        <p class="intro">Das 64'er Extra bringt geballte Information über Ihren C 64 zum Heraustrennen und Sammeln. In dieser siebten Ausgabe finden Sie den dritten Teil einer Übersicht über alle ROM-Routinen des C 64. Statt ziellos in ROM-Li$tings zu blättern, finden Sie hier im Klartext die Funktionsbeschreibung aller irgendwie nutzbaren Routinen.</p>

        <p>LINES $ECFO<br>
            Niederwertiges Byte der Tabelle der Bildschirmzeilen.<br>
            TALK $ED09<br>
            Kernel-Routine TALK.<br>
            LISTN $EDOC<br>
            Kernel-Routine LISTN.<br>
            SEND $ED16<br>
            Sendet mit OR behandeltes Zeichen.<br>
            SET $ED62<br>
            Sendet 8 Datenbits.<br>
            SECND $EECO<br>
            Kernel-Routine SECOND.<br>
            SCATN $EDBE<br>
            Gibt ATN frei.<br>
            TKSA $EDC7<br>
            Kernel-Routine TKSA.<br>
            CIOUT $EDDD<br>
            Kernel-Routine CIOUT.<br>
            UNTKL $EDEF<br>
            Kernel-Routine UNTALK.<br>
            UNLSN $EDFE<br>
            Kernel-Routine UNLSN.<br>
            DLABYE $EE03<br>
            Gibt alle Leitungen frei.<br>
            ACPTR $EE13<br>
            Kernel-Routine CPTR.<br>
            ACP00C $EE47<br>
            »TIMEOUT« Ausführung.<br>
            ACP01 $EE56<br>
            Empfängt 8 Datenbits.<br>
            CLKHI $EE85<br>
            Clock-Leitung high<br>
            CLKL0 $EE8E<br>
            Clock-Leitung low<br>
            DATAHI $EE97<br>
            Data-Leitung high<br>
            DATAL0 $EEA0<br>
            Data-Leitung low<br>
            DEBCIA $EEA9<br>
            CIA-Entprellung.<br>
            WLMS $EEB3<br>
            Verzögerungsschleifen.<br>
            RSTRAB $EEBB<br>
            Teil der Routine, die von NMI verwendet wird, wenn er RS232-Ubertragung bedient.<br>
            RST010 $EED7<br>
            Berechnet Parität. Beim Eintritt ist NXTBIT=O.<br>
            RST050 $EFOO<br>
            Verarbeitung der Stop-Bits.<br>
            RSTBGN $EF06<br>
            Einsprung: Beginnt die Übertragung eines Bytes.<br>
            RST060 $EF13<br>
            Bereitet das Senden des nächstens Bytes vor.<br>
            DSRERR $EF2E<br>
            Legt RS232-Fehler in ST ab.<br>
            BITCNT $EF4A<br>
            Ermittelt die Zahl der zu sendenden Bits+1.<br>
            RSRCVR $EF59<br>
            Sammelt Bits zu einem Byte während NMI.<br>
            RSR030 $EF97<br>
            Überträgt Daten in den Puffer für Paritätsprüfung.<br>
            ECERR $EFCA<br>
            Meldet Empfangsfehler.<br>
            CKO232 $EFE1<br>
            Gibt über die RS232-Schnittstelle am USER-Port eine Datei aus.<br>
            BS0232 $F014<br>
            Gibt ein RS232-Zeichen aus.<br>
            BS0110 $F02E<br>
            Macht die MNIs des Timers 1 in CIA scharf (unterschiedlich zwischen den Kernelversionen 0 und 3).<br>
            CKI232 $F04D<br>
            Liest über die RS232-Schnittstelle (über den Usen-Port) eine Datei ein.<br>
            BSI232 $F086<br>
            Liest ein RS232-Zeichen ein.<br>
            RSP232 $F0A4<br>
            Schützt seriellen Bus und Bandbetrieb vor NMIs.<br>
            SPMSG $F12B<br>
            Gibt die Bandbetriebsmeldung von der Tabelle ab $FOBD aus, falls durch Flag bei $9D freigegeben.<br>
            NGETIN $F13E<br>
            Kernel-Routine GETIN.<br>
            NBASIN $F157<br>
            Kernel-Routine CHRIN.<br>
            JTGET1 $F179<br>
            Holt ein Zeichen vom Band.<br>
            BSCOUT $F1CA<br>
            Kernel-Routine CHROUT.<br>
            CASOUT $F1DD<br>
            Sendet ein Zeichen zum Kassettengerät.<br>
            NCHKIN $F20E<br>
            Kernel-Routine CHKIN.<br>
            NCKOUT $F250<br>
            Kernel-Routine CHKOUT.<br>
            NCLOSE $F291<br>
            Kernel-Routine CLOUSE.<br>
            NCLALL $F32F<br>
            Kernel-Routine CLALL.<br>
            NOPEN $F34A<br>
            Kernel-Routine OPEN.<br>
            0P152 $F38B<br>
            OPEN für Kassettendatei.<br>
            OPENI $F3D5<br>
            OPEN für Datei für ein serielles Gerät (Drucker, Diskettenlaufwerk).<br>
            0PN232 $F409<br>
            OPEN für eine RS232-Datei.<br>
            LOASP $F49E<br>
            Kernel-Routine LOAD.<br>
            LD25 $F4BF<br>
            LOAD für Diskette.<br>
            LD102 $F539<br>
            LOAD für Kassettengerät.<br>
            SAVESP $F5DD<br>
            Kernel-Routine SAVE.<br>
            SV21 $F5FA<br>
            SAVE für Diskette.<br>
            SV102 $65F<br>
            SAVE für Kassettengerät.<br>
            UDTIMK $F69B<br>
            Kernel-Routine UDTIM.<br>
            RDTIMK $F6DD<br>
            Kernel-Routine RDTIM.<br>
            SETTMK $F6E4<br>
            Kernel-Routine SETTIM.<br>
            NSTOP $F6ED<br>
            Kernel-Routine STOP.<br>
            ERROR1 $F6FB<br>
            Tabelle der I/O-Fehlernummern 1&hellip;9 und -meldungen.<br>
            FAH $F72C<br>
            Lädt nächsten Kassettenvorspann.<br>
            TAPEH $F76A<br>
            Schreibt Kassettenvorspann.<br>
            FAF $F7EA<br>
            Lädt angegebenen Kassettenvorspann.<br>
            TRD $F84 A<br>
            Lädt vom Kassettengerät.<br>
            TWRT $F867<br>
            Schreibt zum Kassettengerät.<br>
            READ $F92C<br>
            Kassetten-Lese-Routinen.<br>
            WRITE $FBA6<br>
            Routinen für Schreiben auf Kassette.<br>
            START $FCE2<br>
            Reset-Routine. Einschalten des »64« oder ein Reset-Schalter verursachen einen Sprung hierher, SYS 64738 springt hierher, es sei denn, das RAM unter dem Kernel ist aktiviert. Ist bei $8000 ein Modul vorhanden, erfolgt JMP ($8000), andernfalls laufen RAMTAS, RESTOR, IOINIT, CINT und ein Basic-Kaltstart ab. Sonstiges RAM bleibt unverändert; Basic-Programme lassen sich daher wiedergewinnen.<br>
            RESTOR $FD15<br>
            Kernel-Routine RESTOR.<br>
            VECTOR $FD1A<br>
            Kernel-Routine VECTOR.<br>
            RAMTAS $FD50<br>
            Kernel-Routine RAMTAS.<br>
            IOINIT $FDA3<br>
            Kernel-Routine lOINIT.<br>
            SETNAM $FDF9<br>
            Kernel-Routine SETNAM.<br>
            SETLFS $FEOO<br>
            Kernel-Routine SETFLS.<br>
            READST $FE07<br>
            Kernel-Routine READST.<br>
            SETMSG $FE18<br>
            Kernele-Routine SETMSG.<br>
            SETTMO $FE21<br>
            Kernel-Routine SETTMO.<br>
            MEMTOP $FE25<br>
            Kernel-Routine MEMTOP.<br>
            MEMBOT $FE34<br>
            Kernel-Routine MEMBOT.<br>
            NMI $FE43<br>
            NMI-Routine. Alle NMIs laden hier (es sei denn, der Kernel wurde im RAM modifiziert) und werden über den Vektor in ($0318) gelenkt. STOP-RESTORE, RS232-Betrieb und benutzerdefinierte NMIs werden sämtlich hier verarbeitet.<br>
            TIMB $FE66<br>
            POST-RESTORE oder die BRKs »Not-Rücksetz-Routine«.<br>
            NNM121 $FE66<br>
            Prüft RS232-Schnittstelle und sendet Bit, wenn möglich.<br>
            NNM130 $FEA3<br>
            Prüft RS232-Schnittstelle und empfängt Bit, wenn möglich.<br>
            BAUDOT $FEC2<br>
            Baudaten-Tabelle für RS232<br>
            T2NMI$FED6<br>
            Behandelt Eingang eines RS232-Bits.<br>
            FLNMI $FF07<br>
            Behandelt zeitliche Abstimmung des Startbits für RS232.<br>
            PULS $FF48<br>
            Einsprung für IRQ oder BRK. Alle IRQ-Interrupts laufen über diesen Punkt (es sei denn, der<br>
            Kernel wurde am RAM modifiziert). IRQ lenkt ein Vektor in ($0314), BRK-Befehle ein Vektor in ($0316); Änderungen beider Routinen durch den Benutzer sind daher häufig.<br>
            CINT $FF81<br>
            Setzt die Interrupt-Frequenz.<br>
            IOINIT $FF84<br>
            Initialisiert die Ein-/Ausgabe-Chips.<br>
            RAMTAS $FF87<br>
            Testet und setzt RAM.<br>
            RESTOR $FF8A<br>
            Restauriert Standard-Ein-/Ausgabevektoren.<br>
            VECTOR $FF8D<br>
            Speichert/setzt Ein/Ausgabevektoren.<br>
            SETMSG £FF90<br>
            Gibt Meldung zum Bildschirm aus.<br>
            SECOND $FF93<br>
            Sendet Sekundäradresse nach LISTEN über den seriellen Bus.<br>
            TKSA $FF96<br>
            Sendet Sekundäradresse nach TALK über den seriellen Bus.<br>
            MEMTOP $FF99<br>
            Liest/setzt die obere Grenze des Speichers für Basic.<br>
            MEMBOT $FF82<br>
            Liest/setzt die untere Grenze des Speichers für Basic.<br>
            SCNKEY $FF9F<br>
            Naturabfrage.<br>
            SETTMO $FFA2<br>
            Setzt TIMEOUT für seriellen Bus.<br>
            ACPTR $FFA5<br>
            Holt ein Byte von einem seriellen Gerät (gewöhnlich Floppy-Disk).<br>
            CIOUT $FFA8<br>
            Gibt ein Byte zum seriellen Bus aus (gewöhnlich für Drucker oder Floppy-Disk).<br>
            UNTALK $FFAB<br>
            desaktiviert sendende Geräte am seriellen Bus.<br>
            UNLSN $FFAE<br>
            desaktiviert empfangende Geräte am seriellen Bus.<br>
            LISTN $FFB1<br>
            Schaltet Gerät am seriellen Bus auf Empfang (gewöhnlich Drucker oder Floppy-Disk).<br>
            READST $FFB7<br>
            Liest das Status-Byte nach A ein.<br>
            SETLFS $FFBA<br>
            Setzt Dateinummer, Gerät, Sekundäradresse.<br>
            SETNAM FFBD<br>
            Setzt Dateinamen.<br>
            OPEN $FFCO<br>
            Öffnet Datei zum Lesen/Schreiben.<br>
            CLOSE $FFC3<br>
            Schließt eine Datei.<br>
            CHKIN $FFC6<br>
            Eröffnet Eingabekanal.<br>
            CHKOUT $FFC9<br>
            Eröffnet Ausgabekanal.<br>
            CLRCHN $FFCC<br>
            Schließt Kanal, stellt die Standardbedingungen für I/O wieder her.<br>
            CHRIN $FFCF<br>
            Holt ein Zeichen.<br>
            CHROUT $FFD2<br>
            Gibt ein Zeichen aus.<br>
            LOAD $FFD5<br>
            Lädt ein Programm (von Diskette oder Band).<br>
            SAVE $FFD8<br>
            Speichert einen Bereich als Programm (auf Diskette oder Band).<br>
            SETTIM $FFDB<br>
            Setzt Taktzähler. (BASIC 2 VERIFY)<br>
            RDTIM $FFDE<br>
            Liest Taktzähler. (BASIC 2 SYS)<br>
            STOP $FFE1<br>
            Prüft auf die STOP-Taste.<br>
            GETIN $FFE4<br>
            Holt ein Zeichen (gewöhnlich von der Tastatur — GET).<br>
            CLALL $FFE7<br>
            Beendet jeglichen I/O-Betrieb und schließt alle Dateien.<br>
            UDTIM $FFEA<br>
            Addiert 1 zum Taktzähler; auf Null stellen, wenn 240 000.<br>
            SCREEN $FFED<br>
            Holt Anzahl von Zeilen und Spalten.<br>
            PLOT $FFFO<br>
            Liest/setzt Cursor.<br>
            OBASE $FFF3<br>
            Startadresse des Tastatur-VIA.</p>

        <h2>Nützliche PEEKs und POKEs</h2>

        <p>PRINT PEEK(17)<br>
            Anzeige von 0: die letzte Eingabe wurde über die Anweisung INPUT vorgenommen<br>
            Anzeige von 64: die letzte Eingabe wurde über die Anweisung GET vorgenommen<br>
            Anzeige von 152: die letzte Eingabe wurde über READ vorgenommen<br>
            PRINT PEEK(43)+256*PEEK(44)<br>
            Ausgabe der Adresse, von wo aus das Basic-Programm gespeichert ist<br>
            PRINT PEEK(45)+256*PEEK(46)<br>
            Ausgabe der Adresse, bis wohin das Basic-Programm reicht<br>
            PRINT PEEK(47)+256*PEEK(48)<br>
            Ausgabe der Adresse, bis wohin die Variablen reichen<br>
            PRINT PEEK(49)+256*PEEK(50)<br>
            Ausgabe der Adresse, bis wohin die Felder reichen<br>
            PRINT PEEK(55)+256*PEEK(56)<br>
            Ausgabe der Adresse, bis wohin der Basic-Arbeitsspeicher reicht<br>
            PRINT PEEK(57)+256*PEEK(58)<br>
            Ausgabe der Nummer der momentan bearbeiteten Programmzeile<br>
            PRINT PEEK(63)+256*PEEK(64)<br>
            Ausgabe der Nummer derjenigen DATA-Zeile, aus der Daten entnommen werden (READ-Befehl)<br>
            PRINT CHR$(PEEK(69)AND127) + CHR$(PEEK(70)AND127)<br>
            Ausgabe des zuletzt benutzten Variablennamens<br>
            PRINT PEEK(198)<br>
            Ausgabe der Anzahl der im Tastaturpuffer gespeicherten Zeichen<br>
            POKE 198,0<br>
            Der Tastaturpuffer wird geleert<br>
            PRINT PEEK(214)<br>
            Ausgabe der Nummer der Zeile, in der sich der Cursor befindet; dabei werden die Zeilen von 0 bis 24 ( = 25 Zeilen) gezählt<br>
            POKE 214,Z : POKE 211,S : SYS 58640<br>
            Diese Befehlssequenz setzt den Cursor unmittelbar auf die mittels Z und S angegebene<br>
            Zeilen- beziehungsweise Spaltenposition, wobei die Zeilen von 0 bis 39 und die Spalten von 0 bis 24 gezählt werden<br>
            PRINT PEEK(641)+256*PEEK(642)<br>
            Ausgabe der Adresse, von wo ab der für Basic nutzbare RAM-Bereich beginnt<br>
            PRINT PEEK(643)+256*PEEK(644)<br>
            Ausgabe der Adresse, bis wohin der für Basic nutzbare RAM-Bereich reicht<br>
            POKE 641,AL : POKE 642,AH : SYS 58260<br>
            Die Anfangsadresse für Basic-Programme wird auf den Wert AL+256*AH festgelegt<br>
            POKE 643,EL : POKE 644,EH : SYS 58260<br>
            Die Endadresse für den Basic-Arbeitsspeicher wird auf den Wert EL+256*EH festgelegt<br>
            PRINT PEEK(646)<br>
            Anzeige der Nummer der momentanen Zeichenfarbe<br>
            POKE 646,F<br>
            Einstellen der Zeichenfarbe, wobei F der Farbnummer entspricht<br>
            POKE 649,MX<br>
            MX ist eine Zahl zwischen 0 und 10; diese POKE-Anweisung legt fest, wieviele Zeichen sich maximal im Tastaturpuffer befinden dürfen (der Grundwert ist 10); wenn also MX=0 gewählt wird, ist die Tastatur völlig abgeschaltet und keine Eingabe mehr ist möglich (Vorsicht!!)<br>
            POKE 650,128<br>
            Die Tasten-Wiederholungs-Automatik wird auf alle Tasten ausgedehnt<br>
            POKE 650,64<br>
            Die Tasten-Wiederholungs-Automatik wird für alle Tasten abgeschaltet<br>
            POKE 650,0<br>
            Die Tasten-Wiederholungs-Automatik wird für die INST DEL-, die Leertaste und die Cursortasten eingeschaltet (Grundwert)<br>
            PRINT PEEK(653) AND 7<br>
            Anzeige von 0: keine der Tasten SHIFT, CBM oder CTRL gedrückt<br>
            Anzeige von 1: die SHIFT-Taste ist gedrückt<br>
            Anzeige von 2: die CBM-Taste befindet sich in gedrückter Haltung<br>
            Anzeige von 4: die CTRL-Taste befindet sich in gedrückter Haltung<br>
            Anzeige von 3,5,6,7: diese Zahlen ergeben sich aus der Addition zweier oder aller drei oben beschriebenen Werte und geben somit an, daß sich die den Summanden zugeordneten Tasten in gedrückter Haltung befinden<br>
            POKE 657,128<br>
            Umschaltungsverriegelung von dem Großschrift/Grafik-Modus in den Klein-/Großschrift-Modus<br>
            POKE 657,0<br>
            Aufheben der Verriegelung (siehe voriger POKE-Befehl)<br>
            POKE 775,200<br>
            LIST-Schutz einschalten<br>
            POKE 775,167<br>
            LIST-Schutz ausschalten<br>
            POKE 788,52<br>
            RUN-STOP-Taste wirkungslos machen<br>
            POKE 788,49<br>
            RUN-STOP-Taste reaktivieren<br>
            POKE 801,0 : POKE 802,0 :<br>
            Nach dieser Befehlssequenz wird das Speichern eines Programms unmöglich gemacht<br>
            POKE 808,225<br>
            RUN-STOP- + RESTORE-Taste wirkungslos machen, außerdem erscheint ein »verrücktes« Listing<br>
            POKE 808,237<br>
            RUN-STOP- + RESTORE-Taste reaktivieren<br>
            POKE 53265,11<br>
            Bildschirminhalt unsichtbar machen, ohne daß dessen Inhalt veriorengeht<br>
            POKE 53265,27<br>
            Bildschirminhalt wieder sichtbar machen<br>
            WAIT 56320,16,16<br>
            Warten, bis beim Joystick Port 2:<br>
            der Feuerknopf gedrückt wird,<br>
            WAIT 56320,4,4<br>
            Linksbewegung vorgenommen wird,<br>
            WAIT 56320,1,1<br>
            Bewegung nach oben erfolgt,<br>
            WAIT 56320,2,2<br>
            Bewegung nach unten erfolgt,<br>
            WAIT 56320,8,8<br>
            Rechtsbewegung vorgenommen wird<br>
            WAIT 56321,16,16<br>
            Warten, bis beim Joystick Port 1: der Feuerknopf gedrückt wird, (Richtungsabfragen analog zu Joystick Port 2)</p>
    </article>
</body>

</html>