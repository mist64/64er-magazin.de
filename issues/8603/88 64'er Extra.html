<!DOCTYPE html>
<html lang="de">

<head>
    <title>64'er Extra</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="64er.issue" content="3/86">
    <meta name="64er.pages" content="88-89">
    <meta name="64er.head1" content="64'er Extra">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="Kernel-Routinen und interessante PEEKs und POKEs">
    <meta name="64er.toc_category" content="64'er Extra">
    <meta name="64er.index_title" content="ROM-Kernel-Routinen (Teil 3) + nützliche PEEKS & POKES">
    <meta name="64er.index_category" content="64'er Extra|Kernel">
    <meta name="64er.id" content="extra">
</head>

<body>
    <article>
        <h1>64'er Extra</h1>
        <p class="intro">Das 64'er Extra bringt geballte Information über Ihren C 64 zum Heraustrennen und Sammeln.</p>
        <p class="intro">In dieser siebten Ausgabe finden Sie den dritten Teil einer Übersicht über alle ROM-Routinen des C 64. Statt ziellos in ROM-Listings zu blättern, finden Sie hier im Klartext die Funktionsbeschreibung aller irgendwie nutzbaren Routinen.</p>

        <p class="hanging"><strong>LINES $ECF0</strong><br>
        Niederwertiges Byte der Tabelle der Bildschirmzeilen.</p>
        <p class="hanging"><strong>TALK $ED09</strong><br>
        Kernel-Routine TALK.</p>
        <p class="hanging"><strong>LISTN $ED0C</strong><br>
        Kernel-Routine LISTN.</p>
        <p class="hanging"><strong>SEND $ED16</strong><br>
        Sendet mit OR behandeltes Zeichen.</p>
        <p class="hanging"><strong>SET $ED62</strong><br>
        Sendet 8 Datenbits.</p>
        <p class="hanging"><strong>SECND $EEC0</strong><br>
        Kernel-Routine SECOND.</p>
        <p class="hanging"><strong>SCATN $EDBE</strong><br>
        Gibt ATN frei.</p>
        <p class="hanging"><strong>TKSA $EDC7</strong><br>
        Kernel-Routine TKSA.</p>
        <p class="hanging"><strong>CIOUT $EDDD</strong><br>
        Kernel-Routine CIOUT.</p>
        <p class="hanging"><strong>UNTKL $EDEF</strong><br>
        Kernel-Routine UNTALK.</p>
        <p class="hanging"><strong>UNLSN $EDFE</strong><br>
        Kernel-Routine UNLSN.</p>
        <p class="hanging"><strong>DLABYE $EE03</strong><br>
        Gibt alle Leitungen frei.</p>
        <p class="hanging"><strong>ACPTR $EE13</strong><br>
        Kernel-Routine CPTR.</p>
        <p class="hanging"><strong>ACP00C $EE47</strong><br>
        »TIMEOUT« Ausführung.
        <p class="hanging"><strong>ACP01 $EE56</strong><br>
        Empfängt 8 Datenbits.</p>
        <p class="hanging"><strong>CLKHI $EE85</strong><br>
        Clock-Leitung high</p>
        <p class="hanging"><strong>CLKLO $EE8E</strong><br>
        Clock-Leitung low</p>
        <p class="hanging"><strong>DATAHI $EE97</strong><br>
        Data-Leitung high</p>
        <p class="hanging"><strong>DATALO $EEA0</strong><br>
        Data-Leitung low</p>
        <p class="hanging"><strong>DEBCIA $EEA9</strong><br>
        CIA-Entprellung.</p>
        <p class="hanging"><strong>WLMS $EEB3</strong><br>
        Verzögerungsschleifen.</p>
        <p class="hanging"><strong>RSTRAB $EEBB</strong><br>
        Teil der Routine, die von NMI verwendet wird, wenn er RS232-Ubertragung bedient.</p>
        <p class="hanging"><strong>RST010 $EED7</strong><br>
        Berechnet Parität. Beim Eintritt ist NXTBIT=O.</p>
        <p class="hanging"><strong>RST050 $EF00</strong><br>
        Verarbeitung der Stop-Bits.</p>
        <p class="hanging"><strong>RSTBGN $EF06</strong><br>
        Einsprung: Beginnt die Übertragung eines Bytes.</p>
        <p class="hanging"><strong>RST060 $EF13</strong><br>
        <strong>Bereitet das Senden des nächstens Bytes vor.</strong></p>
        <p class="hanging"><strong>DSRERR $EF2E</strong><br>
        Legt RS232-Fehler in ST ab.</p>
        <p class="hanging"><strong>BITCNT $EF4A</strong><br>
        Ermittelt die Zahl der zu sendenden Bits+1.</p>
        <p class="hanging"><strong>RSRCVR $EF59</strong><br>
        Sammelt Bits zu einem Byte während NMI.</p>
        <p class="hanging"><strong>RSR030 $EF97</strong><br>
        Überträgt Daten in den Puffer für Paritätsprüfung.
        <p class="hanging"><strong>ECERR $EFCA</strong><br>
        Meldet Empfangsfehler.</p>
        <p class="hanging"><strong>CKO232 $EFE1</strong><br>
        Gibt über die RS232-Schnittstelle am USER-Port eine Datei aus.</p>
        <p class="hanging"><strong>BSO232 $F014</strong><br>
        Gibt ein RS232-Zeichen aus.</p>
        <p class="hanging"><strong>BSO110 $F02E</strong><br>
        Macht die MNIs des Timers 1 in CIA scharf (unterschiedlich zwischen den Kernelversionen 0 und 3).</p>
        <p class="hanging"><strong>CKI232 $F04D</strong><br>
        Liest über die RS232-Schnittstelle (über den Usen-Port) eine Datei ein.</p>
        <p class="hanging"><strong>BSI232 $F086</strong><br>
        Liest ein RS232-Zeichen ein.</p>
        <p class="hanging"><strong>RSP232 $F0A4</strong><br>
        Schützt seriellen Bus und Bandbetrieb vor NMIs.</p>
        <p class="hanging"><strong>SPMSG $F12B</strong><br>
        Gibt die Bandbetriebsmeldung von der Tabelle ab $F0BD aus, falls durch Flag bei $9D freigegeben.</p>
        <p class="hanging"><strong>NGETIN $F13E</strong><br>
        Kernel-Routine GETIN.</p>
        <p class="hanging"><strong>NBASIN $F157</strong><br>
        Kernel-Routine CHRIN.</p>
        <p class="hanging"><strong>JTGET1 $F179</strong><br>
        Holt ein Zeichen vom Band.</p>
        <p class="hanging"><strong>BSCOUT $F1CA</strong><br>
        Kernel-Routine CHROUT.</p>
        <p class="hanging"><strong>CASOUT $F1DD</strong><br>
        Sendet ein Zeichen zum Kassettengerät.</p>
        <p class="hanging"><strong>NCHKIN $F20E</strong><br>
        Kernel-Routine CHKIN.</p>
        <p class="hanging"><strong>NCKOUT $F250</strong><br>
        Kernel-Routine CHKOUT.</p>
        <p class="hanging"><strong>NCLOSE $F291</strong><br>
        Kernel-Routine CLOUSE.</p>
        <p class="hanging"><strong>NCLALL $F32F</strong><br>
        Kernel-Routine CLALL.</p>
        <p class="hanging"><strong>NOPEN $F34A</strong><br>
        Kernel-Routine OPEN.</p>
        <p class="hanging"><strong>OP152 $F38B</strong><br>
        OPEN für Kassettendatei.</p>
        <p class="hanging"><strong>OPENI $F3D5</strong><br>
        OPEN für Datei für ein serielles Gerät (Drucker, Diskettenlaufwerk).</p>
        <p class="hanging"><strong>OPN232 $F409</strong><br>
        OPEN für eine RS232-Datei.</p>
        <p class="hanging"><strong>LOASP $F49E</strong><br>
        Kernel-Routine LOAD.</p>
        <p class="hanging"><strong>LD25 $F4BF</strong><br>
        LOAD für Diskette.</p>
        <p class="hanging"><strong>LD102 $F539</strong><br>
        LOAD für Kassettengerät.</p>
        <p class="hanging"><strong>SAVESP $F5DD</strong><br>
        Kernel-Routine SAVE.</p>
        <p class="hanging"><strong>SV21 $F5FA</strong><br>
        SAVE für Diskette.</p>
        <p class="hanging"><strong>SV102 $65F</strong><br>
        SAVE für Kassettengerät.</p>
        <p class="hanging"><strong>UDTIMK $F69B</strong><br>
        Kernel-Routine UDTIM.</p>
        <p class="hanging"><strong>RDTIMK $F6DD</strong><br>
        Kernel-Routine RDTIM.</p>
        <p class="hanging"><strong>SETTMK $F6E4</strong><br>
        Kernel-Routine SETTIM.</p>
        <p class="hanging"><strong>NSTOP $F6ED</strong><br>
        Kernel-Routine STOP.</p>
        <p class="hanging"><strong>ERROR1 $F6FB</strong><br>
        Tabelle der I/O-Fehlernummern 1&hellip;9 und -meldungen.</p>
        <p class="hanging"><strong>FAH $F72C</strong><br>
        Lädt nächsten Kassettenvorspann.</p>
        <p class="hanging"><strong>TAPEH $F76A</strong><br>
        Schreibt Kassettenvorspann.</p>
        <p class="hanging"><strong>FAF $F7EA</strong><br>
        Lädt angegebenen Kassettenvorspann.</p>
        <p class="hanging"><strong>TRD $F84 A</strong><br>
        Lädt vom Kassettengerät.</p>
        <p class="hanging"><strong>TWRT $F867</strong><br>
        Schreibt zum Kassettengerät.</p>
        <p class="hanging"><strong>READ $F92C</strong><br>
        Kassetten-Lese-Routinen.</p>
        <p class="hanging"><strong>WRITE $FBA6</strong><br>
        Routinen für Schreiben auf Kassette.</p>
        <p class="hanging"><strong>START $FCE2</strong><br>
        Reset-Routine. Einschalten des »64« oder ein Reset-Schalter verursachen einen Sprung hierher, SYS 64738 springt hierher, es sei denn, das RAM unter dem Kernel ist aktiviert. Ist bei $8000 ein Modul vorhanden, erfolgt JMP ($8000), andernfalls laufen RAMTAS, RESTOR, IOINIT, CINT und ein Basic-Kaltstart ab. Sonstiges RAM bleibt unverändert; Basic-Programme lassen sich daher wiedergewinnen.</p>
        <p class="hanging"><strong>RESTOR $FD15</strong><br>
        Kernel-Routine RESTOR.</p>
        <p class="hanging"><strong>VECTOR $FD1A</strong><br>
        Kernel-Routine VECTOR.</p>
        <p class="hanging"><strong>RAMTAS $FD50</strong><br>
        Kernel-Routine RAMTAS.</p>
        <p class="hanging"><strong>IOINIT $FDA3</strong><br>
        Kernel-Routine lOINIT.</p>
        <p class="hanging"><strong>SETNAM $FDF9</strong><br>
        Kernel-Routine SETNAM.</p>
        <p class="hanging"><strong>SETLFS $FE00</strong><br>
        Kernel-Routine SETFLS.</p>
        <p class="hanging"><strong>READST $FE07</strong><br>
        Kernel-Routine READST.</p>
        <p class="hanging"><strong>SETMSG $FE18</strong><br>
        Kernele-Routine SETMSG.</p>
        <p class="hanging"><strong>SETTMO $FE21</strong><br>
        Kernel-Routine SETTMO.</p>
        <p class="hanging"><strong>MEMTOP $FE25</strong><br>
        Kernel-Routine MEMTOP.</p>
        <p class="hanging"><strong>MEMBOT $FE34</strong><br>
        Kernel-Routine MEMBOT.</p>
        <p class="hanging"><strong>NMI $FE43</strong><br>
        NMI-Routine. Alle NMIs laden hier (es sei denn, der Kernel wurde im RAM modifiziert) und werden über den Vektor in ($0318) gelenkt. STOP-RESTORE, RS232-Betrieb und benutzerdefinierte NMIs werden sämtlich hier verarbeitet.</p>
        <p class="hanging"><strong>TIMB $FE66</strong><br>
        POST-RESTORE oder die BRKs »Not-Rücksetz-Routine«.</p>
        <p class="hanging"><strong>NNM121 $FE66</strong><br>
        Prüft RS232-Schnittstelle und sendet Bit, wenn möglich.</p>
        <p class="hanging"><strong>NNM130 $FEA3</strong><br>
        Prüft RS232-Schnittstelle und empfängt Bit, wenn möglich.</p>
        <p class="hanging"><strong>BAUDOT $FEC2</strong><br>
        Baudaten-Tabelle für RS232</p>
        <p class="hanging"><strong>T2NMI $FED6</strong><br>
        Behandelt Eingang eines RS232-Bits.</p>
        <p class="hanging"><strong>FLNMI $FF07</strong><br>
        Behandelt zeitliche Abstimmung des Startbits für RS232.</p>
        <p class="hanging"><strong>PULS $FF48</strong><br>
        Einsprung für IRQ oder BRK. Alle IRQ-Interrupts laufen über diesen Punkt (es sei denn, der Kernel wurde am RAM modifiziert). IRQ lenkt ein Vektor in ($0314), BRK-Befehle ein Vektor in ($0316); Änderungen beider Routinen durch den Benutzer sind daher häufig.</p>
        <p class="hanging"><strong>CINT $FF81</strong><br>
        Setzt die Interrupt-Frequenz.</p>
        <p class="hanging"><strong>IOINIT $FF84</strong><br>
        Initialisiert die Ein-/Ausgabe-Chips.</p>
        <p class="hanging"><strong>RAMTAS $FF87</strong><br>
        Testet und setzt RAM.</p>
        <p class="hanging"><strong>RESTOR $FF8A</strong><br>
        Restauriert Standard-Ein-/Ausgabevektoren.</p>
        <p class="hanging"><strong>VECTOR $FF8D</strong><br>
        Speichert/setzt Ein/Ausgabevektoren.</p>
        <p class="hanging"><strong>SETMSG £FF90</strong><br>
        Gibt Meldung zum Bildschirm aus.</p>
        <p class="hanging"><strong>SECOND $FF93</strong><br>
        Sendet Sekundäradresse nach LISTEN über den seriellen Bus.</p>
        <p class="hanging"><strong>TKSA $FF96</strong><br>
        Sendet Sekundäradresse nach TALK über den seriellen Bus.</p>
        <p class="hanging"><strong>MEMTOP $FF99</strong><br>
        Liest/setzt die obere Grenze des Speichers für Basic.</p>
        <p class="hanging"><strong>MEMBOT $FF82</strong><br>
        Liest/setzt die untere Grenze des Speichers für Basic.</p>
        <p class="hanging"><strong>SCNKEY $FF9F</strong><br>
        Naturabfrage.</p>
        <p class="hanging"><strong>SETTMO $FFA2</strong><br>
        Setzt TIMEOUT für seriellen Bus.</p>
        <p class="hanging"><strong>ACPTR $FFA5</strong><br>
        Holt ein Byte von einem seriellen Gerät (gewöhnlich Floppy-Disk).</p>
        <p class="hanging"><strong>CIOUT $FFA8</strong><br>
        Gibt ein Byte zum seriellen Bus aus (gewöhnlich für Drucker oder Floppy-Disk).</p>
        <p class="hanging"><strong>UNTALK $FFAB</strong><br>
        desaktiviert sendende Geräte am seriellen Bus.</p>
        <p class="hanging"><strong>UNLSN $FFAE</strong><br>
        desaktiviert empfangende Geräte am seriellen Bus.</p>
        <p class="hanging"><strong>LISTN $FFB1</strong><br>
        Schaltet Gerät am seriellen Bus auf Empfang (gewöhnlich Drucker oder Floppy-Disk).</p>
        <p class="hanging"><strong>READST $FFB7</strong><br>
        Liest das Status-Byte nach A ein.</p>
        <p class="hanging"><strong>SETLFS $FFBA</strong><br>
        Setzt Dateinummer, Gerät, Sekundäradresse.</p>
        <p class="hanging"><strong>SETNAM FFBD</strong><br>
        Setzt Dateinamen.</p>
        <p class="hanging"><strong>OPEN $FFC0</strong><br>
        Öffnet Datei zum Lesen/Schreiben.
        <p class="hanging"><strong>CLOSE $FFC3</strong><br>
        Schließt eine Datei.</p>
        <p class="hanging"><strong>CHKIN $FFC6</strong><br>
        Eröffnet Eingabekanal.</p>
        <p class="hanging"><strong>CHKOUT $FFC9</strong><br>
        Eröffnet Ausgabekanal.</p>
        <p class="hanging"><strong>CLRCHN $FFCC</strong><br>
        Schließt Kanal, stellt die Standardbedingungen für I/O wieder her.</p>
        <p class="hanging"><strong>CHRIN $FFCF</strong><br>
        Holt ein Zeichen.</p>
        <p class="hanging"><strong>CHROUT $FFD2</strong><br>
        Gibt ein Zeichen aus.</p>
        <p class="hanging"><strong>LOAD $FFD5</strong><br>
        Lädt ein Programm (von Diskette oder Band).</p>
        <p class="hanging"><strong>SAVE $FFD8</strong><br>
        Speichert einen Bereich als Programm (auf Diskette oder Band).</p>
        <p class="hanging"><strong>SETTIM $FFDB</strong><br>
        Setzt Taktzähler. (BASIC 2 VERIFY)</p>
        <p class="hanging"><strong>RDTIM $FFDE</strong><br>
        Liest Taktzähler. (BASIC 2 SYS)</p>
        <p class="hanging"><strong>STOP $FFE1</strong><br>
        Prüft auf die STOP-Taste.</p>
        <p class="hanging"><strong>GETIN $FFE4</strong><br>
        Holt ein Zeichen (gewöhnlich von der Tastatur — GET).</p>
        <p class="hanging"><strong>CLALL $FFE7</strong><br>
        Beendet jeglichen I/O-Betrieb und schließt alle Dateien.</p>
        <p class="hanging"><strong>UDTIM $FFEA</strong><br>
        Addiert 1 zum Taktzähler; auf Null stellen, wenn 240&thinsp;000.</p>
        <p class="hanging"><strong>SCREEN $FFED</strong><br>
        Holt Anzahl von Zeilen und Spalten.</p>
        <p class="hanging"><strong>PLOT $FFF0</strong><br>
        Liest/setzt Cursor.</p>
        <p class="hanging"><strong>OBASE $FFF3</strong><br>
        Startadresse des Tastatur-VIA.</p>

        <h2>Nützliche PEEKs und POKEs</h2>

        <p class="hanging"><strong>PRINT PEEK(17)</strong><br>
        Anzeige von 0: die letzte Eingabe wurde über die Anweisung INPUT vorgenommen<br>
        Anzeige von 64: die letzte Eingabe wurde über die Anweisung GET vorgenommen<br>
        Anzeige von 152: die letzte Eingabe wurde über READ vorgenommen</p>
        <p class="hanging"><strong>PRINT PEEK(43)+256*PEEK(44)</strong><br>
        Ausgabe der Adresse, von wo aus das Basic-Programm gespeichert ist</p>
        <p class="hanging"><strong>PRINT PEEK(45)+256*PEEK(46)</strong><br>
        Ausgabe der Adresse, bis wohin das Basic-Programm reicht</p>
        <p class="hanging"><strong>PRINT PEEK(47)+256*PEEK(48)</strong><br>
        Ausgabe der Adresse, bis wohin die Variablen reichen</p>
        <p class="hanging"><strong>PRINT PEEK(49)+256*PEEK(50)</strong><br>
        Ausgabe der Adresse, bis wohin die Felder reichen</p>
        <p class="hanging"><strong>PRINT PEEK(55)+256*PEEK(56)</strong><br>
        Ausgabe der Adresse, bis wohin der Basic-Arbeitsspeicher reicht</p>
        <p class="hanging"><strong>PRINT PEEK(57)+256*PEEK(58)</strong><br>
        Ausgabe der Nummer der momentan bearbeiteten Programmzeile</p>
        <p class="hanging"><strong>PRINT PEEK(63)+256*PEEK(64)</strong><br>
        Ausgabe der Nummer derjenigen DATA-Zeile, aus der Daten entnommen werden (READ-Befehl)</p>
        <p class="hanging"><strong>PRINT CHR$(PEEK(69)AND127) + CHR$(PEEK(70)AND127)</strong><br>
        Ausgabe des zuletzt benutzten Variablennamens</p>
        <p class="hanging"><strong>PRINT PEEK(198)</strong><br>
        Ausgabe der Anzahl der im Tastaturpuffer gespeicherten Zeichen</p>
        <p class="hanging"><strong>POKE 198,0</strong><br>
        Der Tastaturpuffer wird geleert</p>
        <p class="hanging"><strong>PRINT PEEK(214)</strong><br>
        Ausgabe der Nummer der Zeile, in der sich der Cursor befindet; dabei werden die Zeilen von 0 bis 24 ( = 25 Zeilen) gezählt</p>
        <p class="hanging"><strong>POKE 214,Z : POKE 211,S : SYS 58640</strong><br>
        Diese Befehlssequenz setzt den Cursor unmittelbar auf die mittels Z und S angegebene Zeilen- beziehungsweise Spaltenposition, wobei die Zeilen von 0 bis 39 und die Spalten von 0 bis 24 gezählt werden</p>
        <p class="hanging"><strong>PRINT PEEK(641)+256*PEEK(642)</strong><br>
        Ausgabe der Adresse, von wo ab der für Basic nutzbare RAM-Bereich beginnt</p>
        <p class="hanging"><strong>PRINT PEEK(643)+256*PEEK(644)</strong><br>
        Ausgabe der Adresse, bis wohin der für Basic nutzbare RAM-Bereich reicht</p>
        <p class="hanging"><strong>POKE 641,AL : POKE 642,AH : SYS 58260</strong><br>
        Die Anfangsadresse für Basic-Programme wird auf den Wert AL+256*AH festgelegt</p>
        <p class="hanging"><strong>POKE 643,EL : POKE 644,EH : SYS 58260</strong><br>
        Die Endadresse für den Basic-Arbeitsspeicher wird auf den Wert EL+256*EH festgelegt</p>
        <p class="hanging"><strong>PRINT PEEK(646)</strong><br>
        Anzeige der Nummer der momentanen Zeichenfarbe</p>
        <p class="hanging"><strong>POKE 646,F</strong><br>
        Einstellen der Zeichenfarbe, wobei F der Farbnummer entspricht</p>
        <p class="hanging"><strong>POKE 649,MX</strong><br>
        MX ist eine Zahl zwischen 0 und 10; diese POKE-Anweisung legt fest, wieviele Zeichen sich maximal im Tastaturpuffer befinden dürfen (der Grundwert ist 10); wenn also MX=0 gewählt wird, ist die Tastatur völlig abgeschaltet und keine Eingabe mehr ist möglich (Vorsicht!!)</p>
        <p class="hanging"><strong>POKE 650,128</strong><br>
        Die Tasten-Wiederholungs-Automatik wird auf alle Tasten ausgedehnt</p>
        <p class="hanging"><strong>POKE 650,64</strong><br>
        Die Tasten-Wiederholungs-Automatik wird für alle Tasten abgeschaltet</p>
        <p class="hanging"><strong>POKE 650,0</strong><br>
        Die Tasten-Wiederholungs-Automatik wird für die INST DEL-, die Leertaste und die Cursortasten eingeschaltet (Grundwert)</p>
        <p class="hanging"><strong>PRINT PEEK(653) AND 7</strong><br>
        Anzeige von 0: keine der Tasten SHIFT, CBM oder CTRL gedrückt<br>
        Anzeige von 1: die SHIFT-Taste ist gedrückt<br>
        Anzeige von 2: die CBM-Taste befindet sich in gedrückter Haltung<br>
        Anzeige von 4: die CTRL-Taste befindet sich in gedrückter Haltung<br>
        Anzeige von 3,5,6,7: diese Zahlen ergeben sich aus der Addition zweier oder aller drei oben beschriebenen Werte und geben somit an, daß sich die den Summanden zugeordneten Tasten in gedrückter Haltung befinden</p>
        <p class="hanging"><strong>POKE 657,128</strong><br>
        Umschaltungsverriegelung von dem Großschrift/Grafik-Modus in den Klein-/Großschrift-Modus</p>
        <p class="hanging"><strong>POKE 657,0</strong><br>
        Aufheben der Verriegelung (siehe voriger POKE-Befehl)</p>
        <p class="hanging"><strong>POKE 775,200</strong><br>
        LIST-Schutz einschalten</p>
        <p class="hanging"><strong>POKE 775,167</strong><br>
        LIST-Schutz ausschalten</p>
        <p class="hanging"><strong>POKE 788,52</strong><br>
        RUN-STOP-Taste wirkungslos machen</p>
        <p class="hanging"><strong>POKE 788,49</strong><br>
        RUN-STOP-Taste reaktivieren</p>
        <p class="hanging"><strong>POKE 801,0 : POKE 802,0 :</strong><br>
        Nach dieser Befehlssequenz wird das Speichern eines Programms unmöglich gemacht</p>
        <p class="hanging"><strong>POKE 808,225</strong><br>
        RUN-STOP- + RESTORE-Taste wirkungslos machen, außerdem erscheint ein »verrücktes« Listing</p>
        <p class="hanging"><strong>POKE 808,237</strong><br>
        RUN-STOP- + RESTORE-Taste reaktivieren</p>
        <p class="hanging"><strong>POKE 53265,11</strong><br>
        Bildschirminhalt unsichtbar machen, ohne daß dessen Inhalt verlorengeht</p>
        <p class="hanging"><strong>POKE 53265,27</strong><br>
        Bildschirminhalt wieder sichtbar machen</p>
        <p class="hanging"><strong>WAIT 56320,16,16</strong><br>
        Warten, bis beim Joystick Port 2:<br>
        der Feuerknopf gedrückt wird,</p>
        <p class="hanging"><strong>WAIT 56320,4,4</strong><br>
        Linksbewegung vorgenommen wird,</p>
        <p class="hanging"><strong>WAIT 56320,1,1</strong><br>
        Bewegung nach oben erfolgt,</p>
        <p class="hanging"><strong>WAIT 56320,2,2</strong><br>
        Bewegung nach unten erfolgt,</p>
        <p class="hanging"><strong>WAIT 56320,8,8</strong><br>
        Rechtsbewegung vorgenommen wird</p>
        <p class="hanging"><strong>WAIT 56321,16,16</strong><br>
        Warten, bis beim Joystick Port 1:<br>
        der Feuerknopf gedrückt wird,<br>
        (Richtungsabfragen analog zu Joystick Port 2)</p>
    </article>
</body>

</html>