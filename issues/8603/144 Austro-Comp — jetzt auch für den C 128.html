<!DOCTYPE html>
<html lang="de">

<head>
    <title>Austro-Comp — jetzt auch für den C 128</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Udo Reetz, ah">
    <meta name="64er.issue" content="3/86">
    <meta name="64er.pages" content="144,148">
    <!-- <meta name="64er.toc_category" content="XXX"> -->
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="XXX">
</head>

<body>
    <article>
        <h1>Austro-Comp — jetzt auch für den C 128</h1>
<p class="intro">Basic-Programme beschleunigen und vor Raubkopierern schützen waren nur zwei Bedingungen, die bei der Entwicklung dieses Compilers berücksichtigt wurden. Was noch in ihm steckt und was er leistet, soll dieser Test Ihnen zeigen.</p>

<p>Kaum gibt es einen neuen Computer, dauert es nicht allzu lange, bis die ersten neuen Programme dafür auf den Markt kommen. Austro-Comp 128 war eines der ersten Programme auf dem Anwendersektor, es erschien bereits Mitte 85. Austro-Comp 128 ist, wie der Name schon verrät, ein naher Verwandter des vom C 64 her bekannten Compilers. Die Möglichkeiten, Vor- und Nachteile dieses neuen Compilers sollen im nachfolgenden Test dargestellt werden.</p>

<p>Bei der Erstellung des Austro-Comp 128 wurde auf folgende Punkte großen Wert gelegt:</p>

<ol>
<li>Bei der Programmierung wurde auf eine volle Kompatibilität zum Basic 7.0 des C 128 geachtet. Weiterhin akzeptiert der Compiler auch sogenannte »Extensions«, Befehle, die im Befehlsvorrat nicht vorhanden sind.</li>
<li>Die Ausführungszeiten sollten gegenüber anderen Compilern verkürzt werden.</li>
<li>Der P-Code sollte um einiges verkürzt werden, um auch längere Programme im Speicher zu halten. Auch sollte der P-Code leicht vom Benutzer veränderbar sein.</li>
</ol>


<p>Zu Punkt 1, der Kompatibilität, gibt es, wie kann es auch anders sein, natürlich einige kleine Einschränkungen, die allerdings nur eine Gewohnheitssache darstellen. Die Befehle TRAP, RESUME, COLLISION, GRAPHIC CLR, CONT und die Abfrage der STOP-Taste sind betroffen. Beim TRAP-Befehl darf keine Variable angegeben werden. Ein aktives TRAP wird durch das Nachladen eines Programmes ausgeschaltet. Folgt bei RESUME eine Sprungadresse, so darf auch nur eine Zeilennummer und keine Variable stehen. Das gleiche gilt auch für COLLISION.</p>

<p>Taucht während des Compilierens ein GRAPHIC CLR auf, so werden die 9 KByte für den HiRes-Speicher nicht freigegeben, es wird nur ein GRAPHIC 0 ausgeführt. Nach einem STOP während des Ablaufs eines compilierten Programms kann dieses nicht mit CONT fortgesetzt werden. Die Abfrage der STOP-Taste ist während des Programmablaufs außer Funktion gesetzt, da beim C 128 durch die eingebaute RESET-Taste ein Abbruch jederzeit möglich ist. Meist kann ein Ausstieg mit STOP-RESTORE erzwungen werden.</p>

<h2>Leichte Bedienung</h2>

<p>Das Arbeiten mit Austro-Comp 128 ist sehr einfach. Der Compiler wird dazu in den Arbeitsspeicher des C 128 geladen und durch RUN gestartet. Danach werden keine zusätzlichen Programme mehr benötigt. Sollen mehrere Programme hintereinander compiliert werden, so kann man den Compiler nach Beendigung des Übersetzens erneut mit RUN starten.</p>

<p>Als erstes wird der Anwender nach der Sprache, in der die Meldungen erscheinen sollen, gefragt. Im darauffolgenden Hauptmenü kann man nun zwischen drei unterschiedlichen Compilierarten wählen, die die Ausführungszeit und die Länge des compilierten Basic-Programms beeinflussen und außerdem den zu übersetzenden Befehlsvorrat bestimmen. Weiterhin kann man die Anzahl der Floppy-Laufwerke bestimmen, mit der man zusammenarbeiten möchte. Beim Menüpunkt 2 und 3 wird der Benutzer mit Hilfe von Untermenüs sicher geführt.</p>

<p>Beim Compilieren arbeitet Austro-Comp mit zwei Durchläufen (Passes), in der Betriebsart OVERLAY sogar mit drei Durchläufen. Im ersten Paß wird das Basic-Programm in einen P-Code übersetzt und dabei auf Fehler überprüft. Hierbei können folgende Fehlermeldungen auftreten:<br>
SYNTAX ERROR und TYPE MISMATCH ERROR:</p>

<p>Wird ein solcher Fehler erkannt, dann wird der Fehler und die Zeilennummer aufgelistet, das Übersetzen wird aber nicht abgebrochen, um weitere eventuelle Fehler zu finden.<br>
BAD SUBSCRIPT ERROR :</p>

<p>Sollten einem Array verschiedene Dimensionierungen zugewiesen sein, so wird der Befehl übersetzt, da es ja möglich ist, nach CLR ein Array neu zu belegen.<br>
OVERFLOW ERROR :</p>

<p>Diese Meldung erfolgt, wenn eine Zahl größer als 1E38 ist.</p>

<p>Im zweiten Paß wird dann das Objekt-File zusammengestellt.</p>

<p>Austro-Comp 128 kennt weiterhin fünf Spezialanweisungen. Diese müssen im Basic-Programm stehen, werden aber, um den Programmablauf nicht zu beeinflussen, hinter REM-Anweisungen geschrieben. Die NG-Anweisung (keine Grafik) braucht nur gesetzt werden, wenn längere Programme compiliert werden sollen. Die FL-Anweisung veranlaßt, daß alle Fließkomma-Variablen in Integer-Variablen umgewandelt werden. Dies bringt erhebliche Geschwindigkeitsvorteile auch bei FOR-NEXT-Schleifen, da auch die Schleifenvariablen in INTEGER umgewandelt werden; das war in Basic bisher nicht möglich. Es wird dem Programmierer weiterhin eine fast perfekte Art des Programmschutzes geboten, mit der SP-Anweisung wird der Sperrdongel abgefragt. Ein Sperrdongel ist ein vergossener Baustein, der eine kleine Schaltung beinhaltet und auf den User-Port aufgesteckt wird. Ohne ihn würde ein compiliertes Programm gar nicht funktionieren.</p>

<p>Mit Hilfe von NE werden keine Extensions gelistet, RI setzt den eigenen INPUT-Puffer des Compilers zurück.</p>

<p>Sollte der Compiler einmal eine Extension nicht erkennen, so kann man sie mit zwei Doppelpunkten kennzeichnen.</p>

<p>Ein an ein Basic-Programm angehängtes Maschinenprogramm wird voll übernommen, allerdings ändert sich die Einsprungadresse, da sich die Programmlänge ändert. Das Nachladen eines Maschinenprogramms bereitet auch keine Probleme. Sollen bei einem SYS-Befehl Parameter mit übergeben werden, ist dies genauso möglich.</p>

<p>Ein weiterer Vorteil ist, daß Austro-Comp weniger Platz auf dem Stack belegt und man in der Lage ist, komplexere Programme zu schreiben als es mit dem Interpreter möglich ist.</p>

<p>Was jetzt von Interesse ist, sind die eigentlichen Zeitvorteile, die ein solcher Compiler bringt. Anhand zweier kleiner Basic-Programme soll der Sache auf den Grund gegangen werden.</p>

<p>Programm 1 füllt den Bildschirm, Programm 2 berechnet alle Primzahlen unter 1000.</p>

<p>TODO Listing/table</p>

<p>Im FAST-Modus halbieren sich die angegebenen Zeiten jeweils. Die Zeitersparnis liegt also bei zirka 20 bis 40 Prozent gegenüber reinem Basic. Allerdings fällt die Länge der compilierten Programme unangenehm auf. Das liegt an der Art, wie der Compiler seine Programme aufbereitet. Zum Abarbeiten des Compilats benötigt er noch zirka 11 KByte an Laufzeitroutinen, die leider mit zusätzlichen 44 Blocks auf der Diskette zu Buche schlagen. Dies fällt bei längeren Programmen zwar kaum ins Gewicht, denn schon Basic-Programme mit einer Länge von 100 Blocks sind compiliert nicht mehr länger, aber dafür schneller.</p>

<p>Dem neugierigen Programmierer fällt außerdem auf, daß ein und dasselbe Programm nach jedem Compilieren anders aussieht. Weiterhin lassen sich Texte und Adressen selbst mit einem Monitor nicht erkennen.</p>

<p class="source">Fazit: Ein für lange Programme und zeitintensive Aufgaben (Rechnungen und Grafiken) durchaus geeigneter Compiler mit guten Bedienungskomfort und verständlicher Anleitung. Für kleine Routinen allerdings bleibt dem Nicht-Maschinenspracheprogrammierer nur das Basic als Alternative. Ein Trostpflaster bleibt: Der Käufer erhält gleich noch denselben Compiler für den C 64-Modus mit dazu &hellip;</p>

<address class="author">(Udo Reetz/ah)</address>

<p class="source">Info: DIGMAT, Arbeitergasse 48, A-1050 Wien, Preis: 1990 Schilling etwa 260 Mark inkl. MwSt.</p>
    </article>
</body>
</html>
