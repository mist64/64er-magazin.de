<!DOCTYPE html>
<html lang="de">

<head>
    <title>C 64 extern — Der Weg noch draußen (Teil 3)</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Tobias Nicol, aw">
    <meta name="64er.issue" content="10/85">
    <meta name="64er.pages" content="129-132">
    <meta name="64er.head1" content="Extern-Kurs">
    <meta name="64er.head2" content="C 64/VC 20">
    <meta name="64er.toc_category" content="Kurse">
    <meta name="64er.index_title" content="C 64 Extern – Der Weg nach draußen (Teil 3; Schluß)">
    <meta name="64er.index_category" content="Kurse|Extern">
    <meta name="64er.id" content="extern">
</head>

<body>
    <article>
        <h1>C 64 extern — Der Weg noch draußen (Teil 3)</h1>
        <p class="intro">Nachdem wir in der letzten Folge die Programmierung der Control-Ports abgeschlossen haben, wenden wir uns heute einer der vielseitigsten Schnittstellen des C 64/VC 20 zu — dem User-Port.</p>

        <p>Der User-Port führte neben dem Expansion-Port lange Zeit ein Schattendasein, denn an ihm können keine Programm-Module verwendet werden. Mittlerweile hat der User-Port aber weit aufgeholt. Er wird für Steuerzwecke, zum Anschluß eines Druckers, für die RS232 und auch zum Programmieren von EPROMs mit einem Zusatzgerät verwendet. Sehen wir uns diese interessante Schnittstelle etwas genauer an. Die Anschlußbelegung der User-Ports von C 64 und VC 20 zeigen die Bilder 1 und 2. Beachten Sie bitte, daß die Anschlüsse an der Ober- und Unterseite des User-Ports verschiedene Funktionen haben. Klemmen Sie deshalb dort niemals eine Krokodilklemme oder vergleichbares an! Ich möchte Ihnen nun zuerst zeigen, wie der 8-Bit-Parallelport am User-Port programmiert wird. Dieser Port bietet sehr vielseitige Anwendungsmöglichkeiten, obwohl er einfach zu programmieren ist. Angesprochen wird er über die acht Leitungen PB0 bis PB7 (Pin C bis L).</p>

        <p>Über den Parallelport kann man Daten einlesen und Daten ausgeben. Das Praktische an dieser Tatsache ist, daß man die Richtung der Daten für jede der acht Leitungen einzeln bestimmen kann. Warum es aber gerade acht Leitungen gibt, hat einen einfachen Grund: Zur Steuerung des Ports gibt es im Computer zwei verschiedene Speicherstellen. Jeder Leitung am Port ist in jeder dieser Speicherstellen genau ein Bit zugeordnet. Daher also acht Leitungen, gleich acht Bit, gleich ein Byte.</p>

        <p>Welche Bedeutungen haben nun diese beiden Speicherzellen? Die erste nennt sich »DDR«. Das heißt »Data Direction Register« (Datenrichtungsregister). Hier wird, wie der Name schon sagt, die Datenrichtung festgelegt. Aber wie? Dem Bit X im DDR ist die Datenleitung PBX zugeordnet. Ist zum Beispiel Bit 2 in diesem Register auf 1, dann ist die Leitung PB2 als Ausgang deklariert. Eine 0 macht die entsprechende Leitung zum Eingang. So einfach ist das!</p>

        <p>Die zweite bereits genannte Speicherstelle enthält die eigentlichen Daten. Man bezeichnet sie als Portregister.</p>

        <p>Nehmen wir einmal an, wir hätten in das Datenrichtungsregister die Zahl 255 eingeschrieben, also alle Leitungen als Ausgänge programmiert. Eine 255 im Portregister legt dann High-Pegel auf alle acht Datenleitungen. Eine 0 im Portregister bewirkt GND auf allen Datenleitungen. Man kann also wie im Datenrichtungsregister bitweise den Spannungszustand am Ausgang bestimmen (l = high, 0 = low). Hierbei ist Bit 0 wieder PB0 zugeordnet. Die Spannungspegel, die wir am Port erhalten, können wir dann »extern« verarbeiten, doch davon später.</p>

        <p>Im zweiten Beispiel benutzen wir den Parallelport als Eingang. Nehmen wir an, wir hätten in das Datenrichtungsregister eine 0 eingeschoben, also alle Datenleitungen als Eingänge definiert. Jetzt müssen wir »externe« Daten an den Port anlegen. Das geschieht durch Verbinden der Datenleitungen entweder mit + 5 V oder GND der Computerversorgungsspannung. Dabei entspricht einer »0« GND und eine »1« + 5V. Eine »1« entsteht auch, wenn eine Leitung nicht angeschlossen, also weder mit + 5 V noch mit GND verbunden wird. Das spart oft viel Schaltungsaufwand. Die an den Port angelegte Bitkombination kann jederzeit durch Abfragen des Portregisters ausgelesen werden. Der neue Zustand der Datenleitungen wird, wenn sich etwas geändert hat, jeweils sofort und automatisch in das Portregister übernommen.</p>

        <p>Die beiden Funktionen Eingänge/Ausgänge dürfen, wie schon gesagt, beliebig gemischt werden. So ist beispielsweise möglich, die Leitungen 2, 5 und 7 als Ausgänge und alle restlichen Leitungen als Eingänge zu definieren. Dazu müßte man im Datenrichtungsregister die Zahl 164 ablegen (164 = Bits 2, 5 und 7 gesetzt). Die Information über die Spannungszustände an den Ausgängen müßte in die Bits 2, 5 und 7 des Portregisters gePOKEt und die Information über die Eingänge aus den Bits 0, 1, 3, 4 und 6 des Portregisters ausgelesen werden.</p>

        <p>Nach soviel grauer Theorie wollen wir endlich wieder etwas programmieren. Bevor es losgeht, müssen Sie noch wissen, wie die Adressen der eben besprochenen Speicherstellen lauten. Sie sind in Tabelle 1 aufgelistet. Jetzt haben wir alles nötige Rüstzeug, um voll in eine sinnvolle Anwendung des Computers einzusteigen: Programmieren wir eine Alarmanlage!</p>

        <h2>Alarmanlage per User-Port</h2>

        <p>Tippen Sie Listing 1 ab und starten Sie das Programm mit RUN. Auf dem Bildschirm erscheint der Kontaktplan des Parallelports. Hoffentlich haben Sie beim Einkauf für die letzte Folge an den Stecker für den User-Port gedacht, den brauchen wir nämlich jetzt.</p>

        <p>Bringen Sie an einem der vier Eckkontakte ( = GND, siehe Bild 1) des User-Port-Steckers einen Draht an, und stecken Sie den Stecker in den User-Port. Zum Anbringen des Drahtes ist Löten wohl das Beste. Keinesfalls dürfen Sie einen anderen Anschluß versehentlich berühren, beziehungsweise mit GND in Verbindung bringen.</p>

        <figure>
            <img src="129-1.png" alt="">
            TODO Table
            <figcaption>Bild 1. Anschlußbelegung des C 64 User-Ports. (Bei Aufsicht auf die Computerrückseite)</figcaption>
        </figure>

        <p>Nehmen Sie sich nun das andere Ende des Drahtes zur Hand, und berühren Sie damit eine der Datenleitungen PB1 bis PB7. Bitte nicht die Datenleitung PB0, da diese vom Programm als Ausgang (Alarmanzeiger) benutzt wird (was wir mit diesem machen können, sehen wir in der nächsten Folge). Welche Pins die richtigen sind, können Sie Bild 1 und 2 entnehmen.</p>

        <figure>
            <img src="129-2.png" alt="">
            TODO Table
            <figcaption>Bild 2. Anschlußbelegung des VC 20 User-Ports. (Bei Aufsicht auf die Computerrückseite)</figcaption>
        </figure>

        <p>Beim Berühren erklingt ein Alarmton, der Bildschirmrahmen ändert die Farbe, und der Alarmanzeiger (PB0) geht auf high (+5 V). Zusätzlich wird auf dem Bildschirm angezeigt, welche Kontakte den Alarm ausgelöst haben. Wenn Sie keine der Datenleitung mehr mit dem Draht berühren, die Eingänge also alle High-Signal erhalten, werden alle Alarmsignale sofort gelöscht.</p>

        <p>Werfen wir einen Blick auf das Listing. Nach der Initialisierung der Variablen, der Portregister, des SID-Chips und des Bildschirms wird in Zeile 390 das Portregister (Variable R) so lange ausgelesen, bis ein anderer Wert als 254 auftaucht. Warum 254? 254 ist die Summe der Wertigkeiten der Bits 1 bis 7, also aller Bits des Portregisters ohne den Alarmanzeiger. Das ist der Ruhezustand der Alarmanzeige; alle Kontakte sind geöffnet ( = High-Pegel).</p>

        <p>Wird ein Alarm ausgelöst, dann werden ab Zeile 430 sämtliche Alarmanzeiger eingeschaltet. Ab Zeile 470 wird ein neuer Kontaktplan ausgegeben. Dabei wird jeder Kontakt auf Alarm überprüft und das Ergebnis angezeigt.</p>

        <p>Anschließend wartet der Computer auf das Alarmende. Wenn noch Alarm besteht, wird wieder ein neuer Kontaktplan ausgegeben, weil sich am Kontaktzustand etwas geändert haben kann. Andernfalls werden die Alarmanzeiger ausgeschaltet und es wird zur Bildschirminitialisierung zurückgesprungen.</p>

        <p>Wer sich das Programm genau ansieht, wird schnell feststellen, daß es so, wie es hier abgedruckt ist, zum realen Einsatz als Alarmanlage weniger geeignet ist. Dazu hat es verschiedene Schwächen. Zum einen wird nicht mit Sicherheit jeder Alarm erkannt: Wenn der Alarmimpuls sehr kurz ist, kann es passieren, daß der C 64 gerade etwas anderes tut, als das Portregister auszulesen, zum Beispiel den Rücksprung nach 390 ausführen. Außerdem ist der eigentlich alarmauslösende Zustand am Portregister nicht der, der ausgewertet wird, weil der auszuwertende Zustand erst nach dem Alarmauslösen in Zeile 420 ermittelt wird. In der Zwischenzeit kann sich schon etwas verändert haben. Das genannte trifft aber nur auf sehr kurze Impulse zu.</p>

        <p>Zum anderen ist die Auswertung des Alarmes viel zu einfach gehalten, eben nur als Beispiel. Wenn hier ein Alarm von einer Sekunde auftritt, wird auch nur eine Sekunde lang Alarm gegeben, was natürlich viel zu wenig ist.</p>

        <h2>Codeschloß</h2>

        <p>Kommen wir zu einem weiteren Programmbeispiel, dem Codeschloß in Listing 2. Wir haben es wieder mit Raumsicherung zu tun. Wieder wird die Datenleitung PB0 als Ausgang und die restlichen Datenleitungen als Eingänge benutzt.</p>

        <p>Was leistet das Programm? Sie müssen durch Verbinden der Datenleitungen PB2 bis PB7 einen sechsstelligen Code eingeben. Wenn Sie keinen Fehler gemacht haben, wird die Datenleitung PB0 auf high gelegt, also beispielsweise eine Tür geöffnet oder eine geheime Anlage eingeschaltet. Wie Sie solche Dinge ansteuern können, erfahren Sie im nächsten Teil dieses Kurses. Über die Leitung PB1 wird das Codeschloß zurückgesetzt (sowohl nach dem Auslösen des Schlosses als auch nach einer Fehlereingabe). Jede Berührung an den Eingängen wird durch einen Signalton quittiert.</p>

        <p>In den Zeilen 250/260 werden zwei Variablen deklariert, deren Bedeutung ich kurz erläutern möchte. CL enthält die Länge des einzugebenden Codes, CI$ den Code selbst. Den Inhalt dieser beiden Variablen können Sie nach Belieben verändern. Der von mir gewählte Code ist bewußt sehr primitiv.</p>

        <p>In C2$ wird der Code aufgebaut, den Sie durch Berühren der »externen« Kontakte eingeben. Der große Vorteil hierbei ist, daß die Eingabeeinheit für den Code an einer anderen Stelle (zum Beispiel im Nebenraum) als der Computer sein kann. Man wird also von der Computertastatur unabhängig. Mit einem langen Code wird ein Knacken theoretisch unmöglich. Da sich das Programm durch REM-Anweisungen selbst dokumentiert, bleibt nur noch zu sagen, daß es der Einfachheit halber bei jedem »RESET« an Kontakt PB1 einfach neu mit RUN gestartet wird.</p>

        <p>Auch bei diesem Programm ist nur eine Minimallösung angegeben. Man kann es um viele Raffinessen erweitern, so daß zum Beispiel ein Einbruchsversuch als solcher gedeutet wird und so weiter.</p>

        <p>Nachdem wir nun wissen was sich am User-Port abspielt, wollen wir noch einmal einen Schritt zurückgehen. Im ersten Teil dieses Kurses sind ein paar Fragen offen geblieben, die ich jetzt beantworten möchte.</p>

        <p>Da war als erstes die Sache mit der Umschaltung des Computers auf Joystickeingabe. Vielleicht haben Sie schon eine Ähnlichkeit zwischen Joystick- und Parallelport-Programmierung entdeckt. Bei beiden mußte etwas umgeschaltet werden. Dann gab es zwei mögliche Zustände: 0 oder 1! Die Umschaltung des Computers auf Joystickeingabe ist nichts anderes als die Programmierung des zugehörigen Datenrichtungsregisters. Bitte ,erinnern Sie sich: Wir haben bei der Umschaltung die zugehörigen Bits gelöscht, also die Datenleitungen der Control-Ports zu Eingängen gemacht. Wer darüber nachdenkt, wird schnell zu der Frage kommen, was denn passiert, wenn wir in die DDRs einfach Einsen hineinschreiben. Die Antwort ist trivial: Die Joystickleitungen werden zu Ausgängen! Doch darum wollen wir uns erst im dritten Teil dieses Kurses kümmern. Die Zusammenstellung aller Adressen, die hierfür interessant sind, zeigt Tabelle 2.</p>

        <p>Als nächstes interessiert Sie wahrscheinlich, warum eigentlich Paddles, Joystick, Lichtgriffel und Tastatur einander behindern. Das kommt daher, daß alle diese Eingabeeinheiten dieselben Datenleitungen benutzen. Aus diesem Grund sind auch die Umschaltungen notwendig.</p>

        <p>Warum aber benutzt die Tastatur Leitungen am Control-Port? Eine Computertastatur ist durch eine Matrix aus Zeilen und Spalten mit dem Computer verbunden. An jedem Kreuzungspunkt sitzt eine Taste, die, wenn sie gedrückt wird, die beiden Leitungen des Kreuzungspunktes miteinander verbindet. Die Routine des Betriebssystems, welche die Tastatur abfragt, legt nun an eine Zeile ein Signal an und überprüft, in welcher Spalte dieses Signal auftritt. Daraus läßt sich ableiten, welche Taste gedrückt ist. Wird kein Signal entdeckt, so ist in dieser Zeile keine Taste gedrückt, und das Signal wird an die nächste Zeile angelegt. Aus diesem Verfahren erklärt sich, warum einige Tasten Priorität gegenüber anderen haben. Das können Sie feststellen, indem Sie mehrmals zwei Tasten gleichzeitig drücken. Es wird immer dieselbe Taste vom Computer registriert werden.</p>

        <p>Diese Zeilen- und Spaltenmatrix liegt auf denselben Leitungen wie der Joystick, weil auch hier »externe« Signale gegeben und Informationen gelesen werden müssen, wozu unser Computer eben nur eine bestimmte Anzahl von Bausteinen hat. Deshalb funktioniert die Tastatur nach dem POKEn in die Control-Port-DDRs meist nicht mehr, weil sie nicht mehr ordnungsgemäß decodiert wird. Die Werte, die in bestimmte Speicherzellen immer wieder hineingeschrieben werden (siehe Folge 1) stammen auch aus der Tastaturdecodierungs-Routine.</p>

        <p>Die Störung der Tastatur kommt nun daher, daß es dem Computer völlig gleichgültig ist, ob Sie den Joystickhebel bewegen oder auf die Tasten hämmern. Er prüft artig seine Spalten nach und kümmert sich nicht darum, woher die festgestellte Verbindung denn nun kam. Die Störung durch den Lichtgriffel hat dieselbe Ursache.</p>

        <p>Jetzt müssen wir nur noch einen Rückstand aus der letzten Folge aufklären. Dabei handelt es sich um die Feuerknöpfe der Paddles. Ich kann Ihnen erst jetzt zeigen wie sie abgefragt werden, weil wir auch hier die Kenntnisse über die Programmierung des Parallelports benötigen. Es funktioniert nämlich schon wieder genauso: Man setze im zugehörigen DDR die entsprechenden Bits auf Null (Leitung auf Eingang schalten) und frage dann die entsprechenden Bits im zugehörigen Portregister ab. Natürlich zeigt auch hier wieder eine Null im Portregister an, daß der Feuerknopf am Paddle gedrückt wurde. In Tabelle 3 sind die nötigen Informationen für Port 1 des C 64, in Tabelle 4 die für den Port 2 und in Tabelle 5 die für den VC 20 zusammengefaßt. Dabei sind die Paddles gemäß der Position ihres Verbindungskabels am Control-Port mit links und rechts bezeichnet. Das rechte Paddle ist also an POT X, das linke an POT Y angeschlossen. Da die Feuerknöpfe der Paddles dieselben Leitungen wie der Joystick benutzen, gilt hier ebenfalls das oben Beschriebene über die gleichzeitige Benutzung von Paddles und Tastatur.</p>

        <p>Damit wollen wir es für heute bewenden lassen. Das nächste mal sehen wir dann, wie versprochen, wo sich den Control-Ports Signale entnehmen lassen. Außerdem wollen wir uns mit Anschlußmöglichkeiten verschiedener Adapter an den User-Port beschäftigen und unter anderem einen 220 Volt-Adapter für unseren Computer bauen!</p>

        <address class="author">(Tobias Nicol/aw)</address>
    </article>
</body>

</html>
