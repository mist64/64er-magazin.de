<!DOCTYPE html>
<html lang="de">

<head>
    <title>Directory auf Knopfdruck</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="ah">
    <meta name="64er.issue" content="Sonderheft 8/85">
    <meta name="64er.pages" content="152-153">
    <!-- <meta name="64er.toc_category" content="XXX"> -->
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="XXX">
</head>

<body>
    <article>
        <h1>Directory auf Knopfdruck</h1>
<p class="intro">Häufig steht man vor dem Problem, Programme direkt, also ohne SYS-Aufrufe, über einen Tastencode zu aktivieren. Wir zeigen Ihnen, wie man ein Directory auf dem Bildschirm ausgibt, ohne ein vorhandenes Basic-Programm zu zerstören.</p>

<p>Das Programm »Directory auf Knopfdruck« (siehe Listing 1) kann, nachdem es mit Hypra-Assassembliert wurde, mit dem Befehl SYS 49152 aktiviert werden.</p>

<p>Den erzeugten Maschinencode zeigt Listing 2, das auch direkt mit dem MSE eingegeben werden kann. Solange kein Reset ausgelöst oder die RUN/STOP-Taste gedrückt wird, erscheint bei der Tastenkombination »CTRL-D« das Directory auf dem Bildschirm, ohne ein eventuell im RAM stehendes Basic-Programm zu zerstören.</p>

<p>Der hier vorgestellte Lösungsweg, ein beliebiges Programm auf Tastendruck aufzurufen, hat den Vorteil, daß er allgemeingültig ist und nicht nur auf die Ausgabe des Directorys beschränkt ist.</p>

<p>Im allgemeinen müßte das Betriebssystem geändert werden, um eine zusätzliche Tastaturabfrage einzubinden. Aber wir haben Glück, denn einige Routinen im Betriebssystem werden über einen sogenannten Sprungvektor aufgerufen. Alle zugänglichen Sprungvektoren, die sich ändern lassen, befinden sich in der dritten Page, also im Bereich von $311 bis $333, jeweils im Low-/High-Byte-Format. Der zum Einbinden einer Tastaturabfrage geeignetste Vektor ist der Interruptvektor, denn diese sogenannte Interrupt-Routine wird 60mal pro Sekunde angesprungen. Ein Sprungvektor, der in diese Routine verzweigt, befindet sich in den Speicherzellen $314/$315. Die Speicherzellen enthalten im Normalzustand den Wert $31/$EA. Das bedeutet, daß immer, wenn ein Interrupt ausgelöst wird, zu einer Routine verzweigt wird, die bei $EA31 liegt. Schreibt man nun in die Speicherzellen $314/ $315 einen anderen Wert, wird bei einem Interrupt nicht mehr zur Adresse $EA31, sondern zu der Adresse verzweigt, die in den Speicherzellen $314/315 steht, wobei die Adresse $314das Low- und die Speicherzelle $315 das High-Byte der anzuspringenden, neuen Interrupt-Routine enthält. Damit sich der Vektor aber verändern läßt, muß zuerst der normale Interrupt gesperrt werden, denn sonst könnte folgendes passieren: Angenommen, es wird ein Interrupt ausgelöst, nachdem erst das Low-Byte in die Adresse $314 geschrieben wurde, dann nimmt der Computer an, daß die neue Interrupt-Routine bei $EAOO plus dem in Adresse $314 stehendem Low-Byte liegt, verzweigt an diese Adresse und stürzt ab.</p>

<p>Mit dem Maschinenbefehl »SEI« für SEt Interruptflag läßt sich nun der prozessorinterne Interrupt ausschalten. Dies wird in der Zeile 230 im Listing 1 realisiert. Die Zeilen 240 bis 270 sorgen dafür, daß die Startadresse der neuen Interrupt-Routine in die entsprechenden Adressen kommt. Eine Bemerkung noch zu den Zeilen 240 und 270. Durch das »kleiner«- beziehungsweise »größer«-Zeichen läßt sich eine 16-Bit-Adresse (in diesem Fall »INTER«) in zwei 8-Bit-Zahlen splitten. Durch das »kleiner«-Zeichen erhält man das Low- und entsprechend für das »größer«-Zeichen das High-Byte.</p>

<p>Der folgende »CLI«-Befehl (CLear Interruptflag) läßt nun den normalen Interrupt wieder zu. Nur wird jetzt, wenn ein Interruptstattfindet, nicht mehr zur Adresse $EA31, sondern zur Routine »INTER« verzweigt. Die Aufgabe des Teilprogramms »INTER« ist es, die »CTRL«- und »D«-Taste abzufragen. Sind beide Tasten gleichzeitig gedrückt, wird nach »DIR« verzweigt, ansonsten in der Zeile 420 zum normalen Interrupt nach $EA31. Die Zeilen 370 und 380 beziehungsweise 400 und 410 sperren auch den Interrupt, aber auf eine etwas andere Art.</p>

<p>Sie werden sich vielleicht fragen, warum der Interrupt überhaupt gesperrt werden muß. Die Antwort auf diese Frage ist leicht zu geben. Die Bearbeitung der Routine »DIR« dauert länger als 1/60 Sekunde. Dadurch würde bereits ein neuer Interrupt ausgelöst, bevorderalteabgearbeitetwäre. Die Art, wie der Interrupt abgeschaltet wird, wurde mit Absicht so gewählt, da einige Routinen im Betriebssystem den Interrupt durch den CLI-Befehl wieder zulassen, so auch die Routine »CHROUT«, die ein Zeichen auf einem Gerät, hier dem Bildschirm, ausgibt. Durch die Befehle »LDA #TIMERAUS« und »STA ICR« wird eigentlich nicht der Interrupt abgeschaltet, sondern der Timer gestoppt, der den Interrupt auslöst. Doch nun zum eigentlichen »DIR«-Programm.</p>

<p>Die Zeilen 450 bis 550 entsprechen dem Basic-Befehl »OPEN 1,8,0,"$"«. Dabei liegt das Augenmerk auf der Sekundäradresse »0« und dem Dollarzeichen. Das Dollarzeichen als Filename bewirkt, daß das Directory eingelesen wird und zwar einschließlich Track 18 Sektor 0. Durch die »0« als Sekundäradresse wird das Directory schon soweit aufbereitet, daß nur noch die Zeichen, die sich nach einem »LOAD"$",8« tatsächlich im RAM befinden, zum Computer gesendet werden, inklusive Filetyp, Steuerzeichen, Leerzeichen und Anzahl der Blöcke pro File. Leider enthält ein vom Floppy-Laufwerk gesendeter Directory-Eintrag auch noch Platzhalter für die Zeilenlinkadressen, die wir natürlich nicht brauchen und folglich ausblenden beziehungsweise überlesen müssen. Eine vom Floppy-Laufwerk gesendete Directory-Zeile hat folgendes Format:</p>

<p>LI LI AB SP "filename SP" SP FT</p>

<p>LI = Linkbyte; AB = Anzahl der Blöcke pro File im Low/ High-Byte-Format; SP = Leerzeichen; FT = Filetyp im Klartext.</p>

<p>Das einzige, was zu tun bleibt, ist die Ausgabe »RETURN« am Ende jeder Directory-Zeile (Zeile 811/812). Außerdem muß die Information, die die Anzahl der Blöcke pro File enthält, in dezimale Schreibweise umgerechnet und auf dem Bildschirm ausgegeben werden. Das ist aber kein Problem, denn das Betriebssystem stellt eine solche Routine »INTOUT=$BDCD« zur Verfügung. Wenn sie aufgerufen wird, muß der Akku das High- und das X-Register das Low-Byte der auszugebenden Zahl enthalten. Das Low-Byte wird in Zeile 590 an das X-Register übergeben. Das High-Byte dagegen wird in Zeile 630 durch das Unterprogramm »CHRIN« eingelesen und steht automatisch im Akku.</p>

<h3>Zum Programmablauf</h3>

<p>Die Zeilen 570 bis 620 überlesen 4 Byte beim ersten Durchlauf. Bei allen weiteren Durchläufen werden immer nur die ersten 2 Byte überlesen, die die Zeilenlinkadresse enthalten. Beim ersten Durchlauf wird neben der Zeilenlinkadresse auch die Startadresse ($0801) gesendet, die ebenfalls ausgeblendet werden muß, darum 4 Byte. Bei einem Sprung auf das Label »ROWOUT« enthält das Y-Register die Anzahl der Byte, die überlesen werden sollen plus 1. Wird die Schleife in Zeile 620 verlassen, enthält das X-Register das Low-Byte der Zahl, die die Anzahl der Blöcke pro File kennzeichnet. Das High-Byte wird in Zeile 630 eingelesen und an den Akku übergeben. Die nächste Schleife, die bei dem Label »NEXTCHR« beginnt, gibt den Rest eines Directory-Eintrags auf dem Bildschirm aus. Der »CMP«-Befehl in Zeile 730 überprüft, ob eine »0«, die das Ende des Eintrags kennzeichnet, gesendet wurde oder nicht. Bei einer »0« wird nach »LASTCHR« verzweigt, ein »RETURN« ausgegeben und zum Label »ROWOUT« gesprungen.</p>

<address class="author">(ah)</address>
    </article>
</body>
</html>
