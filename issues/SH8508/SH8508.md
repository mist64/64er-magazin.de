
# Effektives Programmieren in Assembler [74-103]

> Es gibt viele Möglichkeiten, ein Basic-Programm schneller und komfortabler zu gestalten. Aber auch für die Assemblerprogrammierung gibt es einige Tricks und Kniffe, die wir Ihnen in diesem praxisnahen Kurs verraten wollen.

Wer das Optimum an Geschwindigkeit aus seinem Computer herausholen will, kommt an Maschinensprache nicht vorbei. Die Grundlagen zur Maschinenprogrammierung wurden bereits im Kurs »Assembler ist keine Alchimie«, den Sie in diesem Sonderheft finden, geschaffen. Das Thema dieses Artikels ist es nun, die Möglichkeiten von Maschinensprache optimal zu nutzen. Sie erfahren, wie man
a)	Programme beschleunigen und
b)	Speicherplatz sparen kann.

Dazu werden Ihnen eine Vielzahl von Programmiertechniken, Tips und Tricks vermittelt, die Ihnen die Programmierung erleichern.

## 1.	Beschleunigungen des Betriebssystems (in Assembler)

Der C 64 muß viele Aufgaben gleichzeitig erledigen: Bearbeiten des Hauptprogramms, Ablauf der Systeminterrupts und Senden des Video-Signals (an den Monitor/Fernseher). Alle diese Funktionen erfordern

- viele Zugriffe auf den Datenbus des Prozessors
- und dadurch Ausführungszeit.

Unser Grundproblem ist nun, wie wir den Computer dazu bewegen, diese Aufgaben nicht (oder nur teilweise) auszuführen.

### a)	Eingriffe in den Systeminterrupt

Eine detaillierte Beschreibung des Systeminterrupts finden Sie im bereits erwähnten Kurs »Assembler ist keine Alchimie«. Hier möchte ich nur zusammenfassen, was im normalen Interrupt des Betriebssystems geschieht: 60 mal in der Sekunde wird das Hauptprogramm verlassen und die Routine ab $EA31 angesprungen. Ist diese abgearbeitet, wird wieder ins Hauptprogramm zurückgesprungen. Während dieser Unterbrechung (»interrupt«) tut sich einiges:

- die RUN/STOP-Taste wird überprüft
- die Tastatur und der Datasettenmotor werden abgefragt
- das Cursorblinken wird erledigt
- die interne Uhr (Tl$) wird gestellt.

Überlegen wir uns, welche Funktionen verzichtbar sind: Die RUN/STOP-Taste bewirkt nur in Basic-Programmen einen Abbruch, in Assembler müßte sie zum Beispiel über »JSR $FFE1« zusätzlich abgefragt werden. Die interne Uhr findet von Maschinensprache aus praktisch keine Verwendung. Kurz und gut, ein Maschinenprogramm kann auf beide Funktionen verzichten. Dies wird durch ein

LDA #$34
STA $0314

erreicht. Weil der Computer dadurch entlastet wird, läuft das Hauptprogramm etwas schneller ab.

Die Normaleinstellung erhält man mit

LDA #$31
STA $0314

### Beschleunigungsmethode 1:

Trick: Verkürzung der Interrupt-Routine
Nebenwirkungen: Abfrage der STOP-Taste und interne Uhr entfallen

Können Sie zwischenzeitlich auf die ganze Interrupt-Routine verzichten, genügt ein einziger Befehl:

SEI (»set Interrupt«)

Er verhindert grundsätzlich das Auftreten von Interrupts.
Die Normaleinstellung bewirkt:

CLI (»clear interrupt«)

### Beschleunigungsmethode 2:

Trick: Interrupt total abschalten
Nebenwirkungen: Abfrage von Tastatur, STOP-Taste und Datasette, sowie Cursor und interne Uhr entfallen.

Es gibt aber noch eine Möglichkeit, im Zusammenhang mit dem Systeminterrupt: Von der Adresse $DC05, die als Zähler dient, hängtdie Anzahl der Interrupts (in der Regel 60 Aufrufe pro Sekunde) in einer bestimmten Zeit ab. Diese Adresse kann durch Schreibzugriff geändert werden. Schreibt man in $DC05 einen niedrigen Wert (im Extremfall 0), so werden sehr viele Interrupts ausgelöst. Dies macht sich in der Geschwindigkeit der Interrupt-Routine bemerkbar. Cursor und Tastaturabfrage werden sehr schnell, die interne Uhr geht vor, und so weiter. Verwendet man eine eigene, eventuell zeitkritische Interrupt-Routine, kann sie auf diese Weise beschleunigt werden.

Dieser Geschwindigkeitszuwachs geht allerdings auf Kosten des Hauptprogramms, das stark verlangsamt wird. Bei wenigen Interrupts (große Zahl in $DC05) wird es beschleunigt. Die entsprechenden Assemblerbefehle lauten:

LDA #$FF
STA $DC05

um eine starke Beschleunigung zu bewirken.
Die Normaleinstellung wird durch

LDA #$3A
STA $DC05

erreicht.

### Beschleunigungsmethode 3:

Trick: Anzahl der Interruptaufrufe pro Sekunde ändern
Nebenwirkungen: Bei zu wenigen Aufrufen hinken Uhr, Cursor und Tastaturabfrage nach; bei zu vielen werden sie zu schnell.

### b)	VIC-Register Nummer 17

Ist Ihnen schon bei Hypra-Load, beim Arbeiten mitder Datasette und einigen Kopierprogrammen aufgefallen, daß manchmal der Bildschirm abgeschaltet wird (ähnlich wie im FAST-Mode des C 128)? Dies kann man mit einem Vorhang vergleichen, der zwischenzeitlich den Bildschirm verdeckt. Der Bildschirm kann zwar nach wie vor (hinter dem Vorhang) geändert werden (PRINT-Anweisungen werden also ausgeführt), aber sichtbar wird die Wirkung erst, wenn der Vorhang entfernt wird.

Verantwortlich für das Ein-/Ausschalten des Bildschirms ist das VIC-Register Nummer 17:

Bit 4 gesetzt: Bildschirm wird angezeigt
Bit 4 gelöscht: Bildschirm wird abgeschaltet und nimmt Rahmenfarbe an.

Da wir die theoretischen Grundlagen haben, brauchen wir nur noch unser Wissen in Befehle umzusetzen:

Bildschirm abschalten:
LDA $D011 ($D011 ist VIC-Register #17)
AND #$EF ($EF = %11101111)
STA $D011	↑
              Bit4
In diesem Zustand arbeiten manche Kopierprogramme um zirka 15% schneller. Programme, dienichtaufexterneGeräte wie die Floppy zugreifen, laufen zirka 5% schneller ab. Bildschirm wieder einschalten:
LDA $D011
ORA#$10	($10 = %00010000)
STA $D011	↑
               Bit4

Dies ist der Normalzustand.

### Beschleunigungsmethode 4:

Trick: Bildschirm abschalten
Nebenwirkungen: Der Bildschirminhalt ist nicht zu sehen, geht aber auch nicht verloren.

### c)	Hinweise zum bisher Gesagten

Alle bis zu dieser Stelle genannten Tricks beziehen sich auf die Beschleunigung von Programmen. Sie lassen sich leicht nachträglich einfügen, weil am Programmalgorithmus keine Änderungen erforderlich sind.

Sie können das Abschalten des Bildschirms mit dem Abschalten oder Einschränken des Interrupts verknüpfen, um die Geschwindigkeit noch weiter zu erhöhen. Wenn Sie den Interruptganzabschalten (SEI), bringtes keinen zusätzlichen Gewinn, ihn einzuschränken oder die Zahl der Aufrufe zu ändern.

Beachten Sie bitte, daß alle beschriebenen Tricks durch RUN/STOP-RESTORE, einem Reset oder den Assemblerbefehl BRK rückgängig gemacht werden.

## 2.	Systembeschleunigungen in Basic

Hier erfahren Sie, wie sich die Systembeschleunigungen von Basic aus verwerten lassen. Die Nebenwirkungen bleiben allerdings diegleichen, wie unter 1. genannt.

### a)	Interrupt einschränken

POKE788,52 verkürztdie Interrupt-Routine um das Abfragen der RUN/STOP-Taste und das Stellen von Tl$.

POKE 788,49 Normalzustand

In Basic ist das Ausfallen von RUN/STOP und Tl$ wesentlich störender als in Maschinensprache. Überprüfen Sie daher Ihre Programme auf Verwendung von Tl$ und fügen Sie den POKE erst nach (!) der Fertigstellung des Programms ein.

### b)	Interrupt abschalten

POKE 56334,PEEK (56334) AND 254

schaltet den Interrupt ab,

POKE 56334,PEEK(56334) OR 1

schaltet ihn wieder ein. Dies geschieht dadurch, daß der Timer ab- beziehungsweise wieder eingeschaltet wird.

### c)	Anzahl der Interrupt-Aufrufe ändern

POKE 56325,0: Extrem viele Interruptaufrufe
POKE 56325,255: Extrem wenige (daraus folgt: Interrupt langsam, Basic-Programm schnell)

### d)	Bildschirm abschalten

POKE 53265,PEEK(53265) AND 239
schaltet den Bildschirm ab.
POKE 53265,PEEK(53265) OR 16
schaltet ihn wieder ein.

An dieser Stelle sei noch einmal auf Punkt 1c hingewiesen, damit keine (vermeidbaren) Probleme auftreten.

Anhand von Listing 1 wollen wir uns nun mit der Anwendung der Systembeschleunigungen befassen. Dieses kleine Beispielprogramm, an dem Sie nach Herzenslust experimentieren können, versucht, mit Hilfe von Tl$ die Arbeitsdauer der Schleife (Zeile 150) zu messen.

Während des Ablaufs dieser Schleife, die kontinuierlich die Rahmenfarbe ändert, sollten Sie keine Taste drücken, um die Meßwerte nicht zu verfälschen.
Wenn Sie dies beachten, erhalten Sie folgende Werte:

1.	Normalzustand: 000003
2.	Verkürzter Interrupt: 000000<br>An der gemessenen Zeit können Sie erkennen, daß Tl$ abgeschaltet wurde.
3.	Häufige Interrupts: 000010<br>Aufgrund vieler Interrupt-Anforderungen wurde die Uhr Tl$ sehr oft erhöht.
4.	Seltene Interrupts: 000001<br>Da die IRQ-Routine nur selten durchlaufen wurde, ist Tl$ kaum weitergezählt worden.
5.	Bildschirm abgeschaltet: 000002

Nur bei diesem Punkt (und natürlich auch bei »1«) hat Tl$ volle Aussagekraft bezüglich der Ablaufzeit. An dieser Zeit können wir erkennen, daß durch das Abschalten des Bildschirms tatsächlich gegenüber »1« ein Zeitgewinn anfällt.

Bei den Punkten »3« und »4« wurde der Cursor eingeschaltet. Bei »3« (häufige Interrupts) ist er sehr schnell, bei »4« dagegen sehr langsam.

An Punkt »5« können Sie erkennen, daß bei abgeschaltetem Bildschirm der Hintergrund immer die Rahmenfarbe ($D020) annimmt, ohne daß wir die entsprechende Farbe ins Register$DO21 »POKEn«.

## 3.	Optimierung der Bildschirmausgabe

Ohne die Bildschirmausgabe kommt kein Programm aus, aber oft kostet sie unnötig viel Rechenzeit. Der Grund ist hier nicht beim Betriebssystem zu suchen, sondern bei umständlicher Programmierung. Diese wiederum ist auf mangelndes Know-how zurückzuführen, welches wir nun ändern wollen.

In der Regel wird zur Ausgabe eines Zeichens dieses in den Akku geladen und die Routine BASOUT ($FFD2) aufgerufen. Veranschaulichen wir uns einmal die Arbeitsweise von BASOUT: Das Betriebssystem prüft bei jedem Zeichen, ob es sich um einen Buchstaben oder ein Steuerzeichen, zum Beispiel »Bildschirm löschen« handelt. Buchstaben werden in den Bildschirmcode umgewandelt und ins Bildschirm-RAM ab $0400 geschrieben.

Für Steuerzeichen existieren jeweils Unterroutinen die zum Beispiel eine Leerzeile einfügen, den Bildschirm löschen oder ähnliches.

Diese aufwendige Überprüfung verlangsamt die Bildschirmausgabe erheblich. BASOUT läßt sich zwar geringfügig beschleunigen, indem man statt bei $FFD2 (Kerneleinsprung) bei $E716 einsteigt, aber es geht noch schneller:

### a)	Bildschirm löschen

Langsam:

LDA #$93 $93 = 147 = Codefür»Bildschirm löschen«, entspricht PRINT CHR$(147)
JSR $FFD2 (oder$E176)

Schnell:

JSR $E544 (Routine für »Bildschirm löschen«)

### b) Cursor in Home-Position (linke obere Ecke)

Langsam:

LDA #$13 ; $13 = Code für »Cursor Home«
JSR $FFD2 (oder$E176)

Schnell:

JSR $E566 (Routine für »Cursor Home«)

### c)	Cursor-Positionierung

Langsam:
Senden von Steuerzeichen (CRSR DOWN, UP und so weiter) über BASOUT.
Schnell:

LDX #Zeile
LDY #Spalte
JSR $E50C (Cursorposition setzen)

### d)	Textausgabe

Unkomfortable Lösung:
Senden von Zeichen (Buchstaben, Grafikzeichen) über BASOUT.

Eine solche Schleife finden Sie in Listing 2, Zeilen 148 -220 und 320 - 330. Nach dem Start durch »SYS 49152« gibt Listing 2 zweimal hintereinander den Text »DAS IST DER TEXT« aus. Das erste Mal wird der Text über eine BASOUT-Schleife gedrückt, beim zweiten Mal nimmt das Programm die Komfortable Lösung:

Ab der Adresse »TEXT« muß der Text (in ASCII-Darstellung) stehen, in dem keine Anführungszeichen vorkommen dürfen. Am Ende des Textes muß $00 als Endmarkierung zu finden sein. Die Ausgabe erfolgt dann über

LDA #<(TEXT) Low-Byte der Adresse
LDY #>(TEXT) High-Byte
JSR $AB1E

Die Routine $AB1E wird fortan als »STROUT« (STRing-OUTput = String-Ausgabe) bezeichnet. STROUT ist zwar etwas langsamer als BASOUT; dafür erlaubt die komfortable Parameterübergabe eine wesentlich bequemere Programmierung, wie Sie am zweiten Teil von Listing 2 (Zeilen 260 -300, 320 - 330) sehen können. Mit nur drei Befehlen wird der Text ausgegeben!

### Beschleunigungsmethode 5.

TODO TABLE

Zusammenfassung der bisherigen Alternativen
zu BASOUT:
CLEAR HOME:	JSR $E544
CURSOR HOME:	JSR $E566
Cursorpositionierung:
LDX #Zeile
LDY #Spalte
JSR $E50C
Textausgabe:
Text ab TEXT ablegen (wie Listing 2, Zeile 320 - 330)
LDA #<(TEXT)
LDY #>(TEXT)
JSR $AB1E

Alle diese Verfahren sind nicht nur schnell, sondern auch speicherplatzsparend.	

Eine Anwendung von (fast) allen Routinen aus der Beschleunigungsmethode 5 zeigt Listing 3.

Der Bildschirm wird gelöscht und in Zeile 12 ab Spalte 10 ein Text ausgegeben. Auch in diesem Programm sollten Sie zur Übung etwas experimentieren!

### e)	Kopieren des Textes in den Bildschirmspeicher

Dies ist die schnellste Methode: Der Text wird in den Bildschirmspeicher kopiert. Die lange Umwandlung entfällt völlig, da der Text als fertiger Bildschirmcode im Speicher abgelegt wird. Wenn einige Kopfzeilen (zum Beispiel mit Copyright-Vermerken) an verschiedenen Stellen ausgegeben werden sollen, ist es ratsam, ein kleines Unterprogramm zu erstellen. Dieses schreibt dann die Kopfzeilen direkt in den Bildschirmspeicher, ohne die aktuelle Cursor-Position zu beeinflussen.

Eines müssen Sie aber unbedingt beachten: Die Farbgebung ist nur durch Ändern des Farb-RAMs möglich.

Eine Tabelle der Bildschirmcodes finden Sie übrigens im Anhang des C 64-Handbuchs und am Schluß dieser Ausgabe.

Beschäftigen wir uns nun mit Listing 4:

Dieses Programm entspricht in der Wirkung Listing 3, gibt den Text jedoch nicht über die Betriebssystem-Routinen CURSOR und STROUT aus, sondern schreibt ihn direkt in den Bildschirm.

In den Zeilen 310 - 320 steht der Bildschirmcode des Textes.

Zurück zur Routine STROUT: Diese Routine arbeitet, da sie sich auf die BASOUT-Routine stützt, auch mit Peripheriegeräten wie Floppy und Drucker, wenn diese über dem CMD-Befehl als Ausgabegeräte definiert wurden. In »Assembler ist keine Alchimie« wurde gezeigt, wie man mit der BASOUT-Routine die Drucker-Ausgabe betreibt. Dort wurden alle wichtigen Routinen bis ins Detail beschrieben.

Listing 5 gibt einen Text zuerst auf dem Drucker und dann auf dem Bildschirm aus. Daran soll außer dem Druckerbetrieb auch gezeigt werden, wie man die Parameterübergabe an STROUT als Makro (Zeilen 230 - 270) definiert und sich somit einen bequemen Ausgabe-Befehl schafft.

## 4.	Unterprogramme

Ohne die Unterprogramm-Befehle JSR und RTS kommt fast kein Maschinenprogramm aus. Es ist allerdings ziemlich unbekannt, daß beide Befehle das Programm stark verlangsamen. Grund genug für uns, JSR und RTS näher zu betrachten:

Trifft der Prozessor auf JSR, schiebt er den aktuellen Programmzähler plus 2 (= Rücksprungadresse - 1) auf den Stack und springt dann zu der Adresse, die hinter JSR steht. Trifft er auf RTS, holt er die Adresse vom Stapel zurück, erhöht sie um 1 und verwendet sie wieder als Programmzähler.

Bemerkenswert ist, daß die Zugriffe auf den Stapel sich in keiner Weise von den Zugriffen über die Befehle PHA und PLA unterscheiden. Daher muß jedesmal der Stapelzeiger neu errechnet werden. Diese vielen Operationen sind schuld daran, daß JSR und RTS so langsam sind.

Da wir das Problem erkannt haben, können wir damit beginnen, unser Wissen anzuwenden.

### a)	Unterprogrammverschachtelung

Stellen wir uns folgendes Beispiel vor: ein Hauptprogramm ruft das Unterprogramm 1 auf. Dieses ruft an seinem Ende das Unterprogramm 2 auf, um dann mit RTS ins Hauptprogramm zurückzukehren.
Alles ziemlich schwierig, oder?

Deshalb gehen wir mit Hilfe einer Grafik vor: In Bild 1 sehen Sie ein Flußdiagramm nach obigem Aufbau. In der Beschriftung soll »Code« nicht »Kennwort« bedeuten, sondern heißt einfach »Befehlsnummer«.

Wie an den Pfeilen zu erkennen ist, werden zwei RTS-Befehle hintereinander abgearbeitet (von Unterprogramm 2 nach Unterprogramm 1 und von dort zum Hauptprogramm). Dies ist immer ein Indiz dafür, daß das Programm noch optimiert werden kann.

Eine »Übersetzung« von Bild 1 in Assembler ist Listing 6: Wenn Sie dieses über »SYS 49152« starten, ist aus den ausgegebenen Texten ersichtlich, welcher Programmteil wann abgearbeitet wird.

Sobald Sie die Strukturvon Bild 1 beziehungsweise Listing 6 verstanden haben, können wir uns mit der optimierten Form befassen, die in Bild 2 beziehungsweise Listing 7 zu finden ist.

Hier wird das ehemalige Unterprogramm 2 ans Ende von Unterprogramm 1 gehängt (wobei es ebenfalls über JMP UP2 angesprungen werden könnte). Auf diese Weise muß es nicht über JSR aufgerufen werden, was auch einen RTS-Befehl überflüssig macht.

Trotz dieser Änderung kann das Unterprogramm 2 auch weiterhin als Unterprogramm aufgerufen werden, da bei JSR UP2 die CPU auf einen RTS-Befehl trifft (Bild 2).

In Listing 7 muß noch der JMP-Befehl in Zeile 480 erläutert werden:

Dort muß nichtJSR STROUT:RTS stehen, weil am Ende der STROUT-Routine im ROM ohnehin ein RTS steht. Deshalb benötigt unser Programm keinen eigenen RTS-Befehl zur Rückkehr ins Hauptprogramm.

Die folgende Regel gilt für Aufrufe von Betriebssystemroutinen:

JSR $XXXX	entspricht	JMP $XXXX
RTS			

Voraussetzung ist, daß im Unterprogramm ab $XXXX keine Stapelmanipulation erfolgt, wie sie gleich beschrieben wird. Das geschilderte Verfahren zur Unterprogrammverschachtelung und die entsprechenden Regeln können Sie dann auf jede (!) Programmiersprache übertragen.

### b)	Stapelmanipulation

Wenn Sie »Exbasic Level II« kennen, wissen Sie sicher den Befehl »DISPOSE RETURN« zu schätzen. Er dient dazu, ein Unterprogramm ohne RETURN abzuschließen. Dadurch kann dieses zum Beispiel über GOTO verlassen werden.

In Assembler ist dies auch möglich. Die Befehlseingabe

PLA
PLA

entspricht in der Wirkung »DISPOSE RETURN«.

Da die Rücksprungadresse auf den Stapel abgelegt wird und dort 2 Byte in Anspruch nimmt, kann sie über PLA:PLA wieder vom Stapel geholt werden. Ein Unterprogramm ist nach PLA:PLA eigentlich kein Unterprogramm mehr, sondern Bestandteil des aufrufenden Programms. PLA:PLA findet vor allem in der Fehlerbehandlung Anwendung. An einem späteren Listing werden wir dies noch sehen. Nach PLA:PLA kann ein Unterprogramm über JMP verlassen werden. Dies machen wir uns zunutze, um den Rücksprung an eine beliebige Adresse zu simulieren. Dies ist sonst nicht möglich, da bei RTS immer hinter den Befehl gesprungen wird, der das Unterprogramm aufgerufen hat.

Ein RTS an eine beliebige Adresse müßte »RTS XXXX« heißen, doch diesen Befehl gibt es beim 6510 nicht. So wird er aber simuliert:

PLA	;	holt Rücksprungadresse
PLA	;	vom Stapel und
JMP $XXXX	; springt nach $XXXX

So sieht ein Makro dazu aus:

-.MA RTS (RUECKSPRUNGADRESSE)
- PLA
- PLA
- JMP RUECKSPRUNGADRESSE
-.RT

Und noch ein Mangel der Unterprogrammbefehle soll beseitigt werden: Obwohl es JMP (indirekt) gibt, kennt der 6510 keinen Befehl wie JSR (indirekt); über Stapelmanipulation ist dies dennoch möglich (siehe dazu auch im 64’er, Ausgabe 1/86: Assembler-Bedienung leicht gemacht).

Nehmen wir an, im Vektor $14/$15 steht die Adresse $C000. Nun soll über den $14/$15-Vektor ein Unterprogramm aufgerufen werden (also das ab $C000). Bild 3 zeigt, was im einzelnen geschehen muß.

Die Rücksprungadresse steht zwar in Bild 3 direkt hinter dem JMP ($0014)-Befehl, kann aber auch anderswo im Programm stehen.

Folgendes Makro ermöglicht die Simulation von JSR (indirekt):

-. MAJSRIND(VEKTOR, RUECKSPRUNGADRESSE)
- LDA #>(RUECKSPRUNGADRESSE-1)
- PHA
- LDA #<(RUECKSPRUNGADRESSE-1)
- PHA
- JMP (VEKTOR)
-. RT

Diese Simulation von JSR ($XXXX) verwendet auch der SYS-Befehl (disassemblieren Sie von $E12A bis $E155 und betrachten Sie dazu Bild 3).

Zuerst holt er die Zahl nach SYS in die Adressen $14/$15, dann legt er die Rücksprungadresse ($E147) -1 auf dem Stack ab. Nun holt er die Register P, A, X, Y aus den Adressen $030F, $030C, $030D, $030E. Es folgt ein indirekter Sprung über $0014/$0015.

Nach dem Rücksprung werden die Register wieder im Speicher dort abgelegt, woher sie genommen wurden und ein Sprung ins Basic wird durchgeführt.

Später werden wir noch eine weitere Möglichkeit für JSR (ind) kennenlernen, die aber nicht auf Stapelmanipulation beruht.

### c)	Vergleich zwischen Unterprogramm und Makro bezüglich Geschwindigkeit

Wenn Sie den Hypra-Ass (oder einen anderen Makro-Assembler) besitzen, haben Sie die Möglichkeit, Befehlsfolgen als Makros zu definieren. Makros sind deswegen so beliebt, wei! sie den größten Vorteil von Unterprogrammen bieten, nämlich Übersichtlichkeit. Da Makros aber wie »normale« Befehle im Speicher stehen, entfällt der Aufruf über JSR und RTS. Dies ist der Grund, weshalb Makros etwas schneller (wenige Taktzyklen) als Unterprogramme sind. Das Problem, wann Makros und wann Unterprogramme vorteilhaft sind, wird später noch aufgegriffen.

## 5.	Tabellen

lm allgemeinen Sprachgebrauch werden Tabellen als »geordnete Zusammenstellungen von Daten« verstanden. Diese Funktion haben sie auch in Computerprogrammen, wo man sie daran erkennt, daß Tabellen keinen Befehlscharakter haben.

SMON-Benutzer können mit »FT« ein Programm nach Tabellen durchsuchen lassen; dann sucht SMON im Programm nach Bytes, die nicht zu Maschinensprachebefehlen gehören.

Wozu werden nun Tabellen verwendet?

In der Regel dienen Tabellen einem Computerprogramm als »elektronischer Rechenschieber«. So wie das Kopfrechnen durch einen Rechenschieber ersetzt werden kann, weil man nur in einer geordneten Zusammenstellung von Ergebnissen das richtige suchen muß, kann ein Programm aus seinen Tabellen denselben Nutzen ziehen: die Berechnungen entfallen, die Programmierung wird einfacher.

Aus den weniger erforderlichen Berechnungen entsteht ein deutlicher Geschwindigkeitszuwachs, der Hauptvorteil von Tabellen. Wie man Tabellen einsetzt, erfahren Sie im folgenden.

### a)	Tabellen aus Rechenergebnissen

Noch einmal zum Rechenschieber. Es geht beim Kopfrechnen viel schneller, 4x10 auszurechnen als 4x7. Bei einem Rechenschieber besteht kaum ein Unterschied in der »Rechenzeit«.

Dementsprechend existiert fast kein Algorithmus, dessen Ausführungszeit bei unterschiedlichen Parametern immer gleich bliebe. Wer den Artikel »Dem Klang auf der Spur (5)« (64’er, Ausgabe 5/85, Seite 152 ff.) gelesen hat, weiß, welch grobe Differenzen bei Multiplikationen auftreten können.

Ersetzt (beziehungsweise unterstützt) man einen Algorithmus durch eine Multiplikationstabelle, fällt eine einheitlichere (und kürzere) Ausführungszeit an.

Für das Rechnen mit einzelnen Bits in einem Byte werden oft die Zweierpotenzen benötigt; es empfiehlt sich, diese als Tabelle anzulegen:

1000 -; Zweierpotenzen als Tabellle
1010 -; im DOS der Floppy 1541 ab $EFE9
1020 -; zu finden
1030 -; ZWEIPOT .BY2↑O, 2↑1, 2↑2, 2↑3, 2↑4, 2↑5, 2↑6, 2↑7

Folgende Unterroutine legt im Akkumulator den Wert 2tA ab, wobei mit A der Inhalt des Akkumulators bei Aufruf der Routine gemeint ist:

10000 -;
10010 -; Subroutine zur Berechnung von
10020 -; 21A (Ergebnis kommt in den Akku)
10030 -;
10040 - TAX ; Akku in Indexregister
10050 - LDA ZWEIPOT,X; aus Tabelle einlesen
10060 - RTS ; Das war’s schon! Wer ein schnelleres und zugleich so einfaches Verfahren kennt, möge sich melden...
10070 - ZWEIPOT .BY 2↑0,2↑1,2↑2,2↑3,2↑4,2↑5,2↑6,2↑7

Wenn A größerals 7 ist, liefert das Programm falsche Werte. Sie können es noch erweitern, wenn Sie es für nötig halten.

### b)	Tabellen aus Fließkommawerten

Zu den zeitraubendsten Operationen gehört die Rechnung mit Fließkommazahlen. Daß diese selbst in Maschinenprogrammen lähmend wirkt, sehen Sie am HiRes-3-Befehl »FUNKT« (64’er, Ausgabe 3/85, Grafikkurs-Anwendung). Daher sollte man nur dann auf die Fließkommaroutinen zugreifen, wenn es unvermeidbar ist. Berechnen Sie soviele Werte wie möglich voraus, hierfür eignet sich der Direktmodus des Basic-Interpreters besonders gut! Wie Sie einen auf diese Weise berechneten Wert ins MFLPT-(Floating Point)Format umwandeln können, zeigt Ihnen der folgende Kasten.

Verfahren zur Umwandlung einer Zahl ins MFLPT-Format

1.	SMON (oder anderen Monitor) laden
2.	RESET auslösen oder NEW eingeben
3.	»XX = Fließkommazahl« eingeben, zum Beispiel »XX = 1.23456«
4.	Monitor starten (SYS 49152)
5.	»M 0805 0809« eingeben

Sie sehen nun in den Adressen $0805 - $0809 die MFLPT-Darstellung der Zahl, mit der Sie die Variable XX belegt haben.

Damit wir uns unter Zuhilfenahme präziser Fachausdrücke und Abkürzungen verständigen können, sollten Sie den Abschnitt in »Assembler ist keine Alchimie« aufmerksam lesen, der sich mit Fließkommazahlen befaßt. Nach dem Studium dieses Abschnitts sollten Ihnen Begriffe wie »MFLPT«, »FAC« oder »ARG« geläufig sein.

Im Falle der Zahl 1.23456 erhalten wir als Ergebnis:

:0805 81 1E06 0FE5...

Diese Werte legen wir folgendermaßen als Tabelle ab:

540 -BSPZAHL .BY $81, $1E, $06, $0F, $E5

Wie wir nun diese Zahl verarbeiten, zeigt Ihnen Listing 8. Das Makro (200 - 240) stützt sich auf die Interpreter-Routine MEMFAC, die eine Zahl (Adresse wird in Akku/Y-Register übergeben) vom Speicherformat MFLPT in den FAC als FLPT-Zahl schreibt und dabei die erforderliche MFLPT-—FLPT-Umwandlung durchführt.

In der Tabelle in Zeile 540 können Sie beliebige Fließkommawerte (sofern Sie diese wie angegeben berechnet haben) einsetzen, das Programm rechnet dann mit der jeweiligen Fließkommazahl, die ab BSPZAHL im MFLPT-Format steht.

Diese Zahl wird zunächst nur in den FAC geladen und der FAC wird dann ausgedruckt (270 - 290), dann wird die Zahl wieder geholt, die Wurzel berechnet und ausgegeben (310-350). Schließlich wird die Zahl wieder in den FAC geholt, der natürliche Logarithmus errechnet und auch ausgegeben (370-410).

Zur Routine FACOUT sind, außer daß sie den Inhalt des FAC ausgibt, noch zwei Bemerkungen zu machen:

1.	Nach der Zahl wird noch ein CARRIAGE RETURN ausgegeben.
2.	Nach dem Aufruf von FACOUT hat sich der Inhalt des FAC aufgrund mehrerer Divisionen durch Zehnerpotenzen verändert.

Auf das Thema »Fließkommaarithmetik« geht Texteinschub 1 noch näher ein. Dort werden auch weitere Interpreter-Routinen vorgestellt.

### c)	Sprungtabelle

Beim Thema »Unterprogramme« wurde Ihnen eine Methode vorgestellt, um JSR (ind) zu simulieren. Diese erweistsich in Verbindung mit einer Tabelle, in der die Sprungadressen gespeichert sind, als sehr nützlich. So kann beispielsweise eine Parallele zum Basic-Befehl ON...GOSUB ZIEL1,ZIEL2.... geschaffen werden.

Ein Beispiel: Wenn der Basic-Interpreter auf einen Basic-Befehl trifft, holt er aus der Tabelle $AOOC - $A09D die Adresse der zugehörigen Routine. Diese springt er dann durch Stapelmanipulation an.

Der SMON arbeitet genauso: Seine Sprungtabelle liegt im Bereich $C02B - $C06B.

Die Anwendung von Sprungtabellen werden wir noch ausführlich im folgenden Abschnitt d) sowie bei der Besprechung von Listing 11 behandeln.

### d)	Vergleichstabellen

Weder der SMON noch der Basic-Interpreter benutzen zum Suchen der zum jeweiligen Befehl gehörenden Routine eine Reihe von CMP-Abfragen mit BRANCH-Befehlen. Auch für die Vergleichswerte (in diesem Fall die Befehlswörter) gibt es eine Tabelle: Beim SMON liegt sie im Bereich $COOB -$C02A, beim Basic-Interpreter $A09E - $A327.

Sprung- und Vergleichstabellen sind in gleicher Befehlsfolge angeordnet; wird der Befehl an einer bestimmten Stelle in der Vergleichstabelle gefunden, erfolgt ein Sprung an die Adresse, die an gleicher Stelle in der Sprungtabelle steht. So sehen die Befehls- und Vergleichstabellen im SMON aus:

TODO TABLE

Die Sprungadressen sind wegen der Stapelmanipulation in der Tabelle ab $C02B um 1 dekrementiertgespeichert; in der Darstellung sehen Sie aber das tatsächliche Sprungziel.

Wir werden jetzt anhand des SMON die Verwendung einer Vergleichs-Sprungtabelle in Assembler erläutern.

Wenn wir die zum Befehl » # « gehörende Sprungadresse finden wollen, gehen wir folgendermaßen vor:

1.	Wir suchen in Reihe 2 das # -Zeichen.
2.	Wir gehen (in derselben Spalte) eine Reihe nach unten und finden dort die Sprungadresse ($C92C).

Der Computer hat nicht die Möglichkeit, direkt eine Reihe weiter unten die Suche fortzusetzen. Er muß einen Umweg wählen und sich die Spalte merken. Ein Beispiel:

1.	Der SMON sucht unter den Elementen aus Reihe 2 das »#«. In einem Zähler merkt er sich die Spalte, in der der Befehl gefunden wurde.
2.	Nun sucht er in Reihe 3 in der Spalte, die im Zähler steht, die zugehörige Sprungadresse.

Wie ähnlich beide Suchvorgänge sind, erkennen Sie daran, daßjedesmal die Hauptschritte 1. und 2. vorkommen.

Nach so viel Theorie sehen wir uns nun umso ausführlicher die Routine im SMON an, die für die Steuerung der Vergleichs-Befehlstabelle verantwortlich ist. Dazu können Sie »D C303 C323« eingeben.

Bei Adresse $C303 steht im Akku der ASCII-Code des Kommandos, das der SMON ausführen soll (zum Beispiel $40, wenn ein M-Befehl eingegeben wurde).

TODO TABLE/CODE

Damit haben wir SMONs Schleife zum Suchen eines Befehls und dessen Routine durchleuchtet. Sofern Sie ein ROM-Listing zur Verfügung haben, können Sie sich zusätzlich die entsprechenden Stellen im Basic-Interpreter an|sehen. Dieser aber benötigt wegen seiner unterschiedlich langen Befehle einen etwas komplizierteren Suchalgorithmus, was wiederum zu erheblich höherer Ausführungszeit beiträgt.

## 6.	Vergleiche von Prüfsummen

Nun lernen wir ein besonders raffiniertes Vergleichsverfahren kennen:

Wie gesagt, benötigen Vergleiche mit Wörtern, die aus unterschiedlich vielen Zeichen bestehen, mehr Taktzyklen. Dies wäre nicht so, wenn wir alle Zeichen auf eine einheitliche Länge bringen würden. Genau dies tut der Basic-Interpreter: Bei Eingabe einer Zeile wandelt er alle Basic-Befehlswörter in Token um. Jedes Token vertritt einen Befehl und kann, da es nur ein Byte benötigt, schneller erkannt werden, als es bei mehreren Bytes möglich wäre.

Ein Nachteil ist jedoch der Speicherplatzaufwand; für die Umwandlung müssen die Befehle irgendwo im Speicher in Langform vorhanden sein.

Es gibt aber noch ein anderes Verfahren, einer Zeichenkette einen Wert zuzuweisen: Die Prüfsummenberechnung. Dieseführen zum Beispiel die Eingabehilfen »Checksummer« und »MSE« durch: Aus 8 Byte Programmcode und 2 Byte Adresse errechnet der MSE eine 1 Byte Prüfsumme.

In Bild 4 sehen Sie einen sehr zuverlässigen Algorithmus zur Berechnung von Prüfsummen (insofern zuverlässig, als er sehr unterschiedliche Prüfsummen ermittelt). Listing 9 stellt ein Hilfsprogramm dar, das zu einer Eingabe die Prüfsumme nach dem Algorithmus aus Bild 4 errechnet.

In Listing 9 ist Ihnen eventuell die Routine NUMOUT nicht bekannt. Daher eine Kurzbeschreibung: NUMOUT gibt eine positive Integerzahl, die im Akkumulator (High-Byte) und im X-Register (Low-Byte) übergeben wird, aus. NUMOUT wird zum Beispiel von der LIST-Routine bei der Ausgabe einer Zeilennummer aufgerufen.

Die Routine BASIN soll ebenfalls erklärt werden, da sie in allen folgenden Programmen verwendet werden wird. Wenn die Routine BASIN zum ersten Mal aufgerufen wird, erwartet das Betriebssystem eine Eingabe (normalerweise von Tastatur), die der Eingabe einer Basic-Zeile entspricht. Nach der Eingabe wird das erste eingegebene Byte in den Akku geladen, jeder weitere Aufruf von BASIN holt das nächste Zeichen in den Akku. Wurden alle Bytes eingelesen, wird im Akku der Wert 13 ($0D, RETURN) übergeben. Danach führt ein weiterer Aufruf von BASIN zu erneuter Eingabe von Tastatur.

Ein großer Vorteil von Prüfsummen ist, daß die Vergleiche mit nur einem Byte, nämlich der Prüfsumme, durchgeführt werden müssen.

Wie man in den Genuß dieses Vorteils kommt, zeigt Listing 10. Wenn Sie den Namen eines Computers (C 64, VC 20, PC 128 oder AMIGA) eingeben, nennt das Programm den in diesem Computer installierten Mikroprozessor. Bei der Eingabe der Computernamen kann man aufgrund der Zeilen 230 und 248 beliebig viele Leerzeichen eingeben. Bei der Errechnung der Prüfsummen mit Listing 9 dürfen allerdings keine eingegeben werden, da Listing 9 diese nicht überliest und somit ein falsches Ergebnis liefern würde.

Der Programmteil, der die Prüfsumme der Eingabe berechnet, ist mit Ausnahmen der Zeilen 230/240 aus Listing 9 übernommen worden. Nach Zeile 450 wird die ermittelte Prüfsumme mit der Tabelle »PRÜFSUMMEN« (Zeile 2060) verglichen.

Bei »WEITER2« (Zeile 620) steht im X-Register die Spalte, in der die Prüfsumme gefunden wurde. Listing 10 numeriert, im Gegensatz zum SMON die Spalten mit 0 (statt mit 1) beginnend. Außerdem wurde die Adressentabelle in »LOWTAB« (Tabelle der Low-Bytes) und »HIGHTAB« (High-Bytes) zerlegt, was die Programmierung stark erleichtert.

Wir würden zwar Spalten von 1 an numerieren, für den Computer ist es aber besser, mit Spalte 8 zu beginnen. Wenn im X-Register die Spalte (0: VC 20,1: C 64, 2: PC 128, 3: AMIGA) steht, lesen die Zeilen 620/630 aus einer Tabelle die Adresse, ab der die ASCII-Darstellung des Prozessors zu finden ist. Weil jede der Tabellen »LOWTAB« und »HIGHTAB« gleich viele Elemente wie die Tabelle »PRUEFSUMMEN« hat, muß keine komplizierte Umwandlung über Multiplikation mit 2 oder ähnliches erfolgen wie beispielsweise beim SMON.

Auf eine akute Gefahr bei der Verwendung von Prüfsummen soll jetzt hingewiesen werden: die »Überschneidung von Prüfsummen«:

So wie unterschiedliche Basic-Zeilen beim Checksummer eine gleiche Prüfsumme haben können, sind Prüfsummen nie eindeutig.

Wenn Sie bei Listing 10 etwas herumprobieren, werden Sie sicher feststellen, daß auch eigentlich nicht vorgesehene Eingaben Wirkung zeigen. Dies liegt daran, daß diese Eingaben die gleiche Prüfsumme wie die Taste »VC 20«. »C 64«, »PC 128« oder »AMIGA« haben. Daher sollte man immer darauf achten, daß sich die vorgesehenen Eingaben nicht in ihren Prüfsummen überschneiden (das heißt, die gleichen Prüfsummen haben). Wenn man dies aber beachtet, so ist das Arbeiten mit Prüfsummen, vor allem bei kleineren Datenmengen, eine angenehme Sache.

### e)	Beispielprogramm für Tabellen

Wenden wir uns jetzt einem etwas größeren (aber keineswegs komplizierteren) Programm zu. Es heißt schlicht und einfach »TABELLEN-BEISPIEL«, womit schon einiges über die Funktion ausgesagt ist: ein reines Beispielprogramm, das nicht den Anspruch erhebt, etwa als Anwendersoftware nützlich zu sein. In Listing 11 finden Sie den kommentierten Quelltext.

Zuerst soll die Bedienung des Programms erläutert werden. Gestartet wird »TABELLEN-BEISPIEL« durch SYS 49152, worauf man sich in folgendem Menü befindet:

ZAHLINZAHLWORTWANDELN (0)
BILDSCHIRMFARBE (1)
RESETAUSLOESEN (2)
PROGRAMMENDE UEBER RTS (3)
BITTE AUSWAEHLEN!

Die Zahlen in Klammern sehen Sie nicht, diese zeigen nur die interne Numerierung der Menüpunkte an.

Der jeweils angewählte Menüpunkt (unmittelbar nach dem Start: 0) wird im Gegensatz zu den anderen revers hervorgehoben.

Der angewählte Menüpunkt kommt durch Drücken von F1,RETURN, »—« - oder »=«-Taste zur Ausführung.

Wollen Sie einen anderen Menüpunkt anwählen, drücken Sie einfach CRSR DOWN, »D«,F5 oder »+«, um den invertierten Bereich nach unten zu bewegen. Weiter nach oben gelangen Sie über CRSR UP, »U«, F3 oder »-«.

Wenn Sie von »3« aus nach unten wollen, geht es wieder bei »0« los; von »0« nach oben führt auf Punkt »3«.

Auf Punkt »0« (Ausgangseinstellung) kommen Sie über HOME,»0« oder Klammeraffe.

Sicher würden Sie Ihre Programme auch gerne mit einem solch komfortablen Menü aufwerten. Wenn Sie die Beschreibung des Quelltextes gut durchlesen, wird dies keine Schwierigkeiten bereiten.

Nun zu den einzelnen Menüpunkten.

»2« (Reset auslösen) springt in die RESET-Routine ab $FCE2. »3« (Programmende über RTS) bewirkt einen Rücksprung ins Basic. Wenn Sie aber »TABELLEN-BEISPIEL« vom Hypra-Ass aus gestartet haben, finden Sie sich im »AUTO-NUMBER«-Modus wieder. Dies ist weder ein Fehler von »TABELLEN-BEISPIEL« noch von Hypra-Ass, sondern liegt daran, daß beide Programme eine bestimmte Adresse verwenden, die Hypra-Ass dann als Aufforderung zur automatischen Zeilennumerierung wertet. Am besten starten Sie »TABELLEN-BEISPIEL« nur vom normalen Basic aus.

Punkt »0« bittet Sie um Eingabe einer Zahl von 0 bis 9 und gibt zur eingegebenen Zahl das Zahlwort aus. Beispiel: Eingabe »0«, Ausgabe »NULL«.

Danach müssen Sie eine Taste drücken, um ins Hauptmenü zu kommen.

Punkt »1« schließlich bietet die Möglichkeit, die Hintergrundfarbe besonders elegant einzustellen: Sie geben einfach die Farbe als Wort ein, zum Beispiel SCHWARZ.

Folgende Eingaben sind vorgesehen:
SCHWARZ, WEISS, ROT, TUERKIS, VIOLETT, GRUEN, BLAU, GELB, ORANGE, BRAUN, HELLROT, GRAU 1, GRAU 2, HELLGRUEN, HELLBLAU, GRAU 3

Aufgrund der Überschneidung von Prüfsummen zeigen jedoch auch andere Eingaben Wirkung, zum Beispiel:
SCH, HYPRAASS, PRINT, COMPUTER-GRAPHIK, TAGESSCHAU

Nun wollen wir uns mit dem Quelltext befassen.

Ab Zeile 10000 finden Sie die Tabellen. Und weil unser Programm ein Beispiel für die Verwendung von Tabellen sein soll, sind es derer recht viele. Die wichtigsten davon sind jedoch analog der internen Numerierung der Menüpunkte aufgebaut, da sie Daten für die Menüsteuerung beinhalten. Diese Tabellen sind auch mit 0 - 3 numeriert und grafisch in Bild 6 dargestellt.

Sehen wir uns wieder den Quelltext, beginnend mit der ersten Zeile, an.

Auf die Symboldefinitionen (210 - 260) folgt die Initialisierung der Hauptschleife (280 - 310). Diese Initialisierung löscht Bildschirm (280) und Tastaturpuffer (290 - 300). Außerdem wird der aktuelle (= derzeit invers dargestellte) Menüpunkt (immer in der Adresse »MPT« enthalten) auf 0 gesetzt (310). Zeile 310 ist also dafür verantwortlich, daß nach dem Start über SYS 49152 das Inversfeld ganz oben steht (auf Punkt 0).

Die Texte, die der Beschreibung der Menüpunkte dienen, werden in der Hauptschleife »HSCHLEIFE« (350 - 550) ausgegeben. Mit dieser wollen wir uns nun eingehend auseinandersetzen.

Zunächst wird die Tabelle »RVSTAB« gelöscht (350 - 400). Diese Tabelle enthält die Information, ob der erläuternde Text zu einem Menüpunkt invers ausgegeben wird. Wenn nein, so enthält das entsprechende Byte eine »0«, andernfalls eine »18« (= REVERS-ON-Code für Betriebssystem). Das entsprechende Byte aus »RVSTAB« braucht nur vor dem Menüpunkt-Text ausgegeben werden (470- 480). Die Zeilen 410- 430 sorgen dafür, daß das Byte in »RVSTAB«, welches sich auf den aktuellen Menüpunkt bezieht, den RVS-ON-Code erhält.

In der Hauptschleife muß das X-Register in »XSAVE« gesichert werden, weil die Routine »STROUT« den Inhalt des X-Registers ändert.

Mit »TASTE« (610) beginnt dann die Tastaturabfrage im Menü. Die Routine »GET« holt ein Zeichen von der Tastatur als ASCII-Code in den Akku. Wurde keine Taste gedrückt, erhält der Akku den Code 0. In diesem Fall wartet 620 auf eine neue Eingabe. Beachten Sie bitte, daß der Akku nach der Zeile 620 NIE den Wert 0 haben kann (dies wird sich bald als nützlich erweisen)!

Wurde nun eine Taste gedrückt, sucht »SCHLEIFE« (630 -680) in der Tabelle »TASTEN«, die im Quelltextab Zeile 10210 steht, nach dem eingegebenen Zeichen (wird es nicht gefunden, erfolgt in 690 der Sprung zur neuen Eingabe).

Diese Tabelle »TASTEN« enthält alle vorgesehenen Tastendrücke zur Menüsteuerung, die in 4er-Blockweise angeordnet sind (Bild 5). Nach der Suchschleife steht im X-Register die Position der gedrückten Taste innerhalb der Tabelle »TASTEN« (zum Beispiel 0 = F1 gedrückt, 4 = HOME gedrückt). Diese Position wird - ohne Berücksichtigung des Divisions-Restes - durch 4 dividiert (700 - 730), um festzuhalten, von welchem Tastenblock eine Taste gedrückt wurde.

Dadurch ist eindeutig bestimmt, welche Befehlsgruppe aufgerufen werden muß.

Steht nach 730 im X-Register 0, wurde eine der ersten vier in »TASTEN« enthaltenen Tasten gedrückt, die die Ausführung des aktuellen Menüpunktes veranlassen (Zeile 10210 und Bild 5). Ist X=1, so wurde eine Taste aus Zeile 10220 gedrückt. In 10220 stehtals letztes Byte eine 0. Diese dient, da für die Funktion »Inversfeld in HOME-Position« nur drei Tastendrücke vorgesehen wurden, zum Auffüllen auf vier Tasten. 0 kann hier bedenkenlos als Dummy (Füllbyte ohne wirkliche Bedeutung) stehen, da der Akku aufgrund von 620 nie den Wert 0 annehmen wird.

Beinhaltet X nach der Division durch 4 den Wert2, wird das Inversfeld nach unten bewegt, istX=3, dann nach oben. Dies können Sie sich an Bild 6 veranschaulichen.

An den Zeilen 740 - 870 sehen wir nun die Verwendung einer Sprungtabelle. Unsere Sprungtabelle ist »SP1LO/SP1HI«. »SP1LO« beinhaltet die Low-, »SP1HI« die High-Bytes der anzuspringenden Routinen. In den Vektor »SPRUNG« wird einfach die Zieladresse geschrieben (740 - 770).

Die Zuweisungszeile 790 errechnet die Rücksprungadresse des aufzurufenden Unterprogramms. Bei einem RTS soll nämlich zur »HSCHLEIFE« gesprungen werden.

Diese Rücksprungadresse »RUECKSPRUNG« wird auf den Stapel gelegt (830 - 860), zuletzt erfolgt der indirekte Sprung (870). Die über die soeben beschriebene Simulation von JSR (ind) angesprungenen Routinen finden Sie ab Zeile 900. Es wird einfach der aktuelle Menüpunkt »MPT« entsprechend dem Tastendruck geändert, dann wird zur »HSCHLEIFE« gesprungen, die auch die Tabelle »RVSTAB« entsprechend anpaßt.

»EXEC« (1090) holt die Rücksprungadresse vom Stapel (1090 - 1100), da diese Routine nicht als Unterprogramm behandelt werden soll.

Die Zeile 1110 holt den angeforderten Menüpunkt ins X-Register. Dann wird aus »SP2LO/SP2HI« die Adresse der zum Menüpunkt gehörenden Routine geholt und diese über einen gewöhnlichen indirekten Sprung aufgerufen (1160).

Als Routine zu »2« wird einfach die RESET-Routine des Betriebssystems angesprungen, für »3« eignet sich jeder RTS-Befehl, also auch der bei »ENDE« (920).

»ZAHLWORT«, die Routine zu 0, holt eine Zahl als ASCII-Code (1230) und wandelt sie in einen numerischen Wert um (1240 -1250), indem der ASCII-Code von 0 abgezogen wird. Das Ergebnis landet im X-Register (1260). Ob auch eine Zahl eingegeben wurde, prüfen die Zeilen 1310 - 1330. Bei »ZAHLWORT« (1350) wird das Resultat der Subtraktion in »XSAVE« gesichert, der Text »IN WORTEN« ausgegeben und das X-Register wieder geholt.

Die Tabelle »ZWLO/ZWHI« enthält die Adressen, ab denen die Texte der Zahlwörter als ASCII-Code stehen. Aus »ZWLO/ZWHI« wird dann diese Adresse geholt (1400 -1410) und der dort stehende Text ausgegeben (1420). Danach erwartet das Programm noch einen Tastendruck (1440-1450), bevor ins Hauptmenü verzweigt wird (1460).

Als letzte Routine wird »FARBE« besprochen (1500-1850): Hierzu istjedoch aufgrund derÄhnlichkeitzu Listing 10 nicht viel zu erläutern. Bei 1820 steht im X-Register der Code der eingegebenen Farbe (= Position der Prüfsumme innerhalb der Tabelle »PRUEFSUMMEN«). Dieser muß nur noch in die entsprechenden VIC-Register geschrieben werden (1820-1830). Ab Zeile 10000 stehen dann die Tabellen. Wenn Sie die Tabellen angesehen haben, sollten Sie durchaus noch einmal den Quelltext bis 10000 betrachten und die hier endende Beschreibung des Programms lesen. Denn wenn Sie das Programm »TABELLEN-BEISPIEL« ganz verstanden haben, sind Sie einen großen Schritt in der Assemblerprogrammierung weitergekommen I

Ich könnte mir übrigens vorstellen, daß Sie in Ihren eigenen Programmen jetzt auch eine Menüsteuerung wie die in »TABELLEN-BEISPIEL« einbauen; wie das geht, können Sie dem Programm »TABELLEN-BEISPIEL« entnehmen.

Eine Anmerkung ist wichtig: »TABELLEN-BEISPIEL« kann noch weiter verbessert werden. Sie werden sehen, daß viele Stellen noch optimiert werden können. Insbesondere der Speicherplatzbedarf kann verringert werden.

### f)	Weitere Anregungen zur Anwendung von Tabellen

Auch die bisherigen Erläuterungen und das Beispielprogramm können die Kreativität des Programmierers nicht ersetzen, sondern nur die Programmierung erleichtern. Aus diesem Grund möchte ich Ihnen noch einige Beispiele nennen, wie sich Tabellen sinnvoll verwerten lassen.

- Ein Anwenderprogramm, das aus Menüs und Untermenüs besteht, sollte in einer Tabelle die Adressen der Menüs/Untermenüs speichern.
- Spiele müssen oft viele Spritebewegungen, die immer gleich sind, durchführen. Es empfiehlt sich, die Spritebewegungen als Koordinaten in einer Tabelle abzulegen.
 -Bei Software-Interfaces müssen viele Umrechnungen
erfolgen. Durch eine Umwandlungstabelle können diese stark beschleunigt werden.
- Naturwissenschaftlich orientierte Programme müssen verschiedene Maße umrechnen. Die Umrechnungswerte können in einer Tabelle untergebracht werden.

Dies soll nur eine Anregung sein. Ich wüßte aber kein komplexes Programm, das sich nicht durch den gezielten Einsatz von Tabellen vereinfachen und beschleunigen ließe.

### Texteinschub #1: Fließkommazahlen

Im Text wurde ein Verfahren vorgestellt, um eine Zahl ins MFLPT-Fbrmat (MELPT=Memory floating point) umzuwandeln. Das 5 Byte lange Ergebnis dieser Umwandlung kann man dann als KONSTANTE handhaben. Konstanten sind feste, vorausberechnete Werte, die man mit Hilfe der Routine »MEMFAC« in den FAC (Flieskomma-AKKU) kopieren kann. Für viele Werte ist es jedoch überflüssig, die Umwandlung durchzuführen und eine entsprechende Tabelle anzulegen, da sie schon im ROM vorhanden sind. Im Kurs »Assembler ist keine Alchimie« wurden solche Konstanten mitsamt ihrer Adressen schon in einer Tabelle vorgestellt.

Um mit Konstanten (für die Rechenroutinen macht es keinen Unterschied, ob diese im RAM oder im ROM stehen) zu rechnen, kann man diese wie gesagt, in den FAC kopieren und alle weiteren Operationen auf diesen beziehen. Dies war in Listing 8 bei den Funktionen SQR und LOGNAT ausreichend.

Oft möchte man aber den Inhalt des FAC nicht mit einer Funktion wie SQR behandeln, sondern mit anderen Konstanten addieren, multiplizieren und so weiter.

Dafür möchte ich Ihnen im folgenden weitere Interpreter-Routinen vorstellen, die das Rechnen mit Konstanten ermöglichen. Da fast immer in den Akku das Low-, ins Y-Register das High-Byte der Adresse, ab der die Konstante abgelegt ist, geladen werden muß, definieren wir noch vorher folgende Makro:

-	.MA LDAY (ADRESSE)
- LDA#<(ADRESSE)
- LDY#>(ADRESSE)
-.RT

Nun zu den Routinen, bei deren Parameterübergabe wir uns auf das Makro LDAY stützen wollen:

TODO TABLE

ADDMEM	FAC+Konstante - FAC	... LDAY (KONSTANTE) JSR$B867
ADD0,5	FAC+0.5 - FAC	JSR $B849
SUBMEM	Konstante-FAC - FAC	...LDAY(KONSTANTE) JSR $B850
MULMEM	Konstante\*FAC - FAC	...LDAY(KONSTANTE) JSR $BA28
MULT10	FAC\*1O-FAC	JSR $BAE2
DIVMEM	Konstante/FAC - FAC	...LDAY(KONSTANTE) JSR $BBOF
DIVS10	FAC/10 - FAC	JSR $BAFE
CMPMEM	vergleicht Konstante mit FAC FAC<Konstante: Akku=$FF FAC=Konstante: Akku=$OO FAC>Konstante: Akku=$O1	... LDAY (KONSTANTE) JSR $BC5B
POTMEM	Konstante tFAC - FAC	...LDAY(KONSTANTE) JSR $BF78
POTE	e↑FAC-FAC	JSR $BFED
MEMFAC	holt Konstante in FAC	...LDAY(KONSTANTE) JSR $BBA2
FACMEM	FAC ab Konstante als MFLPT-Zahl ablegen	LDX#<(KONSTANTE) LDY#>(KONSTANTE) JSR$BBD7
FACOUT	gibt FAC aus	JSR $AABC


## 7.	Die Initialisierung

»Initialisierung« nennt man eine Routine, die vor einem Programmteil (meist einer Schleife) steht und diese vorbereitet. Die Initialisierung wird nur einmal, eine Schleife aber mehrfach durchlaufen. Deshalb bringt es einen Geschwindigkeitszuwachs, wenn die Initialisierung der Schleife Arbeit abnimmt.

Ein Beispiel: Wenn ein Basic-Programm mit »RUN« gestartet wird, werden alle Variablen gelöscht, Files geschlossen und die Adressen, ab denen die Variablen abgelegt werden dürfen, errechnet. Dies ist die Initialisierung der Interpreterschleife. Dann wird Byte für Byte des Basic-Programms eingelesen und bearbeitet.

Muß im gerade übersetzten Befehl ein Sprung (GOTO 500 oder ähnliches) durchgeführt werden, kostet dies bekanntlich viel Zeit, wenn das Sprungziel am Ende eines langen Programms steht. Dies ist darauf zurückzuführen, daß der Interpreter, beginnend mit der ersten Zeile, das ganze Programm nach der Sprungzeile durchsucht, bis er sie gefunden hat.

Diese Berechnung der Adressen wird bei jedem »GOTO« oder »GOSUB« neu durchgeführt.

Viel besser und schneller wäre folgende Vorgehensweise: Bei »RUN« wird zunächst eine Tabelle angelegt, in der die Adressen aller Zeilen enthalten sind. Diese Tabelle könnte zum Beispiel als Array definiert werden. Folgt nun ein Sprung, kann aus der Tabelle die Adresse der Zeile im Speicher geholt werden.

Damit haben wir noch ein wesentliches Merkmal der Initialisierungsroutinen gefunden: Die Initialisierung kann Tabellen anlegen, die dann von der Hauptschleife verarbeitet werden.

Aber nicht nur Tabellen können generiert werden, auch die Berechnung von Flags ist sinnvoll. So merkt sich die »LOAD/VERIFY«-Routine ($FFD5), ob ein Verifizieren oder Laden gewünscht wird. Die Ladeschleife liest dann ein Zeichen von der Floppy oder der Datasette ein und entscheidet erst anschließend, ob das Byte im Speicher abgelegt oder mit dem Speicher verglichen werden soll.

Halten wir also fest, daß Initialisierungsroutinen Schleifen entlasten können. Näher werden wir uns damit beim Thema »Schleifen« beschäftigen.

## 8.	Die Nutzung der Zeropage

In jedem Assembler-Lehrbuch werden die Vorteile der Zeropage-Adressierung gepriesen. Speicherplatzersparnis und hohe Verarbeitungsgeschwindigkeit sind nicht die einzigen Vorzüge; die indirekt-indizierte Adressierung kann nur auf Zeropage-Adressen zugreifen, nicht auf absolute 16-Bit-Adressen. Damit wird der Leser aber schon alleine gelassen. Er erfährt nicht, welche Adressen in der Zeropage für die Praxis geeignet sind. Das wird nun nachgeholt.

Fast die ganze Zeropage wird durch Basic-Interpreter und Betriebssystem belegt. Deshalb führen bestimmte Werte in Zeropage-Adressen oft zum Absturz oder sonstigem Fehlverhalten des Computers.

Wie dies im einzelnen aussieht, erfahren Sie in der Serie »Memory Map mit Wandervorschlägen«, die im 64’er Stammheft erscheint. Nicht nur in Zweifelsfällen stellt diese Serie das optimale Nachschlagewerk dar.

Ich möchte Ihnen nun zeigen, welche Adressen Sie als (Zwischen-)Speicher ohne Schwierigkeiten verwenden können, beziehungsweise was Sie bei Verwendung von Zeropage-Adressen beachten müssen.

### a)	Adressen, die problemlos verwendet werden können

Auf die Adressen $02 und $FB - $FE wird weder vom Basic-Interpreter noch vom Betriebssystem zugegriffen. Lediglich bei Initialisierung der Arbeitsspeicher (RESET) werden Sie auf 0 gesetzt.

Für die Praxis heißt das, daß Ihnen die genannten Adressen völlig zur Verfügung stehen.

### b)	Adressen, die in keiner Weise verwendet werden sollten

Von anderen Adressen hingegen müssen wir unsere Finger lassen. Diese haben entweder elementare Funktionen für Betriebssystem oder CPU, oder werden von beiden dauernd geändert, so daß die Datensicherheit in Frage gestellt ist. Genauer soll hier nicht unterschieden werden.

Belassen Sie die Adressen $00 und $01 unverändert, da sie (siehe Memory Map) für die CPU wichtige Informationen beinhalten und außerdem einige Bits nur durch externe Vorgänge geändert werden.

Das Betriebssystem und der Basic-Interpreter beanspruchen alle bislang ungenannten Adressen.

Von Bildschirmeditor und Tastaturabfrage werden die Adressen $C6 - $F6 beeinflußt. Die Adressen $90 - $C2 dienen der Ein-/Ausgabe-Steuerung mit Peripheriegeräten und der Verwaltung offener Files. Einzige Ausnahme: $A0 -$A2 (interne Uhr). Wenn ein Maschinenprogrammm in ein Basic-Programm eingebaut ist, sind die Adressen $03 - $56 sowie $73 - $8B tabu.

### c)	Bedingt einsetzbar

Der Vektor $C3/$C4 wird durch RUN/STOP-Restore, RESET oder LOAD beeinflußt. Ansonsten kann mit $C3/$C4 frei verfahren werden.

Ganz Vorsichtige können diesen Vektor auf seinen Ausgangswert $FD30 setzen, sobald das Programm die Adressen $C3/$C4 nicht mehr für eigene Zwecke benötigt.

### d)	Adressen, die unter Verzicht auf Kassettenbetrieb verwendet werden können

Die folgenden Adressen können verwendet werden, wenn nicht auf RS232 oder Datasette zugegriffen wird.

$9E/$9F, $A5-$A7, $A9-$AB, $B0-$B6, $F7-$FA

Bei anderen Adressen, die sich auf den RS232- oder Kassettenbetrieb beziehen, ist Vorsicht angebracht.

### e)	Geeignete Zwischenspeicher

Die Adressen $22-$2A und $57-$60 sind sogenannte »verschieden genutzte Arbeitsbereiche«. Sie werden vom Basic-Interpreter vor allem bei arithmetischen Operationen als Zwischenspeicher verwendet. Als solche Zwischenspeicher können wir sie auch verwenden. Sobald allerdings bestimmte Interpreterroutinen aufgerufen werden, können die Inhalte dieser Adressen verlorengehen. Eine längerfristige Aufbewahrung von Daten in diesen Adressen ist zwar nicht möglich, andererseits können wir aber durch Schreibzugriffe auf diese Adressen das Betriebssystem oder den Basic-Interpreter nicht stören.

Zu sagen wäre noch, daß die Adressen $57 - $60 den wichtigen Routinen BLTUC und UMULT (siehe »Assembler ist keine Alchimie«) als Zwischenspeicher dienen.

### f)	Zeropage kopieren

Zum Abschluß dieses Abschnittes über die Nutzung der Zeropage möchte ich Ihnen noch einen kleinen Trick verraten, der von einigen professionellen Programmen angewandt wird.

Wir sichern die Zeropage-Inhalte in einem anderen Bereich, zum Beispiel von $6F00 an.

Dann können wir viele Adressen in der Zeropage nutzen, sofern wir keine Interpreter- oder Betriebssystemroutine aufrufen. Danach schreiben wir die Zeropage wieder von der Kopie, zum Beispiel von $6F00, zurück und können wie gewöhnlich fortfahren.

Die Adressen 0 und 1 kopieren wir nicht, weil diese nach wie vor für solche Zwecke nutzlos sind. Ebenso könnten wir nur einzelne Bereiche kopieren (zum Beispiel die Zeiger für Basic-Programme$16 - $4A). Dann dürfen wiraberauch nur diesen Bereich verändern. Wenn wir nun den Bereich $02 - $FF kopieren, stehen uns folgende Adressen zur Verfügung: $03-$06, $14-$86, $71-$8A, $C3/$C4, $FB-$FF Diese Adressen können Sie nur so lange verwenden, bis eine Routine des Betriebssystems oder Basic-Interpreters aufgerufen wird. Davor muß die alte Zeropage zurückgeschrieben werden. Da Sie auf diese Weise viel Speicherplatz in der Zeropage gewonnen haben, ist es sogar möglich, eine Tabelle aus Geschwindigkeitsgründen in die Zeropage zu verlegen. Damit steigt auch der Wert der indiziert-indirekten Adressierung erheblich. Dennoch ist der Speicherplatz in der Zeropage begrenzt. Überlegen Sie sich also, auf welche Werte besonders schnell zugegriffen werden muß und schreiben Sie vorzugsweise diese in die Zeropage.

## 9.	Schleifenprogrammierung

Zunächst befassen wir uns mit Schleifen, die maximal 256mal durchlaufen werden.

### Typ a: Schleifen mit maximal 256 Durchläufen

Da 256 verschiedene Zahlen mit einem 8-Bit-Prozessor dargestellt werden können, verwendet man hier das X- (oder Y-) Register als Schleifenzähler. In Listing 12 sehen Sie die einfachste Form einer Schleife, die die Zeropage-Adressen $02 - $FF nach $6F00 kopiert.

Da der Schleifenzähler X in Listing 12 INKREMENTIERT wird, haben wir es mit einer INKREMENTIERSCHLEIFE zu tun. Nach dem Inkrementieren (»6007 INX«) wird durch »6008 CPX # FE« überprüft, ob die Schleife beendet werden kann. Eine eingehendere Beschreibung des Programmablaufs erübrigt sich.

Für Schleifen des Typs a (maximal 256 Durchläufe) ist es aber meist vorteilhaft, eine DEKREMENTIERSCHLEIFE zu verwenden. Wie eine solche Schleife programmiert wird, sehen wir an Listing 13.

Listing 13 unterscheidet sich in der Wirkung nicht von Listing 12, obwohl man dies nicht unbedingt auf den ersten Blick erkennt. Deshalb soll dieses Listing näher besprochen werden. In Zeile 6000 erhält das X-Register den Inhalt $FE. Durch »6002 LDA 01,X« wird damit das letzte Byte der Zeropage, nämlich $FF, zuerst gelesen und nach $7OFE geschrieben. Dann wird X dekrementiert. Ist X noch nicht 0, so wird die Schleife erneut durchlaufen.

Der niedrigste X-Wert innerhalb der Schleife ist folglich 1; aufgrund von »6002 LDA 01,X« ist $02 die niedrigste Zeropage-Adresse, die kopiert wird. In Listing 12 ist 0 der niedrigste X-Wert. Die niedrigste Adresse aufgrund von »6002 LDA 02,X« ist also auch $02 (stimmt auffällig). Warum $FF die höchste kopierte Zeropage-Adresse ist, können Sie nun selbst den Listings 12 und 13 entnehmen.

Listing 14 ist eine Dekrementierschleife, die die Kopie der Zeropage wieder von $6F00 nach $02 zurückholt.

Der Vorteil von Dekrementierschleifen beim Typ a ist, daß zum Erkennen der Abbruchbedingung (X=0) kein Vergleichsbefehl erforderlich ist, weil nach dem DEX-Befehl automatisch das Z-Flag gesetzt wird, wenn X Null wird.

Das Entfallen des Vergleichsbefehls »CPX #« bringt eine Ersparnis von 2 Byte Speicherplatz sowie insgesamt 508 Taktzyklen Rechenzeit. Dajedoch bei 6004 eine Seitenüberschreitung (eine Seite entspricht 256 Byte) vorliegt, schrumpft der Zeitgewinn auf 254 Taktzyklen (dies ließe sich aber vermeiden, indem wir die Zeropage nach $6F01 kopieren, womit durch »6004 STA $6F00,X« keine Seitenüberschreitung auftreten würde).

Nun wollen wir noch einen Sonderfall behandeln:

Dekrementierschleifen vom Typ a, bei denen der Ausgangswert für X < 129 ist.

In Listing 15 sehen Sie eine Schleife, die den Bereich $16 - $4A nach $6F00 kopiert, Listing 16 schreibt die Werte von $6F00 zurück nach $16. Selbstverständlich hätten wir das Problem auch so lösen können wie in Listing 13. Wir wollen aber noch eine andere Konstruktion von Dekrementierschleifen kennenlernen, die in diesem Sonderfall möglich ist. Besprechen wir also Listing 15.

Bei 6000 wird ins X-Register die Zahl geladen, die man zu $16 addieren muß, um $4A zu erhalten. Dadurch wird zunächst bei 6002 die Adresse $4A gelesen und nach $6F34 geschrieben. Bei 6007 wird dekrementiert. Neu ist der Verzweigungsbefehl: es wird das N-Flag überprüft. Ist X = $FF, wird das N-Flag gesetzt und »6008 BPL 6002« beendet die Schleife. Der niedrigste Wert von X, der innerhalb der Schleife vorkommt, ist demnach $00.

Der BPL-Befehl funktioniert nur, wenn der Ausgangswert von X <129 ist. Andernfalls wäre nämlich nach dem Dekrementieren X>127 und damit das N-Flag gesetzt. Dies aber hätte zur Folge, daß die Schleife nur 1mal durchlaufen würde.

Zur soeben behandelten Schleifenkonstruktion sind noch zwei Dinge zu sagen; erstens, daß sie nur in diesem Sonderfall (X<129) möglich ist, und zweitens, daß sie nicht effektiver als eine Lösung wie in Listing 13 ist.

Allgemeine Gültigkeit hat aber folgende Regel für Schleifen vom Typ a:

Bei Schleifen vom Typ a ist Dekrementieren effektiver als Inkrementieren, solange die Durchlaufzahl nicht 255 überschreitet.

Bei 256 Durchläufen erweist sich Inkrementieren oft als besser.

An Listing 17 sehen wir ein Beispiel für den letzten Satz der Regel. Listing 17 kopiert die letzten 256 Speicherplätze des Stapels ($0100 - $01FF) und den Stapelzeiger nach $6F00 - $7000. Listing 18 schreibt den Stapel wieder zurück.

Die Dekrementierschleife (6000 - 600A) kopiert nun den Bereich $0101 - $O1FF, $0100 wird nicht übertragen. Dies geschieht in 600B - 600F. Eine andere Möglichkeit wäre ein zeitraubender CPX #FF-Befehl nach »6008 DEX«.

6011 - 6013 sichert schließlich noch das SP-Register.

Hier ist in der Tat eine Inkrementierschleife besser. Ändern wir Listing 17 also in Listing 17a:

	LDX #00	
- LOOP	LDA 0100,X	
-	STA 6F00,X	
	INX	;(!!)
-	BNE LOOP	
-	TSX	
-	STX 7000	

Analog ergibt sich Listing 18a:

	LDX #00	
- LOOP	LDA 6F00,X	
-	STA 0100,X	
	INX	;(!!)
—	BNE LOOP	
-	LDX 7000	
-	TXS	

In den Listings 17a und 18a habe ich diejenigen Befehle, die sich in der symbolischen Darstellung nicht von den Listings 17 und 18 unterscheiden, mit einem »-« markiert.

### Typ b: Schleifen mit mehr als 256 Durchläufen

Während Schleifen des Typs a meist so schnell abgearbeitet werden, daß man es gar nicht bemerkt, dauern Typ-b-Schleifen oft eine oder mehrere Sekunden.

Deswegen wollen wir hier versuchen, den Zeitbedarf von Typ-b-Schleifen zu verringern.

Unsere erste Typ-b-Schleife (Listing 19) soll den Bereich von $3FD2 bis $475F invertieren (= EOR # FF-verknüpfen, aus jeder 1 wird eine 0 und umgekehrt). Da hierfür ein 8-Bit-Indexregister nicht ausreicht, benötigen wir einen 16-Bit-Zähler, nämlich$14/$15. Dieser soll immer die Adresse beinhalten, die invertiert wird. In diesen Zähler schreibt die Initialisierung der Schleife den Startwert $3FD2 (siehe $6000 -$6007).

Da es beim 6510 keine indirekte Adressierung für LDA/STA gibt, sbndern nur die indirekt-indizierte oder indiziert-indirekte, müssen wir auf eine dieser Adressierungen ausweichen und den Index auf 0 setzen (»6008 LDY #00«).

Bei $600A beginnt die Schleife: der Wert wird eingelesen, mit $FF EOR-verknüpft und zurückgeschrieben. Nun wird der 16-Bit-Zähler $14/$15 erhöht (6010 - 6015). Dann wird überprüft, ob die nächste Adresse schon mit der ersten Adresse nach der Endadresse ($475F), also $4760, übereinstimmt (siehe $6016 - $601D). Dieser 16-Bit-Vergleich wurde bereits im SMON vorgestellt. Bei $601E wird schließlich die Schleife beendet, falls die Abbruchbedingung (C=1) erfüllt ist.

Listing 20 ist eine Dekrementierschleife, die sich in der Wirkung nicht von Listing 19 unterscheidet. Da das Dekrementieren einer 16-Bit-Adresse beim 6510 langsamer und speicherplatzaufwendiger ist als das Inkrementieren, ist Listing 20 weniger effektiv als Listing 19.

Grundsätzlich können Sie an den Listings 19 und 20 sehen, wie man eine Typ-b-Schleife programmiert. Diese arbeitet jedoch nicht besonders schnell. Der Grund ist, daß der Bereich von $3FD2 - $475F nicht restlos in ganze Seiten (256-Byte-Blöcke)aufgeteilt werden kann. Daher sollte man sich immer überlegen, ob die Schleifendurchlaufzahl nicht auf ganze 256-Byte-Blöcke »aufgerundet« werden kann. In unserem Fall würde dies heißen, daß mit einer schnelleren Schleife der exakt 8 x 256 Byte lange Bereich $3FD2 - $47D1 invertiert wird, anstelle des »ungeraden« Bereichs $3FD2 - $475F. An einfacheren Zahlen wollen wir nun eine solche Schleife für ganze Seiten programmieren. Der 32 x 256 Byte umfassende Bereich von $2000 bis $3FFF (einschließlich) soll invertiert werden. Mit einer solcher Routine könnte das gerade sichtbare Bild bei Hi-Eddi invertiert werden.

Die einfachste Form finden Sie in Listing 21. Zuerst wird die Anfangsadresse in $14/$15 abgelegt. Ins Y-Register kommt der Wert 0. Dann wird der Wert invertiert und das Y-Register, der Low-Zähler, erhöht. Ist der Wert noch nicht 0, wird die Schleife neu durchlaufen. Andernfalls wurde gerade eine Seite abgearbeitet. Der High-Zähler ($15) wird erhöht. Ist der Inhalt des High-Zählers = $40, wird die Schleife abgebrochen. Zu bemerken ist, daß während der Schleife die Adresse $14 unverändert 0 bleibt. Die Adresse, die invertiert wird, ergibt sich folgendermaßen:

(Y+Inhalt von $14)+256\*(Inhalt von $15)

Da wir auf die Adresse über das Prozessor-Register Y Einfluß nehmen können und die Adresse $14 nicht verändert werden muß, ist die Verarbeitungsgeschwindigkeit gegenüber der »Normalform« (Listing 20) gestiegen. Das High-Byte müssen wir aber weiterhin in $15 belassen. Neu führen wir den High-Zähler X ein. Im X-Register merken wir uns, wieviele Seiten invertiert werden. Diesen Wert verwenden wir als Dekrementierzähler. In unserem Fall werden $20 Seiten invertiert. Weil $20 zufälligerweise auch das High-Byte der Anfangsadresse ($2000) ist, wird dieser Wert in Listing 22 nur einmal (6005) in den Akku geladen und dann bei 6009 ins X-Register übertragen.

Beachten Sie bitte, daß in Listing 22 die Befehle »6004 TAY« und »6009 TAX« nur bei den Werten dieses Beispiels verwendet werden können. In der Regel sind eigene »LDX # «- oder »LDY #«-Befehle erforderlich. Wenn wir zum Beispiel den Bereich $3FD2 - $47D1 invertieren wollen, muß die Initialisierung so aussehen:

LDA # D2 Low-Byte der ersten Adresse
STA 14
LDY #00 Index-Register
LDA #3F High-Byte der ersten Adresse
STA 15
LDX #08 High-Zähler
... Schleife wie ab 600C in Listing 22

Damit hätten wir eine Schleife, die den Bereich # 3FD2 -$475F (siehe Listings 19 und 20) invertiert und wesentlich schnellerals die Listings 19 und 20 arbeitet. Dawiraber »aufgerundet« haben, wird zusätzlich der Bereich $4760 - $47D1 invertiert, obwohlwirdasgarnichtwollen. Esgibtnun mehrere Möglichkeiten, dies zu verhindern:

1.	Wir verwenden die Schleife aus Listing 19, müssen aber eine deutlich höhere Arbeitsdauer hinnehmen.
2.	Wir verwenden die Schleife aus Listing 22 mit obiger Initialisierung. Dann invertiert eine Typ-a-Schleife den Restbereich $4760 - $47D1 ein weiteres Mal. Damit wären - eine Besonderheit der EOR # FF-Verknüpfung - im Restbereich die alten Inhalte wiederhergestellt. Diese Lösung eignet sich aber (fast) nur bei dieser logischen Verknüpfung und hilft bei den meisten anderen Typ-b-Schleifen nicht weiter.
3.	Dies dürfte wohl die beste Lösung sein: Wir schreiben eine »gemischte« Schleife, die aus einer Typ-a-Schleife und einer Typ-b-Schleife besteht. Dieses Verfahren ist immer (!) möglich und wird von der BLTUC-Routine ($A3BF) des Basic-Interpreters angewandt. Diese Verschiebe-Routine zerlegt den Bereich, der verschoben werden soll, in einen Bereich der aus 256-Byte-Blöcken besteht und in einen Restbereich. Beide Bereiche werden dann getrennt verschoben.

Folgendermaßen sieht die optimale Invertierroutine für den Bereich $3FD2 - $475F aus:

a)	Der exakt 7 Seiten umfassende Bereich 3FD2 - $46D1 wird mit einer Typ-b-Schleife wie in Listing 22 komplementiert.

b)	Der Restbereich $46D2 - $475F wird mit einer Typ-a-Schleife wie in Listing 13 komplementiert.

Wir haben nun viele verschiedene Schleifenkonstruktionen in Theorie und Praxis behandelt. Was uns noch fehlt, sind Formeln, nach denen Sie die einzelnen Parameter (zum Beispiel den Startwert für X in einer Dekrementier-Schleife vom Typ a) errechnen können. Als Zusammenfassung finden Sie in Form von Listing 23 ein Hypra-Ass-Assemblerlisting zu mehreren Schleifenkonstruktionen. An den Quelltext-Ausdrücken können Sie sehen, wie einzelne Parameter errechnet werden können.

Merke: Sofern es der Programmablauf zuläßt, sollten Sie Inkrementierschleifen verwenden.

Bei Verschiebeschleifen ist aber oft eine Dekrementierschleife erforderlich.

Noch etwas zum Schleifen-Inhalt: Wenn mehrere Schleifen einen gleichen Innenteil haben (zum Beispiel einen Invertierbefehl), definieren Sie diesen unbedingt als Makro und nicht als Unterprogramm! JSRs sollten Sie nur beim Aufruf von ROM-Routinen verwenden.

Damit wäre das Thema »Schleifen« erst einmal abgeschlossen. Im nächsten Abschnitt(überSelbstmodifikation) werden wir uns aber wieder mit Schleifen auseinandersetzen.

## 10.	Selbstmodifikation

Bevor wir uns mit dieser Programmiertechnik beschäftigen, die zwar nicht strukturiert, aber sehr trickreich ist, soll der Begriff geklärt werden.

Unter Modifikation versteht man »eine Änderung, Anpassung«. Wenn Sie bei einem Spiel einen der vielen POKE-Befehle, die im 64’er schon vorgestellt wurden, eingeben, so wird dadurch das Spiel »modifiziert«. Die Änderung ist zum Beispiel eine Erhöhung der Spielfigurenanzahl.

Selbstmodifikation bedeutet, daß ein Programm sich selbst programmgesteuert verändert. Dies wäre der Fall, wenn im Spielprogramm eine Passage stünde, die den POKE ausführt.

Wenn Sie sich für die Selbstmodifikation von Basic-Programmen interessieren, finden Sie in der Zeitschrift »Happy-Computer« (Ausgabe 8/85) unter der Überschrift »Lernen Sie Ihren Commodore 64 kennen« alles, was Sie wissen müssen. Auf simulierten Direktmodus wurde im 64’er schon mehrfach eingegangen, unter anderem in der »Memory Map mit Wandervorschlägen«.

Wir werden uns an dieser Stelle ausschließlich mit der Selbstmodifikation von Maschinenprogrammen befassen. Als erstes Beispiel nehmen wir Listing 24.

Es handelt sich um eine selbstmodifizierende Schleife, die den Bereich $2000 - $3FFF komplementiert.

TRACEn Sie doch einmal Listing 24 mit dem SMON und vergleichen Sie die disassemblierten Befehle mit den ursprünglichen Werten, die Sie in Listing 24 finden. Sie werden erkennen, daß die Befehle »6002 LDA 2000,Y« und »6007 STA 2000,Y« aufgrund der INC-Befehle immer auf andere Adressen zugreifen. Besagte INC-Befehle erhöhen jeweils das High-Byte des Operanden. Ist dieses schon $40, so wird die Schleife beendet. In Listing 25 sehen Sie, wie unsere Schleife aus Listing 24 aussieht, wenn sie fertig durchlaufen wurde. Ein weiterer Start bewirkt, daß das Programm sich früher oder später selbst invertiert und darum abstürzt.

Was nämlich unserem Listing 24 fehlt, damit es mehr als einmal arbeitet, ist eine Initialisierung, diejedesmal den Ausgangswert ($2000) in die LDA/STA-Befehle einsetzt. In Listing 26 sehen Sie eine solche Initialisierung (6000 -600F). Die Adresse $FFFF (bei 6012 und 6017) ist ein Dummy-Wert, das heißt er dient nur zum vorläufigen Ausfüllen von Adressen und hat keine programmtechnische Bedeutung. Der Dummy-Wert wird ohnehin von der Initialisierung überschrieben; wir hätten also statt $FFFF auch $040C oder andere verwenden können. Wichtig ist nur, daß »LDA DummyY« 3 Byte belegt.

Ein besonderer Vorteil der Selbstmodifikation ist es, daß selbstmodifizierende Schleifen keine Zähler in der Zeropage benötigen, weil der Zähler praktisch im Programm selbst liegt. In puncto Geschwindigkeit sind selbstmodifizierende Schleifen den herkömmlichen aber oft unterlegen.

Ein weiterer Vorteil von ihnen ist aber, daß man außer mit weniger Zeropage-Speicherplätzen auch mit weniger Registern auskommen kann (sofern man hier Einsparungen vornehmen will). Listing 27 beispielsweise invertiert den Bereich $3FD2 - $475F. X- und Y-Register sowie die Zeropage bleiben unverändert, lediglich der Akkumulator fungiert als Arbeitsregister.

Listing 28 kopiert den Basic-Interpreter ($A000 - $BFFF) ins RAM an gleicher Adresse, wobei nur das X-Register verwendet wird (!).

Nun wollen wir sehen, wie man bei der Entwicklung selbstmodifizierender Programme unter Zuhilfenahme eines guten Assemblers (Hypra-Ass) vorgehen muß.

Zunächst einmal müssen diejenigen Stellen, an denen Modifikationen vorgenommen werden, mit Label definiert werden. Von diesen Label aus können die Stellen im Speicher die geändert werden sollen, leicht berechnet werden.

Befehlscode = LABEL + 0 = LABEL
Low-Operand	=	LABEL + 1
High-Operand	=	LABEL + 2

Bei 2-Byte-Befehlen wird der Parameter wie der Low-Operand eines 3-Byte-Befehls errechnet.

Als Beispiel finden Sie in Form von Listing 29 einen Quelltext (Assembler: Hypra-Ass) für Listing 28. Während in Listing 28 der Ausgangswert bei 6010 »LDX 0000« und bei 6013 »STX 0000« ist, wurde im Quelltext $FFFF verwendet (270, 280), um den Assembler zu zwingen, den Dummy-Wert als 16-Bit-Adresse abzulegen (und nicht als Zeropage-Adresse, wodurch der Befehl nur 2 statt 3 Byte belegen würde).

Die Stellen, die modifiziert werden, wurden mit »MOD1« und »MOD2« definiert. MOD1 ist zugleich der Schleifenbeginn.

Nachdem Sie jetzt den Eingang gefunden haben, möchte ich einige Anregungen liefern, wie Sie die Vorteile der Selbstmodifikation nutzen können. Wir werden hier die Anwendung nach den verschiedenen Adressierungsarten unterteilen.

### a)	Anwendung auf absolute Adressierung

Bei der Stapelmanipulation haben wir schon ein Verfahren kennengelernt, den Befehl JSR (indirekt), der im normalen 6510-Befehlssatz nicht existiert, zu simulieren.

Folgendermaßen kann über Selbstmodifikation ein Unterprogramm ab ADRESSE aufgerufen werden.

LDA # <ADRESSE
STA SPRUNGBEFEHL+1 ; Low-Operand
LDA # >ADRESSE
STA SPRUNGBEFEHL+2; High-Operand
SPRUNGBEFEHL
JSR $FFFF ; $FFFF=Dummy

Genauso kann man mit dem JMP-Befehl verfahren. Sogar bei den Schieber-, Dekrementier- und Inkrementierbefehlen, die im Gegensatz zu JMP die indirekte Adressierung nicht haben, ist auf diese Weise eine Simulation der indirekten Adressierung möglich.

Wird eine Sprungtabelle per Selbstmodifikation verarbeitet, müssen die Sprungadressen in der Tabelle nicht (!) dekrementiert werden.

### b)	Anwendung auf lmmediate-Befehle

Oft müssen Werte, die berechnet werden, auf dem Stapel oder im Speicher abgelegt und dann, wenn sie gebraucht werden, wieder aufgenommen werden.

Ein Beispiel hierfür ist der »Basic-Start-Generator« (64’er, 7/85, Seite 74). Bei Erwähnung dieses Programms taucht natürlich die Frage auf, ob es sich hier noch um ein selbstmodifizierendes Programm handelt oder ob der »Basic-Start-Generator« nicht eher zu den Programmgeneratoren zählt. Diese Frage ist voll berechtigt. Deshalb wollen wir darauf kurz eingehen.

Der »Basic-Start-Generator« ist eindeutig den Programmgeneratoren zuzuordnen, da der generierte Programmteil nie angesprungen wird und somit ein eigenständiges Programm darstellt. Das Programm modifiziert also nicht sich selbst, sondern vielmehr ein zweites Programm, welches dann vom Benutzer gespeichert werden kann.

Die Programmierung ist aber bei Programmgeneratoren nicht anders als bei selbstmodifizierenden Programmen. Auf den Unterschied Programmgeneration/Selbstmodifikation werden wir an späterer Stelle näher eingehen.

Zunächst wollen wir aber ein praktisches Beispiel für die Anwendung der Modifikation von lmmediate-Befehlen behandeln. Oft steht man vor dem Problem, ein Register zu sichern und später wieder zu holen. Im Falle des Akkumulators sieht das so aus:

PHA	; Akku sichern
...     ; weiteres Programm
PLA	; Akku wieder holen

Beim X-Register wird’s schon ungünstiger:

TXA	; X-Register in Akku
PHA	; Akku sichern
...........	; weiteres Programm
PLA	; Akku wieder holen
TAX	; Akku ins X-Register

Hier wird also zusätzlich der Akku beeinflußt. Wenn dies vermieden werden muß, wird folgender Weg gewählt:

STX $02	; $02 = Zwischenspeicher
... ; weiteres Programm
LDX $02	; X wieder holen

Für die Sicherung des X-Registers gibt es aber noch eine weitere Lösung, die den X-Wert im Programm ablegt und dadurch nicht den Stapel oder einen Zwischenspeicher außerhalb des Programms benötigt.

STX GETX+1 ; X direkt in lmmediate-Befehl schreiben
... ; weiteres Programm
GETX LDX #$OO ; $00 = Dummy-Wert

Obiges Beispiel kann sehr leicht auf Akkumulator oder Y-Register umgeschrieben werden.

Folgendermaßen kann das X-Register mit dem Akkumulator verglichen werden:

STX VGL+1 ; in Vergleichsbefehl ablegen
(............. ;	evtl, weitere Programme)
VGL CMP #$00	; $00 = Dummy

Als letztes Beispiel für die Anwendung auf Immediate-Befehle soll das Y-Register zum Akkumulator addiert werden:

STY ADD+1	; in Arithmetikbefehl ablegen
(.................... ;	evtl, weiteres Programm)
CLC	; Carry vor Addition
ADD ADC #$FF ; $FF = Dummy

Die Anwendungsmöglichkeiten sind hier unbegrenzt.

### c)	Anwendung auf komplette Befehle

Bisher haben wir nur die Parameter einzelner Befehle modifiziert. Es ist selbstverständlich auch möglich, die Befehlscodes oder die kompletten Befehle zu modifizieren.

Wenn nur der Befehlscode geändert wird (zum Beispiel ein ORA #- in einen EOR #-Befehl) bleiben die Parameter erhalten. Es könnte ferner ein impliziter Befehl (SEI,CLI,CLD, DEX,INX...) geändert werden, um beispielsweise zwischen In- und Dekrementieren umzuschalten. Außerdem könnte bei einem BRANCH-Befehl die Sprungbedingung (CS,CC,VS, VC,NE,EQ) geändert werden. Aus BCS könnte also leicht BCC werden.

Weil man hier die Opcodes der Befehle kennen muß, empfehle ich das erste 64’er Extra (Ausgabe 9/85) oder die Tabelle am Ende dieser Ausgabe.

Nun lösen wir noch das häufig auftretende Problem, wie die Ausführung eines Unterprogramms verhindert wird. Dazu werden wir drei Lösungen (I - III) entwickeln.

**I**. Die Adresse FLAG wird auf 0 gesetzt, wenn das Unterprogramm ausgeführt werden soll; auf einen anderen Wert, wenn es nicht ausgeführt werden soll.

LDA # 0	;	Flag für Ausführung
STA FLAG	;	Flag setzen
(.......... ;	evtl, weiteres Programm)
LDA FLAG	;	Flag testen
BNE NEIN	;	Flag < > 0, also nicht ausführen
JSR UNTERPROGRAMM ; Aufruf weiteres Programm
NEIN .....

Das Flag könnte auch am Beginn des Unterprogramms abgefragt und dann (wenn FLAG < > 0) das Unterprogramm verlassen werden.

**II**. Als ersten Befehl des Unterprogramms verwenden wir NOP:

UP NOP	; Beginn des Unterprogramms
........	; Fortsetzung des Unterprogramms

So wird die Ausführung des Unterprogramms gestattet:

LDA # $EA ; Opcode für NOP
STA UP	; an Anfang des Unterprogramms schreiben

Und so wird sie verhindert:

LDA #$60	; Opcode für RTS
STA UP	; an Anfang des Unterprogramms schreiben

Wer noch einen NOP-Befehl und damit 1 Byte sparen möchte, kann den NOP-Befehl entfallen lassen. Dann muß auch der Opcode $EA beim Erlauben des Unterprogramms in den Opcode des ersten Byte im Unterprogramm geändert werden. Weil dies ziemlich mühselig ist, ziehe ich die ursprüngliche Lösung II trotz des um 1 Byte erhöhten Speicherbedarfs vor.

**III**.	Das beste Verfahren. Wir schalten den JSR-Befehl aus, indem wir ihn in einen BIT-Befehl abändern.

AUFRUF JSR Unterprogramm

JSR ausschalten:

LDA # $2C ; Opcode für BIT STA AUFRUF

JSR wieder erlauben:

LDA #$20 ; Opcode für JSR STA AUFRUF

Der JSR-Opcode kann auch mit $0C überschrieben werden. $0C ist ein illegaler Opcode für ein 3-Byte-NOP und arbeitet mit allen mir bekannten Versionen des C 64. Ob er ebenfalls auf dem C 128 läuft, konnte ich noch nicht prüfen.

Im übrigen können mit dem soeben beschriebenen Verfahren auch andere Befehle ausgeschaltet werden, zum Beispiel JMP, LDA, STA und so weiter. Wenn aber der JSR-Opcode mit $2C (BIT) überschrieben wird, ist darauf zu achten, daß bei der Ausführung des BIT-Befehls die Prozessorflags gesetzt werden.

Sicherlich gibt es noch mehr Problemlösungen als I - III, aber III dürfte wohl kaum zu übertreffen sein.

### d)	Anwendung auf mehrere Befehle

Selbstverständlich können ganze Befehlsfolgen, also größere Programmteile gegeneinander ausgetauscht werden. Zu beachten ist nur, daß die Routinen, die gegeneinander ausgetauscht werden, auch in dem Bereich, in den sie vom Programm aus geschrieben werden, lauffähig sind. Dies ist vor allem dann gegeben, wenn nur die relative Adressierung verwendet wird und dadurch die Routine im Speicher frei verschoben werden kann.

### e)	Anwendung auf Tabellen

Dieser Anwendungsfall würde auch zum Abschnitt über »Tabellen« passen.

Wir bleiben hier bei der Theorie, denn die Umsetzung in ein Programm ist nicht mehr schwer. Vielmehr soll Ihre Kreativität nicht durch Unmengen von Beispielen gehemmt werden.

Zunächst wollen wir uns ein wenig mit dem SMON befassen. Wenn Sie den Disk-Monitor einschalten, kopiert das Programm einen Floppy-Befehl («U1 ..«) vom Ende des SMON in einen Bereichzwischen $02A0 und $02FF. Dieser Lesebefehl wird nach Bedarf modifiziert, zum Beispiel wird beim Schreiben der »U1«- in einen »U2«-Befehl umgewandelt oder die Angabe des einzulesenden Blocks wird geändert. Dies wäre ein typisches Anwendungsbeispiel für Selbstmodifikation, wenn der Lesebefehl nicht erst in einen Bereich außerhalb des Programms kopiert würde (worin ich keinen Sinn sehe), sondern am Ende des SMON (etwa bei $CFF0) bliebe und dort modifiziert würde.

Im Hi-Eddi liegt eine Tabelle, die die High-Byte der Bit-Map-Anfangsadressen beinhaltet. Diese Tabelle wird von Hi-Eddi bei jedem Bildwechsel umgerechnet.

Nach den vorausgegangenen zwei Beispielen an Spitzenprogrammen aus dem 64’er möchte ich noch andere Anwendungsbeispiele nennen.

Besonders flexible Programme erlauben Eingriffe des Anwenders in die Befehls- oder Text-Tabellen. So können Bildschirmmasken editiert oder Eingabemasken erstellt werden.

Ein solches Programm braucht sich nach den Modifikationen nur selbstabzuspeichern. Weil hier unter Umständen ein erheblicher Teil des Programmschutzes verlorengeht, werden dann lediglich die Tabellen gespeichert.

Ein Adventure-Generator modifiziert in der Regel auch nur die Tabellen eines fertigen Adventureprogramms, das eigentliche Programm bleibt unverändert. In diesen Tabellen sind die einzelnen Spielsituationen enthalten.

Bei diesen (theoretischen) Fällen wollen wir es belassen. Letztendlich muß ja der Programmierer entscheiden, inwieweit er die Selbstmodifikation auf Tabellen anwenden kann.

### f)	Das Beispielprogramm »Loader-Maker 64«

Wie aus dem Namen des Beispielprogramms schon zu entnehmen ist, handelt es sich um einen Programmgenerator. Da - wie gesagt - die Programmierung wie bei selbstmodifizierenden Programmen ist, habe ich bewußt einen Programmgenerator als Beispiel gewählt.

Als Listing 31 finden Sie ein MSE-Listing, falls Sie »Loader-Maker 64« bequem abtippen wollen und an der Anwendung des Programms interessiert sind. Deshalb zunächst eine Kurzbeschreibung für Anwender.

»Loader-Maker« ermöglicht es Ihnen, zu einem Programm ein (Maschinensprache-) Ladeprogramm zu generieren, welches normal geladen und mit »RUN« gestartet wird, worauf es das nachzuladende Programm nachlädt und startet.

Nach dem Laden von »Loader-Maker« wird dieses Programm durch SYS 2154,START gestartet. START ist eine Variable und wird durch die Startadresse des nachzuladenden Programms ausgedrückt. Soll ein Basic-Programm nachgeladen werden, hat diese Adresse keine Bedeutung (einfach SYS2154,0 eingeben). Bei einem Maschinenprogramm handelt es sich hier um die Adresse, mit der das Programm über »SYS« gestartet wird (49152 beim SMON $C000).

Das Programm meldet sich mit »Loader-Maker 64« und gibt die Startadresse aus. Dazu können Sie den Filenamen eingeben.

Bei allen weiteren Eingaben (Gerätenummer, von der geladen werden soll; Maschinenprogramm j/n; Systemmeldungen wie »SEARCHING FOR« ausgeben j/n; LOAD ERROR bei Ladefehler ausgeben j/n) können Sie das Programm durch Eingabe des Linkspfeils abbrechen. Sind alle Eingaben gemacht worden, kommt die Meldung »LOADER GENERIERT« und der Lader kann mit »SAVE« gespeichert werden.

Wenn das nachzuladende Programm von der Adresse geladen werden soll, von der auch das Ladeprogramm selbst eingelesen wurde, ist als Gerätenummer nur 0 einzugeben.

Befassen wir uns nun mit dem Programm, dessen Quelltext Sie als Listing 30 finden.

Die Zeilen bis 990 stellen das Ladeprogramm in unmodifizierter Form dar und enthalten viele Dummywerte, wie zum Beispiel die (unsinnige) Startadresse 0 in Zeile 820.

Mit 1000 beginnt die Modifikationsroutine. Nach 1120 wurde die Startadresse eingelesen, die ja per SYS übergeben wurde, und wird wieder mit dem Titel ausgegeben. 1100/1110 schreiben die Startadresse hinter den JMP-Befehl in Zeile 820.

1150 - 1350 bringen das (noch unmodifizierte) Gerüst in den Ausgangszustand, der dann nach Bedarf geändert wird.

1400 - 1550 holen den Filenamen, legen ihn bei NAME (850) ab, berechnen gleich die Länge des Filenamens und legen diese bei LAENGE (750) ab.

1600 - 1720 holen die Geräteadresse. Da diese im ASCII-Fbrmat vorliegt, muß der ASCII-Code von 0 abgezogen werden (1640/1650). Wurde 0 eingegeben, wird der LDX # DEVICE-Befehl (730) in »LDX $BA« geändert. Die Adresse $BA enthältjeweils die Adresse, von der das letzte Programm geladen wurde.

1750 - 1850 fragen, ob das nachzuladende Programm mit der per SYS übermittelten Startadresse gestartet wird (Eingabe »j«). Wurde »n« eingegeben, muß das Programm über den Basic-Befehl RUN eingegeben werden. Auf eine entsprechende Routine (870 - 980) wird die Startadresse gestellt (1810 - 1840).

1900 - 1970 ermöglichen die Einstellung, ob »SEARCHING..«, »LOADING« etc. ausgegeben werden sollen.

Soll im Falle eines Ladefehlers das Programm nicht gestartet und stattdessen »LOAD ERROR..« ausgegeben werden, wird dies bei 2000 - 2090 festgelegt. Wird die Fehlerausgabe unterdrückt, muß der BCS-Befehl (810) unschädlich gemacht werden. Dies geschieht einfach dadurch, daß die Sprungweite auf 0 gesetzt wird (2070/2080).

Am Programmende wird noch eine Meldung ausgegeben (2140 - 2160) und der Vektor für das Ende des Basic-Programms neu gesetzt, damit das generierte Ladeprogramm mit »SAVE« gespeichert werden kann.

10000 - 10310 enthalten nur die Text-Tabellen.

Von 15000 bis zur letzten Zeile (15170) steht ein Unterprogramm, daß bei jeder J/N-Entscheidung über »JSR J,N« aufgerufen wird.

Es gibt den Text »(J/N)?« aus (15030 - 15050) und holt eine Eingabe. Ist diese »J«, so ist nach dem Verlassen des Unterprogramms (1517) das Zero-Flag gesetzt (andernfalls < nicht).

Wurde der Linkspfeil eingegeben, wird das Programm abgebrochen und eine entsprechende Meldung ausgegeben (15100- 15150).

Wie wir nun gesehen haben, handelfes sich bei »Loader-Maker« um einen Programmgenerator. Mit zwei kleinen Änderungen wird erjedoch zum selbstmodifizierenden Ladeprogramm. Wir müssen nur die beiden »JMP READY.«-Befehle (2240/15150) in »JMP SYSTEM« umwandeln, wodurch am Programmende der generierte Lader angesprungen würde. Schon hätten wir ein selbstmodifizierendes Ladeprogramm.

Um Ihnen noch die Anwendung des Loader-Maker zu erleichtern, hier zwei Eingabebeispiele:

Startadresse.................49152
Filename.....................SMON $C000
Geräteadresse................0
Maschinenprogramm............j
Systemmeldungen..............j
LOAD ERROR ausgeben..j
Startadresse.................0 (bedeutungslos)
Filename.....................HI-EDDI
Geräteadresse................8
Maschinenprogramm............n
Systemmeldungen..............n
LOAD ERROR ausgeben. .j

### g)	Verbesserungen an »Tabellen-Beispiel«

Zum Abschluß des Themas »Selbstmodifikation« wollen wir noch kleine Verbesserungen am Programm »Tabellen-Beispiel« erwähnen. Ich werde hier eher Anregungen geben als fertige Änderungsvorschläge.

Zunächst soll die Adresse XSÄVE (zum Sichern des X-Registers in Schleifen) überflüssig werden. So könnte es nun gesichert werden:

XSV STX GETX
...
GETX LDX #$00 O=Dummy; hier wird X wieder aufgenommen.

Auch die Sprungtabelle läßt sich - viel einfacher, finde ich - anders handhaben:

LDA J?LO,X	JMLO oder JELO
STA SPRO+1
LDA J?HI,X	JMHI oder JEHI
STA SPRG+2
SPRG JMP 0000

In den Tabellen JMLO/JMHI und JELO/JEHI (Low- und High-Bytes der Sprungadressen) dürfen die Adressen aber nicht dekrementiert werden.

Wird ein JSR (IND)-Befehl simuliert, muß nach wie vor die Rücksprungadresse auf den Stapel gelegt werden. Dies würde entfallen, wenn die Rücksprungadresse direkt auf »SPRG JMP 0000« folgen und der JMP-Befehl bei SPRG in JSR umgewandelt würde.

Damit soll das Thema »Selbstmodifikation« abgeschlossen sein. Die vorgestellten Programmiertechniken bieten fast unbegrenzte Möglichkeiten, hier konnte ich nur einen kleinen Überblickgeben, welcher aber für fortgeschrittene Programmierer ausreicht.

## 11.	Mehr über relative Adressierung

So wie wir schon die Tücken der Zeropage-Adressierung zumindest teilweise beseitigen konnten, wollen wir uns mit der in vergleichbarer Weise leistungsstarken Relativ-Adressierung auseinandersetzen.

### a)	So vermeidet man JMP

Oft muß eine Stelle im Programm angesprungen werden, ohne daß erst eine Bedingung geprüft wird. Diese Stelle ist nicht selten weniger als 128 Byte vom Sprungbefehl entfernt, könnte also relativ adressiert werden.

Dennoch ist es in vielen Fällen möglich, einen Branch-Befehl - obwohl diese Befehle eine Bedingung (C=0..) prüfen - zu verwenden.
Beispiel:

7050	BNE 7040
7052	JMP 708A

Kann ersetzt werden durch:

7050	BNE 7040
7052	BEQ 708A

da bei 7052 in jedem Fall das Z-Flag = 0 ist (dafür sorgt der Abfang-Befehl BNE) und somit immer verzweigt wird.

Man könnte den BEQ-Befehl als »Pseudo-Verzweigungsbefehl« bezeichnen, da die Bedingung gar nicht überprüft werden müßte (sie ist sowieso erfüllt).

Der Branch-Befehl übertrifft den JMP-Befehl deutlich an Effektivität, da ein Byte weniger verbraucht wird.

Im übrigen ist auch bei

7050	BVS 7040
7052	CLV

der CLV-Befehl überflüssig, solange vor7052 der Befehl von 7050 verarbeitet wird.

### b)	Zugriff auf Befehle in »Umgebung«

Unter »Umgebung« wollen wir den Bereich um einen Programmteil verstehen, der über relative Adressierung angesprochen werden kann. Da in diesem oft ähnliche Befehlsfolgen stehen wie im anderen Programm, läßt sich hier durch gezielten Zugriff auf die »Umgebung« der Speicherplatzbedarf senken.

Beispielsweise stehen an vielen Stellen im Programm RTS-Befehle. Diese werden, wenn ein Unterprogramm verlassen werden soll, manchmal durch einen Branch-Befehl angesprungen.

X1 RTS ; Ende eines im Speicher vorausgehenden Unterprogramms
UP .......	; Unterprogramm
TEST BEQ X2 ; Unterprogramm verlassen, falls Z=0
..........	; andernfalls weiteres Programm
X2 RTS ; Ende des Unterprogramms

Wenn X1 von TEST aus relativ adressiert werden kann, können wir folgendermaßen ein Byte sparen:

X1 RTS
UP ...
TEST BEQ X1 ; nach X1 springen, wo auch ein RTS steht
X2 RTS ; wird nicht mehr benötigt

Noch ein Beispiel aus dem Basic-Interpreter. Bei Adresse $AF08 stehen zwei Befehle, die einen SYNTAX ERROR erzeugen.

Nun gibt es im Basic-Interpreter unzählige Stellen, an denen ein SYNTAX ERROR aufgerufen werden muß. Deshalb steht dort nur »JMP $AF08«. Diese Stellen werden bei Bedarf relativ adressiert, so daß nicht an jeder Stelle, an der ein SYNTAX ERROR aufgerufen wird, der Befehl »JMP $AF08« stehen muß.

Zur Übung könnten Sie noch versuchen, im Programm Tabellen-Beispiel (Listing 11) die Menüroutine (insbesondere die Routinen HOME, DOWN, UP, EXEC), in der beispielsweise wiederholt STX MPT steht, durch Zugriff auf »Umgebung« zu optimieren. Besonders hilfreich dürfte es sein, zunächst statt Branch-Befehlen JMPs einzusetzen und dann zu überlegen, inwieweit die JMPs durch Branches ersetzt werden können, weil zum Beispiel nach »LDX # 0« das Z-Flag immer gesetzt ist etc.

## 12.	Puffer-Technik

In der Computerei fällt der Begriff »Puffer« sehr häufig. Beim C 64 gehören der Kassetten- und der Tastaturpuffer gemeinhin zu den bekanntesten Puffern. Statt »Puffer« kann man auch Zwischenspeicher sagen. Puffer dienen nämlich immer als Zwischenspeicher.

Zunächst wollen wir klären, was zu einem Puffer gehört,

### a) Was benötigt ein Puffer?

– Pufferspeicher

Selbstverständlich muß ein Puffer einen bestimmten Speicherbereich belegen, in dem die Werte zwischengespeichert werden.

Ebenso muß die maximale Puffergröße festgelegt werden, damit geprüft werden kann, ob sich der Puffer schon angefüllt hat. Beim Kassettenzugriff werden vorerst alle Byte, die auf die Kassette sollen, im Puffer (ab $033C) zwischengespeichert. Ist dieser Puffer voll, würde er beim nächsten Byte, das er aufnehmen soll, überlaufen (das heißt, die maximale Puffergröße überschreiten). Deshalb wird dann Byte für Byte der Puffer entleert, indem die Bytes auf Kassette geschrieben werden. Jedes Byte, das auf Kassette geschrieben wurde, belegt keinen Speicher mehr im Puffer, so daß der Puffer wieder aufnahmefähig ist.

Damit das Programm, das den Puffer verwaltet, auch weiß, aus welcher Adresse im Puffer es sich das nächste Byte holen soll beziehungsweise wo im Puffer das nächste Byte abgelegt werden soll, gibt es noch einen
– Pufferzeiger

Auf englisch heißt er »BUFFER-POINTER«, woher auch die Abkürzung »B-P« beim Floppy-Befehl zur Manipulation des Pufferzeigers stammt.

Dieser Pufferzeiger kann mit dem Stapelzeiger verglichen werden. Auf keinen Fall ist er mit dem
– Puffervektor

zu verwechseln, der die Startadresse des Pufferspeichers beinhaltet. Ein Puffervektor ist nicht unbedingt erforderlich, erhöht aber die Flexibilität.

Damit wären die Fachausdrücke im Zusammenhang mit Puffern geklärt.

### b) Wann verwendet man Puffer?

Puffer dienen in der Regel als Zwischenspeicher, wie zum Beispiel der Basic-Eingabepuffer (ab $0200).

Im Fall des Tastatur- oder Diskettenpuffers aber sind die Puffer als Verbindungsstelle zwischen zwei parallel arbeitenden Programmen beziehungsweise Peripheriegeräten vorgesehen (interruptgesteuerte Tastaturabfrage/Hauptprogramm im Computer, DOS/Betriebssystem des Computers).

Die Puffer sind in diesen Fällen ein Bereich, auf den zwei (quasi-) parallel arbeitende Programme zugreifen.

Bei Computern, die ein wirklich starkes Multitasking bieten (wie der Commodore Amiga) finden Puffer weitaus mehr Verwendung als beim C 64, der nur einen quasiparallelen Ablauf ermöglicht.

Daher werden bei ihm Puffer hauptsächlich im I/O-Bereich verwendet, zum Beispiel bei Druckern, Datasette, Floppy, Tastatur etc. (I/O = lnput/Output = Eingabe/Ausgabe).

## 13.	Pass-Technik

### a)	Begriffserläuterung

Der Begriff »Pass« wurde schon mehrfach im 64’er erläutert (unter anderem Ausgabe 7/85, Seite 51).

Am einfachsten kann der Begriff als »Schritt beim Programmmablauf« verstanden werden. Mit »Schritt« ist hier nicht ein einzelner Befehl, sondern ein größerer Block im Programm gemeint.

Wenn ein Programm in 3 Passes (Durchläufen) arbeitet, heißt dies, daß 3 Schleifen hintereinander abgearbeitet werden, die alle eine Teilaufgabe erfüllen, die in Verbindung mit den anderen Passes erst eine größere Aufgabe (zum Beispiel eine Assemblierung) ausfüllen kann. Jeder einzelne Pass führt eine bestimmte Tätigkeit aus, die für das Funktionieren der darauffolgenden Passes unbedingt erforderlich ist. Pass 1 wirkt also wie eine Initialisierung von Pass 2 etc.

Komplexe Programme in Schritte (Passes) zu gliedern, gehört zu den Grundregeln des strukturierten Programmierens.

### b)	Beispiele von Anwendungen der Pass-Technik

Besonders umfangreiche Programme wie Assembler (Hypra-Ass), Compiler (Austro-Speed) und Interpreter (Comal) sind immer in mehrere Passes eingeteilt.

So erfolgt bei den meisten Assemblern im ersten Pass ein Syntax-Check und das Anlegen der Symbol-Tabelle. Erst im zweiten Pass wird der Objektcode generiert, wobei die bereits erstellte Symboltabelle benötigt wird.

## 14.	Diverse Tips zur optimalen Speichernutzung

Mit übermäßig viel RAM ist der C 64 bestimmt nicht gesegnet. Bei vielen Anwendungen (zum Beispiel Datenverarbeitung) braucht man auch das letzte Byte.

Sie werden nun mehrere Tips erhalten, wie man den wenigen vorhandenen Speicher möglichst sparsam verwenden kann.

Zu den speicherplatzaufwendigsten Einrichtungen gehören die Puffer. Der Kassettenpuffer beispielsweise belegt den RAM-Bereich $033C - $03FB, auf den man somit oft verzichten muß.

Hier wollen wir einfach den Kassettenpuffer in den Bildschirmspeicher (ab $0400 in Normaleinstellung) verlegen.

LDA #<$400
LDY #>$400
STA $B2
STY $B3

Da der Bildschirm beim Kassettenbetrieb ohnehin abgeschaltet wird, fällt dies nicht auf. Nach dem Kassettenbetrieb sollte man aber den Bildschirm unverzüglich löschen.

Ebenso kann man andere Puffer, für die es einen Vektor gibt, problemlos nach $400verlegen, sofern sie nicht größer als 1000 Byte sind.

Ein Problem für sich stellt das RAM ab $E000 (also unter dem Betriebssystem!) dar. Diesen Speicher kann man nur durch Bank-Switching nutzen, wobei man noch auf das Betriebssystem verzichten muß, solange der $E000-Bereich auf RAM geschaltet ist.

Hier können wir uns zunutze machen, daß der VIC auch ohne Ändern des Prozessor-Ports (Adresse $0001) auf diesen RAM-Bereichzugreifen kann. FürGrafikbilderodereinen geänderten Zeichensatz ist der$E000-Bereich bestens geeignet.

Oft wird der $E000-Bereich zur Ablage verschiedener Daten verwendet, auf die nicht andauernd zugegriffen werden muß.

Man könnte aber auch das Betriebssystem ins RAM ab $E000 kopieren und diejenigen Bereiche, in denen nicht benötigte Routinen stehen (zum Beispiel für Kassettenbetrieb) einfach überschreiben. Dies ist dann sinnvoll, wenn nur ein paar Byte im $E000-Bereich gebraucht werden. Außerdem ist eine gute Kenntnis des C 64-ROMs erforderlich.

Nun wollen wir noch besprechen, wie der Speicherplatzbedarf eines Programms niedriggehalten werden kann. Dazu wurde im Laufe des Kurses schon einiges gesagt (Unterprogramme statt Makros verwenden etc.).

Jedes Programm benötigt eine Menge Flags. Meist belegt ein Flag genau 1 Byte, für dessen Inhalt es oft nur zwei mögliche Werte gibt: einen für »JA« und einen für »NEIN«.

Für diese primitive Unterscheidungsform genügt aber auch 1/8 Byte, also ein Bit.

Wenn Sie sich das 64’er Extra in der Ausgabe 10/85 ansehen, werden Sie feststellen, daß fast jedes VIC-Register mehrere Funktionen hat, weil jedem Bit eine eigene Bedeutung zukommt. Würde der VIC hier statt auf Bits auf Bytes zugreifen müssen, wäre er

1.	langsamer und
2.	würde der Speicherplatzaufwand für die Register sich vervielfachen.

Man sollte also bei Flags jedem Bit eine Bedeutung geben und nur die Bits prüfen:

BIT FLAG

Danach ist das N-Flag gesetzt, falls das 7. Bit im FLAG gesetzt ist, und das V-Flag, falls das 6. Bit gesetzt ist. Die übrigen Flags erhält man über das Z-Flag im Prozessor-Status-Register mit Hilfe des Akkus. Angenommen, man möchte testen, ob Bit 0 im Flag gesetzt ist oder nicht, dann macht das folgendes Programm:

LDA #01
BIT Flag
BNE ???	; (Bit gesetzt)
.
.
.
; (Bit nicht gesetzt)

Der Bit-Befehl ANDet den Inhalt des Akkus mit dem Inhalt der Speicherzelle »Flag«. Möchte man Bit 1 testen, so ist der Befehl LDA # 01 zu ersetzen durch LDA # 02 und so weiter.

Durch Selbstmodifikation können Flags bekanntlich vermieden werden. Aber auch sonst bietet die Selbstmodifikation die Möglichkeit, Speicherplatz zu sparen: die Steuerung einer Sprungtabelle belegt mit Selbstmodifikation weniger Speicher als ohne.

Auch die »Wegwerfmethode« ist sehr vorteilhaft. Programmteile werden einmal abgearbeitet und dann (zum Beispiel durch Nachladen) überschrieben.

Damit hätten wir unseren Kurs abgeschlossen. Ich hoffe, daß er Ihnen etwas Spaß gemacht hat und Sie einige interessante Informationen herausholen konnten. Sie sollten sich jedoch darüber im klaren sein, daß einige der hier vorgestellten Methoden die Lesbarkeit eines Assembler-Listings einschränken können. Also, verzichten Sie, wenn nicht unbedingt notwendig, auf allzu trickreiche Programmierung. Falls Sie noch Fragen oder Probleme haben (vielleicht erst wegen diesem Artikel), dann schreiben Sie doch einfach.

(Florian Müller/tr)

# Schleifen mit Format [141-143]

> In manchen Pascal-Versionen geht es automatisch, beim C 64 nur mit einem Trick: das Einrücken von Schleifen. Anhand eines Programms in Maschinensprache bringen Sie Form in Ihre Listings. Wir zeigen auch, wie es geht.

Anhänger der strukturierten Programmierung haben es gelernt, selbst der in Schulungen: ein Programm modular aufbauen, in kleine Schritte zerlegen, übersichtlich gestalten. Leider ist es mit dem C 64 nicht so ganz einfach. Außer IF..THEN, GOTO, GOSUB und FOR..NEXT wird strukturiertes Codieren nicht unterstützt.

Eine Möglichkeit ist, FOR..NEXT-Schleifen einzurücken. Normalerweise macht man das, indem nach der Zeilennummer ein Doppelpunkt gesetzt wird und erst danach die gewünschte Anzahl Leerstellen. Ein kurzes Beispiel:
Schleife ohne einrücken:

10 FOR I=1 TO 10
20 A = A + 1
30 GOSUB 100
40 FOR J = 1 TO10
50 PRINT I,J,A\*J
60 NEXT J
70 NEXT I
Schleife mit einrücken durch Doppelpunkte:
10 FOR I=1 TO 10
20 : A=A+1
30 : GOSUB 100
40 : FOR J=1 TO 10
50 : PRINT I,J,A\*J
60 : NEXT J
70 NEXT I
Das sieht schon viel besser aus. Bei langen Listings werden Sie diese Form schätzen lernen. Allerdings, das Nonplusultra ist es auch nicht. Besser wäre es, das Listing würde so aussehen:

10 FOR I=1 TO 10
20 A=A+I 100
30 GOSUB 100
40 FOR J = 1 TO 10
50 PRINT I,J,A\*J
60 NEXT J
70 NEXT I
Um das zu erreichen, müssen wir eine kleine Maschinenroutine schreiben. Aber wie?

Ein Gedanke liegt nah: Warum nicht die normale LIST-Routine des C 64 verwenden? Sie erledigt ja schon einen großen Teil der Aufgabe, nämlich das normale LISTen. Was fehlt, ist nur noch das Einrücken. Zuerst muß also ein dokumentiertes ROM-Listing her. Dort finden wir die LIST-Routine des Basic-Interpreters ab $A69C. Sie geht bis $A740. Soweit, so gut. Aber wie greifen wir in diese Routine ein? Sieht man sich die LIST-Routine etwas genauer an, findet man einen indirekten Sprung ab Adresse $A717 (JMP ($0306)). Das bedeutet, an dieser Stelle springt die LIST- Routine zu der Adresse, die sich aus dem Inhalt der Adressen $0306/$0307 (LO/HI-Byte) ergibt. Man spricht in so einem Fall auch von einem Vektor. Dort kurz spioniert, finden wir in $0306/$0307 die Zahlen $1A und $A7, zusammengesetzt also die Adresse A71 A, das heißt genau die Adresse, die dem JMP($0306) folgt. Damit haben wir genau das, was wir suchen, eine Möglichkeit, in die LIST-Routine einzugreifen. Denn $0306 steht im RAM, kann also (von uns) geändert werden.

Im Prinzip brauchen wir also nur folgendes zu machen: Wir schreiben die Anfangsadresse unserer Routine in die Speicherstellen $0306/$0307. Damit springt die Original-LIST- Routine unsere neue Routine an und führt sie aus. In »Fachkreisen« würde man sagen, der LIST-Vektor ist verbogen worden. Am Ende unseres Programms müssen wir noch dafür sorgen, daß die alte LIST-Routine wieder fortgesetzt wird und zwar machen wir das mit JMP $A71A.

Grundsätzlich kennen wir nun also das Wie. In der Zwischenzeit taucht aber noch ein Gedanke auf: Wie soll das Programm gestartet werden? Nach dem Lesen des Assembler-Kurses (Assembler ist keine Alchimie) im 64’er und einigen anderen Artikeln fällt das Stichwort: Interrupt.

Interrupt war für mich immer ein Wort, vor dem ich mich etwas gedrückt habe, aber so schlimm ist es gar nicht. Doch zuerst einmal zur Aufgabe: Die neue LIST-Routine soll mit der Funktionstaste F7 an- und mit F1 ausgeschaltet werden. Um das zu erreichen, muß noch einmal ein Vektor verbogen werden, und zwar der Interrupt-Vektor in Adresse $0314/$0315 auf unser eigenes Programm (siehe Listing 2, Zeilen 290 bis 360). Wir müssen dafür sorgen, daß die Tasten F7 und F1 dauernd abgefragt werden. Das erreicht man, indem die Interrupt-Routine erweitert wird. Auch hier hilft ein kleines Programm (Listing 2, Zeilen 364 bis 372). Im Prinzip soll unsere neue LIST-Routine so ablaufen:

1. Initialisieren des Programms mit SYS adresse (»adresse« können wir selbst festlegen)
2. mit F7 einschalten und mit F1 ausschalten.
3. mitdem ganz normalen LIST-Befehl ein beliebiges Basic-Programm auf dem Bildschirm oder Drucker ausgeben. Auf dem Drucker sollen die Basic-Befehle FOR und NEXT fettgedruckt werden.

Und damit auch zu sehen ist, ob die neue oder die normale Routine aktiviert ist, soll der Rahmen beim Drücken von F7 die Farbe wechseln (Listing 2, Zeile 452/453) und bei F1 ebenso (Listing 2, Zeile 522/523).

## Die LIST-Routine

Die eigentliche neue LIST-Routine finden Sie in Listing 2, Zeile 1000 bis 1340. Danach folgen einige Unterprogramme, zum Beispiel Fettdruck ein-/ausschalten und Leerzeichen ausgeben.

Um das Programm zu verstehen, muß man folgendes wissen:

1. Wenn die neue LIST-Routine angesprungen wird, steht im Akku ein Zeichen aus dem Basic-Listing, das wir ausgeben wollen. Das kann jedes Zeichen sein zwischen der Basic-Zeilennummer und dem Ende einer Basic-Zeile (die Zeilennummer selbst wird vorher, von der alten List-Routine selbst, ausgegeben.).
2. Der Akku-Inhalt muß am Ende unserer LIST-Routine wieder an das Original-LIST übergeben werden. Aus diesem Grund wird er sicherheitshalber am Anfang der Routine mit PHA gesichert und am Ende mit PLA zurückgeholt.
3. Jeder Basic-Befehl wird im Speicher als Token abgelegt, eine Abkürzung. Der Befehl FOR hat den Wert $81 und NEXT den Wert $82.

Der Algorithmus istjetzt nicht mehr schwer zu entwickeln. Da man FOR..NEXT-Schleifen (fast) beliebig schachteln kann, setzen wir einen Zähler ein (im Listing 2 ZAEHLER genannt), der die Anzahl der Verschachtelungen zählt: Bei jedem FOR wird ZAEHLER um 1 erhöht (Zeile 1210 bis 1240, bei jedem NEXT um 1 vermindert (Zeile 1160 bis 1180). Der Inhalt von ZAEHLER bestimmt auch die Anzahl der Leerzeichen, die am Anfang der Zeile, nach der Zeilennummer, ausgegeben werden (Zeile 1190 bis 1207). Der Anfang der Zeile wird durch eine 4 im Y-Register gekennzeichnet. Das hängt mit dem Aufbau einer Basic-Zeile im C 64 zusammen und mit der indirekt-indizierten Adressierung, die die LIST-Routine verwendet (Y=0 und Y=1 sind die Startadresse der Basic-Zeile, Y=2 und Y=3 die Zeilennummer und ab Y=4 folgt der Rest der Basic-Zeile).

Das Unterprogramm BLANKOUT (Zeile 2010 bis 2070 gibt Leerzeichen aus, und zwar so viele, wie in ZAEHLER stehen.

Die Routinen FETTDRUCK und NORMDRUCK schalten bei Ausgabe auf Drucker (mit OPEN 1,4:CMD1:LIST) Fettdruck an und aus. Interessant sind hier vielleicht die Zeilen 1510 bis 1530 oder 1710 bis 1730. Durch die Abfrage der Speicherstelle $9A (dezimal 154) kann die mit CMD gewählte Geräteadresse überprüft werden (4 steht für Drucker). Die Sequenz, diehiergewähltwurde, um Fettschrift einzuschalten, giltfür Epson-kompatible Drucker (Zeile 1630 und Normalschrift Zeile 1830). Sie können diese Routinen natürlich entfernen, es ist Geschmacksache, die FOR..NEXT- Schleife auch noch fettgedruckt zu sehen (Listing 1).

### Hinweise zum Abtippen

Listing 2 ist der Quelltext oder, wie man auch sagt, der Sourcecode der neuen Listroutine. Wenn Sie wollen, können Sie ihn mit Hypra-Ass eingeben. Das hat den Vorteil, daß Sie das Programm weiterentwickeln oder verändern können. Wollen Sie das Programm lediglich benutzen, tippen Sie am besten Listing 3 mit dem MSE ab. Gestartet wird mit SYS 5\*4096 oder SYS 20480. Mit F7 ist die neue LIST-Routine aktiv, mit F1 abgeschaltet. Auch während des LISTens kann umgeschaltet werden. Eine korrekte FOR..NEXT - Schleife wird daran erkannt, daß sich FOR und NEXT auf der gleichen Höhe befinden (Listing 1). Wenn Sie das Programm etwas genauer analysieren, dürfte es nicht schwerfallen, eigene Wünsche zu verwirklichen.

(H. Zwartscholten/gk)

# ÜberLISTet [143-144]

> Mit dieser Betriebssystemerweiterung wird das Schreiben von Basic-Programmen zum Vergnügen. Scrolling aufwärts und abwärts sowie einige Zusatzfunktionen machen es möglich.

Dieses Maschinenprogramm (eventuell in Verbindung mit einem Toolkit) macht das Editieren von Basic-Texten fast so komfortabel wie mit einem guten Textverarbeitungssystem. Man kann damit nämlich nicht nur, wie von vielen teuren Basic-Erweiterungen bekannt, das Listing mit den Cursortasten hinauf und hinunterscrollen, sondern auch:

- andere Erweiterungen verwenden
- einzelne Zeilen löschen und einfügen
- eine Zeile bis beziehungsweise ab Cursorposition löschen
- eine ganze Zeile mit Leerzeichen füllen
- einen Zeilenausschnitt beliebig oft an andere Positionen kopieren.

Dies alles geschieht auf einfachen Tastendruck und ohne Absturzgefahr.

Um mit möglichst vielen anderen Programmen zusammenarbeiten zu können, liegt das zirka 1300 Byte lange Programm im Bereich $7A00 - 7F20 (Hexadezimal). Dazu muß das Ende des Basic-Bereichs gegebenenfalls herabgesetzt werden (POKE 56,122:POKE 55,0: NEW). Mit »SYS 31232« wird die Erweiterung in den Interrupt eingehängt und ist dann sofort einsatzbereit. Es wird nur der IRQ-Vektor verändert.

Das Listing läßt sich im Direktmodus mit Hilfe der Cursortasten fließend hoch- und runterscrollen. Die Programmzeilen können dabei natürlich wie gewohnt geändert und mittels der RETURN-Taste übernommen werden. Stößt man jedoch mit dem Cursor gegen den oberen beziehungsweise unteren Bildschirmrand, wird der Inhalt des Bildschirms in die entsprechende Richtung gescrollt und die nächste Zeile ausgegeben.

Das Programm geht dabei so vor: Es sucht die am nächsten zum Cursor stehende Zeilennummer. Steht keine Zahl in der ersten Spalte, wird normal gescrollt (auch nach unten). Ist die gefundene Zahl größer gleich 64000, wird der Cursor auf diese Zeile gesetzt und das Scrolling verhindert. Andernfalls wird die nächsthöhere beziehungsweise nächstniedrigere Zeile aus dem Basic-Listing gesucht, der Bildschirm in die richtige Richtung gescrollt und die gefundene Zeile gelistet.

Die Erweiterung arbeitet nur im Direktmodus, das heißt wenn in einem Programm ein »INPUT«-Befehl oder ähnliches vorkommt, verhält sich der Bildschirm normal.

Zusätzlich bietet dieses Programm noch einige andere Möglichkeiten, die das Editieren erleichtern. Diese Funktionen werden durch gleichzeitiges Drücken der Control-Taste und einer Buchstabentaste aufgerufen. Zwischen zwei Anführungszeichen werden diese »Control-Codes« jedoch normal ausgegeben.

TODO TABLE

CTRL-i Einfügen (Insert) einer Leerzeile. Der untere Teil des Bildschirms wird nach unten geschoben. Dies dient zur Übersichtlichkeit, wenn eine neue Basic-Zeile eingegeben werden soll, da keine anderen Zeilen überschrieben werden brauchen.
CTRL-d Löschen (Delete) einer Zeile mit Nachrücken des unteren Bildschirmteils. Auch dies dient der Übersichtlichkeit. Soll eine Zeile gänzlich aus dem Listing gelöscht werden, muß man (wie üblich) die »leere« Zeilennummer und RETURN eingeben.
CTRL-I Füllen einer Zeile (Line) mit Leerzeichen. Nach den drei letztgenannten Funktionen springt der Cursor an den Anfang der Zeile.
CTRL-b löscht die Zeile bis ausschließlich Cursorposition
CTRL-a löscht die Zeile ab einschließlich Cursorposition
CTRL-u setzt Cursor in die linke untere Ecke
CTRL-k Kopieren eines Zeilenausschnitts. Der Bereich wird durch Invertieren angezeigt und kann mit der Cursor-right/left Taste vergrößert oder verkleinert werden. Bei Betätigen der RETURN- oder der STOP-Taste wird der vorher invertierte Bereich gespeichert.
CTRL-w schreibt (Write) vorher markierten Bereich wieder auf den Bildschirm.

Die Erweiterung läßt sich durch Normalisieren des IRQ-Vektors (zum Beispiel über die Tastenkombination RUN/STOP-RESTORE) oder CTRL-X (exit) abschalten.

Starten von »Listmaster«: Tippen Sie das Listing mit dem MSE ab und speichern Sie es auf Disk oder Kassette. Bei Bedarf laden Sie es absolut (das heißt mit ,8,1 oder ,1,1) und geben ein:

POKE 56,122: POKE 55,0:NEW
Dies ist wie gesagt notwendig, um das Ende des Basic-Bereichs herabzusetzen und das Maschinenprogramm vor der Zerstörung durch Basic-Variablen zu schützen.

Noch ein paar Informationen zu »Listmaster«: Erarbeitet mit anderen Interrupt-Programmen zusammen, da die Routine, auf die der IRQ-Vektor ($0314) vor der Initialisierung von »Listmaster« zeigte, als Unterprogramm aufrufen wird. Man darf also keinesfalls zweimal nacheinander »SYS 31232« eingeben. Das würde einen Selbstaufruf und somit Systemabsturz bewirken. Außerdem benötigt »Listmaster« einige Direkteinsprünge ins Betriebssystem, so daß es bei stark geänderten Varianten desselbigen zu Fehlfunktionen kommen kann.

An Speicheradressen verändert »Listmaster« nur einige wenige, die auch vom Standardbasic oder vom normalen Bildschirmeditor gebraucht werden. Es sind dies im Wesentlichen:

TODO TABLE

$07	;Zwischenspeicher
$14/15	;Zwischenspeicher
$22/23	;Suchzeiger
$5F/60	;Suchzeiger
$62/63	;Zwischenspeicher
$AC/AD	;Zeiger für Scrolling
$AE/AF	;Zeiger für Scrolling
$B0	;Zwischenspeicher
$CC	;Flag für Cursor blinken
$D1/D2	;Zeiger auf aktuelle Zeile
$D9-F2	;Tabelle Bildschirmzeilen
$F3/F4	;Zeiger auf Farbram
$0314/15	;Interruptvektor

Die Daten für den k-Befehl werden unmittelbar hinter dem »Listmaster«-Programm aufbewahrt (maximal 80 Zeichen).

(Matthias Meyer/tr)

# Drei »Quickies« [145]

> Einzeiler lassen sich nicht nur in Basic, sondern auch in Assembler schreiben! Tippen Sie unsere drei »Quickies« ein, und lassen Sie sich überraschen, mit welchen Tricks da gearbeitet wurde.

Die beiden Basic-Programme »Zeichensatz ändern« und »invertierte Grafik« müssen Sie mit dem MSE eingeben. Dies hat zwei Gründe: Erstens einmal lassen sich dadurch Tippfehler leichter ausschalten und zweitens wäre die Eingabe über Basic sehr mühsam. Wenn Sie die »Einzeiler« auf Diskette gespeichert haben, können Sie sie ohne weiteres wie normale Basic-Listings laden, listen und mit »RUN« starten.

## Stop!

1 fori = 828to839:reada:pokei,a:next:data72,173,141,2, 201,1,240, 249,104,76,202,241

TODO TABLE

Einschalten poke806,60:poke807,3
Ausschalten poke 806,202:poke807,241

In diesem kleinen Maschinenprogramm wird während des Listens eines Programms die Shift-Taste abgefragt und, wenn diese gedrückt ist, gewartet. Sonst wird zur Adresse 61898 (Ausgabe eines Zeichens) gesprungen. Durch die zwei POKEs wird der Ausgabe-Vektor ($F1CA) auf den Kassettenpuffer nach 828 »verbogen«.

TODO TABLE

828	pha	: Akku sichern
829	Ida 653	: Flag fürSHIFT
832	cmp#1	: gedrückt?
834	beq 829	: ja, dann warten
836	pla	: Akku wiederherstellen
837	jmp 61898	: zur Ausgaberoutine

(Ulrich Pasch/tr)

## Zeichensatz ändern

Dieser Einzeiler verschiebt den Zeichensatz in den Speicherbereich Hexadezimal $2000 - $3000. Damit können jederzeit beliebige Zeichen geändert werden; zum Beispiel, um Sonderzeichen zu definieren.

### Zum Aufbau des Programms (Listing 1a und 1b)

Ein PRINT-Befehl schreibt das Maschinenprogramm in den Bildschirmspeicher, wo es dann mit SYS 1024 gestartet wird.

Das Maschinenprogramm setzt zunächst das Interruptflag, um einen Interrupt durch den CIA 1 zu unterbinden. Das ist nötig, da der Computer sonst abstürzen würde, wenn das Zeichen-ROM eingeschaltet wird. Danach wird das ZeichenROM eingeschaltet. Jetzt wird nach der nötigen Parameterübergabe (alter Blockanfang, altes Blockende, neues Blockende) die Blockverschieberoutine des Interpreters aufgerufen. Dann wird der Zeichengenerator wieder abgeschaltet und der Zeiger auf den Zeichengenerator entsprechend geändert (Hexadezimal D018, Bit 1-3). Nach dem Löschen des Interruptflags erfolgt der Rücksprung ins Basic.

(Peter Sajonez/tr)

## Invertierte Grafik

Dieser Einzeiler (Listing 2) invertiert eine im Speicher stehende Grafik. Gegenüber dem Einzeiler, der in der 64’er, 3/85 veröffentlicht wurde, braucht er zur Ausführung nur den Bruchteil einer Sekunde. Er besteht im wesentlichen aus einer kleinen Maschinenroutine, die mittels einem PRINT-Befehl in den Bildschirm geschrieben und mit SYS 1024 gestartet wird.

(Frank Meister/tr)

# INPUT mit Pfiff [146-151]

> Einen INPUT-Befehl, der keine Wünsche mehr offenläßt, stellen wir Ihnen mit diesem Programm vor. Anhand des ausführlich dokumentierten Assembler-Listings können Sie zum Beispiel lernen, wie man eigene Befehle in den Interpreter einbaut.

Exinput 64« löst all Ihre Probleme, die Sie jemals mit dem INPUT-Befehl des Basic V2 gehabt haben. Mit dieser kleinen Erweiterung haben Sie ein Werkzeug in der Hand, das alle seitenlangen GET-Eingabeschleifen vergessen läßt. »Exinput 64« beschränkt sich nicht auf 80 Zeichen; Sie haben, wenn Sie wollen, die volle Länge eines Strings (255 Zeichen) zur Verfügung. Das Eingabefeld wird dabei durch eine Linie sichtbar gemacht. Sämtliche Zeichen können übernommen werden - auch Kommata und Doppelpunkte. Natürlich kann man die Eingabe auch auf bestimmte Tasten beschränken.

Eingabehinweis: Bitte geben Sie Listing 1 mit dem MSE ein, und speichern Sie es mit einem beliebigen Namen.

### Programmbeschreibung

Die Erweiterung steht im Speicher von $C000 bis $C51D, wird mit »LOAD ”Name”,8,1« geladen, mit »SYS 49152« gestartet und muß nur nach einem Reset wieder neu initialisiert werden. Die Routine wurde über einen Zeiger aus der Zero-Page des C 64 in das normale Basic eingebunden.

Dies ist der Zeiger für »Basic-Befehlsadresse holen« in den Adressen $308/$309 (dezimal 776/777). Der Zeiger in diesen beiden Speicherstellen wird von $A7E4 auf den Anfang der Befehlserweiterung, in diesem Fall auf $C00B geändert. Dies wird beim Start des Programms durch die vier ersten Assemblerbefehle gemacht. Danach springt das Programm wieder ins Basic zurück und die beiden zusätzlichen »Basic-Befehle« stehen zum sofortigen Gebrauch im Basic-Programm zur Verfügung (siehe auch Kasten).

Die Routine übernimmt das selektieren der neuen Befehlsworte. Wird ein INPUT- oder PRINT-Befehl gefunden, wird auf das Erkennungszeichen der neuen Befehle (>) geprüft. Ist dieses Zeichen vorhanden, so wird in die eigene Routine verzweigt, ansonsten wird die Routine des Basic-Interpreters aufgerufen.

Der INPUT-Befehl sieht auf den ersten Blick vielleicht etwas kompliziert aus, ist es aber nach ein wenig Ausprobieren nicht mehr.

INPUT> Zeile, Spalte, Länge, Farbe, Text, Code, Zeichen, Variable

### Erklärung der Parameter

TODO TABLE

Zeile:	1 bis 25	(oder Variable)
Spalte:	1 bis 40	(oder Variable)
Länge:	1bis 255 (oder Variable)
Farbe:	0-15	(Farbe des Textes und des Eingabefeldes)
Text:	Beliebiger Text zwischen "", erscheint vor dem Eingabefeld
Code:	- 'A' = Alle Zeichen bei der Eingabe erlaubt
- ’B’ = Nur Buchstaben, Leerzeichen, ’.’ und ’-’ für Abkürzung und Trennung
- ’Z’ = Nur Ziffern, Minuszeichen und Dezimalpunkt
Zeichen: Einzelne Ziffern, Buchstaben oder jedes andere Zeichen zwischen " ", das bei der Eingabe erlaubt ist. (< 30 Zeichen) zum Beispiel Menüpunktabfrage zwischen 1 und 4: INPUT >20,5,1,1,"Bitte wählen: ",**Z**,"**1234**", X$
Variable: Muß eine String-Variable sein.
Einziger Nachteil: Ziffern müssen zum Rechnen mit VAL umgewandelt werden.

Ganz einfach ist der Befehl, weil man verschiedene Parameter einzeln oder zusammen weglassen kann, und zwar »Farbe«, »Text« und »Zeichen«. Dann bleibt zum Beispiel noch übrig:

INPUT>10,3,15,B,A$

Die Länge des Eingabefeldes wird durch eine Linie markiert, dessen einzelnes Zeichen (CHR$(100)) an der Adresse 49244 steht und durch »POKE 49244, CHR$-Code« beliebig geändert werden kann, zum Beispiel 32 (Leerzeichen), 46 (Punkt) etc.

Wird eine unerlaubte Taste gedrückt, oder soll der Cursor die Feldgrenze überschreiten, ertönt zur Warnung ein Piepston. Dieser kann mit »POKE 50340,0« ausgeschaltet und mit »POKE 50340,65« wieder eingeschaltet werden.

Am Ende des Eingabefeldes wird das letzte Zeichen bei weiteren Eingaben überschrieben.

### Editier-Tasten

TODO TABLE

CRSR Left	
CRSR Right	
CRSR Up	(Nur bei mehreren Zeilen)
CRSR Down INST DEL HOME CLR/HOME	(Nur bei mehreren Zeilen)
RETURN	übernimmtden Feldinhaltohne Leerstellen am Ende
SHIFT/RETURN	übernimmtauch die Leerstellen, also das ganze Feld
Ob mit oder ohne Leerstellen kann bei den beiden Tasten auch selbst bestimmt werden.
Für RETURN: »POKE 49595, 182(ohne)/208(mit)«
Für SHIFT/RETURN: »POKE 49602, 208(mit)/182(ohne)«
F8	läßt einen eventuellen Inhalt der Variablen im Eingabefeld erscheinen, jedoch nur bis zur Länge des Feldes selbst
Der zweite Befehl der Erweiterung betrifft den PRINT-Befehl.

### Die Syntax des PRINT-Befehls

PRINT > Zeile, Spalte, Farbe, String
Hier kann die Farbe weggelassen werden, der zu druckende String muß zwischen " " stehen wie beim normalen PRINT-Befehl und jeder Parameter kann durch eine Variable ersetzt werden.

Mit den Angaben der im Kasten genannten Routinen kann man leicht eine Variable erstellen. Man kopiert nur die Adresse des reservierten Bereichs und die Länge in den Stringdescriptor und den Text der Variablen schreibt man in den reservierten Bereich. Alles andere erfahren Sie, wenn Sie das Programm selbst durchlesen (Listing 2).

(Guy Mootz/og)

TODO ASIDE

### Erklärungen zu oft benötigten ROM-Routinen und zur Erstellung der Variablen.

TODO TABLE

CHRGET:	Diese Routine steht ab $E3A2 im Betriebssystem und wird beim Einschalten des Computers nach $0073 in die Zero-Page kopiert Der Zeiger in $007A/$007B zeigt immer auf das aktuelle Zeichen im Basic-Text und beim Ansprung der Routine wird jeweils das nächste Zeichen in den Akku geholt.
CHRGOT:	Dies ist nur eine andere Einsprungadresse der CHRGET-Routine. Hier wird das aktuelle Zeichen in den Akku geholt und die Flags wieder gesetzt, ohne den Zeiger in $7A/$7B vorher zu erhöhen.
CHKCOM: Hier handelt es sich um eine Basic-Routine, die das laufende Zeichen prüft. Beim Einsprung in »CHKCOM« ($AEFD) wird auf ein Komma im Basic-Text geprüft, bei $AEF7 auf »Klammer zu« und bei $AEFA auf »Klammer auf«. Stimmen die Zeichen nicht überein, wird automatisch ein »Syntax Error« ausgegeben.<br>Vor dem Rücksprung liest die Routine gleich das nächste Zeichen aus dem Basic-Text in den Akku, so daß dies beim Weiterführen des Programms entfallen kann.
GETBYT:	Diese Basic-Routine holt eine Zahl (Byte 0-255) in das X-Register. Beim Einsprung in $B79B wird zuerst durch »JSR $0073« das nächste Zeichen geholt (CHRGET). Hat man vorher jedoch mit »JSR $AEFD« auf ein Komma geprüft (CHKCOM), darf man erst bei $B79E einspringen, weil das nächste Zeichen sich bereits im Akku befindet.
GETVAR:	Diese Routine holt sich den Variablennamen aus dem Basic-Text und sucht diese Variable dann im Speicher. Wenn sie nicht vorhanden ist, wird sie angelegt. Danach stehen dann in $0D das Typflag dieser Variablen (String=$FF/Zahl = $OO), im Akku das Low-Byte und im Y-Register das High-Byte der Adresse, an der der Stringdescriptor beginnt.
FRESTR:	Mit dieser Routine wird die weitere Auswertung der mit »GETVAR« eingelesenen Variablen vorgenommen. Nachher stehen im X-Register das Low-Byte der Adresse, im Y-Register das High-Byte der Adresse und im Akku die Länge des Strings.
STRPOI:	Hiermit berechnet man den Stringzeiger und reserviert gleichzeitig Speicher für den String am Ende des Stringspeichers. Die Länge des Strings muß vorher im Akku stehen, wo sie sich nach »FRESTR« ja auch befindet. Man findet dann in $61 die Länge des reservierten Bereichs, in $62 das Low-Byte der Adresse und in $63 das High-Byte der Adresse des reservierten Bereichs.

# Directory auf Knopfdruck [152-153]

> Häufig steht man vor dem Problem, Programme direkt, also ohne SYS-Aufrufe, über einen Tastencode zu aktivieren. Wir zeigen Ihnen, wie man ein Directory auf dem Bildschirm ausgibt, ohne ein vorhandenes Basic-Programm zu zerstören.

Das Programm »Directory auf Knopfdruck« (siehe Listing 1) kann, nachdem es mit Hypra-Assassembliert wurde, mit dem Befehl SYS 49152 aktiviert werden.

Den erzeugten Maschinencode zeigt Listing 2, das auch direkt mit dem MSE eingegeben werden kann. Solange kein Reset ausgelöst oder die RUN/STOP-Taste gedrückt wird, erscheint bei der Tastenkombination »CTRL-D« das Directory auf dem Bildschirm, ohne ein eventuell im RAM stehendes Basic-Programm zu zerstören.

Der hier vorgestellte Lösungsweg, ein beliebiges Programm auf Tastendruck aufzurufen, hat den Vorteil, daß er allgemeingültig ist und nicht nur auf die Ausgabe des Directorys beschränkt ist.

Im allgemeinen müßte das Betriebssystem geändert werden, um eine zusätzliche Tastaturabfrage einzubinden. Aber wir haben Glück, denn einige Routinen im Betriebssystem werden über einen sogenannten Sprungvektor aufgerufen. Alle zugänglichen Sprungvektoren, die sich ändern lassen, befinden sich in der dritten Page, also im Bereich von $311 bis $333, jeweils im Low-/High-Byte-Format. Der zum Einbinden einer Tastaturabfrage geeignetste Vektor ist der Interruptvektor, denn diese sogenannte Interrupt-Routine wird 60mal pro Sekunde angesprungen. Ein Sprungvektor, der in diese Routine verzweigt, befindet sich in den Speicherzellen $314/$315. Die Speicherzellen enthalten im Normalzustand den Wert $31/$EA. Das bedeutet, daß immer, wenn ein Interrupt ausgelöst wird, zu einer Routine verzweigt wird, die bei $EA31 liegt. Schreibt man nun in die Speicherzellen $314/ $315 einen anderen Wert, wird bei einem Interrupt nicht mehr zur Adresse $EA31, sondern zu der Adresse verzweigt, die in den Speicherzellen $314/315 steht, wobei die Adresse $314das Low- und die Speicherzelle $315 das High-Byte der anzuspringenden, neuen Interrupt-Routine enthält. Damit sich der Vektor aber verändern läßt, muß zuerst der normale Interrupt gesperrt werden, denn sonst könnte folgendes passieren: Angenommen, es wird ein Interrupt ausgelöst, nachdem erst das Low-Byte in die Adresse $314 geschrieben wurde, dann nimmt der Computer an, daß die neue Interrupt-Routine bei $EAOO plus dem in Adresse $314 stehendem Low-Byte liegt, verzweigt an diese Adresse und stürzt ab.

Mit dem Maschinenbefehl »SEI« für SEt Interruptflag läßt sich nun der prozessorinterne Interrupt ausschalten. Dies wird in der Zeile 230 im Listing 1 realisiert. Die Zeilen 240 bis 270 sorgen dafür, daß die Startadresse der neuen Interrupt-Routine in die entsprechenden Adressen kommt. Eine Bemerkung noch zu den Zeilen 240 und 270. Durch das »kleiner«- beziehungsweise »größer«-Zeichen läßt sich eine 16-Bit-Adresse (in diesem Fall »INTER«) in zwei 8-Bit-Zahlen splitten. Durch das »kleiner«-Zeichen erhält man das Low- und entsprechend für das »größer«-Zeichen das High-Byte.

Der folgende »CLI«-Befehl (CLear Interruptflag) läßt nun den normalen Interrupt wieder zu. Nur wird jetzt, wenn ein Interruptstattfindet, nicht mehr zur Adresse $EA31, sondern zur Routine »INTER« verzweigt. Die Aufgabe des Teilprogramms »INTER« ist es, die »CTRL«- und »D«-Taste abzufragen. Sind beide Tasten gleichzeitig gedrückt, wird nach »DIR« verzweigt, ansonsten in der Zeile 420 zum normalen Interrupt nach $EA31. Die Zeilen 370 und 380 beziehungsweise 400 und 410 sperren auch den Interrupt, aber auf eine etwas andere Art.

Sie werden sich vielleicht fragen, warum der Interrupt überhaupt gesperrt werden muß. Die Antwort auf diese Frage ist leicht zu geben. Die Bearbeitung der Routine »DIR« dauert länger als 1/60 Sekunde. Dadurch würde bereits ein neuer Interrupt ausgelöst, bevorderalteabgearbeitetwäre. Die Art, wie der Interrupt abgeschaltet wird, wurde mit Absicht so gewählt, da einige Routinen im Betriebssystem den Interrupt durch den CLI-Befehl wieder zulassen, so auch die Routine »CHROUT«, die ein Zeichen auf einem Gerät, hier dem Bildschirm, ausgibt. Durch die Befehle »LDA #TIMERAUS« und »STA ICR« wird eigentlich nicht der Interrupt abgeschaltet, sondern der Timer gestoppt, der den Interrupt auslöst. Doch nun zum eigentlichen »DIR«-Programm.

Die Zeilen 450 bis 550 entsprechen dem Basic-Befehl »OPEN 1,8,0,"$"«. Dabei liegt das Augenmerk auf der Sekundäradresse »0« und dem Dollarzeichen. Das Dollarzeichen als Filename bewirkt, daß das Directory eingelesen wird und zwar einschließlich Track 18 Sektor 0. Durch die »0« als Sekundäradresse wird das Directory schon soweit aufbereitet, daß nur noch die Zeichen, die sich nach einem »LOAD"$",8« tatsächlich im RAM befinden, zum Computer gesendet werden, inklusive Filetyp, Steuerzeichen, Leerzeichen und Anzahl der Blöcke pro File. Leider enthält ein vom Floppy-Laufwerk gesendeter Directory-Eintrag auch noch Platzhalter für die Zeilenlinkadressen, die wir natürlich nicht brauchen und folglich ausblenden beziehungsweise überlesen müssen. Eine vom Floppy-Laufwerk gesendete Directory-Zeile hat folgendes Format:

LI LI AB SP "filename SP" SP FT

LI = Linkbyte; AB = Anzahl der Blöcke pro File im Low/ High-Byte-Format; SP = Leerzeichen; FT = Filetyp im Klartext.

Das einzige, was zu tun bleibt, ist die Ausgabe »RETURN« am Ende jeder Directory-Zeile (Zeile 811/812). Außerdem muß die Information, die die Anzahl der Blöcke pro File enthält, in dezimale Schreibweise umgerechnet und auf dem Bildschirm ausgegeben werden. Das ist aber kein Problem, denn das Betriebssystem stellt eine solche Routine »INTOUT=$BDCD« zur Verfügung. Wenn sie aufgerufen wird, muß der Akku das High- und das X-Register das Low-Byte der auszugebenden Zahl enthalten. Das Low-Byte wird in Zeile 590 an das X-Register übergeben. Das High-Byte dagegen wird in Zeile 630 durch das Unterprogramm »CHRIN« eingelesen und steht automatisch im Akku.

### Zum Programmablauf

Die Zeilen 570 bis 620 überlesen 4 Byte beim ersten Durchlauf. Bei allen weiteren Durchläufen werden immer nur die ersten 2 Byte überlesen, die die Zeilenlinkadresse enthalten. Beim ersten Durchlauf wird neben der Zeilenlinkadresse auch die Startadresse ($0801) gesendet, die ebenfalls ausgeblendet werden muß, darum 4 Byte. Bei einem Sprung auf das Label »ROWOUT« enthält das Y-Register die Anzahl der Byte, die überlesen werden sollen plus 1. Wird die Schleife in Zeile 620 verlassen, enthält das X-Register das Low-Byte der Zahl, die die Anzahl der Blöcke pro File kennzeichnet. Das High-Byte wird in Zeile 630 eingelesen und an den Akku übergeben. Die nächste Schleife, die bei dem Label »NEXTCHR« beginnt, gibt den Rest eines Directory-Eintrags auf dem Bildschirm aus. Der »CMP«-Befehl in Zeile 730 überprüft, ob eine »0«, die das Ende des Eintrags kennzeichnet, gesendet wurde oder nicht. Bei einer »0« wird nach »LASTCHR« verzweigt, ein »RETURN« ausgegeben und zum Label »ROWOUT« gesprungen.

(ah)

# Tips und Tricks zu Hypra-Ass [154-155]

> Hypra-Ass, ein Assembler der Spitzenklasse beherrscht alles, was zum Programmieren in Maschinensprache erforderlich ist. Hier wollen wir Ihnen anhand vieler Beispiele zeigen, was in ihm steckt und was er wirklich leistet.

Hypra-Ass ist einer der leistungsfähigsten Assembler die zur Zeit auf dem Markt sind. Eine seiner hervorstechendsten Eigenschaften ist der integrierte Editor mit einer formatierenden LIST-Routine. Aber gerade durch diese Eigenschaft weicht die Bedienung vom normalen Basic-Editor ab. Dadurch traten bei vielen Lesern Schwierigkeiten auf, die hier im einzelnen behandelt werden.

Im Gegensatz zum Basic-Editor kann unter Hypra-Ass eine Zeile nicht dadurch gelöscht werden, daß nur die Zeilennummer eingegeben und anschließend RETURN gedrückt wird. Bei Hypra-Ass ist unbedingt darauf zu achten, daß hinter der Zeilennummer ein Minuszeichen eingegeben wird. Drückt man nun die RETURN-Taste ist die Zeile auch verschwunden. Da aber dieses Minuszeichen hinter der Zeilennummer meistens vergessen wird, ist es empfehlenswert, nicht nur Zeilenbereiche, sondern auch einzelne Zeilen mit dem Editor-Befehl »/D zeilennummer« zu löschen, bis auf die Zeile »0«, die sich mit dem »/D«-Befehl nicht löschen läßt. In diesem Fall geben Sie bitte »0-« < RETURN > ein.

Ein kleiner Fehler tritt beim Sortieren der Symboltabelle auf. Hypra-Ass stürzt ab, wenn die Symboltabelle genau 36, 73, 109 (und so weiter) Variablen oder Label enthält. Der Fehler liegt in den Speicherzellen $1EB8 bis $1EBB. Hier wurden zwei Branch-Befehle vertauscht. Es muß richtig lauten:

TODO

1EB8 90 D0	BCC 1EA8
1EBA D0 04	BNE 1EC0

Diese Änderung kann unmittelbar mit einem Monitor in die entsprechenden Speicherzellen geschrieben und anschließend gespeichert werden. Sollten Sie keinen Monitor haben, dann geben Sie bitte den folgenden Quelltext ein:

TODO

10 -.BA $C000
;STARTADRESSE = $C000
20 -	LDY #0
30 - LBL	LDA TAB,Y
;KORREKTUREN VORNEHMEN
40-	STA$1EB8,Y
50 -	INY
60 -	CPY #4
70 -	BNE LBL
80 -.EQ SOURCESTART = $1FD8 ;UND DIE KORRIGIERTE
90 -.EQ NAMLEN = 12	;VERSION SPEICHERN
100-	LDA #1
110-	LDX#8
120-	STA$FE
130-	STX $FF
140-	LDA #8
150-	JSR $FFBA
160-	LDA#NAMLEN
170-	LDX#<(NAME)
180-	LDY#>(NAME)
190-	JSR $FFBD
200-	LDA #$FE
210-	LDX #<(SOURCESTART)
220-	LDY # >(SOURCESTART)
230-	JMP $FFD8
240-;
250-NAME	.TX "HYPRA-ASS.V1 "
260-TAB	.BY $90,$D0,$D0,$04

Nach dem Assemblieren wird mit SYS 49152 < RETURN > Hypra-Ass geändert und unter dem neuen Namen »Hypra-Ass.VI« auf Diskette gespeichert.

Der »/A«-Befehl zur automatischen Zeilennumerierung reagiert auch recht sensibel. Wird mit diesem Befehl gearbeitet, darf der Cursor mit den entsprechenden Steuertasten auf keinen Fall auf eine andere Zeile gesetzt und RETURN gedrückt werden. Sollte das versehentlich doch einmal passieren, läßt sich die so entstandene, ewas seltsam aussehende Zeile mit dem »/D«-Befehl problemlos löschen.

Diskettenbefehle können mit dem Editorbefehl »/@« zum Floppy-Laufwerk gesendet werden. Hinter den Editorbefehl werden dann die Diskettenbefehle unmittelbar angehängt. So formatiert der Befehl »/@N:NEWDISK,ND« eine neue Diskette.

## Der Editor

Eine feine Sache ist auch das Arbeiten mit dem »/P«-Befehl, der dazu dient, Arbeitsseiten beziehungsweise Arbeitsbereiche anzulegen. Durch diesen Befehl, auf den sich die meisten Editor-Befehle beziehen, ist es möglich, jedem zusammenhängenden Quelltextteil (Unterprogramme oder Unterprogrammblöcke) einen Arbeitsbereich zuzuordnen. Möchte man dann in der Page 3 etwas ändern oder nachschauen, LISTet der Befehl »/3« nur diesen Bereich und nicht das komplette Listing wie bei dem »/E«-Befehl. Legt man nun die einzelnen Arbeitsbereiche gleich von vornherein so an, daß sie jeweils einen Zeilenbereich von zum Beispiel 5000 Zeilen überdecken, dürfte für die einzelnen Quelltextteile genügend Platz vorhanden sein, so daß beim Durchnumerieren der einzelnen Arbeitsbereiche keine Überlappungen auftreten können. Die Arbeitsbereiche selbst dürfen sich aber durchaus überlappen. So läßt sich zum Beispiel ein Arbeitsbereich von 0 bis 5000, ein zweiter von 10000 bis 15000 und ein dritter von 0 bis 15000 anlegen.

Bei dem Assembler selbst sind bisher keine Fehler bekannt. Deshalb möchte ich an dieser Stelle auf einige Dinge eingehen, mit denen viele Leser Schwierigkeiten hatten. Da wäre zum Beispiel das unmittelbare Erzeugen des Objektcodes auf Diskette mit dem ».OB«-Pseudo-Opcode.

Der Pseudo-Opcode ».OB "filename,P,W"« muß am Anfang des Quelltextes stehen und zwar in der ersten beziehungsweise zweiten Zeile (nach dem ».Ll«-Pseudo zur Ausgabe des Assembler-Listings). In dem Zusammenhang sei auch erwähnt, daß es unmöglich ist, den Objektcode und gleichzeitig das Assembler-Listing mit dem Befehl ».LI 2,8,2, "filename,U,W"«auf Diskette zu erzeugen. Der Grund ist der, daß zwei Kanäle zum Schreiben geöffnet werden müßten und das ist nicht möglich. Zu dem ».OB«-Pseudo gehört unmittelbar ein zweiter Pseudo ».EN«, der das mit »filename« gekennzeichnete File schließt. Dazu muß dieser Pseudo am Ende des Quelltextes stehen. Sollten mit dem ».AP« mehrere Quelltexte verkettet werden, muß der ».EN«-Pseudo am Schluß des letzten Quelltextes auftauchen.

Bei der Anwendung von Makros gab es auch einige Schwierigkeiten. Wird zum Beispiel von einem Makro (Ordnung 1) zweimal ein weiteres Makro (Ordnung 2) aufgerufen, meldet Hypra-Ass einen »label twice error«, vorausgesetzt, im Makro zweiter Ordnung befindet sich ein Label. Zum Beispiel würde folgendes Programm zu einer solchen Fehlermeldung führen:

TODO

i o -.BA $C000
20 -.MA MAK1 ;MAKRODEFINITION 1. ORDNUNG
30 - ... MAK2 ;MAKROAUFRUF 2. ORDNUNG
40 - ... MAK2
50 -.RT
60-.MA MAK2
7O-LBL NOP
80 -.RT
90 -	... MAK1

Dabei ist Mak1 das Makro 1. Ordnung und Mak2 das Makro 2. Ordnung. Alle Label in Makros zweiter oder dritter Ordnung sind untereinander global. Das heißt, daß in Makros zweiter Ordnung nur einmal das Label mit dem Namen »LBL« definiert werden dürfte.

Im Augenblick wird an einer Erweiterung gearbeitet, die diesen Mißstand beseitigt. Denn gerade beim intensiven Arbeiten mit Makros sind Makros zweiter und sogar dritter Ordnung unabdingbar. Ganz deutlich sieht man dies an dem Artikel »Wichtige Makros für Hypra-Ass« in dieser Ausgabe. Dort wurde ein Makro mit dem Namen »INCW (adresse)« definiert. Würde man die dort stehende 16-Bit-Addition ersetzen durch:

TODO

INC ADRESSE
BNE LBL
INC ADRESSE+1 LBL

könnte dieses Makro von keinem anderen Makro aus zweimal aufgerufen werden, weil durch das Label »LBL« ein »label twice error« erscheinen würde.

Der gleiche Fehler erscheint natürlich auch dann, wenn ein anderes Makro aufgerufen wird, das »LBL« als Label oder Variable benutzt. Denn die Ordnungszahl, die den beiden Labeln »LBL« zugewiesen wird, ist identisch.

## Bedingte Assemblierung

Auch mit der bedingten Assemblierung wissen nur die wenigsten etwas anzufangen, obwohl sie gerade im Zusammenhang mit Makros eine große Rolle spielt. Dies soll an einem kleinen Beispiel demonstriert werden:

TODO

10 -.MA ADW (ADR1,ADR2,SUMME,RETTEN)		
20 -.IF RETTEN !	= ! 1	;NUR WENN RETTEN = 1, WIRD
30 -	PHA	;PHA IN DAS MASCHINENPROGRAMM
40 -.EI 50 -	CLC	;ASSEMBLIERT
60 -	LDA ADR1	
70 -	ADC ADR2	
80 -	STA SUMME	
90 -	LDA ADR1 + 1	
100-	ADC ADR2 + 1	
110-	STASUMME+1	
120 -.IF RETTEN !	= ! 1	;NUR WENN RETTEN = 1, WIRD
130-	PLA	;PLA IN DAS MASCHINENPROGRAMM
140 -.EI ; 150 -.RT		ASSEMBLIERT

Dieses Makro addiert (ADR1,ADR1+1)+(ADR2,ADR2 +1) und speichert das Ergebnis in den Speicherzellen (SUMME,SUMME+1). ADR1, ADR2 und SUMME können beliebige Speicherzellen oder Variablen sein. Soll der Inhalt des Akkumulators erhalten bleiben, wird für RETTEN eine 1, ansonsten eine beliebige andere Zahl eingegeben. Anhand des Übergabeparameters RETTEN erkennt der Assembler, ob das erzeugte Maschinenprogramm den Maschinenbefehl »PHA« beziehungsweise »PLA« enthalten soll oder nicht. Die Befehle zur bedingten Assemblierung zeigen also einzig und allein eine Wirkung beim Assemblieren. Durch sie wird bestimmt, welche Teile des Quelltextes im erzeugten Maschinenprogramm stehen und welche unter bestimmten Bedingungen übersprungen werden sollen. Schauen Sie sich nun noch einmal die Zeilen 20 und 120 an. Sie finden dort in der bedingten »,IF«-Abfrage den Operator »=«, der wie alle anderen Operatoren auch in Ausrufezeichen einzufassen ist. Durch dieses Ausrufezeichen erkennt Hypra-Ass, daß es sich bei dem Operator »=« um eine Rechenvorschrift aus dem Quelltext heraus handelt. Alle Operatoren können außer bei der bedingten Assemblierung zum Beispiel auch bei der unmittelbaren Adressierungangewendetwerden. Ein kleines Beispiel soll die Wirkung dieser Operatoren bei der unmittelbaren Adressierung verdeutlichen:

TODO

20 -.EQ VARIABLE1 = 10
30 -.EQ VARIABLE2 = 20
40 -	LDA#(VARIABLE1!0!VARIABLE2)

Der Akkumulator wird mit einer Zahl geladen, die mit der Variablen »VARIABLE1« und »VARIABLE2« wie im Basic geORt wird. Das Ergebnis ist folglich 30.

Viele Maschinensprache-Anfänger verwechseln die Befehle zur bedingten Assemblierung mit normalen Basic-Befehlen. Deshalb möchte ich an einem kleinen Beispiel zeigen, was nicht mit der bedingten Assemblierung funktioniert:

TODO

10 -.BA $cooo
20 -	INC $D020
30 -.GO 20

## Was nicht funktioniert

Das Programm sollte die Bildschirmrahmenfarbe laufend um 1 incrementieren. Wird der Assembler jedoch gestartet, ersetzt er den Befehl ».GO 20« nicht durch den Befehl »JMP adresse«. Vielmehr versucht er den gesamten Speicher von $C000 bis unendlich mit dem Befehl »INC $D020« zu füllen, denn es fehlt jegliche Abbruchbedingung. Nur mit einer Abbruchbedingung ist der ».GO«-Befehl sinnvoll. Sollte das Maschinenprogramm zehnmal hintereinander den Befehl »INC $D020« enthalten, könnte das so aussehen:

TODO

10 -.LI1,3
20 -.BA $C000
30 -.EQ A = 0
40 -.EQ A = A + 1
50 -	INC $D020
60 -.IFA!<!11
70 -.GO 40
80 -.EI
90 -	JMP $C000

Der Assembler überprüft in Zeile 60, ob die Variable »A« kleiner 11 ist. Trifft das zu, wird in Zeile 70 durch den ».GO«-Befehl zur Zeile 40 verzweigt und der Befehl »INC $D020« ein weiteres Mal assembliert. Sobald »A« gleich 10 ist, verzweigt der Assembler in die Zeile 90, übersezt den Befehl »JMP $C000« und beendet den Assembliervorgang.

Sollte Ihnen der Umgang mit Makros und der bedingten Assemblierung noch nicht klar sein, empfehle ich Ihnen den Artikel »Assemblerbedienung leicht gemacht (2)« in der 64’er Ausgabe 1/85. In diesem Artikel wird ausführlich auf den Gebrauch von Makros und eben der bedingten Assemblierung eingegangen.

(ah)

# Wichtige Makros zum Assembler Hypra-Ass [156-157]

> Der beschränkte Befehlssatz des 6502-Prozessors macht Maschinenprogramme unübersichtlich und fehleranfällig. Wir zeigen Ihnen hier, wie sich mit Hypra-Ass der Maschinen-Befehlssatz durch Makros erweitern läßt. Aber nicht nur das ist möglich, Sie können sich auch Ihre eigene, ganz persönliche Sprache basteln.

esonders dem Maschinensprache-Anfänger dürfte das Wort »Makro« gänzlich unbekannt sein. Denn weder das im C 64 implementierte noch irgendein anderes Basic kennt die Definition eines Makros. Das ist wahrscheinlich auch der Grund dafür, warum Makros nur selten angewendet werden. Sie spielen jedoch gerade beim 6502- beziehungsweise 6510-Prozessor eine wichtige Rolle. Durch Makros läßt sich nämlich der bescheiden ausgefallene Befehlssatz des Prozessors um wichtige Befehle erweitern. Es werden durch Makros prinzipiell keine neuen Maschinenbefehle geschaffen, sind aber Makros einmal definiert, lassen sie sich aufrufen wie ganz normale Maschinenbefehle. Was sind nun eigentlich Makros? Dies soll an einem kleinen Beispiel erklärt werden.

Angenommen, Sie möchten in einem Maschinenprogramm 20 verschiedene 16-Bit Adressen inkrementieren, dann müßte Ihr Programm zwangsläufig zwanzigmal folgende Befehlsfolge enthalten:

TODO

INC ADRESSE
BNE LBL
INC ADRESSE+1
LBL

Diese 20 Befehlsfolgen machen aber das Programm unübersichtlich und vor allen Dingen fehleranfällig. Genau so gut ließe sich auch ein Makro mit dem Namen »INCW (adresse)« für INCWord definieren, das dann anstelle der Befehlsfolgen 20mal im Quelltext erscheint. Das Makro selbst würde wie folgt aussehen:

TODO

10 -.MA INCW (ADRESSE)
20 -	INC	ADRESSE
30 -	BNE	LBL
40 -	INC	ADRESSE+l
50 -LBL
60 -.RT

Aufgerufen wird das Makro im Quelltext nun durch den neuen Befehl»... INCW (adresse)«.

Gefolgt von dem Makronamen und in Klammern den Übergabeparametern, diedurch Kommatagetrenntwerden, leitet der ».MA«-Pseudo-Opcode die Definition eines Makros ein. Dies geschieht in Zeile 10. Der Pseudo-Opcode ».RT« in Zeile 60 schließt die Definition des Makros ab. Alle im Makro stehenden Label sind lokal. Das heißt, daß dem Programm außerhalb des Makros die internen Label unbekannt sind. Würde dies nicht so sein, dann würde der Assembler den zweiten Makroaufruf mit der Fehlermeldung »label twice error« ahnden. Was macht der Assembler, wenn er auf einen Makroaufruf stößt? Er assembliert in den Objektcode, wie man das erzeugte Maschinenprogramm auch nennt, die Befehlsfolgen, die im Makro definiert wurden. Das heißt, daß letztendlich im erzeugten Maschinenprogramm wieder zwanzigmal, um bei dem Beispiel zu bleiben, die oben stehenden Befehlsfolgen auftauchen.

Im Listing sind die wichtigsten Makros aufgeführt. Neben den »Befehlserweiterungen« ist noch eine interessante Gruppe von Makros definiert worden, die die strukturierte Programmierung durch »Repeat...Until«- und »While...Endwhile«-Schleifen unterstützt. Zu beachten istjedoch, daß die Schleifen nichtverschachteltwerden dürfen. Schleifenkonstruktionen wie

TODO

REPEAT
REPEAT
UNTIL
UNTIL

sind veboten. Die einzelnen Makros haben folgende Wirkung:
**TXY**: Das Y-Register wird mit dem Inhalt des X-Registers geladen.
**TYX**: Das X-Register wird mit dem Inhalt des Y-Registers geladen.
**PHX**: Das X-Register wird auf dem Stack abgelegt
**PHY**: Das Y-Register wird auf dem Stack abgelegt
**PLX**: Das X-Register wird vom Stack geholt.
**PLY**: Das Y-Register wird vom Stack geholt.

Die folgenden vier Makros definieren einen Userstack, der an eine beliebige Stelle gelegt werden kann. Dazu muß im Hauptprogramm eine globale Variable mit dem Namen »USER« in der Zeropage angelegt werden. Anschließend muß in die Adresse, die die Variable repräsentiert, die Startadresse des Stacks geschrieben werden. Das könnte so aussehen:

TODO

10 -.GL USER = 3
20	-	LDA	#0	;L0-BYTE
STARTADRESSE USERSTACK
30	-	STA	USER
40	-	LDA	#$C0	;HI-BYTE
STARTADRESSE USERSTACK
50	-	STA	USER+1

Hier wurde ein Userstack angelegt, der bei Adresse $C000 beginnt. Der Stackpointer, als oder Zeiger, der auf die aktuelle Stackadresse zeigt, steht in der Zeropage in den Speicherzellen 3 und 4.
**PUSHA**: Der Inhalt des Akkumulators wird auf dem Userstack abgelegt.
**PUSHAY**: Der Inhalt des Akkumulators und der Inhalt des Y-Registers werden auf dem Userstack abgelegt.
**PULLA**: Der Akkumulator wird vom Userstack geholt.
**PULLAY**: Der Akkumulator und das Y-Register werden vom Userstack geholt.
**ADW (adresse)**: 16-Bit Addition. Der Inhalt einer beliebigen Adresse wird zum Inhalt des Akkumulators (Low-Byte) und zum Inhalt des Y-Registers (High-Byte) addiert. Das Ergebnis steht anschließend im Akkumulator (Low-Byte) und im Y-Register (High-Byte).
**ADMW (adr1,adr2,summe)**: 16-Bit Addition. Der Inhalt von adr1 und adr1 + 1 wird zum Inhalt der Adresse adr2 und adr2 +1 addiert und das Ergebnis in der Adresse summe und summe+1 abgelegt.
**SBCW (adresse)**: 16-Bit Subtraktion. Der Inhalt von adresse und adresse+1 wird vom Inhalt des Akkumulators (Low-Byte) und vom Inhalt des Y-Registers (High-Byte) abgezogen. Das Ergebnis steht anschließend im Akkumulator (Low-Byte) und im Y-Register (High-Byte).
**SBCMW(adr1,adr2,diff)**: 16-Bit Subtraktion. Vom Inhalt adr1 und adr1 + 1 wird der Inhalt von adr2 und adr2 + 1 abgezogen. Das Ergebnis wird in der Adresse diff und diff+1 abgelegt.
**INCW(adresse)**: Der Inhalt von adresse und adresse+1 wird inkrementiert. Das Ergebnis steht in adresse und adresse+1. DECW (adresse): Der Inhalt von adresse und adresse+1 wird dekrementiert. Das Ergebnis steht in adresse und adresse+1.
**LDAY (adresse)**: Der Akkumulator wird mit dem Inhalt von adresse und das Y-Register mit dem Inhalt von adresse+1 geladen.
**STAY (adresse)**: Der Inhalt des Akkumulators wird nach adresse und der Inhalt des Y-Registers nach adresse+1 geschrieben.
**LDAYI (wert)**: Der Akkumulator und das Y-Register wird mit »wert« unmittelbar geladen. Dabei steht das Low-Byte im Akkumulator und das High-Byte im Y-Register.
Die folgenden Makros unterstützen die strukturierte Programmierung.
**REPEAT, EXITREPEAT, UNTIL (übergabe.bedingung)**: Die Schleife wird so lange fortgesetzt, bis die Speicherzelle »übergabe« den Wert »bedingung« enthält. Beispiel:

TODO

io -	LDX #255
20 -	REPEAT
30 -	DEX
40 -	STX $FB
50 -	... UNTIL ($FB,0)

Das X-Register wird solange dekrementiert, bis es den Wert »0« enthält.
**WHILE (übergabe,bedingung), EXITWHILE, ENDWHILE:** Die Schleife wird solange fortgesetzt, bis der Inhalt der Speicherzelle »übergabe« gleich »bedingung« ist. Beispiel:

TODO

10 -	LDX #255
20 -	... WHILE ($FB,0)
30 -	DEX
40 -	STX $FB
50 -	... ENDWHILE

Solange der Inhalt der Speicherzelle $FB ungleich Null ist, wird das X-Register dekrementiert.

(ah)

# Tips & Tricks ausführlich erklärt [158-163]

> Die folgenden Programmbeispiele sollen vor allem dem Anfänger den Einstieg in die Maschinensprache des C 64 erleichtern.

Zu ihrem Verständnis sollte man wenigstens ungefähr mit dem Befehlssatz der 6510-CPU und mit der Speicherorganisation des C 64 vertraut sein. Die Beispiele stammen aus den verschiedensten Anwendungsgebieten. Ihnen allen gemeinsam ist: - eine überschaubare Kürze

- Formulierung als Hypra-Ass-Quelltext
- eine ausführliche Beschreibung der Wirkungsweise.

### 1. Ein allererster Gehversuch mit Hypra-Ass

Zu diesem und zu allen folgenden Programmen benötigen Sie den Hypra-Ass. Er wird wie ein Basic-Programm geladen und mit RUN initialisiert. Jedes weitere RUN startetjetzt einen Assemberlauf, ist aber zunächst noch wirkungslos, da noch nichts im Textspeicher des Assemblers steht. Geben Sie nun folgende vier Zeilen ein:

TODO

10 - .BA $C000
20 - LDA #1
30 - STA $400
40 - RTS

Dabei dürfen die Minus-Zeichen nach den Zeilennummern nicht vergessen werden (Eigenartvon Hypra-Ass). Auch das Leerzeichen nach den Minus-Zeichen ist wichtig. Sie werden feststellen, daß der Assember die Zeilen nach Drücken der RETURN-Taste formatiert. Listen Sie die vier Zeilen auch einmal probeweise mit
LIST (unformatiert) und
/E (formatiert)

Das Programm ist schnell erklärt:

Mit .BA $C000 wird dem Assembler die Startadresse (BAsisadresse) des Programms mitgeteilt. .BA ist ein Pseudobefehl. Ein solcher Befehl steuert die Arbeitsweise des Assemblers, bewirkt aber keine Erzeugung eines Maschinenbefehls.

LDA # 1 lädt den Akkumulator mit 1, dem Bildschirmcode des Buchstabens A.

STA $400 speichert den Akkumulatorinhalt, also die 1 an die Speicherstelle $400. $400 ist die Startadresse des Bildschirm-RAMs und entspricht der linken oberen Bildschirmecke. Dort muß also ein »A« erscheinen.

RTS (ReTurn from Subroutine) bedeutet Rücksprung aus einem Unterprogramm. Mit RTS müssen Programme abgeschlossen sein, die mit JSR (Jump to SubRoutine) oder SYS (von Basic aus) aufgerufen werden. Dies dürfte für die überwiegende Mehrheit aller Maschinenprogramme der Fall sein. Ausnahmen sind:

Programme., die von einem Monitor aus gestartet werden. Sie sollten mit einem BRK (Break) abgeschlossen sein.

Programme, die durch Interrupts aktiviert werden, werden normalerweise durch RTI (ReTurn from Interrupt) abgeschlossen.

Mit RUN wird der Assembler gestartet. Er erzeugt ein 6 Byte kurzes Maschinenprogramm ab $C000 und gibt in einer Abschlußmeldung den belegten Speicherbereich zusammen mit der Assemblierzeit bekannt. Das Maschinenprogramm kann nun mit

TODO

SYS $C000 oder SYS 12 \* 4096

gestartet werden. (Wenn Hypra-Ass aktiv ist, versteht der C 64 auch Hex-Zahlen). Es müßte ein »A« in der linken oberen Bildschirmecke erscheinen. Sollte das nicht der Fall sein, so kann das zwei Ursachen haben:

1.	Das »A« wurde nach oben weggescrollt, weil Sie den SYS-Befehl zu weit unten auf dem Bildschrim eingetippt haben.
2.	Sie besitzen eine alte Version des C 64, bei der das FarbRAM mit der Hintergrundfarbe vorbesetzt wird.

Im zweiten Fall ergänzen Sie das Programm durch:

TODO

35 - STA $D800

Dieser Befehl speichert die immer noch im Akkumulator (im folgenden nur Akku genannt) stehende 1 an die Startadresse des Farb-RAMs. Dadurch erscheint das »A« in weißer Farbe.

Ergänzen Sie Ihr kleines Programm einmal durch den Pseudobefehl

TODO

5 - .LI 1,3,0

und assemblieren Sie mit RUN. Der Assembler erzeugtjetzt ein Listing, dessen Zeilen von links nach rechts wie folgt aufgebaut sind:

-	Speicheradresse des folgenden Maschinenbefehls
-	Der Code des Maschinenbefehls. Da es Maschinenbefehle mit ein, zwei oder drei Byte gibt, sind diese Einträge unterschiedlich lang.
-	Ein Doppelpunkt und die ursprüngliche Quelltextzeile. Bei Pseudobefehlen, die ja keinen Code erzeugen, entfälltder Teil bis einschließlich zum Doppelpunkt.

Das Assemblerlisting ist bei der Fehlersuche mit einem Monitor nützlich, da es zu jedem Maschinenbefehl seine Adresse enthält. Mit dem Pseudobefehl:

TODO

.11 1,4,0

erhält man ein Druckerlisting. Angenehm dabei ist, daß es bei ausgeschaltetem Drucker automatisch auf den Bildschrim umgeleitet wird.

Die abgedruckten Listings enthalten allerdings keine Speicheradressen mit zugehörigem Maschinencode. Diese Information ist zum Studieren der Programme uninteressant und zum Eintippen der Listings nicht erforderlich. Die Listings wurden mit dem Editorbefehl /E (formatiertes Listen) gewonnen, nachdem vorher die Ausgabe durch

TODO

OPEN 4,4:CMD 4

auf den Drucker umgeleitet wurde.

### 2.	Eine einfache Programmschleife

Das folgende kleine Programm (Listing 1) schreibt 240mal den Buchstaben »A« auf den Bildschirm. Zur Arbeitsweise: Akku A wird wieder mit dem Bildschirmcode des Buchstabens A geladen. Das X-Register übernimmt zwei Aufgaben: Es zählt Schleifendurchläufe und liefert Werte zur Adreßverschiebung. X wird mit 0 vorbesetzt. In Zeile 1280 ist LOOP ein Label (auch SYMBOL oder Sprungmarke). LOOP steht für die Adresse des STA-Befehls, die man an anderen Programmstellen durch den Namen LOOP ansprechen kann, ohne daß man den Wert dieser Adresse kennt. Den Assemblerprogrammierer interessieren absolute Adressen normalerweise auch gar nicht, es sei denn, es handelt sich um systemspezifische Adressen, wie zum Beispiel die Adressen der Video-Chip-Register. Eine derartige Zuordnung einer Programmadresse zu einem Label nennt man implizite Definition.

Die Zieladresse des STA-Befehls in Zeile 180 ergibt sich durch die Summe aus $400 und X. Da X am Anfang 0 gesetzt worden ist, wird also eine 1 an die Stelle $400 gespeichert. INX erhöht X um Eins. CPX # 240 vergleicht X mit der Zahl 240. Bei Ungleichheit wird das Zero-Flag im Statusregister auf 0 gesetzt. Auf dieses Zero-Flag bezieht sich dann der bedingte Sprung BNE LOOP. BNE springt dann, wenn der vorige Vergleich Ungleichheit ergeben hat. (Daher auch der Name BNE = Branch if Not Equal = verzweige, wenn ungleich). Beim nächsten Schleifendurchlauf wird die 1 aus dem Akku an die Adresse $4012 gespeichert. X wird solange inkrementiert, bis 240 erreicht ist. In diesem Fall springt BNE nicht und das Programm endet mit RTS. Bei den 240 Schleifendurchläufen werden nacheinander die Adressen $400 bis $400+239 angesprochen. Programmschleifen wie diese benützt man oft zum Löschen eines Speicherbereichs. (Akku mit 0 vorbesetzt.)

### 3.	Blockverschiebung (maximal 255 Byte)

Das Programm (Listing 2) arbeitet mit einer ähnlichen Schleife wie das vorige. In den Zeilen 150,160 und 170 werden Label explizit definiert. Dies geschieht mit dem Pseudobefehl .EQ.

Die explizite Definition eines Labels ist praktisch dasselbe wie die Zuweisung eines Wertes an eine Variable. Hier werden die Anfangsadressen des ursprünglichen Blocks und des verschobenen Blocks sowie die Blocklänge definiert. X läuft hier rückwärts von LAENGE bis 0. Dadurch kann der CPX-Befehl eingespart werden. DEX setzt nämlich automatisch das Zero-Flag, wenn nach dem Dekrement X den Wert 0 hat. BNE LOOP springt also nur solange nach LOOP, solange X größer als 0 ist. Mit den vorliegenden Werten für QUELLE, ZIEL und LAENGE kopiert das Programm die Bildschirmzeilen 1 bis 6 auf die Zeilen 7 bis 12.

Programme zur Blockverschiebung wie dieses oder zur Blockfüllung wie das vorige sind nurfür Blocklängen bis maximal 255 Byte geeignet, da das X-Register nur 8 Bit lang ist. Wenn man größere Speicherbereiche auf diese Weise verarbeiten will, muß man mehr Aufwand treiben.

### 4.	Blockverschiebung (ohne Einschränkungen)

Das Programm (Listing 3) ist sicher nicht die kürzeste Lösung des Problems, es demonstriert dafür aber ohne verwirrende Tricks die Adressierungsart »Indirekt Indiziert«.
Beispiel: LDA (ZEIGER),Y
Bei dieser Adressierungsart enthalten zwei aufeinanderfolgende Speicherstellen der Zero-Page eine Adresse in der üblichen Reihenfolge Low-Byte - High-Byte. Im Programm wird nicht diese Adresse selbst angegeben, sondern die Adresse der ersten der beiden Zero-Page-Speicherstellen (hier ZEIGER genannt). Diese Technik nennt man indirekte Adressierung, was im Assemblertext durch die runden Klammern um die Zero-Page-Adresse zum Ausdruck kommt. Zu der aus der Zero-Page stammenden Adresse wird noch Y addiert, daher »indiziert«. Da man diese zusätzliche Indizierung oft nicht braucht, setzt man das Y-Register vorher auf O.

Das Programm verwendet für den Blocktransfer zwei Zeiger(= Zero-Page-Speicherstellenpaare). Sie werden mit der Startadresse des Quell- beziehungsweise des Zielblocks initialisiert und nach jedem Byte-Transfer hochgezählt, bis der Zeiger in den Quellblock (ZEIGER1) das Ende des Quellblocks (Adresse BIS) erreicht hat.

Das Inkrementieren eines 16-Bit Wertes verläuft nach dem Schema:

TODO

INC ZEIGER ;Low-Byte inkrementieren
BNE Weiter ;falls ungleich 0, dann fertig INC ZEIGER+l;Ubertrag ins High-Byte
WEITER (Programmfortsetzung)

Spezifisch für den Hypra-Ass ist, daß man mit

< (Adresse) beziehungsweise > (Adresse)

das Low- bezeihungsweise High-Byte einer Adresse (beziehungsweise eines Labels) gezielt ansprechen kann. Von dieser Möglichkeit wird im Programm häufig Gebrauch gemacht. So bedeutet zum Beispiel:

TODO

LDA #< (VON)

Lade den Akkumulator mit dem Low-Byte des Wertes VON.

Mit den im Program definierten Adressen VON, BIS und ZIEL kopiert das Programm einen Teilbereich aus dem Basic-Interpreter direkt auf den Bildschrim. Im Groß-/Kleinschriftmodus (Commodore-Shift drücken) kann man dann Basic-Schlüsselwörter sowie Texte von Fehlermeldungen lesen.

### 5.	Verwendung von Betriebssystem-Funktionen und Mechanismen zur Parameterübergabe

Ein Betriebssystem ist unter anderem dazu da, Standarddienste wie Ein- und Ausgabe zur Verfügung zu stellen, damit diese nicht jedesmal mühsam und fehleranfällig neu programmiert werden müssen. Die Standardfunktionen des Betriebssystems (oft »Kernel« genannt) sind im Programmierhandbuch von Commodore hinreichend erläutert. Viele weitere nützliche Routinen findet man beim Studium eines kommentierten ROM-Listings.

Die Parameterübergabe an Maschinensprache-Unterprogramme gestaltet sich leider nicht so systematisch wie bei den meisten höheren Programmiersprachen. Es werden mehrere Möglichkeiten bunt gemischt angewendet.

TODO NESTED

1. Man schreibt Parameter in vereinbarte Speicherstellen. Aus diesen holt sich dann das aufgerufene Programm die Parameter.
2. Wenn nur Ein- bis Drei-Byte-Parameter benötigt werden, kann man diese auch in den Registern A, X und Y übergeben. Auf diese Weise werden die meisten Kernel-Funktionen mit Parametern versorgt.<br>Dieser Mechanismus steht übrigens auch von Basic aus zur Verfügung: Man schreibt Registerparameter per POKE an speziell dafür vorgesehene Speicherstellen:
TODO
AkkuA	780	($30C)
IndexX	781($30D)
IndexY	782	($30E)
Status-Register 783	($30f)
Das Maschinenprogramm (Listing 4) wird nun mit SYS aufgerufen. Der Basic-Interpreter besetzt erst die Register mit den Inhalten dieser Speicherstellen und bringt dann in das Unterprogramm. Nach der Rückkehr werden die (neuen) Registerinhaltewiederin denselben Speicherstellen abgelegt, wo sie für eine eventuelle Inspektion durch das Basic-Programm zur Verfügung stehen.
3.	Man kann Parameter auch über den Stack übergeben. Diese Methode ist wegen des kleinen Stackbereichs der 6510-CPU (256 Byte) nur bedingt brauchbar und wird deshalb auch kaum praktiziert.
4.	Durch geschickte Verwendung von Unterprogrammen in Basic-ROM kann man Parameter direkt hinter den SYS-Befehl schreiben. Diese Methode ist
-	komfortabel, weil keine umständlichen POKEs nötig sind
-	schnell, weil der Interpreter weniger zu tun hat
-	flexibel, weil als Parameter auch ganze arithmetische oder Stringausdrücke geschrieben werden können.

Diese Methode wird in den Programm-Listings 5 bis 8 verwendet.


Das folgende Programm (Listing 4) nutzt die Funktionen GETIN und CHROUT. GETIN liefert den ASCII-Code einer gedrückten Taste im Akku. Falls keine Taste gedrückt wurde, wird 0 zurückgegeben. GETIN entspricht damit genau dem GET-Befehl in Basic.

CHROUT gibt ein Zeichen, dessen ASCII-Code im Akku stehen muß, auf dem Bildschrim aus. Es entspricht dem Basic-Befehl (man beachte das Semikolon):

TODO

PRINT CHR$(A);

Das Programm gibt einen Prompt aus und erwartet anschließend Eingaben. Unter einem Prompt versteht man ein (beliebig zu vereinbarendes) Zeichen am linken Bildschirmrand, das dem Benutzer mitteilt, daß Eingaben von ihm erwartet werden. Bei interaktiven Programmen (wie zum Beispiel Monitore, Editore) sind Prompts sehr nützlich, da der Benutzer daran eindeutig erkennen kann, in welchem Programm er gerade ist. Das vorliegende Programm gibt die Eingabezeichen sofort wieder aus, ohne sie weiter zu verarbeiten. Nach maximal zehn Zeichen wird automatisch ein Zeilenvorschub ausgeführt und ein weiterer Prompt ausgegeben. Das Programm ist eine Endlosschleife, die man mit der Eingabe von »X« verlassen kann.

### 6. Verwendung von Interpreter-Routinen zur Parameterübergabe

Diese Interpreter-Routinen werden in den folgenden Programmbeispielen eingesetzt:

TODO TABLE

CHKKOM ($AEFD) liest aus dem laufenden Basic-Text ein Komma. Steht an der aktuellen Stelle kein Komma, wird das Programm mit SYNTAX ERROR abgebrochen. Kommata sind nötig, um Parameter voneinander abzugrenzen.
FRMNUM ($AD8A) wertet einen beliebigen arithmetischen Ausdruck aus. Das Ergebnis wird im Fließkomma-Akkumulator 1 (kurz FAC) abgelegt. Der FAC besteht aus den Speicherstellen $61-$66. Die Bedeutung der einzelnen Byte ist hier nicht relevant.
GETADR ($B7F7) wandelt den Inhalt des FAC in ein 2-Byte-Integer-Format um, sofern diese Zahl im Bereich 0 ... 65535 liegt. Ansonsten wird ein ILLEGAL QUANTITY ERROR ausgegeben. Die Integerzahl steht in den Speicherstellen $14/$15 und zusätzlich im Registerpaar Y/A. Mit der Kombination FRMNUM und GETADR kann man also 16-Bit-Größen aus Basic-Programmen übernehmen.
XBYTE ($B79E) wertet ebenfalls arithmetische Ausdrücke aus und wandelt das Ergebnis in 8-Bit-Integerformat, sofern es im Bereich 0 ... 255 liegt. Das Byte-Ergebnis wird im X-Register übergeben.
USR () ist eine Basic-Funktion, mit der man Werte von Maschinenprogrammen an Basic zurückgeben kann. USR wertet einen in Klammern stehenden Ausdruck aus und übergibt ihn in den FAC. Es wird ein Maschinenprogramm aufgerufen, dessen Startadresse in $311/$312 steht. (USR-Vektor). Das Maschinenprogramm kann dann im FAC einen Wert an Basic zurückgeben.

Das folgende Listing (Listing 5) ist der Programmkopf zu den vier nachfolgenden Beispielen. Diese können mit dem Kopf zusammen assembliert werden. Der Kopf enthält eine Sprungliste. Dadurch werden Einsprungstellen ($C000, $C003, etc.) für die vier aufgeführten Programme fixiert, unabhängig davon, wo die Programme dann später tatsächlich im Speicher stehen. Diese Technik ist zum Beispiel sinnvoll, wenn mehrere Leute zusammen an einem größeren Programm arbeiten. Ein Programmierer kann seinen Kollegen bereits feste Einsprungstellen für Routinen, an denen er noch arbeitet oder die noch gar nicht existieren, zur Verfügung stellen.

### PRINT AT
Das Programm (Listing 6) ermöglicht eine freie und schnelle Cursorpositionierung zusammen mit einer Druckausgabe. Mit der Definition

PR=123\*4096 :REM Startadresse

kann mit

SYSPR,Zeile,Spalte,Printliste

alles ausgeben werden, was auch mit PRINT ausgegeben werden kann. Man lasse sich einmal von der Geschwindigkeit des folgenden Programms beeindrucken:

10 FOR 1=1 TO 24:SYSPR, I,I,"A":NEXT
20 FOR 1=1 TO 24:SYSPR,-I,I,"B":NEXT

Das Assemberlisting zu PRINT AT bedarf keiner großen Erläuterung. PLOT ist eine Kernel-Funktion, mit der man die Cursorposition auf dem Bildschirm setzen kann. Parameter sind Zeilen- und Spaltennnummern in den Registern X und Y. Das Programm PRINT AT ist eigentlich nicht mehr als eine geschickte Kombination der Routinen PLOT und PRINT.

### DEEK (Doppelbyte-PEEK)

Dieses Programm (Listing 7) ist eine Abänderung der PEEK-Routine. DEEK liefert einen 16-Bit-Speicherinhalt an Basic zurück. DEEK wird durch

X=USR(Adresse)

aufgerufen. Mit Adresse ist die Adresse des Low-Bytes gemeint. Da USR einen Wert zurückgibt, darf es nicht isoliert dastehen, sondern muß als rechte Seite einer Zuweisung oder als Funktionsargument eingesetzt werden. Vor dem ersten Aufruf muß der USR-Vektor auf die Startadresse des Programms gestellt werden:

POKE 785,3 :REM LOW-BYTE $03
POKE 786,192 :REM HIGH-BYTE $C0

Im Assemblerlisting steckt eine Besonderheit: Die Zugriffe auf die beiden zu lesenden Bytes (LDA ($14),Y) sind durch ein SEI/CLI-Paar eingerahmt. SEI sperrt die CPU für Interruptanforderungen. Dadurch wird garantiert, daß die beiden Lesezugriffe nicht durch ein Interruptprogramm, welches eines oder beide Bytes ändern könnte, unterbrochen werden können. CLI löst die Interruptsperre wieder.

### DOKE (Doppelbyte-POKE)

Um in Basic-Programmen 16-Bit-Größen (zum Beispiel Adressen, Vektoren) in den Speicherzu schreiben, muß man sie vorher erst umständlich in High- und Low-Byte zerlegen, um dann beide Byte POKEn zu könen. Dazu wird meistens die Sequenz:

HI=INT(X/256)
L0=X-256\*HI
POKE AD,L0
POKE AD+l,HI verwendet.

Wenn man bedenkt, daß jeder Befehl interpretiert werden muß und daß jede Rechenoperation (auch »+1«) in voller Fließkomma-Genauigkeit durchgeführt wird, versteht man, daß dazu viel Rechenzeit nötig ist. Das kleine Maschinenprogramm (Listing 8), das keiner Erläuterung mehr bedarf (FRMNUM, GETADR und CHKKOM sind bekannt) zeigt, wie es einfacher geht:

SYSD0,AD,Y

(Natürlich muß man DO einmal vorher definieren: DO=12\*4096+6). Auch bei DOKE werden die beiden kritischen STA-Befehle durch ein SEI/CLI-Paar untrennbar gemacht. Mit DOKE kann man daher sogar den Interrupt-Vektor ändern. Versucht man dies dagegen mit Hilfe zweier POKEs, kann es passieren, daß ein Interrupt gerade dann auftritt, nachdem das Low-Byte aber noch nicht das High-Byte geändert worden ist. Der Interrupt führt dann auf eine unbestimmte Adresse, was meistens einen Programmabsturz nach sich zieht.

DEEK und DOKE können natürlich auch verschachtelt eingesetz werden. So kann man mit

SYSD0,A2,USR(A1)

einen 16-Bit-Wert von der Stelle A1 nach A2 kopieren.

### Speichern beliebiger Speicherbereiche auf Diskette

Das Programm (Listing 9) realisiert das Gegenstück zum Basic-Befehl:

LOAD "Name",8,1

Aufgerufen wird es durch:

SYSSAV,Date iname,gn,s a,ea

Dabei kann bei »Dateinamen« ein Name oder ein Stringausdruck in Anführungszeichen stehen.
»gn« ist die Gerätenummer (8 oder 9)
»sa« und »ea« sind Start- und Endadresse des abzuspeichernden Bereiches. Zum Programm selbst:

Die Routine bei $E257 beschafft sich den Filenamen aus dem Basic-Text und stellt ihn der später folgenden SAVE-Routine zur Verfügung. Mit SETLFS kann man dem Betriebssystem eine logische Filenummer (im Akku), eine Gerätenummer (in X) und eine Sekundäradresse (in Y) bekanntgeben. Die Parametrisierung der Kernel-SAVE-Routine ist etwas komplizierter:

TODO

X	Endadresse Low-Byte
Y	Endadresse High-Byte
A	Zeiger auf das untere	Byte eines Zero-Page-Bytepaares, welches die Startadresse enthält.

Die SAVE-Routione kehrt mit gesetztem Carry-Flag zurück, falls beim Speichern ein Fehler aufgetreten ist. Das Programm bei $E0F9 sorgt dann für eine ordentliche Fehlermeldung.

### Multiplikation

Das Programm (Listing 10) multipliziert zwei Byte-Werte miteinander und liefert ein 16-Bit-Produkt. Es ist aber trotz seiner Kürze nicht ganz einfach zu verstehen. Die beiden zu multiplizierenden Faktoren seien mit

Multiplikator MR und Mulitplikand MD

bezeichnet. Für das Resultat ist es natürlich gleichgültig, welcher Faktor als MR und welcher als MD an das Programm übergeben wird. MR kann man sich, wie jede binäre Größe, folgendermaßen vorstellen:

MR=MR(7)\*128+MR(6)\*64+...+MR(1)\*2+MR(0)\*1

Dabei bezeichnet zum Beispiel MR(6) das Bit Nummer 6 von MR in der üblichen Zählweise von 0 bis 7 und von rechts nach links. Das Produkt MR\*MD kann man nun so berechnen:
Addiere folgende Teilprodukte:
MD\*128,	falls	MR(7)=1,	sonst	0
MD\*64,	falls	MR(6)=1,	sonst	0
MD\*2,	falls	MR(1)=1,	sonst	0
MD,	falls	MR(0)=l,	sonst	0

Die Teilprodukte erhält man einfach durch Linksverschieben von MD:

MD\*128 durch 7-maligen Links-Shift
MD\*64 durch 6-maligen Links-Shift

Zu addieren ist nur dann etwas, wenn das entsprechende Bit in MR= 1 ist. Wenn man MR mit dem ROL-Befehl achtmal nach links schiebt, so durchwandern alle 8 Bit nacheinander das Carry-Flag und letzteres kann leicht abgefragt werden. Der Trick des Programms besteht nun darin, daß das Berechnen von Teilproduktsummen mit dem Linksschieben von MR kombiniert wird. Zunächst wird die Zwischensumme in A mit 0 vorbesetzt. MR wird nach links geschoben. Das höchstwertige Bit von MR steht jetzt im Carry-Flag. Ist es 1, so wird MD zum Akku addiert. Eigentlich müßte jetzt der Akku um sieben Positionen nach links geschoben werden, da zum ersten Teilprodukt der Faktor 128 gehört. Diese Verschiebung ergibt sich aber automatisch im Verlauf der nächsten sieben Schleifendurchläufe.

Sowie MR nach links geschoben wird, werden rechts in MR Bits frei, die dann von den von rechts kommenden höherwertigen Bits der Zwischensumme belegt werden. Nach 8 Schleifendurchläufen ist schließlich MR nach links verdrängt worden. An seiner Stelle steht nun das High-Byte des Produkts. Das Low-Byte des Produkts steht im Akku, während MD unverändert geblieben ist.

Erwähnenswert sind hier noch die Befehle ASL und ROL: Beide schieben nach links und bei beiden wird Bit 7 ins Carry-Flag geschoben. Der Unterschied:

ASL besetzt Bit 0 mit 0
ROL besetzt Bit 0 mit dem alten Inhalt des Carry-Flags.

Mit ASL (ohne Adreßteil) wird also der Akku arithmetisch verdoppelt, während mit ROL MR zusätzlich der Übertrag aus dieser Verdoppelung in Bit O von MR gelangt.

### Schieberegister-Folgen als Pseudo-Zufallszahlen

Das Programm (Listing 11) zeigt eine interessante Anwendung von Schieberegistern. Wenn man ein Schieberegister (SR) an den »richtigen« Bitpositionen »anzapft« und das Exklusiv-Oder-Produkt dieser Bits an den SR-Eingang zurückführt, erhält man eine Folge von Bits, die vollkommen zufällig zu sein scheint. Die Folgen sind zwar periodisch, sie wiederholen sich also nach einer gewissen Zeit, die Periodenlänge kann aber beliebig lang gemacht werden. Macht man eine so erzeugte 0-1-Folge mit einem Lautsprecher hörbar, so klingt diese wie weißes Rauschen.

Die folgende Tabelle enthält geeignete Anzapfstellen für Schieberegister unterschiedlicher Länge.

TODO TABLE

Registerlänge	Rückkopplung	Periodenlänge
2	O + 1	3
3	1+2	7
4	2 + 3	15
5	2 + 4	31
6	4+5	63
7	5 + 6	127
8	1+2+3+7	255
9	4 + 8	511
10	6 + 9	1023
11	8+10	2047
12	1+9 + 10+11	4095
13	0 + 10+11 + 12	8191
14	1+11 + 12 + 13	16383
15	13+14	32767
16	10 + 12 + 13+15	65535
»+« steht hier für »EOR«

Die angegebenen Periodenlängen sind die bei der jeweiligen Registerlänge maximal möglichen. Die Schieberegisterfolgen haben die angenehme Eigenschaft, daß die Registerwerte alle Zahlen von 1 bis zur Periodenlänge in quasizufälliger Reihenfolge durchlaufen. Man darf ein solches Schieberegister allerdings nicht mit lauter Nullen vorbesetzen, da es dann seinen Zustand nicht mehr ändert (O EOR 0 =O).

Der Kern des folgenden Programms ist die kleine Routine SHIFT. Die beiden Zero-Page-Speicherstellen SR und SR+1 bilden ein 16-Bit-Schieberegister. Rückgekoppelt wird es an den Positionen 6 und 9. Es werden quasi nur 10 Bit von den 16 vorhandenen ausgenutzt. SHIFT erzeugt bei wiederholtem Aufruf eine Folge mit der Periode 1023.

Das Hauptprogramm wendet nun diese Folge in grafisch reizvoller Weise an. Zunächst wird das Low-Byte des Schieberegisters mit einem zufälligen Wert (ungleich 0) vorbesetzt. Dieser Wert stammt aus dem ständig laufenden Timer A in CIA Nummer 1. SHIFT wird nun 1023 mal aufgerufen und erzeugtdadurch alle Zahlen von 1 bis 1023 in quasizufälliger Reihenfolge. Diese Zahlen werden als Adressen relativ zum Bildschirm-RAM verwendet. Bei den adressierten Bytes wirdjeweils Bit 7 invertiert, was eine Reversdarstellung der Bildschirmzeichen bewirkt. Das Programm MAIN bewirkt also nichts anderes als eine Invertierung des gesamten Textbildschirms. Da dies aber in zufälliger Abfolge geschieht, ist der Effekt sehr auffallend. Über die Variable DELAY ($FA)=250) kann man das Tempo der Invertierung beeinflussen. Das anschließende Basic-Programm (Listing 12) erzeugt einen Flimmereffekt, indem es eine einfache Zufallsgrafik mit dem Programm MAIN invertiert.

(Thomas Krätzig/aw)

# Superhirn, einmal andersherum [164-166]

> Lassen Sie den C 64 Ihre Kombination herausfinden. Nach einem perfekten Algorithmus kann der C 64 Ihre Zahlenfolge in maximal sechs Versuchen berechnen.

Beim Spiel Superhirn geht es darum, einen von einem Q Mitspieler ausgedachten Farbcode zu erraten. Man W probiert verschiedene Farbcodes aus; der Mitspieler gibt nach einer versuchten Kombination Information über deren Richtigkeit.

Es gibt schon einige Superhirn-Programme, die eine Kombination wählen, die dann der menschliche Mitspieler erraten muß.

Superhirn II geht den anderen Weg: Der Mensch denkt sich eine Kombination aus, die dann der Computer erraten muß! Superhirn II findet jede Kombination garantiert (siehe Kasten).

Die Farben werden durch Zahlen symbolisiert. Es gibt sechs»Farbzahlen«, nämlich die Ziffern 1,2,3,4,5und6. Für die Farben gibt es vier Positionen 

### Bedienungsanleitung:

Geben Sie Superhirn II bitte mit dem MSE ein (Listing 1) und starten Sie es mit »SYS 13312«.

Sie antworten, indem Sie zuerst die Anzahl der richtigen Farbziffern an der richtigen Position eingeben und dann mit »RETURN« abschließen. Dann geben Sie die Anzahl der richtigen Farbziffern an der falschen Position ein und bestätigen wiederum mit »RETURN«.

Superhirn II gibt dann seinen neuen Lösungsvorschlag aus; Sie antworten wieder wie oben. Das Programm ist beendet, wenn

- das Programm die richtige Kombination gefunden hat (es meldet sich mit »OK«)
- oder wenn Sie eine unmögliche Antwort gegeben haben (das Programm meldet sich mit »ERROR«).

### Beispiel:

Nehmen wir die Kombination »3436«. Nach Programm-Start beginnt Superhirn II wie üblich mit seiner Startkombination »1234«.

Der Computer hat die »3« richtig als Zahl und Position; die »4« stimmt nur als Zahl.
Also wird eingegeben:

TODO

1234	- der Vorschlag des Computers.
1 < RETURN > - für die richtige »3«.
1 < RETURN > - für die »4« an falscher Position.
Jetzt sucht der Computer einen neuen Lösungsvorschlag.
Verfolgen wir die Eingaben bis zum Ende ...
2211	- der 2. Versuch des Computers.
0 < RETURN > - keine richtige Position/richtige Ziffer.
0 < RETURN > - keine falsche Position/richtige Ziffer.
4333	- der 3. Versuch des Computers.
1 < RETURN > - für die richtige »3«.
2 < RETURN > - für die »3« und »4«.
3344	- der 4. Versuch des Computers.
1 < RETURN > - diesmal stimmt die erste »3«.
2 < RETURN > - dafür sind »3« und »4« vertauscht.
3435	- der 5. Versuch des Computers.
3 < RETURN > - bis auf die fehlende »6« richtig.
0 < RETURN > - die »5« ist falsch.
3436	- der 6. Versuch des Computers.
4 < RETURN > - die Kombination ist gefunden.
OK	- Sie befinden sich wieder im Basic.

Das Programm kann mit »SYS 13312« wieder gestartet werden.

### Hinweise:

Die Eingabe unlogischer Daten führt zur Ausgabe von »ERROR«. Sie haben dann entweder eine offensichtlich falsche Eingabe gemacht (zum Beispiel bei der Eingabe einer »6« für die Anzahl der richtigen Ziffern - es kann ja nur höchstens »4« als korrekte Eingabe vorkommen!) oder eine logisch falsche Eingabe.

Was ist eine logisch falsche Eingabe? Nehmen wir unser Beispiel von oben:

Geben Sie nach dem 6. Versuch des Computers nicht die (richtige!) »4« ein, sondern »0« und nochmal »0«, antwortet Ihnen der Computer mit »ERROR«. Warum?

Nun gibt es einfach keine Ziffernkombination mehr, die allen Ihren Eingaben gerecht werden kann. Folglich müssen Sie einen Eingabe-Fehler gemacht haben.

Geben Sie in unserem Beispiel nach dem 3. Versuch des Computers nicht »1« und »2« (was nach Wahl unserer Ziffernkombination »3436« die einzig korrekte Eingabe ist), sondern »2« und »2«, kann Fehleingabe natürlich nicht miteinem »ERROR« beantwortet werden, weil nämlich jetzt noch Ziffernkombinationen vorhanden sind, die nicht im Widerspruch zu Ihren bis dahin gemachten Eingaben stehen.

### Zum Programm:

Den Quelltext des Programms entnehmen Sie Listing 2. Die Eingabe-Routine liest nur das erste Zeichen jeder Zeile - es macht also keinen Unterschied, ob man als Antwort »1« oder »123456« eingibt, da die restlichen Zeichen nicht berücksichtigt werden.

Das Programm ist leicht auf zum Beispiel 10 Positionen erweiterbar - man muß jedoch folgendes beachten: Die Abstände zwischen den Registern POS1,...., CWEISSE müssen vergrößert werden, da möglicherweise neun Versuche nicht zum Ziel führen.

Auch die Anzahl der möglichen Ziffern kann leicht von sechs auf acht erweitert werden. Möchte man mehr als acht Ziffern, muß man mit 16-Bit-Zahlen arbeiten, was größere Umschreibarbeiten zur Folge hat.

### Kombinations-Codierung:

Es bleibt noch die Frage, in welcher Art und Weise die Kombinationen gespeichert werden. Nehmen wir dazu doch wieder unsere Kombination aus dem Beispiel, also »3436«.

In POS1, POS2, POS3 und POS4 steht immer die aktuelle Kombination, die der Computer gerade als Lösungsversuch ausgegeben hat.

Ist das Problem gerade bei der Lösung angelangt, dann steht nicht etwa in POS1 die »3«, in POS2 die »4«, in POS3 wieder die »3« und in POS4 die »6« - sondern die Kombination ist folgendermaßen festgehalten:
POS1 - 2 hoch (3-1)
POS2 - 2 hoch (4-1)
POS3 - 2 hoch (3-1)
POS4 - 2 hoch (6-1)

Durch diese Darstellung ist es später leichter möglich, die Anzahl der Schwarzen (= richtige Ziffer/richtige Position) und die Anzahl der Weißen (= richtige Ziffer/falsche Position) zu bestimmen.

Der Lösungsversuch des Computers in der x-ten Runde stehtgenauso codiertin POS1+X, POS2+X, POS3+Xund POS4+X.

(A. Reiser/H. Bauschke/og)

TODO ASIDE

Das Programm gibt den ersten Lösungsvorschlag aus. Nach der Eingabe des menschlichen Mitspielers wird eine Ziffernkombination gesucht, die logisch richtig ist in bezug auf alle vorher gemachten Eingaben.

Dabei werden alle Ziffernkombinationen von »1111« bis »6666« getestet.

Ist die aktuelle Ziffernkombination logisch richtig, gibt sie der Computer aus.

Das Programm beginnt bei der nächsten Suche nach der Lösung bei der zuletzt ausgegebenen Ziffernkombination; es muß also nicht wieder bei »1111« anfangen.

Hat der menschliche Gegner nicht mit »4« bei richtiger Position/richtige Farbe geantwortet und ist das Programm bei »6666« angelangt, kann es sich nur um eine falsche Eingabe handeln - es wird »ERROR« ausgegeben.

Wie beurteilt das Programm nun, ob es in seiner Schleife von »1111« bis »6666« gerade bei einer logisch richtigen oder logisch falschen Ziffernkombination ist?

Dazu benutzt der Algorithmus folgenden Trick: Es wird angenommen, daß die zu prüfende Ziffernkombination die richtige ist. Dann werden alle bis dahin getätigten Eingaben mit dieser Kombination verglichen. Es wird also nach der Anzahl der richtigen Ziffer/richtige Position und nach der Anzahl richtige Ziffer/falsche Position gesucht. Das Ergebnis wird festgehalten und mit den Eingaben, die Sie gemacht haben, verglichen.

Stimmen diese Werte sämtlich überein, kann es sich bei der zu prüfenden Kombination um die Lösung handeln - sie muß es aber nicht sein!

Trifft nun das Programm auf eine solche Lösungsmöglichkeit, gibt es diese auch aus.

Ist die Prüfung negativ ausgefallen, das heißt, es gab mindestens eine Abweichung von der tatsächlichen Eingabe des menschlichen Mitspielers, wird in der großen Schleife weitergesucht - so lange, bis die Kombination gefunden ist.

So findet das Programm die Kombination

# Befehlssatz des 6510 [171-172,174-178]

> Hier finden Sie, alphabetisch geordnet, eine Auflistung aller bekannten Befehle des C64-Prozessors. Dazu gehören auch die »illegalen Opcodes«.

Zuerst ein Wort zu den illegalen Opcodes, die in Tabelle 1 enthalten sind:
Seit Erscheinen des C 64 vor ungefähr drei Jahren sind einige verschiedene Versionen des Prozessors 6510 gebaut worden. Diese sind untereinander voll kompatibel, was den normalen Befehlssatz aus Tabelle 2 anbetrifft. Die illegalen Opcodes jedoch laufen nicht auf allen Versionen der CPU 6510. Welche Befehle auf welchem Computer eine korrekte Ausführung bewirken, läßt sich nur durch Ausprobieren feststellen. Äußerst hilfreich dabei ist der SMON aus dieser Ausgabe: Er zeigt einen illegalen Opcode nicht wie die meisten Maschinensprachmonitore durch drei Fragezeichen an, sondern disassembliert den Befehl mit den in Tabelle 1 genannten Abkürzungen. Ein vorangestelltes Sternchen (\*) kennzeichnet bei SMON den Befehl als illegalen Opcode (zum Beispiel \*AXS).

In Tabelle 3 finden Sie eine Übersicht über die in den beiden anderen Tabellen verwendeten Abkürzungen.

(tr)

TODO TABLE

# ROM-Routinen in eigenen Programmen [178-180]

> Das Rad ist schon erfunden! Ähnlich verhält es sich mit verschiedenen Routinen, die ein Assembler-Programmierer immer wieder benötigt. Aber warum soll man sich die Arbeit des Programmierens machen, wenn das Betriebssystem viele ständig benötigte Routinen schon enthält und man nur noch zu wissen braucht, ab welcher Adresse sie stehen?

Angenommen, Sie möchten in Assembler einige komplexe Dinge programmieren wie beispielsweise eine neue mathematische Funktion (wie wäre es mit dem Kotangens) und diese auf dem Bildschirm ausgeben. Das ist eine große Aufgabe, zu der zunächst einmal die Übernahme des Arguments in das Maschinenprogramm, dann einige Fließkomma-Rechenoperationen und schließlich die Ausgabe auf dem Bildschirm geschrieben werden müßten, wenn da nicht schon fast alles an verborgener Stelle als fertige Programm-Module im Computer vorhanden wäre!

Sowohl im unteren (von $A000 bis $BFFF) als auch im oberen ROM-Bereich (von $E000 bis $FFFF) liegt die Firmware fest verschachtelt vor. Der untere ROM-Abschnitt wird manchmal auch Basic-Interpreter, der obere ROM-Bereich Betriebssystem genannt, wobei diese Einteilung aber den Kern der Sache nicht genau trifft, denn Interpreter, Editor und Betriebssystem führen ein gemischtes Dasein quer durch alle genannten ROM-Bereiche hindurch.

Mindestens fünf Informationen braucht ein Assembler-Programmierer, wenn er das breite Programmangebot des ROMs nutzen möchte:

1.	Einsprungadresse
2.	Format der Eingabeparameter
3.	Adressen der Eingabeparameter
4.	Adressen der Ausgabeparameter
5.	Format der Ausgabeparameter

Nicht alle Routinen, die man benutzen kann, erfordern alle fünf Informationen, manche weniger, einige auch mehr und schließlich gibt es noch Programmroutinen, die noch den Aufruf einer oder sogar mehrerer anderer Routinen nötig machen.

In der beigefügten Tabelle sind - nach Anwendungen sortiert - die wichtigsten Firmware-Möglichkeiten mit den erforderlichen Ein- und Ausgabeparametern aufgeführt. Das sind natürlich beileibenichtalle. Die Auswahl erfolgte subjektiv! Es sind einfach diejenigen, die mir bislang am häufigsten untergekommen sind. Außerdem wurde auf die Kernel-Routinen verzichtet: Man findet diese sehr gut dokumentiert bereits in einer Reihe von Büchern und im Assembler-Kurs.

Die Tabelle nennt den Label-Namen, die Einsprungadresse und gibt eine Kurzbeschreibung der Funktion. Das Ein- und auch das Ausgabeformat ist ebenso angegeben wie auch die Adressen, an denen diese Parameter übergeben werden. Die verwendeten Bezeichnungen halten sich eng an die im Assembler-Kurs kennengelernten. Sie sind allgemein üblich:

TODO TABLE

FAC	Fließkomma-Akku 1
ARG	Fließkomma-Akku 2
A	Akkumulator
X,Y	X-, Y-Register
A/Y	2-Byte-Angabe im Format LSB/MSB im Akku/Y-Register
FLPT	Fließkommazahl im Normalformat
MFLPT	gepacktes Fließkommaformat

Damit das alles nicht so trocken abläuft, soll noch ein kleines Beispiel vorgestellt werden! Die oben schon erwähnte Kotangens-Funktion wird in einem Maschinenprogramm erzeugt, das durch USR anzuspringen ist. In Bild 1 finden Sie ein Flußdiagramm zu dem Programm, welches hier als Hypra-Ass-Listing abgebildet ist (Listing 1). Ein kurzes Testprogramm liefert Listing 2.

Der Einsprung mittels USR bietet den Vorteil, daß der Übergabewert gleich im FLPT-Fbrmat im FAC »landet«. Es ist aber sinnvoll, den Übergabeparameter mittels der MOVMF-Routine zu »retten«, weil durch die Kosinus-Funktion der FAC verändert wird. Wenn auch das Ergebnis der Kosinus-Funktion mittels MOVMF beiseite gelegt wurde, holen wir durch MOVFM den Anfangswert wieder in den FAC und bilden mittels SIN den Sinus davon. Schließlich teilen wir den im Speicher stehenden Kosinuswert durch den im FAC befindlichen Sinuswert (unter Verwendung von FDIV). Das Ergebnis ist der Kotangens:

COTX = (COSX/SIN X)

Dieser Wert befindet sich nun im FAC und wird mit dem RTS an das Basic-Programm zurückgeliefert. Im Testprogramm weisen wir ihm dann die Variable E zu.

Dieses kurze Beispiel soll Ihnen den Mund wässrig machen. Sehr viel detaillierter werden die ROM-Routinen im Kurs »Von Basic zu Assembler« im 64’er behandelt werden.

(Heino Ponnath/hm)

Literatur:
1.	Kassera/Kassera, Programmieren in Maschinensprache, München 1985: Markt & Technik Verlag, MT 830
2.	West, C64 Computerhandbuch, München 1984, Te-wi
3.	Babel/Krause/Dripke, Das Interface Age Systemhandbuch zum C 64, München 1983: Interface Age Verlag
4.	Ponnath, C 64 Wunderland der Grafik, München 1985: Markt & Technik Verlag MT 756.

TODO TABLES

# Die Codes des C 64 [181-182,184]

> Die kompletten ASCII-, CHR$- und Bildschirmcodes und dazu noch die vollständigen Tastencodes des C 64 finden Sie in der folgenden Tabelle anwenderfreundlich, also so, daß man sie auch benutzen kann, gegenübergestellt.

Programmieren in Maschinensprache beinhaltet oft Ein- und Ausgaben, zum Beispiel für eine Benutzerführung, oder um Eingaben vom Bildschirm einzulesen. Häufig steht man vor dem Problem, daß man nur einzelne Zeichen eines Textes in einem Maschinenprogramm verändern will. In allen Fällen benötigt man dann die CHR$- oder Bildschirmcodes, von denen hier die Rede ist. Das gleiche gilt natürlich auch für die Tastatur. Das Betriebssystem stellt uns die momentan gedrückte Taste in zwei Speicherstellen zur Verfügung.

## Warum verschiedene Codes?

Vergleicht man in der Tabelle 1 die Spalten, so wird man feststellen, daß es einige nicht druckende Zeichen gibt, Codes, die auf dem Bildschirm nichts schreiben. Es sind dies die ASCII- beziehungsweise die CHR$-Codes von 0 bis 31 und von 128 bis 159. Auch findet man auf dem Bildschirm Zeichen, die in der ASCII-Tabelle nicht auftauchen - die reversen Zeichen mit den Codes von 128 bis 255. Um alle druckenden ASCII-Zeichen auch auf dem Bildschirm sichtbar zu machen, und dabei keine sinnlos leeren Felder mitzuführen, mußte man die Tabelle im Computer umstellen.

Ganz anders verhält es sich mit der Tastatur. Hier sieht die Codierung zunächst sehr zufällig aus. Natürlich ist dies mit der Anordnung der Tasten und der Methode, wie das Betriebssystem die Tasten abfragt, zu erklären. Uns soll es hier genügen, zu wissen, wie man von einem (Maschinen-) Programm aus einen Tastendruck registrieren kann. Man findet die zuletzt gedrückte Taste in den Speicherstellen 197 ($C5) und 203 ($CB), die mit PEEK beziehungsweise auf der Maschinensprache-Ebene mit LDA ausgelesen werden kann.

Die nachfolgende Tabelle 1 bietet auf einen Blick alle Codes, die im C64 enthalten sind. Die Tabelle ist nach den CHR$-Zeichen sortiert, also eine aufsteigende Reihe von 0 bis 255. Um das Programmieren in Maschinensprache zu erleichtern, sind neben den dezimalen Zahlen auch die hexadezimalen Werte aufgeführt.

Die Spalten drei und vier enthalten die CHR$-Zeichen des C 64. Spalte drei zeigt dabe\* die Zeichen im Groß-/Grafikmodus, Spalte vier die entsprechenden Zeichen in Klein-/Großschriftmodus.

Die Zeichen von 0 bis 31 und von 128 bis 159 sind diejenigen CHR$-Codes, deren Aufruf auf dem Bildschirm kein sichtbares Zeichen hervorbringt, so zum Beispiel das Umstellen der Cursorfarbe, oder die Codes der Funktionstasten, die man nichtschreibenkann(?CHR$(133)ergibtnicht»F1«), aberfür eine Abfrage (IF A$ = CHR$(133) THEN...) nutzen kann. Hier wird nicht zwischen den Modi unterschieden, da das Ergebnis in beiden Fällen das gleiche ist. Damit der Text in die Tabelle paßt, ließen wir ihn sogar bis in die sechste Spalte übergreifen. Über den Bildschirmcode kann man nicht über diese Funktionen verfügen!

Die Bildschirmcodes der fünften und sechsten Spalte sind die Werte, die man erhält, wenn man das CHR$-Zeichen mit PRINT ausgibt und die entsprechende Bildschirmspeicherstelle mit PEEK ausliest. Für Maschinensprache ist auch hier wieder der hexadezimale Wert angegeben. Die reversen Zeichen erhält man durch Addition von 128, in Maschinensprache durch den Befehl »ORA # $80«.

Obwohl der C64 keinen echten ASCII-Zeichensatz hat, ist dieser in Spalte sieben aufgeführt. Man benötigt den ASCII-Code vor allem für die Datenfernübertragung (DFÜ) und zur Ansteuerung von nicht MPS-kompatiblen Druckern, die nicht mit einem »intelligenten« Interface betrieben werden. Die Erklärungen der verwendeten Kurzzeichen stehen in der Tabelle 2.

In den letzten beiden Spalten sind die Tastaturcodes enthalten, wie man sie beim Auslesen der Speicherstellen 197 und 203 erhält. Bitte beachten Sie, daß der Code 63 ($3F) der RUN/STOP-Taste entspricht, also dem CHR$-Code 3. Da aber PRINT CHR$(3) ein Programm nicht anhält und sich nicht abfragen läßt, ist es in der Tabelle nicht aufgeführt.

(og)

TODO TABLE

NUL = Null
SOH = Start of Heading
STX = Start of Text (Textbeginn)
ETX = End of Text (Textende)
EOT	=	End of Transmission (Übertragungsende)
ENQ = Enquiry (Testanfrage)
ACK = Acknowledge (Quittierung)
BEL = Bell (Klingelzeichen)
BS = Backspace (Zeichen zurück)
HT = Horizontal Tabulation
LF = Line Feed (Zeilenvorschub)
VT = Vertical Tabulation
FF = Form Feed (Formatanpassung)
CR = Carriage Return (Wagenrücklauf)
SO = Shift out (Shift aus)
SI = Shift in (Shift ein)
DLE	=	Data Link Escape (Datenverbindung abhalten)
DC	=	Device Control (Gerätesteuerung)
NAK	=	Negative Acknowledge (Gegenquittierung)
SYN	=	Synchronous Idle (synchronlos)
ETB = End of Transmission Block (Block Übertragungsende)
CAN = Cancel (Stornieren, zum Beispiel Puffer leeren)
EM	=	End of Medium (z. B. Papierende)
SUB = Substitute (Austausch)
ESC = Escape (übergehen, Druckercode)
FS	=	File Separator (Filetrennung)
GS = Group Separator (Trennung von Gruppen)
RS	=	Record Separator (Aufzeichnung trennen)
US	=	Unit Separator (Einheitentrenner)
SP	=	Space (Leerzeichen)
DEL	=	Delete (Löschen)
Tabelle 2. Erklärung der in Tabelle 1 abgekürzten ASCII-Zeichen

TODO TABLE

# Befehlsübersicht - Zusammenfassung [184-185]

> Kennen Sie die Programme Hypra-Ass, Reassembler und SMON? Wenn ja, dann wird Ihnen die Befehlsübersicht bei der Arbeit mit diesen Programmen sehr hilfreich sein.

Selbst für den eingefleischten Profi ist es fast unmöglich alle Befehle von Hypra-Ass, Reassembler und SMON zujeder Zeit parat zu haben. Um aber diese Programme optimal zu nutzen, ist die Kenntnis aller Befehle und deren Wirkungsweise sehr wichtig. Die nun folgende Befehlsübersicht soll Ihnen das ewige Nachschlagen ersparen. Natürlich kann es sich bei einer Übersicht nicht um eine ausführliche Anleitung handeln. Bei Verständnisschwierigkeiten finden Sie nähere Informationen an den entsprechenden Stellen in den Artikeln.

(ak)

TODO TABLES
