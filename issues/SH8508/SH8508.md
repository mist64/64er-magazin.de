
# Effektives Programmieren in Assembler [74-103]

> Es gibt viele Möglichkeiten, ein Basic-Programm schneller und komfortabler zu gestalten. Aber auch für die Assemblerprogrammierung gibt es einige Tricks und Kniffe, die wir Ihnen in diesem praxisnahen Kurs verraten wollen.

Wer das Optimum an Geschwindigkeit aus seinem Computer herausholen will, kommt an Maschinensprache nicht vorbei. Die Grundlagen zur Maschinenprogrammierung wurden bereits im Kurs »Assembler ist keine Alchimie«, den Sie in diesem Sonderheft finden, geschaffen. Das Thema dieses Artikels ist es nun, die Möglichkeiten von Maschinensprache optimal zu nutzen. Sie erfahren, wie man
a)	Programme beschleunigen und
b)	Speicherplatz sparen kann.
Dazu werden Ihnen eine Vielzahl von Programmiertechniken, Tips und Tricks vermittelt, die Ihnen die Programmierung erleichern.
1.	Beschleunigungen des Betriebssystems (in Assembler)
Der C 64 muß viele Aufgaben gleichzeitig erledigen: Bearbeiten des Hauptprogramms, Ablauf der Systeminterrupts und Senden des Video-Signals (an den Monitor/Fernseher). Alle diese Funktionen erfordern
-	viele Zugriffe auf den Datenbus des Prozessors
-	und dadurch Ausführungszeit.
Unser Grundproblem ist nun, wie wir den Computer dazu bewegen, diese Aufgaben nicht (oder nur teilweise) auszuführen.
a)	Eingriffe in den Systeminterrupt
Eine detaillierte Beschreibung des Systeminterruptsfinden Sie im bereits erwähnten Kurs »Assembler ist keine Alchimie«. Hier möchte ich nur zusammenfassen, wasim normalen Interrupt des Betriebssystems geschieht: 60 mal in der Sekunde wird das Hauptprogramm verlassen und die Routine ab $EA31 angesprungen. Ist diese abgearbeitet, wird wieder ins Hauptprogramm zurückgesprungen. Während dieser Unterbrechung (»interrupt«) tut sich einiges:
-	die RUN/STOP-Taste wird überprüft
-	die Tastatur und der Datasettenmotor werden abgefragt
-	das Cursorblinken wird erledigt
-	die interne Uhr (Tl$) wird gestellt.
Überlegen wir uns, welche Funktionen verzichtbar sind: Die RUN/STOP-Taste bewirkt nur in Basic-Programmen einen Abbruch, in Assembler müßte sie zum Beispiel über »JSR $FFE1« zusätzlich abgefragt werden. Die interne Uhr findet von Maschinensprache aus praktisch keine Verwendung. Kurz und gut, ein Maschinenprogramm kann auf beideFunk-tionen verzichten. Dies wird durch ein
LDA #$34
STA $0314
erreicht. Weil der Computer dadurch entlastet wird, läuft das Hauptprogramm etwas schneller ab.
Die Normaleinstellung erhält man mit
LDA #$31
STA $0314
Beschleunigungsmethode 1:
Trick: Verkürzung der Interrupt-Routine Nebenwirkungen: Abfrage der STOP-Taste und interne Uhr entfallen
Können Sie zwischenzeitlich auf die ganze Interrupt-Routine verzichten, genügt ein einziger Befehl:
SEI (»set Interrupt«)
Er verhindert grundsätzlich das Auftreten von Interrupts.
Die Normaleinstellung bewirkt:
CLI (»clear interrupt«)
Beschleunigungsmethode 2:
Trick: Interrupt total abschalten
Nebenwirkungen: Abfrage von Tastatur, STOP-Taste und Datasette, sowie Cursor und interne Uhr entfallen.
Es gibt aber noch eine Möglichkeit, im Zusammenhang mit dem Systeminterrupt: Von der Adresse $DC05, die als Zähler dient, hängtdie Anzahl der Interrupts (in der Regel 60 Aufrufe pro Sekunde) in einer bestimmten Zeit ab. Diese Adresse kann durch Schreibzugriff geändert werden. Schreibt man in $DC05 einen niedrigen Wert (im Extremfall 0), so werden sehr viele Interrupts ausgelöst. Dies macht sich in der Geschwindigkeit der Interrupt-Routine bemerkbar. Cursor undTastaturabfragewerdensehrschnell,dieinterneUhrgeht vor, und so weiter. Verwendet man eine eigene, eventuell zeitkritische Interrupt-Routine, kann sie auf diese Weise beschleunigt werden.
Dieser Geschwindigkeitszuwachs geht allerdings auf Kosten des Hauptprogramms, das stark verlangsamt wird. Bei wenigen Interrupts (große Zahl in $DC05) wird es beschleunigt. Die entsprechenden Assemblerbefehle lauten:
LDA #$FF
STA $DC05
um eine starke Beschleunigung zu bewirken.
Die Normaleinstellung wird durch
LDA #$3A
STA $DC05
erreicht.
Beschleunigungsmethode 3:
Trick: Anzahl der Interruptaufrufe pro Sekunde ändern Nebenwirkungen: Bei zu wenigen Aufrufen hinken Uhr, Cursor und Tastaturabfrage nach; bei zu vielen werden sie zu schnell.
b)	VIC-Register Nummer 17
Ist Ihnen schon bei Hypra-Load, beim Arbeiten mitder Datasette und einigen Kopierprogrammen aufgefallen, daß manchmal der Bildschirm abgeschaltet wird (ähnlich wie im FAST-Mode des C 128)? Dies kann man mit einem Vorhang vergleichen, der zwischenzeitlich den Bildschirm verdeckt. Der Bildschirm kann zwar nach wie vor (hinter dem Vorhang) geändert werden (PRINT-Anweisungen werden also ausgeführt), aber sichtbar wird die Wirkung erst, wenn der Vorhang entfernt wird.
74
iÄj1
C64
Kurs
Verantwortlich für das Ein-/Ausschalten des Bildschirms ist das VIC-Register Nummer 17:
Bit 4 gesetzt: Bildschirm wird angezeigt
Bit 4 gelöscht: Bildschirm wird abgeschaltet und nimmt Rahmenfarbe an.
Da wir die theoretischen Grundlagen haben, brauchen wir nur noch unser Wissen in Befehle umzusetzen:
Bildschirm abschalten:
LDA $D011 ($D011istVIC-Register#17)
AND #$EF ($EF = %111O1111)
STA $DO11	1
Bit4
In diesem Zustand arbeiten manche Kopierprogramme um zirka 15% schneller. Programme, dienichtaufexterneGeräte wie die Floppy zugreifen, laufen zirka 5% schneller ab. Bildschirm wieder einschalten:
LDA $D011
ORA#$10	($1O = %OOO1OOOO)
STA $DO11	1
Bit4
Dies ist der Normalzustand.
Beschleunigungsmethode 4:
Trick: Bildschirm abschalten
Nebenwirkungen: Der Bildschirminhalt ist nicht zu sehen, geht aber auch nicht verloren.
c)	Hinweise zum bisher Gesagten
Alle bis zu dieser Stelle genannten Tricks beziehen sich auf die Beschleunigung von Programmen. Sie lassen sich leicht nachträglich einfügen, weil am Programmalgorithmus keine Änderungen erforderlich sind.
Sie können das Abschalten des Bildschirms mit dem Abschalten oder Einschränken des Interrupts verknüpfen, um die Geschwindigkeit noch weiter zu erhöhen. Wenn Sie den Interruptganzabschalten (SEI), bringtes keinen zusätzlichen Gewinn, ihn einzuschränken oder die Zahl der Aufrufe zu ändern.
Beachten Sie bitte, daß alle beschriebenen Tricks durch RUN/STOP-RESTORE, einem Reset oder den Assemblerbefehl BRK rückgängig gemacht werden.
2.	Systembeschleunigungen in Basic
Hier erfahren Sie, wie sich die Systembeschleunigungen von Basic aus verwerten lassen. Die Nebenwirkungen bleiben allerdings diegleichen, wie unter 1. genannt.
a)	Interrupt einschränken
POKE788,52 verkürztdie Interrupt-Routine um das Abfragen der RUN/STOP-Taste und das Stellen von Tl$.
POKE 788,49 Normalzustand
In Basic ist das Ausfallen von RUN/STOP und Tl$ wesentlich störender als in Maschinensprache. Überprüfen Sie daher Ihre Programme auf Verwendung von Tl$ und fügen Sie den POKE erst nach (!) der Fertigstellung des Programms ein.
b)	Interrupt abschalten
POKE 56334,PEEK (56334) AND 254 schaltet den Interrupt ab,
POKE 56334,PEEK(56334) OR 1
schaltet ihn wieder ein. Dies geschieht dadurch, daß der Timer ab- beziehungsweise wieder eingeschaltet wird.
c)	Anzahl der Interrupt-Aufrufe ändern
POKE 56325,0: Extrem viele Interruptaufrufe
POKE 56325,255: Extrem wenige (daraus folgt:
Interrupt langsam, Basic-Programm schnell)
d)	Bildschirm abschalten
POKE 53265,PEEK(53265) AND 239
schaltet den Bildschirm ab.
POKE 53265,PEEK(53265) OR 16 schaltet ihn wieder ein.
An dieser Stelle sei noch einmal auf Punkt 1c hingewiesen, damit keine (vermeidbaren) Probleme auftreten.
Anhand von Listing 1 wollen wir uns nun mit der Anwendung der Systembeschleunigungen befassen. Dieses kleine Beispielprogramm, an dem Sie nach Herzenslust experimentieren können, versucht, mit Hilfe von Tl$ die Arbeitsdauer der Schleife (Zeile 150) zu messen.
Während des Ablaufs dieser Schleife, die kontinuierlich die Rahmenfarbe ändert, sollten Sie keine Taste drücken, um die Meßwerte nicht zu verfälschen.
Wenn Sie dies beachten, erhalten Sie folgende Werte:
1.	Normalzustand: 000003
2.	Verkürzter Interrupt: 000000
An der gemessenen Zeit können Sie erkennen, daß Tl$ abgeschaltet wurde.
3.	Häufige Interrupts: 000010
Aufgrund vieler Interrupt-Anforderungen wurde die Uhr Tl$ sehr oft erhöht.
4.	Seltene Interrupts: 000001
Da die IRQ-Routine nur selten durchlaufen wurde, ist Tl$ kaum weitergezählt worden.
5.	Bildschirm abgeschaltet: 000002
Nur bei diesem Punkt (und natürlich auch bei »1«) hat Tl$ volle Aussagekraft bezüglich der Ablaufzeit. An dieser Zeit können wir erkennen, daß durch das Abschalten des Bildschirms tatsächlich gegenüber »1« ein Zeitgewinn anfällt.
Bei den Punkten »3« und »4« wurde der Cursor eingeschaltet. Bei »3« (häufige Interrupts) ist er sehr schnell, bei »4« dagegen sehr langsam.
An Punkt »5« können Sie erkennen, daß bei abgeschaltetem Bildschirm der Hintergrund immer die Rahmenfarbe ($D020) annimmt, ohne daß wir die entsprechende Farbe ins Register$DO21 »POKEn«.
90 GOTO 200	<026>
100 REM	» UP -	SCHLEIFE	<<	<138>
110 :	<086>
120 PRINT" <TASTE>";:WAIT 198,l:PQKE 198,0 :FOR 1=1 TO	7:PRINT	CHR$(20);:NEXT	<221>
130 :	<106>
140 FOR	1=1 TO 100:NEXT	<122>
150 TIf="000000":FOR I = 0 TO 255:P0KE 532
80,1 AND 15:NEXT:PRINT TI*sRETURN	<205>
160 :	<136>
170 REM >> UP - CURSORBLINKEN	AUS	«	<206>
180 :	<156>
190 POKE 207,0:POKE 204,l:PRINT"	":RETURN <186>
200 REM------------------------------------------- <222>
210 REM — HAUPTPROGRAMM —	<045>
220 REM------------------------------------------- <242>
230 :	<206>
240 PRINT CHR$(147)"DEM0 FUER SYSTEMBESCHL
EUNIGUNGEN (BASIC)";	<061>
250 PRINT"-----------------------------------------
<127>
260 PRINT"<2D0WN}1) NORMALZUSTAND";:GOSUB
100	<033>
270 :	<248>
280 PRINT"<D0WN>2) VERKUERZTER INTERRUPT";
:POKE 788,52:G0SUB 100:POKE 788,49	<084>
290 :	<012>
300 PRINT"<DOWN}3) HAEUFIGE INTERRUPTS";:P
OKE 56325,20:POKE 204,0:GOSUB 100:GOSU B 170	<018>
310 :	<032>
320 PRINT"4) SELTENE<2SPACE}INTERRUPTS";:P OKE 56325,150:POKE 204,0:GOSUB 100:GOS UB 170	<113>
330 SYS 64931:REM	NORMALZUSTAND EIN	<253>
340 :	<062>
350 PRINT"5) BILDSCHIRM ABGESCHALTET ";:PO KE 53265,PEEK(53265) AND 239:G0SUB 140 <107>
360 POKE 53265,PEEK(53265) OR 16sPRINT"<D0 WNJ** ENDE **"	<066>
© 64'er
Listing 1. Systembeschleunigungen in Basic

75
Kurs
C64
3.	Optimierung der Bildschirmausgabe
Ohne die Bildschirmausgabe kommt kein Programm aus, aber oft kostet sie unnötig viel Rechenzeit. Der Grund ist hier nicht beim Betriebssystem zu suchen, sondern bei umständlicher Programmierung. Diese wiederum ist auf mangelndes Know-how zurückzuführen, welches wir nun ändern wollen.
In der Regel wird zur Ausgabe eines Zeichens dieses in den Akku geladen und die Routine BASOUT ($FFD2) aufgerufen. Veranschaulichen wir uns einmal die Arbeitsweise von BASOUT: Das Betriebssystem prüft bei jedem Zeichen, ob es sich um einen Buchstaben oder ein Steuerzeichen, zum Beispiel »Bildschirm löschen« handelt. Buchstaben werden in den Bildschirmcode umgewandelt und ins Bildschirm-RAM ab $0400 geschrieben.
FürSteuerzeichen existierenjeweilsUnterroutinendiezum Beispiel eine Leerzeile einfügen, den Bildschirm löschen oder ähnliches.
Diese aufwendige Überprüfung verlangsamt die Bildschirmausgabe erheblich. BASOUT läßt sich zwar geringfügig beschleunigen, indem man stattbei $FFD2 (Kerneleinsprung) bei $E716 einsteigt, aber es geht noch schneller:
a)	Bildschirm löschen
Langsam:
LDA #$93 $93 = 147 = Codefür»Bildschirm löschen«, entspricht PRINT CHR$(147)
JSR$FFD2 (oder$E176)
Schnell:
JSR $E544 (Routine für »Bildschirm löschen«) b) Cursor in Home-Position (linke obere Ecke) Langsam:
LDA #$13 ; $13 = Code für »Cursor Home«
JSR$FFD2 (oder$E176)
Schnell:
JSR $E566 (Routine für »Cursor Home«)
c)	Cursor-Positionierung
Langsam:
Senden von Steuerzeichen (CRSR DOWN, UP und so weiter) über BASOUT.
Schnell:
LDX #Zeile
LDY #Spalte
JSR $E50C (Cursorposition setzen)
d)	Textausgabe
Unkomfortable Lösung:
Senden von Zeichen (Buchstaben, Grafikzeichen) über BASOUT.
Eine solche Schleife finden Sie in Listing 2, Zeilen 148 -220 und 320 - 330. Nach dem Start durch »SYS 49152« gibt Listing 2 zweimal hintereinander den Text »DAS IST DER TEXT« aus. Das erste Mal wird der Text über eine BASOUT-Schleife gedrückt, beim zweiten Mal nimmt das Programm die Komfortable Lösung:
Ab der Adresse »TEXT« muß der Text (in ASCII-Darstellung) stehen, in dem keine Anführungszeichen vorkommen dürfen. Am Ende des Textes muß $00 als Endmarkierung zu finden sein. Die Ausgabe erfolgt dann über
LDA # < (TEXT) Low-Byte der Adresse
LDY#>(TEXT) High-Byte
JSR $AB1E
Die Routine $AB1E wird fortan als »STROUT« (STRing-OUTput = String-Ausgabe) bezeichnet. STROUT ist zwar etwas langsamer als BASOUT; dafür erlaubt die komfortable Parameterübergabe eine wesentlich bequemere Programmierung, wie Sie am zweiten Teil von Listing 2 (Zeilen 260 -300, 320 - 330) sehen können. Mit nur drei Befehlen wird der Text ausgegeben!
Beschleunigungsmethode 5. Zusammenfassung der bisherigen Alternativen	
zu BASOUT: CLEAR HOME:	JSR $E544
CURSOR HOME:	JSR$E566
Cursorpositionierung:	LDX #Zeile LDY #Spalte JSR $E50C
Textausgabe:	Text ab TEXT ablegen (wie Listing 2, Zeile 320 - 330) LDA # < (TEXT) LDY #>(TEXT) JSR $AB1E
Alle diese Verfahren sind nicht nur schnell, sondern auch	
speicherplatzsparend.	
Eine Anwendung von (fast) allen Routinen aus der Beschleunigungsmethode 5 zeigt Listing 3.
100
110
120
130
140
150
160
170
180
190
200
210
220
230
240
250
260
270
280
290
300
310
320
330
-.LI 1,3,0
—; TEXTAUSGABE (UEBER BASOUT)
-.BA $C000 ; START: SYS 49152
-.GL BASOUT = $FFD2
LDX #0
-SCHLEIFE	LDA	TEXT,X	;	ZEICHEN LESEN
INX JSR	BASOUT	;	UND AUSGEBEN
BNE	SCHLEIFE	;	SCHON ENDMARKIERUNG?
-; TEXTAUSGABE (UEBER STROUT)
-.GL STROUT = $ABlE
LDA #<(TEXT) ; LOW-BYTE IN AKKU LDY #>(TEXT) ; HIGH-BYTE IN Y JMP STROUT ; TEXTAUSGABE UND ENDE
-TEXT	.TX "DAS IST DER TEXT!"
-.BY 0 ; ENDMARKIERUNG DES TEXTES
SEARCHING FOR $$
100
110
120
130
140
150
160
170
180
190
200
210
220
230
240
250
260
270
280
290
300
310
320
LI 1,3,0
TEXTAUSGABE (UEBER STROUT)
BA
GL GL GL
GL GL
$C000
STROUT CURSOR CLRSCR
ZEILE SPALTE
-TEXT -.BY 0
START: SYS 49152
$ABlE $E50C $E544
12
10
JSR LDX LDY JSR LDA LDY JMP
TX
BILDSCHIRM LOESCHEN
CLRSCR #ZEILE #SPALTE CURSOR #<(TEXT) #>(TEXT) STROUT
"DAS IST
= PRINT CHR$(147) ZEILE IN X SPALTE IN Y CURSOR SETZEN LOW-BYTE IN AKKU HIGH-BYTE IN Y TEXTAUSGABE & ENDE
DER TEXT!"
ENDMARKIERUNG FUER STROUT
Listing 2. Die unkomfortable Lösung, einen Text auszugeben
Listing 3. Die komfortable Lösung einen Text auszugeben
76
C64
Kurs
Der Bildschirm wird getöscht und in Zeile 12 ab Spalte 10 ein Text ausgegeben. Auch in diesem Programm sollten Sie zur Übung etwas experimentieren!
e)	Kopieren des Textes in den Bildschirmspeicher
Dies ist die schnellste Methode: Der Text wird in den Bildschirmspeicher kopiert. Die lange Umwandlung entfälltvöllig, da der Text als fertiger Bildschirmcode im Speicher abgelegt wird. Wenn einige Kopfzeilen (zum Beispiel mit Copyright-Vermerken) an verschiedenen Stellen ausgegeben werden sollen, ist es ratsam, ein kleines Unterprogramm zu erstellen. Dieses schreibt dann die Kopfzeilen direkt in den Bildschirmspeicher, ohne die aktuelle Cursor-Position zu beeinflussen.
Eines müssen Sie aber unbedingt beachten: Die Farbgebung ist nur durch Ändern des Farb-RAMs möglich.
Eine Tabelle der Bildschirmcodes finden Sie übrigens im Anhang des C 64-Handbuchs und am Schluß dieser Ausgabe.
Beschäftigen wir uns nun mit Listing 4:
Dieses Programm entspricht in der Wirkung Listing 3, gibt den Text jedoch nicht über die Betriebssystem-Routinen CURSOR und STROUT aus, sondern schreibt ihn direkt in den Bildschirm.
In den Zeilen 310 - 320 steht der Bildschirmcode des Textes.
Zurück zur Routine STROUT: Diese Routine arbeitet, da sie sich auf die BASOUT-Routine stützt, auch mit Peripheriegeräten wie Floppy und Drucker, wenn diese über dem CMD-Befehl als Ausgabegeräte definiert wurden. In »Assembler ist keine Alchimie« wurde gezeigt, wie man mit der BASOUT-Routinedie Drucker-Ausgabebetreibt. Dortwurdenallewich-tigen Routinen bis ins Detail beschrieben.
Listing 5 gibt einen Text zuerst auf dem Drucker und dann auf dem Bildschirm aus. Daran soll außer dem Druckerbetrieb auch gezeigt werden, wie man die Parameterübergabe an STROUT als Makro (Zeilen 230 - 270) definiert und sich somit einen bequemen Ausgabe-Befehl schafft.
4.	Unterprogramme
Ohne die Unterprogramm-Befehle JSR und RTS kommt fast kein Maschinenprogramm aus. Es ist allerdings ziemlich unbekannt, daß beide Befehle das Programm starkverlangsa-men. Grund genug für uns, JSR und RTS näher zu betrachten:
Trifft der Prozessor auf JSR, schiebt er den aktuellen Programmzähler plus 2 (= Rücksprungadresse - 1) auf den Stack und springt dann zu der Adresse, die hinter JSR steht. Trifft er auf RTS, holt er die Adresse vom Stapel zurück, erhöht sie um 1 und verwendet sie wieder als Programmzähler.
Bemerkenswert ist, daß die Zugriffe auf den Stapel sich in keiner Weise von den Zugriffen über die Befehle PHA und PLA unterscheiden. Daher muß jedesmal der Stapelzeiger neu errechnet werden. Diese vielen Operationen sind schuld daran, daß JSR und RTS so langsam sind.
Da wir das Problem erkannt haben, können wir damit beginnen, unser Wissen anzuwenden.
a)	Unterprogrammverschachtelung
Stellen wir uns folgendes Beispiel vor: ein Hauptprogramm ruft das Unterprogramm 1 auf. Dieses ruft an seinem Ende das Unterprogramm 2 auf, um dann mit RTS ins Hauptprogramm zurückzukehren.
Alles ziemlich schwierig, oder?
Deshalb gehen wirmit Hilfe einerGrafikvor: In Bild 1 sehen Sie ein Flußdiagramm nach obigem Aufbau. In der Beschriftung soll »Code« nicht »Kennwort« bedeuten, sondern heißt einfach »Befehlsnummer«.
Wie an den Pfeilen zu erkennen ist, werden zwei RTS-Befehle hintereinander abgearbeitet (von Unterprogramm 2 nach Unterprogramm 1 und von dort zum Hauptprogramm).
100 -.LI 1,3,0
110 -;
120 -J TEXT IN VIDEO-RAM SCHREIBEN
130	-5
140 -.BA $C000 ; START: SYS 49152
150 -;
180 -.BL CLRSCR = $E544 ; BILDSCHIRM LOESCHEN
190 -;
200 -.GL ZEILE = 12
210 -.GL SPALTE = 10
220 -;
230 -.GL VIDEORAM = 1024 ; BILDSCHIRMSPEICHER
240 -.GL ADRESSE = VIDEORAM + (40*ZEILE) + SPALTE
250 -;
255	-	JSR	CLRSCR	;	= PRINT CHR$(147)
260	-	LDX	#0
270	-SCHLEIFE LDA	TEXT,X	;	BILDSCHIRMCODE	LESEN
280	-	BEQ	ENDE	;	=0, DANN ENDE
290 -	STA ADRESSE,X ; IN BILDSCHIRMSPEICHER
295	-	INX
296	-	JMP	SCHLEIFE	;	NAECHSTES	ZEICHEN
300	-ENDE	RTS
305	-;
310	-TEXT	.BY	4,1,19,“	",9,19,20,"	"
311	-.BY4,5,18," ",20,5,24,20,"!"
320 -.BY 0 ; ENDMARKIERUNG DES TEXTES
Listing 4. Die schnellste Lösung, einen Text auszugeben
100	-.LI	1,3,0	
110			
120	-; DRUCKER-AUSGABE MIT		
130	-; DER STROUT-ROUTINE		
140			
150	— -GL	STROUT = $ABlE	
160	-.GL	SETNAM = $FFBD ;	DIE BEDEUTUNG
170	-.BL	SETLFS = $FFBA ;	DIESER ROUTINEN
180	“.GL	OPEN = $FFC0 ;	ENTNEHMEN SIE
190	-.GL	CHKOUT = $FFC9 ;	BITTE DEM KURS
200	-.GL	CLRCHN = $FFCC ;	"ASSEMBLER IST
210	-.GL	CLOSE = $FFC3 ;	KEINE ALCHIMIE"
220			
230	-.MA	PRINT (ADRESSE)	
240		LDA #<(ADRESSE)	
250	—	LDY #>(ADRESSE)	
260	—	JSR STROUT	
270	-.RT		
280			
290	“.BA	$C000 ; START: SYS 49152	
300			
310		LDA #0	; KEINEN
320		JSR SETNAM	; FILENAMEN
330			
340		LDA #4	5 LOG. FILENUMMER =4
350		TAX	; GERAETEADRESSE 4
360		LDY #0	; SEKUNDAERADRESSE 0
370		JSR SETLFS	; PARAMETER SETZEN
380			
390	—	JSR OPEN	; FILE OEFFNEN
400			
410		LDX #4	; FILENUMMER 4
420	—	JSR CHKOUT	; AUSGABE AUF DRUCKER LENKEN
430			
440	-...PRINT (TEXT) ; TEXT AUSGEBEN		
450			
460		JSR CLRCHN	; WIEDER BILDSCHIRMAUSGABE
470			
480	-...PRINT (TEXT) ; JETZT AUF BILDSCHIRM		
490	5		
500	—	LDA #4	; LOG. FILENUMMER 4
510	—	JMP CLOSE	; FILE SCHLIESSEN
520		PROGRAMM BEENDEN	
530	—:		
540	—TEXT	.TX "DIESER	! TEXT WIRD AUF"
550	-.TX	" DEN DRUCKER AUSGEGEBEN !"	
560	-.BY	13,13,13,0 ; 3 *	CAR.RETURN
Listing 5. So gibt man Text auf dem Drucker aus
77
Kurs
C64
Dies ist immer ein Indiz dafür, daß das Programm noch optimiert werden kann.
Eine »Übersetzung« von Bild 1 in Assembler ist Listing 6: Wenn Sie dieses über »SYS 49152« starten, ist aus den ausgegebenen Texten ersichtlich, welcher Programmteil wann abgearbeitet wird.
Sobald Sie die Strukturvon Bild 1 beziehungsweise Listing 6 verstanden haben, können wir uns mit der optimierten Form befassen, die in Bild 2 beziehungsweise Listing 7 zu finden ist.
Hier wird das ehemalige Unterprogramm 2 ans Ende von Unterprogramm 1 gehängt (wobei es ebenfalls über JMP UP2 angesprungen werden könnte). Auf diese Weise muß es nicht über JSR aufgerufen werden, was auch einen RTS-Befehl überflüssig macht.
Trotz dieser Änderung kann das Unterprogramm 2 auch weiterhin als Unterprogramm aufgerufen werden, da bei JSR UP2 die CPU auf einen RTS-Befehl trifft (Bild 2).
In Listing 7 muß noch der JMP-Befehl in Zeile 480 erläutert werden:
Dort muß nichtJSR STROUT:RTS stehen, weil am Ende der STROUT-Routine im ROM ohnehin ein RTS steht. Deshalb benötigt unser Programm keinen eigenen RTS-Befehl zur Rückkehr ins Hauptprogramm.
Die folgende Regel gilt für Aufrufe von Betriebssystemroutinen:
^ Hauptprogramm
Unterprogramm 1
Code des Hauptprogramms
Code des früheren Unterprogramms 2
Code von Unterprogramm 1
restlicher Code des Hauptprogramms
^ Programmende ^
Bild 2. Der optimierte Algorithmus zur Verschachtelung von Unterprogrammen
Einsprungpunkt, wenn Unterprogramm 2 einzeln aufgerufen werden soll (also: ohne daß der Code von Unterprogramm 1 ausgeführt wird)
JSR $XXXX	entspricht	JMP $XXXX
RTS			
Voraussetzung ist, daß im Unterprogramm ab $XXXX keine Stapelmanipulation erfolgt, wie sie gleich beschrieben wird. Das geschilderte Verfahren zur Unterprogrammverschachte-
100	-.LI 1,3,0	
110	-.BA $C000	5 START: SYS 49152
120		
130	-; UNTERPROGRAMMVERSCHACHTELUNG	
140	-■ (OPTIMIERTE ASSEMBLERVERSION)	
150		
160	-.GL STROUT = $ABlE	
170		
180	-.MA PRINT	(ADRESSE)
190	—	LDA #<(ADRESSE)
200	—	LDY #>(ADRESSE)
210	—	JSR STROUT
220	-.RT	
230		
240	_.				 HAUPTPROGRAMM
250	— -	
260	-...PRINT	(TEXT1)
270	—:	
280	—	JSR UP1
290	— -	t AUFRUF VON UNTERPROGRAMM 1
300	— :	
310	-...PRINT	(TEXT2)
320	— -	
330	—	JMP $A474	; WARMSTART
340		
350		
360			 UNTERPROGRAMM 1
370		
380	-UP1	NOP	; BELIEBIGER CODE
390	-...PRINT	(TEXT3)
400	—:	
410		
420	— -	
430	_.				 CODE VON UNTERPROGRAMM 2
440		
450	-UP2	NOP	; BELIEBIGER CODE
460	—	LDA #<(TEXT4) ; LOW-BYTE
470	—	LDY #>(TEXT4)	; HIGH-BYTE
480	—	JMP STROUT	5 TEXTAUSGABE
490	-; UND RUECKSPRUNG VOM UNTERPROGRAMM,	
500	—5 WEIL AM	ENDE DER STROUT-ROUTINE
510	—; EIN RTS	-BEFEHL STEHT.
100 -.LI 1,3,0
10000-;
10010-;
10020-; ---------------TEXTE
10030-;
10040-TEXT1 .TX "HIER IST DAS HAUPTPROGRAMM."
10050-.BY 13,13 ; 1 LEERZEILE
10060-.BY 0 ; ENDMARKIERUNG
10070-;
10080-TEXT2 .TX "HIER IST WIEDER DAS HAUPTPROGRAMM." 10090-.BY 13,13,0 10100—5
10110-TEXT3 .TX "HIER IST DAS UNTERPROGRAMM 1." 10120-.BY 13,13,0 10130-;
10140-TEXT4 .TX "HIER IST DAS UNTERPROGRAMM 2." 10150-.BY 13,13,0
Listing 6. Die umständliche Methode, Unterroutinen aufzurufen
110 -.BA $C000 ; START: SYS 49152
120 -;
130	-; UNTERPROGRAMMVERSCHACHTELUNG IN ASSEMBLER
140	-;
150 -.GL STROUT = *ABlE
160	-;
170	-.MA PRINT (ADRESSE)
180	-	LDA	#<(ADRESSE)
190	-	LDY	#>(ADRESSE)
200	-	JSR	STROUT
210 -.RT
220	-;
230	-; ----------------HAUPTPROGRAMM
240	-;
250 -...PRINT (TEXT1)
260	-;
270 -	JSR UP1
280 —;	T AUFRUF VON UNTERPROGRAMM 1
290	-;
300 -...PRINT (TEXT2)
310	-;
320	-	JMP $A474	; WARMSTART
330	—5
340	-;
350	-; ---------------UNTERPROGRAMM 1
360	-;
365 -UP1	NOP	; BELIEBIGER CODE
370 -...PRINT (TEXT3)
380	-;
390 -	JSR UP2
400 —5	t AUFRUF VON UNTERPROGRAMM 2
410	—5
420 -	RTS	; UP1 VERLASSEN
430 — 5
440	-;
450	-; ---------------UNTERPROGRAMM 2
460	—5
465 -UP2	NOP	; BELIEBIGER CODE
470 -...PRINT (TEXT4)
480	-;
490	-	RTS	? UP2 VERLASSEN
500 -;
10000-;
10010-; ---------------TEXTE
10020-;
10030-TEXT1 .TX "HIER IST DAS HAUPTPROGRAMM."
10040-.BY 13,13 ; 1 LEERZEILE
10050-.BY 0 ; ENDMARKIERUNG 10060-;
10070-TEXT2 .TX "HIER IST WIEDER DAS HAUPTPROGRAMM." 10080-.BY 13,13,0 10090-;
10100-TEXT3 .TX "HIER IST DAS UNTERPROGRAMM 1."
10110-.BY 13,13,0
10120—5
10130-TEXT4 .TX "HIER IST DAS UNTERPROGRAMM 2."
10140-.BY 13,13,0
Listing 7. Die optimierte Methode, Unterroutinen aufzurufen
78

C64
Kurs
lung und die entsprechenden Regeln können Sie dann auf jede (!) Programmiersprache übertragen.
b)	Stapelmanipulation
Wenn Sie »Exbasic Level II« kennen, wissen Sie sicher den Befehl »DISPOSE RETURN« zu schätzen. Er dient dazu, ein Unterprogramm ohne RETURN abzuschließen. Dadurch kann dieses zum Beispiel über GOTO verlassen werden.
In Assembler ist dies auch möglich. Die Befehlseingabe PLA
PLA
entspricht in der Wirkung »DISPOSE RETURN«.
Da die Rücksprungadresse auf den Stapel abgelegt wird und dort 2 Byte in Anspruch nimmt, kann sie über PLA:PLA wieder vom Stapel geholt werden. Ein Unterprogramm ist nach PLA:PLA eigentlich kein Unterprogramm mehr, sondern Bestandteil des aufrufenden Programms. PLA:PLA findet vor allem in der Fehlerbehandlung Anwendung. An einem späteren Listing werden wir dies noch sehen. Nach PLA:PLA kann ein Unterprogramm über JMP verlassen werden. Dies machen wir uns zunutze, um den Rücksprung an eine beliebige Adresse zu simulieren. Dies ist sonst nicht möglich, da bei RTS immer hinter den Befehl gesprungen wird, der das Unterprogramm aufgerufen hat.
Ein RTS an eine beliebige Adresse müßte »RTS XXXX« heißen, doch diesen Befehl gibt es beim 6510 nicht. So wird er aber simuliert:
PLA	;	holt Rücksprungadresse
PLA	;	vom Stapel und
JMP $XXXX	; springt nach $XXXX
So sieht ein Makro dazu aus:
-.MA RTS (RUECKSPRUNGADRESSE)
PLA PLA JMP RUECKSPRUNGADRESSE
-.RT
Und noch ein Mangel der Unterprogrammbefehle soll beseitigt werden: Obwohl es JMP (indirekt) gibt, kennt der 6510 keinen Befehl wie JSR (indirekt); über Stapelmanipulation ist dies dennoch möglich (siehe dazu auch im 64’er, Ausgabe 1/86: Assembler-Bedienung leicht gemacht).
Nehmen wir an, im Vektor $14/$15 steht die Adresse $C000. Nun soll über den $14/$15-Vektor ein Unterprogramm aufgerufen werden (also das ab $C000). Bild 3 zeigt, was im einzelnen geschehen muß.
Die Rücksprungadresse steht zwar in Bild 3 direkt hinter dem JMP ($0014)-Befehl, kann aber auch anderswo im Programm stehen.
Folgendes Makro ermöglicht die Simulation von JSR (indirekt):
-. MAJSRIND(VEKTOR, RUECKSPRUNGADRESSE) LDA # > (RUECKSPRUNGADRESSE-1) PHA
LDA # < (RUECKSPRUNGADRESSE-1) PHA
JMP (VEKTOR)
-. RT
Diese Simulation von JSR ($XXXX) verwendet auch der SYS-Befehl (disassemblieren Sie von $E12A bis $E155 und betrachten Sie dazu Bild 3).
Zuerst holt er die Zahl nach SYS in die Adressen $14/$15, dann legt er die Rücksprungadresse ($E147) -1 auf dem Stack ab. Nun holt er die Register P, A, X, Y aus den Adressen $030F, $030C, $030D, $030E. Es folgt ein indirekter Sprung über $0014/$0015.
Nach dem Rücksprung werden die Register wieder im Speicher dort abgelegt, woher sie genommen wurden und ein Sprung ins Basic wird durchgeführt.
Später werden wir noch eine weitere Möglichkeit für JSR
verzweigt dorthin
Bild 3. Der Algorithmus, um einen JSR (indirekt^ Befehl zu simulieren
(ind) kennenlernen, die aber nicht auf Stapelmanipulation beruht.
c)	Vergleich zwischen Unterprogramm und Makro bezüglich Geschwindigkeit
Wenn Sie den Hypra-Ass (oder einen anderen Makro-Assembler) besitzen, haben Sie die Möglichkeit, Befehlsfolgen als Makros zu definieren. Makros sind deswegen so beliebt, wei! sie den größten Vorteil von Unterprogrammen bieten, nämlich Übersichtlichkeit. Da Makros aber wie »normale« Befehle im Speicher stehen, entfällt der Aufruf über JSR und RTS. Dies ist der Grund, weshalb Makros etwas schneller (wenige Taktzyklen) als Unterprogramme sind. Das Problem, wann Makros und wann Unterprogramme vorteilhaft sind, wird später noch aufgegriffen.
5.	Tabellen
lm allgemeinen Sprachgebrauch werden Tabellen als »geordnete Zusammenstellungen von Daten« verstanden. Diese Funktion haben sie auch in Computerprogrammen, wo man sie daran erkennt, daß Tabellen keinen Befehlscharakter haben.
SMON-Benutzer können mit »FT« ein Programm nach Tabellen durchsuchen lassen; dann sucht SMON im Programm nach Bytes, die nicht zu Maschinensprachebefehlen gehören.
Wozu werden nun Tabellen verwendet?
In der Regel dienen Tabellen einem Computerprogramm als »elektronischer Rechenschieber«. So wie das Kopfrechnen durch einen Rechenschieber ersetzt werden kann, weil man nur in einer geordneten Zusammenstellung von Ergebnissen das richtige suchen muß, kann ein Programm aus seinen Tabellen denselben Nutzen ziehen: die Berechnungen entfallen, die Programmierung wird einfacher.

79
Kurs
C64
Aus den weniger erforderlichen Berechnungen entsteht ein deutlicher Geschwindigkeitszuwachs, der Hauptvorteil von Tabellen. Wie man Tabellen einsetzt, erfahren Sie im folgenden.
a)	Tabellen aus Rechenergebnissen
Noch einmal zum Rechenschieber. Es geht beim Kopfrechnen viel schneller, 4x10 auszurechnen als 4x7. Bei einem Rechenschieber besteht kaum ein Unterschied in der »Rechenzeit«.
Dementsprechend existiert fast kein Algorithmus, dessen Ausführungszeit bei unterschiedlichen Parametern immer gleich bliebe. Wer den Artikel »Dem Klang auf der Spur (5)« (64’er, Ausgabe 5/85, Seite 152 ff.) gelesen hat, weiß, welch grobe Differenzen bei Multiplikationen auftreten können.
Ersetzt (beziehungsweise unterstützt) man einen Algorithmus durch eine Multiplikationstabelle, fällt eine einheitlichere (und kürzere) Ausführungszeit an.
Für das Rechnen mit einzelnen Bits in einem Byte werden oft die Zweierpotenzen benötigt; es empfiehlt sich, diese als Tabelle anzulegen:
1000 -; Zweierpotenzen als Tabellle
1010 -; im DOS der Floppy 1541 ab $EFE9
1020 -; zu finden
1030 -; ZWEIPOT.BY2tO, 2t1, 2t2, 2t3, 2t4, 2t5, 2t6, 2t7
Folgende Unterroutine legt im Akkumulator den Wert 2tA ab, wobei mit A der Inhalt des Akkumulators bei Aufruf der Routine gemeint ist:
10000 -;
10010 -; SubroutinezurBerechnungvon
10020 -; 21A(ErgebniskommtindenAkku)
10030 -;
10040 - TAX ; Akku in Indexregister
10050 - LDAZWEIPOT,X;ausTabelleeinlesen
10060 - RTS ; Das war’s schon! Wer ein schnelleres und zugleich so einfaches Verfahren kennt, möge sich melden...
10070 - ZWEIPOT
.BY2t0,2t1,2t2,2t3,2t4,2t5,2t6,2t7
Wenn A größerals 7 ist, liefert das Programm falsche Werte. Sie können es noch erweitern, wenn Sie es für nötig halten.
108 110	-.LI 1,3,0 -.BA $C000 ; START: SYS 49152	
120 130	-; RECHNUNG MIT FLIESSKOMMAWERTEN	
140 150 160 170 180 190 200	-.GL MEMFAC = $BBA2 -.GL FACOUT = $AABC -.GL SQRFAC = $BF71 -.GL LOGNAT = $B9EA -.MA HOLE (ADRESSE) ; MAKRO-DEF.	
210	LDA #<(ADRESSE);	HOLT MFLPT-ZAHL
220	LDY #>(ADRESSE);	VON ADRESSE IN
230	JSR MEMFAC	;	DEN FAC
240 250 260 270 280 290	-.RT -...HOLE (BSPZAHL) JSR FACOUT	;	AUSDRUCKEN
300 310 320 330	-...HOLE (BSPZAHL) JSR SQRFAC	;	QUADRATWURZEL
340 350	JSR FACOUT	;	AUSDRUCKEN
360 370 380 390	-...HOLE (BSPZAHL) JSR LOGNAT	;	LOGARITHMUS NATURALIS
400 410	JMP FACOUT	;	AUSDRUCKEN
500 510 520 530 540	—; BEISPIELZAHL 1.23456 —; IM MFLPT-FORMAT -BSPZAHL .BY $Bl,$lE,$06,	$0F,TE5
550	—; Listing8. Fließkommazahlen in Assembler verarbeiten		
b)	Tabellen aus Fließkommawerten
Zu den zeitraubendsten Operationen gehörtdie Rechnung mit Fließkommazahlen. Daß diese selbst in Maschinenprogrammen lähmend wirkt, sehen Sie am HiRes-3-Befehl »FUNKT« (64’er, Ausgabe 3/85, Grafikkurs-Anwendung). Daher sollte man nurdann auf die Fließkommaroutinen zugreifen, wenn es unvermeidbar ist. Berechnen Sie soviele Werte wie möglich voraus, hierfür eignet sich der Direktmodus des Basic-Interpreters besonders gut! Wie Sie einen auf diese Weise berechneten Wert ins MFLPT-(Floating Point)Format umwandeln können, zeigt Ihnen der folgende Kasten.
Verfahren zur Umwandlung einer Zahl ins MFLPT-Format
1.	SMON (oder anderen Monitor) laden
2.	RESET auslösen oder NEW eingeben
3.	»XX = Fließkommazahl« eingeben, zum Beispiel »XX = 1.23456«
4.	Monitor starten (SYS 49152)
5.	»M 0805 0809« eingeben
Sie sehen nun in den Adressen $0805 - $0809 die MFLPT-Darstellung der Zahl, mit der Sie die Variable XX belegt haben.
Damit wir uns unter Zuhilfenahme präziser Fachausdrücke und Abkürzungen verständigen können, sollten Sie den Abschnitt in »Assembler ist keine Alchimie« aufmerksam lesen, der sich mit Fließkommazahlen befaßt. Nach dem Studium dieses Abschnitts sollten Ihnen Begriffe wie »MFLPT«, »FAC« oder »ARG« geläufig sein.
Im Falle der Zahl 1.23456 erhalten wir als Ergebnis: :0805 81 1E06 0FE5...
Diese Werte legen wir folgendermaßen als Tabelle ab:
540 -BSPZAHL .BY $81, $1E, $06, $0F, $E5
Wie wir nun diese Zahl verarbeiten, zeigt Ihnen Listing 8. Das Makro (200 - 240) stützt sich auf die Interpreter-Routine MEMFAC, die eine Zahl (Adresse wird in Akku/Y-Register übergeben) vom Speicherformat MFLPT in den FAC als FLPT-Zahl schreibt und dabei die erforderliche MFLPT-—FLPT-Umwandlung durchführt.
In der Tabelle in Zeile 540 können Sie beliebige Fließkommawerte (sofern Sie diese wie angegeben berechnet haben) einsetzen, das Programm rechnet dann mit der jeweiligen Fließkommazahl, die ab BSPZAHL im MFLPT-Format steht.
Diese Zahl wird zunächst nur in den FAC geladen und der FAC wird dann ausgedruckt (270 - 290), dann wird die Zahl wieder geholt, die Wurzel berechnet und ausgegeben (310-350). Schließlich wird die Zahl wieder in den FAC geholt, der natürliche Logarithmus errechnet und auch ausgegeben (370-410).
Zur Routine FACOUT sind, außer daß sie den Inhalt des FAC ausgibt, noch zwei Bemerkungen zu machen:
1.	Nach der Zahl wird noch ein CARRIAGE RETURN ausgegeben.
2.	Nach dem Aufruf von FACOUT hat sich der Inhalt des FAC aufgrund mehrerer Divisionen durch Zehnerpotenzen verändert.
Auf das Thema »Fließkommaarithmetik« geht Texteinschub 1 noch näher ein. Dort werden auch weitere Interpreter-Routinen vorgestellt.
c)	Sprungtabelle
Beim Thema »Unterprogramme« wurde Ihnen eine Methode vorgestellt, um JSR (ind) zu simulieren. Diese erweistsich in Verbindung mit einerTabelle, in der die Sprungadressen gespeichert sind, als sehr nützlich. So kann beispielsweise eine Parallele zum Basic-Befehl ON...GOSUB ZIEL1,ZIEL2.... geschaffen werden.
80
C64
Kurs
Ein Beispiel: Wenn der Basic-Interpreter auf einen Basic-Befehl trifft, holt er aus der Tabelle $AOOC - $A09D die Adresse der zugehörigen Routine. Diese springt er dann durch Stapelmanipulation an.
Der SMON arbeitet genauso: Seine Sprungtabelle liegt im Bereich $C02B - $C06B.
Die Anwendung von Sprungtabellen werden wir noch ausführlich im folgenden Abschnitt d) sowie bei der Besprechung von Listing 11 behandeln.
d)	Vergleichstabellen
Weder der SMON noch der Basic-Interpreter benutzen zum Suchen der zum jeweiligen Befehl gehörenden Routine eine Reihe von CMP-Abfragen mit BRANCH-Befehlen. Auch für die Vergleichswerte (in diesem Fall die Befehlswörter) gibt es eine Tabelle: Beim SMON liegt sie im Bereich $COOB -$C02A, beim Basic-Interpreter $A09E - $A327.
Sprung- und Vergleichstabellen sind in gleicher Befehlsfolge angeordnet; wird der Befehl an einer bestimmten Stelle in der Vergleichstabelle gefunden, erfolgt ein Sprung an die Adresse, die an gleicher Stelle in der Sprungtabelle steht. So sehen die Befehls- und Vergleichstabellen im SMON aus:
Spalte Nr. Befehl Sprungadr. $	1 / CADB	2 # C920	3 $ C908	4 % C91C	
Die Sprungadressen sind wegen der Stapelmanipulation in derTabelleab $C02B um 1 dekrementiertgespeichert; in der Darstellung sehen Sie aber das tatsächliche Sprungziel.
Wir werden jetzt anhand des SMON die Verwendung einer Vergleichs-Sprungtabelle in Assembler erläutern.
Wenn wir die zum Befehl » # « gehörende Sprungadresse finden wollen, gehen wir folgendermaßen vor:
1.	Wir suchen in Reihe 2 das # -Zeichen.
2.	Wir gehen (in derselben Spalte) eine Reihe nach unten und finden dort die Sprungadresse ($C92C).
Der Computer hat nicht die Möglichkeit, direkt eine Reihe weiter unten die Suche fortzusetzen. Er muß einen Umweg wählen und sich die Spalte merken. Ein Beispiel:
1.	Der SMON sucht unter den Elementen aus Reihe 2 das »#«. In einem Zähler merkt er sich die Spalte, in der der Befehl gefunden wurde.
2.	Nun sucht er in Reihe 3 in der Spalte, die im Zähler steht, die zugehörige Sprungadresse.
Wie ähnlich beide Suchvorgänge sind, erkennen Sie daran, daßjedesmal die Hauptschritte 1. und 2. vorkommen.
Nach so viel Theorie sehen wir uns nun umso ausführlicher die Routine im SMON an, die für die Steuerung der Vergleichs-Befehlstabelle verantwortlich ist. Dazu können Sie »D C303 C323« eingeben.
Bei Adresse $C303 steht im Akku der ASCII-Code des Kommandos, das der SMON ausführen soll (zum Beispiel $40, wenn ein M-Befehl eingegeben wurde).
C303LDX#$20	32-1 Befehle müssen durchsucht
werden. Weshalb »-1« erforderlich ist, liegtan derSchleifenstruktur und ist unbedeutend.
C305 CMP $C00A,X Akku (enthält Befehl) mit X-tem Element der Befehlstabelle vergleichen; $C00A = Befehlstabelle -1, weil Adresse $C00A nie zum Vergleich herangezogen wird.
C308 BEQ $C30F Vergleich positiv; im X-Registersteht jetzt die Spalte.
C30A DEX
C308 BNE $C305
C30D BEQ $C2D1
C30FJSR $C315
C312JMP$C2D6
Zähler wird dekrementiert; es handelt sich hier um eine »Dekremen-tierschleife« (dieses Thema wird noch behandelt).
Wenn der Zähler noch nicht gleich 0 ist, folgt ein Sprung zum Schleifenbeginn.
Wenn X=0, dann wurde die ganze Tabelle durchsucht, und der Befehl nicht gefunden! Deshalb wird in die SMON-Fehlerbehandlung gesprungen.
Diese Stelle wird von $C308 aus angesprungen; hier wiederum steht ein Aufruf des Unterprogramms ab $C315, das etwas weiter unten besprochen wird.
Nachdem nun der Befehl durch die Subroutine $C315 abgearbeitet wurde, folgt ein Sprung zur Eingabe des nächsten Befehls.
C315TXA
C316 ASL
C317TAX
C318INX
C319 LDA $C029, X
C31C PHA
C31DDEX
C31ELDA$C029,X
C321 PHA
C322 RTS
Das ist sie, die Subroutine! Weil im X-Register die Nummer des Befehls (= Spalte in Tabelle) steht, kommt das X-Register ins Hauptrechenregister.
Die Befehlsnummer wird mit 2 multipliziert ...
und kommt wieder ins X-Register. Die Multiplikation mit 2 ist erforderlich, weil in der Sprungtabelle ein Element doppelt so lang ist, wie in der Vergleichstabelle, nämlich 2 Byte. Die Sprungadressen belegen deshalb 2 Byte, weil sie aus Low- und High-Bytes bestehen.
Das X-Register wird um 1 erhöht, da das High-Byte eine Position hinter dem Low-Byte steht.
High-Bytewirdgelesen. DieSprung-tabelle beginnt zwar 2 Byte nach $C029, aber weil es keine Spalte 0 gibt, muß der Speicherbedarf einer Sprungadresse (=2) abgezogen werden.
Das High-Byte der Adresse wird auf den Stapel gelegt.
-1, weil Low-Byte eine Adresse vor High-Byte steht.
Nun wird auch das Low-Byte der Adresse
auf den Stapel geschoben.
Der Befehl RTS wird hier zur Simulation von JMP (ind) verwendet. Auf dieses (unpraktische) Verfahren soll nicht weiter eingegangen werden, weil der 6510 den Befehl JMP (ind) kennt. Wichtig ist für uns nur, daß jede SMON-Routine mit einem RTS abgeschlossen wird, dann erfolgt ein RücksprungzurAdresse $C312.
Kurs
C64
Damit haben wir SMONs Schleife zum Suchen eines Befehls und dessen Routine durchleuchtet. Sofern Sie ein ROM-Listing zur Verfügung haben, können Sie sich zusätzlich die entsprechenden Stellen im Basic-Interpreter an|se-hen. Dieser aber benötigt wegen seiner unterschiedlich langen Befehle einen etwas komplizierteren Suchalgorithmus, was wiederum zu erheblich höherer Ausführungszeit beiträgt.
6.	Vergleiche von Prüfsummen
Nun lernen wir ein besonders raffiniertes Vergleichsverfahren kennen:
Wie gesagt, benötigen Vergleiche mit Wörtern, die aus unterschiedlich vielen Zeichen bestehen, mehr Taktzyklen. Dies wäre nicht so, wenn wir alle Zeichen auf eine einheitliche Länge bringen würden. Genau dies tut der Basic-Interpreter: Bei Eingabe einer Zeile wandelt er alle Basic-Befehlswörter in Token um. Jedes Token vertritt einen Befehl und kann, da es nur ein Byte benötigt, schnelleTerkannt werden, als es bei mehreren Bytes möglich wäre.
Ein Nachteil ist jedoch der Speicherplatzaufwand; für die Umwandlung müssen die Befehle irgendwo im Speicher in Langform vorhanden sein.
Es gibt aber noch ein anderes Verfahren, einer Zeichenkette einen Wert zuzuweisen: Die Prüfsummenberechnung. Dieseführen zum Beispiel die Eingabehilfen »Checksummer« und »MSE« durch: Aus 8 Byte Programmcode und 2 Byte Adresse errechnet der MSE eine 1 Byte Prüfsumme.
In Bild 4 sehen Sie einen sehr zuverlässigen Algorithmus zur Berechnung von Prüfsummen (insofern zuverlässig, als er sehr unterschiedliche Prüfsummen ermittelt). Listing 9 stellt ein Hilfsprogramm dar, das zu einer Eingabe die Prüfsumme nach dem Algorithmus aus Bild 4 errechnet.
In Listing 9 ist Ihnen eventuell die Routine NUMOUT nicht bekannt. Daher eine Kurzbeschreibung: NUMOUT gibt eine positive Integerzahl, die im Akkumulator (High-Byte) und im X-Register (Low-Byte) übergeben wird, aus. NUMOUT wird zum Beispiel von der LIST-Routine bei der Ausgabe einer Zeilennummer aufgerufen.
Die Routine BASIN soll ebenfalls erklärt werden, da sie in allen folgenden Programmen verwendet werden wird. Wenn die Routine BASIN zum ersten Mal aufgerufen wird, erwartet das Betriebssystem eine Eingabe (normalerweise von Tastatur), die der Eingabe einer Basic-Zeile entspricht. Nach der Eingabe wird das erste eingegebene Byte in den Akku geladen, jeder weitere Aufruf von BASIN holt das nächste Zeichen in den Akku. Wurden alle Bytes eingelesen, wird im Akku der Wert 13 ($0D, RETURN) übergeben. Danach führt ein weiterer Aufruf von BASIN zu erneuter Eingabe von Tastatur.
Ein großer Vorteil von Prüfsummen ist, daß die Vergleiche mit nur einem Byte, nämlich der Prüfsumme, durchgeführt werden müssen.
Wie man in den Genuß dieses Vorteils kommt, zeigt Listing 10. Wenn Sie den Namen eines Computers (C 64, VC 20, PC 128 oder AMIGA) eingeben, nennt das Programm den in diesem Computer installierten Mikroprozessor. Bei der Eingabe der Computernamen kann man aufgrund der Zeilen 230 und 248 beliebig viele Leerzeichen eingeben. Bei der Errechnung der Prüfsummen mit Listing 9 dürfen allerdings keine eingegeben werden, da Listing 9 diese nicht überliest und somit ein falsches Ergebnis liefern würde.
Der Programmteil, der die Prüfsumme der Eingabe berechnet, ist mit Ausnahmen der Zeilen 230/240 aus Listing 9 übernommen worden. Nach Zeile 450 wird die ermittelte Prüfsumme mit der Tabelle »PRÜFSUMMEN« (Zeile 2060) verglichen.
Bei »WEITER2« (Zeile 620) steht im X-Register die Spalte,
100	-.LI 1,3,0		
110	-.BA $C000	; START: SYS	49152
120			
130	-.GL BASIN	= *FFCF	
140	-.8L NUMOUT = $BDCD		
150	-.GL STROUT = $ABlE		
160			
170	-ANFANG	LDA #<(TEXT1)	
180		LDY #>(TEXT1)	
190	-	JSR STROUT	
200			
210		LDX #0	
220	-SCHLEIFE1	JSR BASIN	
230		CMP #13	; 13 = RETURN
240	-	BEQ WEITER	
250	—	STA STORE,X	
260	—	INX	
270	—	JMP SCHLEIFE1	
280			
290	-WEITER	STX LAENGE	
300	—	LDA #<(TEXT2)	
310		LDY #>(TEXT2)	
320	—	JSR STROUT	
330		LDA #0	
340	-; 0 = AUSGANGSWERT DER		PRUEFSUMME
350	—	TAX	; ZAEHLER = 0
360	-SCHLEIFE2	ROL	; PRUEFSUMME * 2
370	—	EOR STORE,X	
380	—	INX	; ZAEHLER ERHOEHEN
390	—	CPX LAENGE	
400		BNE SCHLEIFE2	
410	—	CLC	
420	—	ADC LAENGE	; LAENGE ADDIEREN
430	—	TAX	; PRUEFSUMME
440		LDA #0	; AUSGEBEN
450	—	JSR NUMOUT	
460	—	JMP ANFANG	S NOCH EINMAL
1000			
1010	-; TEXTE		
1020			
1030	-TEXT1	.BY 13	
1040	-.TX "				-	11
1050	-.TX “EINGABE ?	"		
1060	-.BY 0		
1070			
1080	-TEXT2	.BY 13	
1090	-.TX "PRUEFSUMME "		
1100	-.BY 0		
2000	“?		
2010	—; ZWISCHENSPEICHER		
2020			
2030	-LAENGE	.BY 0	; ZWISCHENSPEICHER
2040	-STORE	.BY 0	
2050	-; 1 AB STORE WIRD DIE EINGABE ABGELEGT		
Listing 9. Die Berechnung von Prüfsummen			
Bild 4. Das Flußdiagramm zur Prüfsummenberechnung
82
C64
Kurs
in der die Prüfsumme gefunden wurde. Listing 10 numeriert, im Gegensatz zum SMON die Spalten mit 0 (statt mit 1) beginnend. Außerdem wurde die Adressentabelle in »LOWTAB« (Tabelle der Low-Bytes) und »HIGHTAB« (High-Bytes) zerlegt, was die Programmierung stark erleichtert.
Wir würden zwar Spalten von 1 an numerieren, für den Computer ist es aber besser, mit Spalte 8 zu beginnen. Wenn im X-Register die Spalte (0: VC 20,1: C 64, 2: PC 128, 3: AMIGA) steht, lesen die Zeilen 620/630 aus einer Tabelle die Adresse, ab der die ASCII-Darstellung des Prozessors zu finden ist. Weil jede der Tabellen »LOWTAB« und »HIGHTAB« gleich viele Elemente wie die Tabelle »PRUEFSUMMEN« hat, muß keine komplizierte Umwandlung über Multiplikation mit 2 oder ähnliches erfolgen wie beispielsweise beim SMON.
Auf eine akute Gefahr bei der Verwendung von Prüfsummen soll jetzt hingewiesen werden: die »Überschneidung von Prüfsummen«:
So wie unterschiedliche Basic-Zeilen beim Checksummer eine gleiche Prüfsumme haben können, sind Prüfsummen nie eindeutig.
Wenn Sie bei Listing 10 etwas herumprobieren, werden Sie sicher feststellen, daß auch eigentlich nicht vorgesehene Eingaben Wirkung zeigen. Dies liegt daran, daß diese Eingaben die gleiche Prüfsumme wie die Taste »VC 20«. »C 64«, »PC 128« oder »AMIGA« haben. Daher sollte man immer darauf achten, daß sich die vorgesehenen Eingaben nicht in ihren Prüfsummen überschneiden (das heißt, die gleichen Prüfsummen haben). Wenn man dies aber beachtet, so ist das Arbeiten mit Prüfsummen, vor allem bei kleineren Datenmengen, eine angenehme Sache.
e)	Beispielprogramm für Tabellen
Wenden wir uns jetzt einem etwas größeren (aber keineswegs komplizierteren) Programm zu. Es heißt schlicht und einfach »TABELLEN-BEISPIEL«, womit schon einiges über die Funktion ausgesagt ist: ein reines Beispielprogramm, das nicht den Anspruch erhebt, etwa als Anwendersoftware nützlich zu sein. In Listing 11 finden Sie den kommentierten Quelltext.
Zuerst soll die Bedienung des Programms erläutert werden. Gestartet wird »TABELLEN-BEISPIEL« durch SYS 49152, worauf man sich in folgendem Menü befindet:
ZAHLINZAHLWORTWANDELN (0) BILDSCHIRMFARBE (1) RESETAUSLOESEN (2) PROGRAMMENDE UEBER RTS (3) BITTE AUSWAEHLEN!
Die Zahlen in Klammern sehen Sie nicht, diese zeigen nur die interne Numerierung der Menüpunkte an.
Der jeweils angewählte Menüpunkt (unmittelbar nach dem Start: 0) wird im Gegensatz zu den anderen revers hervorgehoben.
Der angewählte Menüpunkt kommt durch Drücken von F1,RETURN, »—« - oder »=«-Taste zur Ausführung.
Wollen Sie einen anderen Menüpunkt anwählen, drücken Sie einfach CRSR DOWN,»D«,F5 oder»+«, um den invertierten Bereich nach unten zu bewegen. Weiter nach oben gelangen Sie über CRSR UP,»U«,F3 oder»-«.
Wenn Sie von »3« aus nach unten wollen, geht es wieder bei »0« los; von »0« nach oben führt auf Punkt »3«.
Auf Punkt »0« (Ausgangseinstellung) kommen Sie über HOME,»0« oder Klammeraffe.
Sicher würden Sie Ihre Programme auch gerne mit einem solch komfortablen Menü aufwerten. Wenn Sie die Beschreibung des Quelltextes gut durchlesen, wird dies keine Schwierigkeiten bereiten.
Nun zu den einzelnen Menüpunkten.
»2« (Reset auslösen) springt in die RESET-Routine ab $FCE2. »3« (Programmende über RTS) bewirkt einen Rücksprung ins Basic. Wenn Sie aber »TABELLEN-BEISPIEL« vom
100 -.LI 1,3,0
110 -.BA $C000 ; START: SYS 49152
120 -;
130 -.GL BASIN = $FFCF
140 -.GL NUMOUT = $BDCD
150 -.GL STROUT = $ABlE
160	5				
170	-ANFANG	LDA	#<(TEXT1)		
180	—	LDY	#>(TEXT1)		
190	—	JSR	STROUT		
200					
210	—	LDX	#0		
220	-SCHLEIFE1	JSR	BASIN		
230	—	CMP	#" "	; SPACE?	
240	—	BEQ	SCHLEIFE1	; DANN	UEBERLESEN
250	—	CMP	#13	; 13 =	RETURN
260	—	BEQ	WEITER1		
270	—	STA	STORE,X		
280	—	INX			
290	—	JMP	SCHLEIFE1		
300	— :				
310	-WEITER1	STX	LAENGE		
320	—	LDA	#<(TEXT2)		
330	—	LDY	#>(TEXT2)		
340	—	JSR	STROUT		
350	—	LDA	#0		
360	-; 0 = AUSGANGSWERT DER PRUEFSUMME				
370	-	TAX		; ZAEHLER = 0	
380	-SCHLEIFE2	ROL		; PRUEFSUMME * 2	
390		EDR	STORE,X		
400		INX		; ZAEHLER ERHOEHEN	
410		CPX	LAENGE		
420	—	BNE	SCHLEIFE2		
430	—	CLC			
440		ADC	LAENGE	; LAENGE ADDIEREN	
450	—; HIER STEHT I		JIE PRUEFSUMME IM		AKKU
460					
470		LDX	#0		
480	—SCHLEIFE3	CMP	PRUEFSUMMEN	,X	
490	—	BEQ	WEITER2		
500		INX			
510	—	CPX	#4		
520		BNE	SCHLEIFE3		
530	-; PRUEFSUMME t		JICHT GEFUNDEN		
540					
550	—	PLA			
560	—	PLA			
570		LDA	#<(TEXT3)		
580	—	LDY	#>(TEXT3)		
590	—	JSR	STROUT		
600	—	JSR	ANFANG	; VON	VORNE
610					
620	-WEITER2	LDA	LOWTAB,X	; LOW-	BYTE
630		LDY	HIGHTAB,X	; HIGH	-BYTE
640		JSR	STROUT		
650		JMP	ANFANG	; NOCH	EINMAL!
660					
1000					
1010	-; TEXTE				
1020	—:				
1030	-TEXT1	.BY	13		
1040		 TV II—					
	■ 1 A				
1050	-.TX "COMPUTER		. •>		
1060	-.BY 0				
1070	—:				
1080	-TEXT2	.BY	13		
1090	-.TX "PROZESSOR: "				
1100	-.BY 0				
1110					
1120	-TEXT3	.TX	"WEISS ICH	NICHT!	
1130	-.BY 0				
1140					
1150	—:				
1160	-T6502	.TX	"MOS 6502"		
1170	-.BY 0				
1180					
1190	-T6510	.TX	"MOS 6510"		
1200	-.BY 0				
1210	—:				
1220	-T8502	.TX	"MOS 8502 &	Z80"	
1230	-.BY 0				
1240					
1250	-T68000	.TX	"MOTOROLA 68000"		
1260	-.BY 0				
1270					
2000					
2010	-; NUMERISCHE		FABELLEN		
2020					
2030	-LOWTAB	.BY	<(T6502),<(T6510)		,<(T8502),<(T68000)
2040	-HIGHTAB	.BY	>(T6502),>(T6510)		,>(T8502),>(T68000)
2050					
2060 -PRUEFSUMMEN .BY 228,83,149,136
2070 -; REIHENFOLGE: VC20,C64,PC128,AMIGA
3000 -;
3010 -; ZWISCHENSPEICHER
3020 -;
3030 -LAENGE	.BY 0	: ZWISCHENSPEICHER
3040 -STORE	.BY 0
3050 -; t AB STORE WIRD DIE EINGABE ABGELEGT
Listing 10. Eine Anwendung der Prüfsummenberechnung
83
Kurs
C64
Hypra-Ass aus gestartet haben, finden Sie sich im »AUTO-NUMBER«-Modus wieder. Dies ist weder ein Fehler von »TABELLEN-BEISPIEL« noch von Hypra-Ass, sondern liegt daran, daß beide Programme eine bestimmte Adresse verwenden, die Hypra-Ass dann als Aufforderung zur automatischen Zeilennumerierung wertet. Am besten starten Sie »TABELLEN-BEISPIEL« nur vom normalen Basic aus.
Punkt »0« bittet Sie um Eingabe einer Zahl von 0 bis 9 und gibt zur eingegebenen Zahl das Zahlwort aus. Beispiel: Eingabe »0«, Ausgabe »NULL«.
Danach müssen Sie eine Taste drücken, um ins Hauptmenü zu kommen.
Punkt »1« schließlich bietet die Möglichkeit, die Hintergrundfarbe besonders elegant einzustellen: Sie geben einfach die Farbe als Wort ein, zum Beispiel SCHWARZ.
Folgende Eingaben sind vorgesehen:
SCHWARZ,WEISS,ROTTUERKISyiOLETT,GRUEN,BLAU, GELB,ORANGE,BRAUN,HELLROt,GRAU 1,GRAU 2, HELLGRUEN,HELLBLAU,GRAU 3
Aufgrund der Überschneidung von Prüfsummen zeigen jedoch auch andere Eingaben Wirkung, zum Beispiel: SCH,HYPRAASS,PRINT,COMPUTER-GRAPHIK, TAGESSCHAU
Nun wollen wir uns mit dem Quelltext befassen.
AbZeile 1OOOOfinden SiedieTabellen. UndweilunserPro-gramm ein Beispiel für die Verwendung von Tabellen sein soll, sind es derer recht viele. Die wichtigsten davon sind jedoch analog der internen Numerierung der Menüpunkte aufgebaut, da sie Daten für die Menüsteuerung beinhalten. Diese Tabellen sind auch mit 0 - 3 numeriert und grafisch in Bild 6 dargestellt.
Sehen wir uns wieder den Quelltext, beginnend mit der ersten Zeile, an.
Auf die Symboldefinitionen (210 - 260) folgt die Initialisierung der Hauptschleife (280 - 310). Diese Initialisierung löscht Bildschirm (280) und Tastaturpuffer (290 - 300). Außerdem wird der aktuelle (= derzeit invers dargestellte) Menüpunkt (immer in der Adresse »MPT« enthalten) auf 0 gesetzt (310). Zeile 310 ist also dafür verantwortlich, daß nach dem Start über SYS 49152 das Inversfeld ganz oben steht (auf Punkt 0).
Die Texte, die der Beschreibung der Menüpunkte dienen, werden in der Hauptschleife »HSCHLEIFE« (350 - 550) ausgegeben. Mit dieser wollen wir uns nun eingehend auseinandersetzen.
Zunächst wird die Tabelle »RVSTAB« gelöscht (350 - 400). Diese Tabelle enthält die Information, ob der erläuternde Text zu einem Menüpunkt inversausgegeben wird. Wenn nein, so enthält das entsprechende Byte eine »0«, andernfalls eine »18« (= REVERS-ON-Code für Betriebssystem). Das entsprechende Byte aus »RVSTAB« braucht nur vor dem Menüpunkt-Text ausgegeben werden (470- 480). DieZeilen 410- 430 sorgen dafür, daß das Byte in »RVSTAB«, welches sich auf den aktuellen Menüpunkt bezieht, den RVS-ON-Code erhält.
In der Hauptschleife muß das X-Register in »XSAVE« gesichert werden, weil die Routine »STROUT« den Inhalt des X-Registers ändert.
Mit »TASTE« (610) beginnt dann die Tastaturabfrage im Menü. Die Routine »GET« holt ein Zeichen von der Tastatur als ASCII-Code in den Akku. Wurde keine Taste gedrückt, erhält der Akku den Code 0. In diesem Fall wartet 620 auf eine neue Eingabe. Beachten Sie bitte, daß der Akku nach der Zeile 620 NIE den Wert 0 haben kann (dies wird sich bald als nützlich erweisen)!
Wurde nun eine Taste gedrückt, sucht »SCHLEIFE« (630 -680)inderTabelle»TASTEN«, die im Quelltextab Zeile 10210 steht, nach dem eingegebenen Zeichen (wird es nicht gefunden, erfolgt in 690 der Sprung zur neuen Eingabe).
100 -.BA $C000 ; START: SYS 49152
110	— 5
120	-;	*************************
130	—;	*	*
140	-;	*	TABELLEN - BEISPIEL	*
150	-;	*	===================	*
160	-;	*	*
170	—;	*	BY FLORIAN MUELLER	*
180	-;	*	*
190	-;	*************************
200	-;
210 -.BL STROUT = $ABlE
220 -.GL CURSORHOME = $E566
230 -.GL GET - $FFE4
240 -.GL BASIN = fFFCF
250 -.GL BASOUT = $FFD2
260 -.GL RESET = $FCE2 ; SOFTWARE-RESET
270	-;
280	-START	JSR	$E544	;	= PRINT CHR$(147)
290	-	LDA	#0	;	TASTATURPUFFER
300	-	STA	198	;	LOESCHEN
310	-	STA	MPT
320 -; T SETZT AKTUELLEN MENUEPUNKT AUF 0
330 -HSCHLEIFE JSR CURSORHOME
340 -; t HSCHLEIFE = HAUPTSCHLEIFE
350	-	LDA	#0
360	-	TAX
370 -SCHLEIFEI STA RVSTAB,X
380	-	INX
390	-	CPX	#4
400	-	BNE	SCHLEIFE1
410	-	LDX	MPT
420 —	LDA #18	; 18 = REVERS EIN
430	-	STA	RVSTAB,X
440	-	LDX	#0
450	—5 t SCHLEIFENZAEHLER INITIALISIEREN			
460 -SCHLEIFE2	STX	XSAVE	; X RETTEN
470 -	LDA	RVSTAB,X	
480 -	JSR	BASOUT	
490 -	LDA	TEXTLO,X	; ERKLAERUNG
500 -	LDY	TEXTHI,X	; ZUM MENUEPUNKT
510	-	JSR	STROUT	; AUSGEBEN
520	-	LDX	XSAVE	; X WIEDER HOLEN
530 -	INX		
540	-	CPX	#4	
550 - 560 -; 570 -;	BNE	SCHLEIFE2	
580	-; HIER IST DAS MENUE BEREITS AUF 590 -; DEN BILDSCHIRM AUSGEGEBEN WORDEN.			
600	-; 610 -TASTE	JSR	GET	5 TASTATURABFRAGE
620 -	BEQ	TASTE	; WARTEN AUF TASTENDRUCK
630	-	LDX	#0	
640 -SCHLEIFE3	CMP	TASTEN,X	
650	-	BEQ	WEITER1	
660 -	INX		
670	-	CPX	#16	
680	-	BNE	SCHLEIFE3	
690 -	JMP	TASTE	
700 -WEITER1	TXA		
710	-	LSR		; DIVIDIERT AKKU-
720 -	LSR		; MULATOR DURCH 4
730	-	TAX		
740	-	LDA	SPlLO,X	
750	-	STA	SPRUNG	
760	-	LDA	SPlHI,X	
770 - 780 —;	STA	SPRUNG+1	
790 -.EQ RUECKSPRUNG = HSCHLEIFE-1 800 —; T LEGT RUECKSPRUNGADRESSE DES			
810	—; UNTERPROGRAMMS FEST.			
820 -;			
830	-	LDA	#>(RUECKSPRUNG)	
840	-	PHA		
850 -	LDA	#< (RUECKSPRUNG)	
860	-	PHA		
870	-	JMP	(SPRUNG)	
880 -; 890	-; 900 -HOME	LDX	#0	
910	-	STX	MPT	
920 -ENDE 930	-;	RTS		; ENDE DES UNTERPRG
940 -DOWN	LDX	MPT	; MENUEPUNKT
950 -	INX		; UM 1 ERHOEHEN
960	-	CPX	#4	; GROESSER ALS 3?
970 -	BEQ	HOME	; DANN =0
980	-	STX	MPT	; SONST UEBERNEHMEN
990	-	RTS		; ZUR HAUPTSCHLEIFE
1000 -; 1010 -UP	LDX	MPT	; MENUEPUNKT
1020 -	DEX		; DEKREMENTIEREN
1030 -	BPL	ENDUP	; > 0?
1040 -	LDX	#3	; NEIN, DANN =3
1050 -ENDUP	STX	MPT	; UND UEBERNEHMEN
1060 - 1070 -; 1080 -;	RTS		; ZUR HAUPTSCHLEIFE
1090 -EXEC	PLA		; STAPELMANIPULATION
1100 -	PLA		
1110 -	LDX	MPT	
Listing 11. »Tabellen-Beispiel«, ein Beispiel zur Verwendung von Tabellen
84
C64
Kurs
1120 -		LDA SP2L0,X		
1130		STA	SPRUNG	
1140		LDA	SP2HI,X	
1150	—	STA	SPRUNG+1	
1160		JMP	(SPRUNG)	
1170	-;			
1180				
1190				
1200	-ZAHLWORT	LDA	#<(TZAHL)	; AUFFORDERUNG
1210		LDY	#>(TZAHL)	; ZUR EINGABE
1220	—	JSR	STROUT	; AUSGEBEN
1230	—	JSR	BASIN	; HOLT ZEICHEN
1240	—	SEC		; IN BINAERZAHL
1250	—	SBC	#"0"	; UMWANDELN
1260		TAX		; INS X-REGISTER
1270				
1280	— ; JETZT STEHT		IM X-REGISTER	
1290	— ; DIE EINGEBEBENE ZAHL			
1300				
1310		CMP	#10	; > 10?
1320		BCC	ZAHLWORT1	; NEIN=> WEITER
1330		JMP	ZAHLWORT	; NEUEINGABE
1340				
1350	-ZAHLWORT1	STX	XSAVE	; X RETTEN
1360		LDA	#<(TWORT)	; AUFFORDERUNG
1370		LDY	#>(TWORT)	; ZUR EINGABE
1380		JSR	STROUT	; AUSGEBEN
1390		LDX	XSAVE	; X WIEDER HOLEN
1400		LDA	ZWLO,X	; ADRESSE DES
1410		LDY	ZWHI,X	; ZAHLWORTES HOLEN
1420		JSR	STROUT	; UND Z.WORT DRUCKEN
1430				
1440	-WAIT	JSR	GET	; WARTET AUF
1450		BEQ	WAIT	5 TASTENDRUCK
1460		JMP	START	; ZUM HAUPTMENUE
1470				
1480				
1490				
1500	-FARBE	LDA	#<(TFARBE)	
1510		LDY	#>(TFARBE)	
1520		JSR	STROUT	
1530	—	LDX	#0	
1540	-FARBE1	JSR	BASIN	5 HOLT EINGABE
1550		CMP	#" "	; SPACE ?
1560	—	BEQ	FARBE1	; JA=>UEBERLESEN
1570	—	CMP	#13	; ENDE DER EINGABE?
1580		BEQ	FARBE2	; JA, DANN WEITER
1590		STA	FARBWORT,X	; EINGABE SPEICHERN
1600		INX		; ZAEHLER ERHOEHEN
1610		JMP	FARBE1	; ZUR SCHLEIFE
1620	-FARBE2	STX	2	; LAENGE MERKEN
1630		LDX	#0	
1640		TXA		
1650	-FARBE3	ROL		
1660		EOR	FARBWORT,X	
1670	—	INX		
1680	—	/	CPX	2	; SCHON FERTIG?
1690		BNE	FARBE3	; NEIN,ZUR SCHLEIFE
1700	—	CLC		; LAENGE
1710		ADC	2	; ADDIEREN
1720	~5			
1730	—; HIER STEHT ]		[M AKKU DIE	PRUEFSUMME
1740	—:			
1750	—	LDX	#0	
1760	-FARBE4	CMP	PRUEFSUMMEN	l,X
1770	—	BEQ	FARBE5	; GEFUNDEN
1780	—	INX		
1790	—	CPX	#16	
1800	—	BNE	FARBE4	
1810	—	JMP	FARBE	; NEUE EINGABE
1820	-FARBE5	STX	53280	; BILDSCHIRM-
1830	—	STX	53281	; FARBE SETZEN
1840	—	JMP	START	; ZUM MENUE
1850				
10000-;
10010-; TABELLEN
10020-; ========
10030-;
10040-; TEXTE: 10050-;
10060-PUNKT0 .TX "ZAHL IN ZAHLWORT UMWANDELN" 10070-.BY 13,13,0 10080-; 10090-PUNKT1	.TX "BILDSCHIRMFARBE"
10100-.BY 13,13,0 10110-; 10120-PUNKT2 .TX "RESET AUSLOESEN" 10130-.BY 13,13,0 10140-; 10150-PUNKT3 .TX "PROGRAMMENDE UEBER RTS" 10160-.BY 13,13,13 10170-.TX "BITTE AUSWAEHLEN !" 10180-.BY 0 10190-;
10200-;
10210-TASTEN .BY 133,13,"*","="; 133=Fl,13=RETURN 10220-.BY 19,"0","@",0 ; 19=HOME,0=DUMMY
10230-.BY 17,"D",135,"+" ; 17=CRSR D0WN,135=F5 10240-.BY 145,"U",134,"-" ; 145=CRSR UP,134=F3 10250-;
10260-;
10270-TZAHL .BY 147	; CLEAR HOME
10280-.TX "ZAHL (0-9) ? " 10290-.BY 0			
10300-; 10310-TWORT	.TX	" IN WORTEN	
10320-.BY 0 10330-; 10340-; 10350-; Z AHLWOERTER		(0-9)	
10360-; 10370-; 10380-NULL	.TX	"NULL"	
10390-.BY 0 10400-; 10410-EINS	.TX	"EINS"	
10420-.BY 0 10430-; 10440-ZWEI	.TX	"ZWEI"	
10450-.BY 0 10460-; 10470-DREI	.TX	"DREI"	
10480-.BY 0 10490-; 10500-VIER	.TX	"VIER"	
10510-.BY 0 10520-; 10530-FUENF	.TX	"FUENF"	
10540-.BY 0 10550-; 10560-SECHS	.TX	"SECHS"	
10570-.BY 0 10580-; 10590-SIEBEN	.TX	"SIEBEN"	
10600-.BY 0 10610-; 10620-ACHT	.TX	"ACHT"	
10630-.BY 0 10640-; 10650-NEUN	.TX	"NEUN"	
10660-.BY 0 10670-; 10680-; 10690-TFARBE	.BY	147	;	CLEAR HOME
10700-.TX "WELCHE FARBE ?
10710-.BY 0
10720-;
10730-;
10740-RVSTAB .BY 0,0,0,0	; 4 BYTES RESERVIEREN
10750-; 10760-; 10770-; ZAHLEN: 10780-; 10790-; ADRESSEN DER TEXTE, DIE DIE 10800-; MENUEPUNKTE BESCHREIBEN 10810-; 10820-TEXTLO .BY <(PUNKT0),<(PUNKT1) 10830-.BY <(PUNKT2),<(PUNKT3) 10840-; 10850-TEXTHI .BY >(PUNKT0),>(PUNKT1) 10860-.BY >(PUNKT2),>(PUNKT3) 10870-; 10880-; 10890-; ADRESSEN DER ZAHLWOERTER 10900-;
10910-ZWLO .BY <(NULL),<(EINS),<(ZWEI),<(DREI)
10920-.BY <(VIER),<(FUENF),<(SECHS),<(SIEBEN)
10930-.BY <(ACHT),<(NEUN) 10940-;
10950-ZWHI	.BY >(NULL),>(EINS),>(ZWEI),>(DREI)
10960-.BY >(VIER),>(FUENF),>(SECHS),>(SIEBEN)
10970-.BY >(ACHT),>(NEUN)
10980-;
10990-;
11000-; ADRESSEN DER UNTERROUTINEN
11010-; FUER DIE MENUESTEUERUNG
11020-;
11030-SP1LO	.BY <(EXEC),<(HOME),<(DOWN),<(UP)
11040-;
11050-SP1HI	.BY >(EXEC),>(HOME),>(DOWN),>(UP)
11060-; 11070-; 11080-; ADRESSEN DER EINZELNEN 11090-; MENUEPUNKTE 11100-; 11110-SP2LO .BY <(ZAHLWORT),<(FARBE) 11120-.BY <(RESET),<(ENDE) ; BEI ENDE STEHT 11130-SP2HI	.BY >(ZAHLWORT),>(FARBE)
11140-.BY >(RESET),>(ENDE) ; EIN RTS-BEFEHL 11150-; 11160-; PRUEFSUMMEN DER FARB-WDERTER 11170-;
11180-PRUEFSUMMEN .BY 41,158,137,212,159,101
11190-.BY 3,2,33,69,201,116,113,121,127,114 11200-; 11210-; 11220-; ZWISCHENSPEICHER 11230-; 11240-MPT	.BY	0	;	1	BYTE	RESERVIEREN
11250-XSAVE	.BY	0
11260-SPRUNG	.WO	0	;	2	BYTES	FREIHALTEN
11270-FARBWORT	.BY	0
11280-; t AB 'FARBWORT' WIRD DIE EINGABE 11290-; DER FARB-BEZEICHNUNG ABGELEGT.
READY.
85
C64
Kurs
Spalte	0			1			2			3			
TEXTLO		0			1			2			3		I Adressen der Text-Tabellen, die 1 die Menüpunkte beschreiben
													
TEXTHI		0			1			2			3		
zeigen als Vektoren auf:										V			
		PUNKTO			PUNKT 1			PUNKT2			PUNKT 3		^Text-Tabellen
													) enthält Information, ob Text zu J Menüpunkt invertiert werden soll
/ RVSTAB		0			1			2			3		
													
SP2L0		0			1			2			3		I enthält die Adressen der | Routinen zu den Menüpunkten
	I						I						
SP2HI		0			1			2			3		
zeigen als Vektoren auf:	Routine ZAHLWORT			Routine FARBE			V Routine RESET			V Routine ENDE			
	Bild 5. So verwendet man Tabellen zur Realisierung eines Menüs												
Diese Tabelle »TASTEN« enthält alle vorgesehenen Tastendrücke zur Menüsteuerung, die in 4er-Blockweise angeordnet sind (Bild 5). Nach der Suchschleife steht im X-Register die Position der gedrückten Taste innerhalb der Tabelle »TASTEN« (zum Beispiel 0 = F1 gedrückt, 4 = HOME gedrückt). Diese Position wird - ohne Berücksichtigung des Divisions-Restes - durch 4 dividiert (700 - 730), um festzuhalten, von welchem Tastenblock eine Taste gedrückt wurde.
Dadurch ist eindeutig bestimmt, welche Befehlsgruppe aufgerufen werden muß.
Steht nach 730 im X-Register 0, wurde eine der ersten vier in »TASTEN« enthaltenen Tasten gedrückt, die die Ausführung des aktuellen Menüpunktes veranlassen (Zeile 10210 und Bild 5). Ist X=1, so wurde eine Taste aus Zeile 10220
gedrückt. In 10220 stehtals letztes Byte eine 0. Diese dient, da für die Funktion »Inversfeld in HOME-Position« nur drei Tastendrücke vorgesehen wurden, zum Auffüllen auf vier Tasten. 0 kann hier bedenkenlos als Dummy (Füllbyte ohne wirkliche Bedeutung) stehen, da der Akku aufgrund von 620 nie den Wert 0 annehmen wird.
Beinhaltet X nach der Division durch 4 den Wert2, wird das Inversfeld nach unten bewegt, istX=3, dann nachoben. Dies können Sie sich an Bild 6 veranschaulichen.
An den Zeilen 740 - 870 sehen wir nun die Verwendung einer Sprungtabelle. Unsere Sprungtabelle ist »SP1LO/SP1HI«. »SP1LO« beinhaltet die Low-, »SP1HI« die High-Bytes der anzuspringenden Routinen. In den Vektor »SPRUNG« wird einfach die Zieladresse geschrieben (740 - 770).
X =
3
0
2
1
TASTEN
10240
10210
10230
10220
in Zeile
dazugehörige Routine:
EXEC
HOME
DOWN
UP
Wirkung:
angewählter
Menüpunkt wird ausgeführt (Sprung in 1160)
aktueller Menüpunkt wird auf 0 gesetzt
Inversfeld wird nach unten bewegt
Inversfeld wird nach oben bewegt
MPT =
0
3
ZAHLWORT FARBE RESET ENDE
Bild 6. Die Tastaturabfrage aus Listing 11
86

C64
Kurs
Die Zuweisungszeile 790 errechnet die Rücksprungadresse des aufzurufenden Unterprogramms. Bei einem RTS soll nämlich zur »HSCHLEIFE« gesprungen werden.
Diese Rücksprungadresse »RUECKSPRUNG« wird auf den Stapel gelegt (830 - 860), zuletzt erfolgt der indirekte Sprung (870). Die über die soeben beschriebene Simulation von JSR (ind) angesprungenen Routinen finden Sie ab Zeile 900. Es wird einfach der aktuelle Menüpunkt »MPT« entsprechend dem Tastendruck geändert, dann wird zur »HSCHLEIFE« gesprungen, die auch die Tabelle »RVSTAB« entsprechend anpaßt.
»EXEC« (1090) holt die Rücksprungadresse vom Stapel (1090 - 1100), da diese Routine nicht als Unterprogramm behandelt werden soll.
Die Zeile 1110 holt den angeforderten Menüpunkt ins X-Register. Dann wird aus »SP2LO/SP2HI« die Adresse der zum Menüpunkt gehörenden Routine geholt und diese über einen gewöhnlichen indirekten Sprung aufgerufen (1160).
Als Routine zu »2« wird einfach die RESET-Routine des Betriebssystems angesprungen, für »3« eignet sich jeder RTS-Befehl, also auch der bei »ENDE« (920).
»ZAHLWORT«, die Routine zu 0, holt eine Zahl als ASCII-Code (1230) und wandelt sie in einen numerischen Wert um (1240 -1250), indem der ASCII-Code von 0 abgezogen wird. Das Ergebnis landet im X-Register (1260). Ob auch eine Zahl eingegeben wurde, prüfen die Zeilen 1310 - 1330. Bei »ZAHLWORT« (1350) wird das Resultat der Subtraktion in »XSAVE« gesichert, der Text »IN WORTEN« ausgegeben und das X-Register wieder geholt.
Die Tabelle »ZWLO/ZWHI« enthält die Adressen, ab denen die Texte der Zahlwörter als ASCII-Code stehen. Aus »ZWLO/ZWHI« wird dann diese Adresse geholt (1400 -1410) und der dort stehende Text ausgegeben (1420). Danach erwartet das Programm noch einen Tastendruck (1440-1450), bevor ins Hauptmenü verzweigt wird (1460).
Als letzte Routine wird »FARBE« besprochen (1500-1850): Hierzu istjedoch aufgrund derÄhnlichkeitzu Listing 10 nicht viel zu erläutern. Bei 1820 steht im X-Register der Code der eingegebenen Farbe (= Position der Prüfsumme innerhalb der Tabelle »PRUEFSUMMEN«). Dieser muß nur noch in die entsprechenden VIC-Register geschrieben werden (1820-1830). Ab Zeile 10000 stehen dann die Tabellen. Wenn Sie die Tabellen angesehen haben, sollten Sie durchaus noch einmal den Quelltext bis 10000 betrachten und die hier endende Beschreibung des Programms lesen. Denn wenn Sie das Programm »TABELLEN-BEISPIEL« ganz verstanden haben, sind Sie einen großen Schritt in der Assemblerprogrammierung weitergekommen I
Ich könnte mir übrigens vorstellen, daß Sie in Ihren eigenen Programmen jetzt auch eine Menüsteuerung wie die in »TABELLEN-BEISPIEL« einbauen; wie das geht, können Sie dem Programm »TABELLEN-BEISPIEL« entnehmen.
Eine Anmerkung ist wichtig: »TABELLEN-BEISPIEL« kann noch weiter verbessert werden. Sie werden sehen, daß viele Stellen noch optimiert werden können. Insbesondere der Speicherplatzbedarf kann verringert werden.
f)	Weitere Anregungen zur Anwendung von Tabellen
Auch die bisherigen Erläuterungen und das Beispielprogramm können die Kreativität des Programmierers nicht ersetzen, sondern nur die Programmierung erleichtern. Aus diesem Grund möchte ich Ihnen noch einige Beispiele nennen, wie sich Tabellen sinnvoll verwerten lassen.
-	Ein Anwenderprogramm, das aus Menüs und Untermenüs besteht, sollte in einer Tabelle die Adressen der Menüs/Untermenüs speichern.
-	Spiele müssen oft viele Spritebewegungen, die immer gleich sind, durchführen. Es empfiehlt sich, die Spritebewegungen als Koordinaten in einerTabelle abzulegen.
-	Bei Software-Interfaces müssen viele Umrechnungen
erfolgen. Durch eine Umwandlungstabelle können diese stark beschleunigt werden.
-	Naturwissenschaftlich orientierte Programme müssen verschiedene Maße umrechnen. Die Umrechnungswerte können in einer Tabelle untergebracht werden.
Dies soll nur eine Anregung sein. Ich wüßte aber kein komple-xesProgramm, dassich nichtdurch dengezielten Einsatzvon Tabellen vereinfachen und beschleunigen ließe.
Texteinschub #1: Fließkommazahlen
lm Text wurde ein Verfahren vorgestellt, um eine Zahl ins MFLPT-Fbrmat (MELPT=Memory floating point) umzuwandeln. Das 5 Byte lange Ergebnis dieser Umwandlung kann man dann als KONSTANTE handhaben. Konstanten sind feste, vorausberechnete Werte, die man mit Hilfe der Routine »MEMFAC« in den FAC (Flieskomma-AKKU) kopieren kann. Für viele Werte ist es jedoch überflüssig, die Umwandlung durchzuführen und eine entsprechende Tabelle anzulegen, da sie schon im ROM vorhanden sind. Im Kurs »Assembler ist keine Alchimie« wurden solche Konstanten mitsamt ihrer Adressen schon in einer Tabelle vorgestellt.
Um mit Konstanten (für die Rechenroutinen macht es keinen Unterschied, ob diese im RAM oder im ROM stehen) zu rechnen, kann man diese wie gesagt, in den FAC kopieren und alle weiteren Operationen auf diesen beziehen. Dies war in Listing 8 bei den Funktionen SQR und LOGNAT ausreichend.
Oft möchte man aber den Inhalt des FAC nicht mit einer Funktion wie SQR behandeln, sondern mit anderen Konstanten addieren, multiplizieren und so weiter.
Dafür möchte ich Ihnen im folgenden weitere Interpreter-Routinen vorstellen, die das Rechnen mit Konstanten ermöglichen. Da fast immer in den Akku das Low-, ins Y-Register das High-Byte der Adresse, ab der die Konstante abgelegt ist, geladen werden muß, definieren wir noch vorher folgende Makro:
-	.MA LDAY (ADRESSE)
LDA#<(ADRESSE) LDY#>(ADRESSE)
-.RT
Nun zu den Routinen, bei deren Parameterübergabe wir uns auf das Makro LDAY stützen wollen:
ADDMEM	FAC+Konstante - FAC	... LDAY (KONSTANTE) JSR$B867
ADD0,5	FAC+0.5 - FAC	JSR $B849
SUBMEM	Konstante-FAC - FAC	...LDAY(KONSTANTE) JSR $B850
MULMEM	Konstante*FAC - FAC	...LDAY(KONSTANTE) JSR $BA28
MULT10	FAC*1O-FAC	JSR $BAE2
DIVMEM	Konstante/FAC - FAC	...LDAY(KONSTANTE) JSR $BBOF
DIVS10	FAC/10 - FAC	JSR $BAFE
CMPMEM	vergleicht Konstante mit FAC FAC<Konstante: Akku=$FF FAC=Konstante: Akku=$OO FAC>Konstante: Akku=$O1	... LDAY (KONSTANTE) JSR $BC5B
POTMEM	Konstante tFAC - FAC	...LDAY(KONSTANTE) JSR $BF78
POTE	etFAC-FAC	JSR $BFED
MEMFAC	holt Konstante in FAC	...LDAY(KONSTANTE) JSR $BBA2
FACMEM	FAC ab Konstante als MFLPT-Zahl ablegen	LDX#<(KONSTANTE) LDY#>(KONSTANTE) JSR$BBD7
FACOUT	gibt FAC aus	JSR $AABC
Kurs
C64
7.	Die Initialisierung
»Initialisierung« nennt man eine Routine, die vor einem Programmteil (meist einer Schleife) steht und diese vorbereitet. Die Initialisierung wird nur einmal, eine Schleife aber mehrfach durchlaufen. Deshalb bringt es einen Geschwindigkeitszuwachs, wenn die Initialisierung der Schleife Arbeit abnimmt.
Ein Beispiel: Wenn ein Basic-Programm mit »RUN« gestartet wird, werden alle Variablen gelöscht, Files geschlossen und die Adressen, ab denen die Variablen abgelegt werden dürfen, errechnet. Dies ist die Initialisierung der Interpreterschleife. Dann wird Byte für Byte des Basic-Programms eingelesen und bearbeitet.
Muß im gerade übersetzten Befehl ein Sprung (GOTO 500 oder ähnliches) durchgeführt werden, kostet dies bekanntlich viel Zeit, wenn das Sprungziel am Ende eines langen Programms steht. Dies ist darauf zurückzuführen, daß der Interpreter, beginnend mit der ersten Zeile, das ganze Programm nach der Sprungzeile durchsucht, bis er sie gefunden hat.
Diese Berechnung der Adressen wird bei jedem »GOTO« oder »GOSUB« neu durchgeführt.
Viel besser und schneller wäre folgende Vorgehensweise: Bei »RUN« wird zunächst eine Tabelle angelegt, in der die Adressen aller Zeilen enthalten sind. Diese Tabelle könnte zum Beispiel als Array definiert werden. Folgt nun ein Sprung, kann aus der Tabelle die Adresse der Zeile im Speicher geholt werden.
Damit haben wir noch ein wesentliches Merkmal der Initialisierungsroutinen gefunden: Die Initialisierung kann Tabellen anlegen, die dann von der Hauptschleife verarbeitet werden.
Aber nicht nur Tabellen können generiert werden, auch die Berechnung von Flags ist sinnvoll. So merkt sich die »LOAD/VERIFY«-Routine ($FFD5), ob ein Verifizieren oder Laden gewünscht wird. Die Ladeschleife liest dann ein Zeichen von der Floppy oder der Datasette ein und entscheidet erst anschließend, ob das Byte im Speicher abgelegt oder mit dem Speicher verglichen werden soll.
Halten wir also fest, daß Initialisierungsroutinen Schleifen entlasten können. Näher werden wir uns damit beim Thema »Schleifen« beschäftigen.
8.	Die Nutzung der Zeropage
ln jedem Assembler-Lehrbuch werden die Vorteile der Zeropage-Adressierung gepriesen. Speicherplatzersparnis und hohe Verarbeitungsgeschwindigkeit sind nicht die einzigen Vorzüge; die indirekt-indizierte Adressierung kann nur aufZeropage-Adressen zugreifen, nichtauf absolute 16-Bit-Adressen. Damit wird der Leser aber schon alleine gelassen. Er erfährt nicht, welche Adressen in der Zeropage für die Praxis geeignet sind. Das wird nun nachgeholt.
Fast die ganze Zeropage wird durch Basic-Interpreter und Betriebssystem belegt. Deshalb führen bestimmte Werte in Zeropage-Adressen oft zum Absturz oder sonstigem Fehlverhalten des Computers.
Wie dies im einzelnen aussieht, erfahren Sie in der Serie »Memory Map mit Wandervorschlägen«, die im 64’er Stammheft erscheint. Nicht nur in Zweifelsfällen stellt diese Serie das optimale Nachschlagewerk dar.
Ich möchte Ihnen nun zeigen, welche Adressen Sie als (Zwischen-)Speicher ohne Schwierigkeiten verwenden können, beziehungsweise was Sie bei Verwendung von Zeropage-Adressen beachten müssen.
a)	Adressen, die problemlos verwendet werden können
Auf die Adressen $02 und $FB - $FE wird weder vom
,6000	A2 00	LDX #00
,6002	B5 02	LDA 02,X
,6004 ,6007	9D 00 6F E8	STA 6F00,X INX
,6008	E0 FE	CPX #FE
,600A	D0 F6	BNE 6002
Listing 12
, 6000	A2 FE	LDX #FE
,6002	B5 01	LDA #01
,6004	9D FF 6E	STA 6EFF,X
,6007	CA	DEX
,6008	D0 F8	BNE 6002
Listing 13
6000	A2	FE	LDX	#FE
6002	BD	FF 6E	LDA	6EFF,X
6005	95	01	STA	#01
6007	CA		DEX	
6008	D0	F8	BNE	6002
Listing 14
,6000	A2	34	LDX	#34
,6002	B5	16	LDA	16,X
,6004	9D	00 6F	STA	6F00,X
,6007	CA		DEX	
,6008	10	F8	BPL	6002
Listing 15				
,6000	A2	34	LDX #34	
,6002	BD	00 6F	LDA	6F00,X
,6005	95	16	STA	16,X
,6007	CA		DEX	
,6008	10	F8	BPL	6002
Listing 16				
,6000	A2	FF	LDX	#FF
,6002	BD	00 01	LDA	0100,X
,6005	9D	00 6F	STA	6F00,X
,6008	CA		DEX	
,6009	D0	F7	BNE	6002
,600B	AD	00 01	LDA	0100
,600E	8D	00 6F	STA	6F00
,6011	BA		TSX	
,6012	8E	00 70	STX	7000
Listing 17				
,6000	A2	FF	LDX	#FF
,6002	BD	00 6F	LDA	6F00,X
,6005	9D	00 01	STA	0100,X
,6008	CA		DEX	
,6009	D0	F7	BNE	6002
,600B	AD	00 6F	LDA	6F00
,600E	8D	00 01	STA	0100
,6011	AE	00 70	LDX	7000
,6014	9A		TXS	
Listing 18
88

C64
Kurs
Basic-Interpreter noch vom Betriebssystem zugegriffen. Lediglich bei Initialisierung der Arbeitsspeicher (RESET) werden Sie auf 0 gesetzt.
Für die Praxis heißt das, daß Ihnen die genannten Adressen völlig zur Verfügung stehen.
b)	Adressen, die in keiner Weise verwendet werden sollten
Von anderen Adressen hingegen müssen wir unsere Finger lassen. Diese haben entweder elementare Funktionen für Betriebssystem oder CPU, oder werden von beiden dauernd geändert, so daß die Datensicherheit in Frage gestellt ist. Genauer soll hier nicht unterschieden werden.
Belassen Sie die Adressen $00 und $01 unverändert, da sie (siehe Memory Map) für die CPU wichtige Informationen beinhalten und außerdem einige Bits nur durch externe Vorgänge geändert werden.
Das Betriebssystem und der Basic-Interpreter beanspruchen alle bislang ungenannten Adressen.
Von Bildschirmeditor und Tastaturabfrage werden die Adressen $C6 - $F6 beeinflußt. Die Adressen $90 - $C2 dienen der Ein-/Ausgabe-Steuerung mit Peripheriegeräten und der Verwaltung offener Files. Einzige Ausnahme: $A0 -$A2 (interne Uhr). Wenn ein Maschinenprogrammm in ein Basic-Programm eingebaut ist, sind die Adressen $03 - $56 sowie $73 - $8B tabu.
c)	Bedingt einsetzbar
Der Vektor $C3/$C4 wird durch RUN/STOP-Restore, RESET oder LOAD beeinflußt. Ansonsten kann mit $C3/$C4 frei verfahren werden.
Ganz Vorsichtige können diesen Vektor auf seinen Ausgangswert $FD30 setzen, sobald das Programm die Adressen $C3/$C4 nicht mehr für eigene Zwecke benötigt.
d)	Adressen, die unter Verzicht auf Kassettenbetrieb verwendet werden können
Die folgenden Adressen können verwendet werden, wenn nicht auf RS232 oder Datasette zugegriffen wird.
$9E/$9F, $A5-$A7, $A9-$AB, $B0-$B6, $F7-$FA
Bei anderen Adressen, die sich auf den RS232- oder Kassettenbetrieb beziehen, ist Vorsicht angebracht.
e)	Geeignete Zwischenspeicher
Die Adressen $22-$2A und $57-$60 sind sogenannte »verschieden genutzte Arbeitsbereiche«. Sie werden vom Basic-Interpreter vor allem bei arithmetischen Operationen als Zwischenspeicher verwendet. Als solche Zwischenspeicher können wir sie auch verwenden. Sobald allerdings bestimmte Interpreterroutinen aufgerufen werden, können die Inhalte dieser Adressen verlorengehen. Eine längerfristige Aufbewahrung von Daten in diesen Adressen ist zwar nicht möglich, andererseits können wir aber durch Schreibzugriffe auf diese Adressen das Betriebssystem oder den Basic-Interpreter nicht stören.
Zu sagen wäre noch, daß die Adressen $57 - $60 den wichtigen Routinen BLTUC und UMULT (siehe »Assembler ist keine Alchimie«) als Zwischenspeicher dienen.
f)	Zeropage kopieren
Zum Abschluß dieses Abschnittes über die Nutzung der Zeropage möchte ich Ihnen noch einen kleinen Trick verraten, der von einigen professionellen Programmen angewandt wird.
Wir sichern die Zeropage-Inhalte in einem anderen Bereich, zum Beispiel von $6F00 an.
Dann können wir viele Adressen in der Zeropage nutzen, sofern wir keine Interpreter- oder Betriebssystemroutine aufrufen. Danach schreiben wir die Zeropage wieder von der Kopie, zum Beispiel von $6F00, zurück und können wie gewöhnlich fortfahren.
Die Adressen 0 und 1 kopieren wir nicht, weil diese nach wie vor für solche Zwecke nutzlos sind. Ebenso könnten wir
,600»	A9	D2	LDA	#D2
,6002	85	14	STA	14
,6004	A9	3F	LDA	#3F
,6006	85	15	STA	15
,6008	A0	00	LDY	#00
,600A	81	14	LDA	(14),Y
,600C	49	FF	EOR	#FF
,600E	91	14	STA	(14),Y
,6010	E6	14	INC	14
,6012	D0	02	BNE	6016
,6014	E6	15	INC	15
,6016	A5	14	LDA	14
,6018	C9	60	CMP	#60
,601A	A5	15	LDA	15
,601C	E9	47	SBC	#47
,601E	90	EA	BCC	600A
Listing 19				
,6000	A9	5F	LDA	#5F
,6002	85	14	STA	14
,6004	A9	47	LDA	#47
,6006	85	15	STA	15
,6008	A0	00	LDY	#00
,600A	Bl	14	LDA	(14),Y
,600C	49	FF	EOR	#FF
,600E	91	14	STA	(14),Y
,6010	A5	14	LDA	14
,6012	D0	02	BNE	6016
,6014	C6	15	DEC	15
,6016	C6	14	DEC	14
,6018	A5	14	LDA	14
,601A	C9	D2	CMP	#D2
,601C	A5	15	LDA	15
,601E	E9	3F	SBC	#3F
,6020	B0	E8	BCS	600A
Listing 20
,6000	A9	00	LDA	#00
,6002	85	14	STA	14
,6004	A9	20	LDA	#20
,6006	85	15	STA	15
,6008	A0	00	LDY	#00
,600A	Bl	14	LDA	(14),Y
,600C	49	FF	EOR	#FF
,600E	91	14	STA	(14),Y
,6010	C8		INY	
,6011	D0	F7	BNE	600A
,6013	E6	15	INC	15
,6015	A5	15	LDA	15
,6017	C9	40	CMP	#40
,6019	D0	EF	BNE	600A
Listing 21				
Kurs
C64
,6000	A9	00	LDA	#00 ,6002	85	14	STA	14 , 6004	A8	TAY ,6005	A9	20	LDA	#20 ,6007	85	15	STA	15 ,6009	AA	TAX ,600A Bl 14	LDA (14),Y ,600C	49	FF	EOR	#FF ,600E 91 14	STA (14),Y ,6010	C8	INY ,6011	D0	F7	BNE	600A ,6013	E6	15	INC	15 ,6015	CA	DEX ,6016	D0	F2	BNE	600A Listing 22	nur einzelne Bereiche kopieren (zum Beispiel die Zeiger für Basic-Programme$16 - $4A). Dann dürfen wiraberauch nur diesen Bereich verändern. Wenn wir nun den Bereich $02 - $FF kopieren, stehen uns folgende Adressen zur Verfügung: $03-$06, $14-$86, $71-$8A, $C3/$C4, $FB-$FF Diese Adressen können Sie nur so lange verwenden, bis eine Routine des Betriebssystems oder Basic-Interpreters aufgerufen wird. Davor muß die alte Zeropage zurückgeschrieben werden. Da Sie auf diese Weise viel Speicherplatz in der Zeropage gewonnen haben, ist es sogar möglich, eine Tabelle aus Geschwindigkeitsgründen in die Zeropage zu verlegen. Damit steigt auch der Wert der indiziert-indirekten Adressierung erheblich. Dennoch ist der Speicherplatz in der Zeropage begrenzt. Überlegen Sie sich also, auf welche Werte besonders schnell zugegriffen werden muß und schreiben Sie vorzugsweise diese in die Zeropage.
70	-.BA $C000	710	LDA #<(ANFANGSADRESSE)
80	-.LI 1,3,0	720	STA ZAEHLER
90		730	LDA #>(ANFANGSADRESSE)
100	—; *******************************	740	STA ZAEHLER+1
110	-; *	QUELLTEXTE (HYPRA-ASS) *	750	LDY #0
120	-; *	==========================	*	760	-SCHLEIFE4 LDA (ZAEHLER),Y
130	-; *	*	770	EOR #$FF
140	-; * FUER VERSCHIEDENE SCHLEIFEN *	780	STA(ZAEHLER),Y
150	— : *	*	790	INC ZAEHLER
160	-; * 28.08.85 BY FLORIAN MUELLER *	800	BNE WEITER
170	— s *	*	810	INC ZAEHLER+1
180	—; *******************************	820	-WEITER	LDA ZAEHLER
190		830	CMP #<(ENDADRESSE+1)
200		840	LDA ZAEHLER+1
210	-; QUELLTEXT ZU LISTING 1	850	SBC #>(ENDADRESSE+1)
220	— 8 ======================	860	BCC SCHLEIFE4
230		870	
240	-.EQ ANFANGSADRESSE = $02	880	
250	-.EQ ENDADRESSE = $FF	890	-; QUELLTEXT ZU LISTING 10
260	-.EQ ZIELBEREICH = $6F00	900	
270		910	— ■
280	LDX #0	920	-.EQ ANFANGSADRESSE = $2000
290	-SCHLEIFEI LDA ANFANGSADRESSE,X	930	-.EQ ENDADRESSE = $3FFF
300	STA ZIELBEREICH,X	940	-.EQ ZAEHLER = $14
310	INX	950	
320	CPX #(ENDADRESSE+l-ANFANGSADRESSE)	960	LDA #<(ANFANGSADRESSE)
330	BNE SCHLEIFE1	970	STA ZAEHLER
340		980	LDA #>(ANFANGSADRESSE)
350		990	STA ZAEHLER+1
360	-; QUELLTEXT ZU LISTING 2	1000	LDY #0
370	! ======================	1010	-SCHLEIFE5 LDA (ZAEHLER),Y
380		1020	EOR #$FF
390	-.EQ ANFANGSADRESSE = $02	1030	STA (ZAEHLER),Y
400	-.EQ ENDADRESSE = $FF	1040	INY
410	-.EQ ZIELBEREICH = $6F00	1050	BNE SCHLEIFE5
420		1060	INC ZAEHLER+1
430	LDX #(ENDADRESSE+l-ANFANGSADRESSE)	1070	LDA ZAEHLER+1
440	-SCHLEIFE2 LDA ANFANGSADRESSE-l,X	1080	CMP #>(ENDADRESSE+1)
450	STA ZIELBEREICH-1,X	1090	BNE SCHLEIFE5
460	DEX	; DEKREMENTIERBEFEHL	1100	“S
470	BNE SCHLEIFE2	1110	— s
480		1120	-; QUELLTEXT ZU EINER SCHLEIFE,
490		1130	-; DIE DEN BEREICH $3FD2-$47D1
500	-; QUELLTEXT ZU LISTING 4	1140	-; KOMPLEMENTIERT
510	—•	======================	1150	
520		1160	-.EQ ANFANGSADRESSE = $3FD2
530	-.EQ ANFANGSADRESSE - $16	1170	-.EQ ENDADRESSE = $47D1
540	-.EQ ENDADRESSE = $4A	1180	-.EQ ZAEHLER = $14
550	-.EQ ZIELBEREICH = $6F00	1190	— •
560		1200	LDA #<(ANFANGSADRESSE)
570	LDX #(ENDADRESSE-ANFANGSADRESSE)	1210	STA ZAEHLER
580	-SCHLEIFE3 LDA ANFANGSADRESSE,X	1220	LDA #>(ANFANGSADRESSE)
590	STA ZIELBEREICH,X	1230	STA ZAEHLER+1
600	DEX	1240	LDX #>(ENDADRESSE+l-ANFANGSADRESSE)
610	BPL SCHLEIFE3 ; PRUEFT N-FLAG	1250	LDY #0
620	~5	1260	-SCHLEIFE6 LDA (ZAEHLER),Y
630		1270	EOR #$FF
640	-; QUELLTEXT ZU LISTING 8	1280	STA (ZAEHLER),Y
650	—■	======================	1290	INY
660		1300	BNE SCHLEIFE6
670	-.EQ ANFANGSADRESSE = $3FD2	1310	INC ZAEHLER+1
680	-.EQ ENDADRESSE = $475F	1320	DEX
690	-.EQ ZAEHLER = $14	1330	BNE SCHLEIFE6
700	“5	1340	
Listing 23		1350	-; ENDE VON LISTING 12
90
C64
Kurs
9.	Schleifenprogrammierung
Zunächst befassen wir uns mit Schleifen, die maximal 256mal durchlaufen werden.
Typ a: Schleifen mit maximal 256 Durchläufen
Da 256 verschiedene Zahlen mit einem 8-Bit-Prozessor dargestellt werden können, verwendet man hier das X- (oder Y-) Register als Schleifenzähler. In Listing 12 sehen Sie die einfachste Form einer Schleife, die die Zeropage-Adres-sen $02 - $FF nach $6F00 kopiert.
Da der Schleifenzähler X in Listing 12 INKREMENTIERT wird, haben wir es mit einer INKREMENTIERSCHLEIFE zu tun. Nach dem Inkrementieren (»6007 INX«) wird durch »6008 CPX # FE« überprüft, ob die Schleife beendet werden kann. Eine eingehendere Beschreibung des Programmablaufs erübrigt sich.
Für Schleifen des Typs a (maximal 256 Durchläufe) ist es aber meist vorteilhaft, eine DEKREMENTIERSCHLEIFE zu verwenden. Wie eine solche Schleife programmiert wird, sehen wir an Listing 13.
Listing 13 unterscheidet sich in der Wirkung nicht von Listing 12, obwohl man dies nicht unbedingt auf den ersten Blick erkennt. Deshalb soll dieses Listing näher besprochen werden. In Zeile 6000 erhält das X-Register den Inhalt $FE. Durch »6002 LDA 01,X« wird damit das letzte Byte der Zeropage, nämlich $FF, zuerst gelesen und nach $7OFE geschrieben. Dann wird X dekrementiert. Ist X noch nicht 0, so wird die Schleife erneut durchlaufen.
Der niedrigste X-Wert innerhalb der Schleife ist folglich 1; aufgrund von »6002 LDA 01,X« ist $02 die niedrigste Zeropage-Adresse, die kopiert wird. In Listing 12 ist 0 der niedrigste X-Wert. Die niedrigste Adresse aufgrund von »6002 LDA 02,X« ist also auch $02 (stimmt auffällig). Warum $FF die höchste kopierte Zeropage-Adresse ist, können Sie nun selbst den Listings 12 und 13 entnehmen.
Listing 14 ist eine Dekrementierschleife, die die Kopie der Zeropage wieder von $6F00 nach $02 zurückholt.
Der Vorteil von Dekrementierschleifen beim Typ a ist, daß zum Erkennen der Abbruchbedingung (X=0) kein Vergleichsbefehl erforderlich ist, weil nach dem DEX-Befehl automatisch das Z-Flag gesetzt wird, wenn X Null wird.
Das Entfallen des Vergleichsbefehls »CPX #« bringt eine Ersparnis von 2 Byte Speicherplatz sowie insgesamt 508 Taktzyklen Rechenzeit. Dajedoch bei 6004 eine Seitenüberschreitung (eine Seite entspricht 256 Byte) vorliegt, schrumpft der Zeitgewinn auf 254 Taktzyklen (dies ließe sich aber vermeiden, indem wir die Zeropage nach $6F01 kopieren, womit durch »6004 STA $6F00,X« keine Seitenüberschreitung auftreten würde).
Nun wollen wir noch einen Sonderfall behandeln:
Dekrementierschleifen vom Typ a, bei denen der Ausgangswert für X < 129 ist.
In Listing 15 sehen Sie eine Schleife, die den Bereich $16 - $4A nach $6F00 kopiert, Listing 16 schreibt die Werte von $6F00 zurück nach $16. Selbstverständlich hätten wir das Problem auch so lösen können wie in Listing 13. Wir wollen aber noch eine andere Konstruktion von Dekrementierschleifen kennenlernen, die in diesem Sonderfall möglich ist. Besprechen wir also Listing 15.
Bei 6000 wird ins X-Register die Zahl geladen, die man zu $16 addieren muß, um $4A zu erhalten. Dadurch wird zunächst bei 6002 die Adresse $4A gelesen und nach $6F34 geschrieben. Bei 6007 wird dekrementiert. Neu ist der Verzweigungsbefehl: es wird das N-Flag überprüft. Ist X = $FF, wird das N-Flag gesetzt und »6008 BPL 6002« beendet die Schleife. Der niedrigste Wert von X, der innerhalb der Schleife vorkommt, ist demnach $00.
Der BPL-Befehl funktioniert nur, wenn der Ausgangswert
,6000	A0	00	LDY	#00 ,6002	B9	00	20	LDA	2000,Y ,6005	49	FF	EOR	#FF ,6007	99	00	20	STA	2000,Y ,600A C8	INY ,600B	D0	F5	BNE	6002 ,600D	EE	04	60	INC	6004 ,6010	EE	09	60	INC	6009 ,6013	AD	09	60	LDA	6009 ,6016	C9	40	CMP	#40 ,6018	D0	E8	BNE	6002 Listing 24

,6000	A0	00	LDY	#00 ,6002	B9	00	40	LDA	4000,Y ,6005	49	FF	EOR	#FF ,6007	99	00	40	STA	4000,Y ,600A C8	INY ,600B	D0	F5	BNE	6002 ,600D	EE	04	60	INC	6004 ,6010	EE	09	60	INC	6009 ,6013	AD	09	60	LDA	6009 ,6016	C9	40	CMP	#40 ,6018	D0	E8	BNE	6002 Listing 25

,6000	A9	00	LDA	#00 ,6002	8D	13	60	STA	6013 ,6005	8D	18	60	STA	6018 ,6008	A9	20	LDA	#20 ,600A	8D	14	60	STA	6014 ,600D	8D	19	60	STA	6019 ,6010	A0	00	LDY	#00 ,6012	B9	FF	FF	LDA	FFFF,Y ,6015	49	FF	EOR	#FF ,6017	99	FF	FF	STA	FFFF,Y ,601A C8	INY ,601B	D0	F5	BNE	6012 ,601D	EE	14	60	INC	6014 ,6020	EE	19	60	INC	6019 ,6023	AD	19	60	LDA	6019 ,6026	C9	40	CMP	#40 ,6028	D0	E8	BNE	6012 Listing 26
von X <129 ist. Andernfalls wäre nämlich nach dem Dekre-mentieren X>127 und damit das N-Flag gesetzt. Dies aber hätte zur Folge, daß die Schleife nur 1mal durchlaufen würde.
Zur soeben behandelten Schleifenkonstruktion sind noch zwei Dinge zu sagen; erstens, daß sie nur in diesem Sonderfall (X<129) möglich ist, und zweitens, daß sie nicht effektiver als eine Lösung wie in Listing 13 ist.
Allgemeine Gültigkeit hat aber folgende Regel für Schleifen vom Typ a:
Bei Schleifen vom Typ a ist Dekrementieren effektiver als Inkrementieren, solange die Durchlaufzahl nicht 255 überschreitet.
Bei 256 Durchläufen erweist sich Inkrementieren oft als besser.
91
Kurs
C64
An Listing 17 sehen wir ein Beispiel für den letzten Satz der Regel. Listing 17 kopiert die letzten 256 Speicherplätze des Stapels ($0100 - $01FF) und den Stapelzeiger nach $6F00 - $7000. Listing 18 schreibt den Stapel wieder zurück.
Die Dekrementierschleife (6000 - 600A) kopiert nun den Bereich $0101 - $O1FF, $0100 wird nicht übertragen. Dies geschieht in 600B - 600F. Eine andere Möglichkeit wäre ein zeitraubender CPX #FF-Befehl nach »6008 DEX«.
6011 - 6013 sichert schließlich noch das SP-Register.
Hier ist in der Tat eine Inkrementierschleife besser. Ändern wir Listing 17 also in Listing 17a:
	LDX #00	
- LOOP	LDA 0100,X	
-	STA 6F00,X	
	INX	;(!!)
-	BNE LOOP	
-	TSX	
-	STX 7000	
Analog ergibt sich Listing 18a:
	LDX #00	
- LOOP	LDA 6F00,X	
-	STA 0100,X	
	INX	;(!!)
—	BNE LOOP	
-	LDX 7000	
-	TXS	
In den Listings 17a und 18a habe ich diejenigen Befehle, die sich in der symbolischen Darstellung nicht von den Listings 17 und 18 unterscheiden, mit einem »-« markiert. Typ b: Schleifen mit mehr als 256 Durchläufen
Während Schleifen des Typs a meist so schnell abgearbeitet werden, daß man es gar nicht bemerkt, dauern Typ-b-Schleifen oft eine oder mehrere Sekunden.
Deswegen wollen wir hier versuchen, den Zeitbedarf von Typ-b-Schleifen zu verringern.
Unsere erste Typ-b-Schleife (Listing 19) soll den Bereich von $3FD2 bis $475F invertieren (= EOR # FF-verknüpfen,
,6000	A9	D2	LDA	#D2
,6002	8D	11 60	STA	6011
,6005	8D	16 60	STA	6016
,6008	A9	3F	LDA	#3F
,600A	8D	12 60	STA	6012
,600D	8D	17 60	STA	6017
,6010	AD	00 00	LDA	0000
,6013	49	FF	EOR	#FF
,6015	8D	00 00	STA	0000
,6018	EE	11 60	INC	6011
,601B	EE	16 60	INC	6016
,601E	D0	06	BNE	6026
,6020	EE	12 60	INC	6012
,6023	EE	17 60	INC	6017
,6026	AD	11 60	LDA	6011
,6029	C9	60	CMP	#60
,602B	AD	12 60	LDA	6012
,602E	E9	47	SBC	#47
, 6030	90	DE	BCC	6010
Listing 27				
ausjeder 1 wird eine 0 und umgekehrt). Da hierfür ein 8-Bit-lndexregister nicht ausreicht, benötigen wir einen 16-Bit-Zähler, nämlich$14/$15. DiesersollimmerdieAdressebein-halten, die invertiert wird. In diesen Zähler schreibt die Initialisierung der Schleife den Startwert $3FD2 (siehe $6000 -$6007).
Da es beim 6510 keine indirekte Adressierung für LDA/STA gibt, sbndern nur die indirekt-indizierte oder indiziertindirekte, müssen wir auf eine dieser Adressierungen ausweichen und den Index auf 0 setzen (»6008 LDY #00«),
Bei $600A beginnt die Schleife: der Wert wird eingelesen, mit $FF EOR-verknüpft und zurückgeschrieben. Nun wird der 16-Bit-Zähler $14/$15 erhöht (6010 - 6015). Dann wird
,6000	A2	00		LDX	#00
,6002	8E	11	60	STX	6011
,6005	8E	14	60	STX	6014
,6008	A2	A0		LDX	#A0
,600A	8E	12	60	STX	6012
,600D	8E	15	60	STX	6015
,6010	AE	00	00	LDX	0000
,6013	8E	00	00	STX	0000
,6016	EE	11	60	INC	6011
,6019	EE	14	60	INC	6014
,601C	D0	F2		BNE	6010
,601E	EE	12	60	INC	6012
,6021	EE	15	60	INC	6015
,6024	AE	12	60	LDX	6012
,6027	E0	C0		CPX	#C0
,6029	D0	E5		BNE	6010
Listing 28					
80	-.BA $6000	
90 100	-.LI 1,3,0 ~5	
110	—5 HYPRA-ASS-QUELLTEXT ZU EINER	
120	SELBSTMODIFIZIERENDEN SCHLEIFE	
130 140	-; (ARBEITET WIE LISTING 5)	
150 160 170	-; 1985 BY “5	FLORIAN MUELLER
180	-.GL START	= $A000
190 200	-.GL ENDE — 5	= SBFFF
210		LDX #<(START)
220	—	STX MODl+1
230	—	STX M0D2+l
240	—	LDX #>(START)
250	-	STX M0Dl+2
260	-	STX MOD2+2
270	-MODI	LDX $FFFF
280	-M0D2	STX $FFFF
290		INC MODl+1
300	—	INC M0D2+l
310	—	BNE MODI
320		INC MQDl+2
330	_	INC M0D2+2
340	—	LDX MQDl+2
350		CPX #>(ENDE+1)
360	- Listing 29		BNE MODI
92
C64
Kurs
100 110 120
130
140
150
160
170
180
190
200 210
220
230
240
250
260
270
280
290
300
310
320
330
340
350
360
370
380
390
400
410
420
430
440
450
460
470
480
490
500
510
520
530
540
550
560
570
580
590
600
610
620
630
640
650
660
670
680
690
700
710
720
730
740
750
760
770
780
790
800
810
820
830
840
850
860
870
880
890
900
910
920
930
940
950
960
970
980
990
1000 1010 1020
1030
1040 1050 1060
1070
-.BA $0801
-.OB "LOADER-MAKER 64,P,W"
*****************************
* L 0 A D E R - M A K E R *
*****************************
* EIN PROGRAMMGENERATOR *
* VON FLORIAN MUELLER *
*****************************
-.GL BASIN	= $FFCF
-.GL SETPAR = $FFBA	
-.GL SETNAM = $FFBD	
-.GL LOAD	= $FFD5
-.GL READY	= $A474
-.GL NUMOUT = $BDCD	
-.GL TASTPF = 631 ; TASTATURPUFFER	
-.GL ANZAHL = 198 ; ENTHAELT ANZAHL	
	DER ZEICHEN IM
— 5	TASTATURPUFFER
-.GL KASSPF = 828 ; KASSETTENPUFFER	
5	
-.MA PRINT	(TEXT)
—	LDA #<(TEXT)	; MAKRO
—	LDY #>(TEXT)	; FUER
—	JSR $ABlE	; TEXTAUSGABE
-.RT	
— 5	
	
— 5	
— :	
-.WO LINK+	1 ; LINKPOINTER
-.WO 1985	; ZEILENNUMMER
-.BY $9E	; TOKEN FUER "SYS"
—	.TX "2061"
-LINK	.BY 0,0,0	; ENDMARKIERUNG
	DER BASIC-ZEILE
-SYSTEM	LDX #0	; FLAG FUER SYSTEM-
-	STX $9D	; MELDUNGEN SETZEN
	LDX #$49	; DEKR.-ZAEHLER
-SCHLEIFE1	LDA ABLAGE,X ; LADEROUTINE
—	STA KASSPF,X ; VON ABLAGE IN
—	DEX	; DEN BEREICH
—	BPL SCHLEIFE1 ; KOPIEREN, IN
	DEM SIE LAEUFT
~5	JMP KASSPF	; & STARTEN
-; ES FOLGT DIE LADEROUTINE, DIE HIER	
-; AN FALSCHER STELLE ABGELEGT IST UND	
-; VON DER	"SCHLEIFEI" (600-640) IN
-; DEN ORIGINALBEREICH GESCHRIEBEN WIRD.	
-ABLAGE	LDA #1	; FILENUMMER #1
—	TAY	; SEKUNDAERADRESSE #1
-GERAETENR	LDX #0	; GERAETEADRESSE #?
-	JSR SETPAR	; PARAMETER SETZEN
-LAENGE	LDA #0	; LAENGE DES FILENAMEN
—	LDX #<($35C)	; ADRESSE DES
—	LDY #>($35C)	; FILENAMEN: $035C
-	JSR SETNAM	; NAMEN SETZEN
	LDA #0	; FLAG FUER "LADEN"
—	JSR LOAD
-FEHLER	BCS LOADERROR ; LADEFEHLER?
-START	JMP 0	; ZUR STARTADRESSE
-LOADERROR	LDX #$lD	; "LOAD ERROR"
-	JMP ($300)	; AUSGEBEN
-NAME	.BY 0,0,0,0	; 16 BYTES
—	.BY 0,0,0,0	; FUER FILENAMEN
—	.BY 0,0,0,0	; RESERVIEREN
-	.BY 0,0,0,0
-BASIC	STX $2D	; POINTER FUER
—	STY $2E	; PROGRAMMENDE SETZEN
—	JSR $E544	; = PRINT CHR$(147)
—	LDX #3	; 3 BYTES IN
-	STX ANZAHL	; TASTATURPUFFER
-SCHLEIFE2	LDA $0383,X	j AUS DER TABELLE
—	STA TASTPF,X ; IN ZEILE 1100
—	DEX	; KOPIEREN
—	BPL SCHLEIFE2
1080 -	JMP READY	; WARMSTART 1090 -; 1100 -.BY "R",$D5,13 ; "R",SHIFT U,RETURN 1110 -; 1120 -; HIER ENDET DER PROGRAMMTEIL, 1130 -; DER MODIFIZIERT WIRD. 1140 -; ES FOLGT DIE MODIFIKATIONSROUTINE: 1150 -; 1160 -MDFIKATOR JSR $E544	; = PRINT CHR$(147) 1170-...PRINT (TEXT1) 1180 -; STARTADRESSE HOLEN 1190 -; 1200 -	JSR	$AEFD	j	PRUEFT AUF KOMMA 1210 -	JSR	$AD8A	;	HOLT PARAMETER 1220 -	JSR	$B7F7	;	NACH $14/$15 1230 -; 1240 -	LDX	$14	;	STARTADRESSE 1250 -	LDA	$15	;	HOLEN, 1260 -	STX	START+1	;	IM PROGRAMM 1270 -	STA	START+2	;	ABLEGEN UND 1280 -	JSR	NUMOUT	;	UND AUSGEBEN 1290 -; 1300 -; 1310 -; NUN WIRD NOCH DER ZU MODIFIZIERENDE 1320 —5 PROGRAMMTEIL IN DEN AUSGANGSZUSTAND 1330 -; GEBRACHT: 1340 -; 1350 -	LDX	#15	;	NAMEN MIT NULL-BYTES 1360 -	LDA	#0	;	BELEGEN 1370 -SCHLEIFE3 STA	NAME,X	;	DURCH EINE 1380 -	DEX	;	DEKREMENTIER- 1390 -	BPL	SCHLEIFE3 ;	SCHLEIFE 1400 -; 1410 -	STA SYSTEM+1	; KEINE SYSTEMMELDUNGEN 1420 -; 1430 -	LDA #3	; SPRUNGWEITE = 3 1440 -	STA FEHLER+1 1450 -; 1460 -	LDA #$A2	; OPCODE FUER "LDX #" 1470 -	STA GERAETENR 1480 —; 1490 -; 1500 -; AN DIESER STELLE IST DAS "GERUEST" 1510 -; (DER ZU MODIFIZIERENDE TEIL) 1520 -; IM AUSGANGSZUSTAND 1530 -; 1540 -; 1550 -; EINGABE DES FILENAMEN	
1570 -; 1580 -...PRINT (TEXT2) 1590 -	LDX	#0	;	ZAEHLER AUF 0 1600 -SCHLEIFE4 JSR	BASIN 1610 -	CMP	#13	;	ENDE DER EINGABE? 1620 -	BEQ	WEITER1	5	JA=>WEITER 1630 -	STA	NAME,X	;	BYTE ABLEGEN 1640 -	INX 1650 -	CPX	#16	;	16 ZEICHEN MAX. 1660 -	BNE SCHLEIFE4 ; NAECHSTES ZEICHEN 1670 -; 1680 -; WENN DIESE STELLE DURCHLAUFEN WIRD, 1690 -; HAT DAS X-REGISTER DEN WERT 16. 1700 -; 1710 -; BEI "WEITER1" HINGEGEN KANN ES AUFGRUND 1720 -; DES BRANCH-BEFEHLS "BEQ WEITER1" 1730 -; UNTERSCHIEDLICHE WERTE HABEN. 1740 -; 1750 -WEITER1 STX LAENGE+1 1760 -; 1770 -; 1780 -; EINGABE DER GERAETEADRESSE	
1/7u —; 1800 -; 1810 -. 1820 -1830 -1840 -1850 —; 1860 —; 1870 -1880 -1890 -; 1900 -; 1910 -; 1920 -; 1930 -; 1940 -; 1950 -; 1960 - 1970 -1980 -1990 -2000 — 5 2010 -; 2020 -; 2030 -; 2040 -; 2050 -Wl	..PRINT (TEXT3) JSR BASIN	;	HOLT ZEICHEN SEC	;	VOR SUBTRAKTION SBC #"0"	;	IM AKKU STEHT JETZT DIE ZAHL STA GERAETENR+1; ABLEGEN BNE WEITER2	; GERAET<>0 : WEITER DA ALS GERAETENUMMER 0 EINGEGEBEN WURDE, MUSS DER GESAMTE BEFEHL "LDX #GERAET" IN "LDX $BA" UMGEWAENDELT WERDEN, DAMIT DAS NACHLADEN VON DEM GERAET ERFOLGT, VON DEM DER LADER EINGELESEN WIRD. LDA #$A6	; OPCODE FUER "LDX ZP" STA GERAETENR LDA #$BA	; "LDX $BA" STA GERAETENR+1; GENERIEREN MASCHINENPROGRAMM (J/N)?
	EITER2 ... PRINT(TEXT4)
Listing 30
93
Schaffen Sie si<h ein interessantes Nachsdilaqewerk und gleichzeitig ein wertwIles Ardiiv!
Kennen Sie alle Ausgaben von 64’er? Suchen Sie einen ganz bestimmten Testbericht? Oder haben Sie einen Tbil eines interessanten Kurses versäumt? Suchen Sie nach einer spezieUen Anwendung?
Damit Sie jetzt fehlende Hefte mit »Ihrem« Artikel nachbesteUen können, finden Sie auf diesen Seiten eine ZusammensteUung aller wesentiichen Artikel von Ausgabe 4/84 bis Ausgabe 3/85.
Und so kommen Sie schneU an die noch lieferbaren Ausgaben: Prüfen Sie, welche Ausgabe in Ihrer Sammlung noch fehlt, oder welches Thema Sie interessiert. Tragen Sie die Nummer dieser Ausgabe und das Erscheinungsjahr (z.B, 2/85) auf dem BesteUabschnitt der hier eingehefteten Bestell-ZaMkarte ein. Die ausgefüUte ZaHkarte einfach heraustrennen und Rechnungsbetrag beim nächsten Postamt einzahlen. Ihre BesteUung wird nach Zahlungseingang umgehend zur AusUeferung gebracht.
Stichwort	Titel	Seite	Ausgabe
Computer	AktueU Die neuen — 264 und 364 (von der CES in Las Vegas)	9	4/84
	Heiße Messe in der Wüste: CES (PC 128, PC 10, Commodore LCD)	8	3/85
DFÜ	Datex-P und ausländische Netzwerke	59	10/84
	Interessant bis brisant — die elektronischen Brief-	10	12/84
	kästen Internationaler Chaos Communiction Congress	15	3/85
	Kreatives Chaos (Interview mit dem CCC)	12	10/84
	MCI Mail: die schnelle Post	8	2/85
Floppy	Neues 1451-Laufwerk	14	3/85
	SFD 1002	8	9/84
Messen	Consumer Electronics Show in Chicago	10	8/84
Musik	Musikneuigkeiten aus den USA — MIDI	44	9/84
Abtippen	Listings zum Abtippen Anwendung Checksummer (C 64 und VC 20)	72	1/85
	Checksummer (C 64 und VC 20)	65	2/85
	MSE — Abtippen sicher und leicht gemacht	68	2/85
	MSE — Abtippen sicher und leicht gemacht	78	3/85
	Neuer Checksummer 64 — blitzschnell und kürzer	68	3/85
DFU	Mailboxprogramm für den C 64	114	9/84
EPROM	Datenbrennerei: Wie programmiere ich EPROMs?	162	9/84
Familie	Familienplanung mit dem VC 20 (AdM)	52	2/85
Finanzen	Abgerechnet wird mit dem C 64 (AdM)	68	8/84
	Menügesteuerte Finanzmathematik (AdM)	68	10/84
Floppy	Drucker/Floppy ein- oder ausgeschaltet?	77	8/84
	Hypra-Load: Schnelles Laden von Diskette QdM)	67	10/84
Kalender	Elekronisches Notizbuch fVC 20)	50	4/84
Maske	Bildschirmasken schnell erstellt	78	9/84
Mathematik	Mathematical-Basic: Das Super-Basic für den	50	12/84
Monitor	VC 20 (LdM) Ohne gutes Werkzeug geht es nicht: SMON (Teil 2)	61	12/84
	Ohne gutes Werkzeug geht es nicht: SMON fTeil 3)	69	1/85
	Ohne gutes Werkzeug geht es nicht: SMON fTeil 4)	72	2/85
Musik	Die Musik macht der C 64: Elektronikorgel (AdM)	70	9/84
	Musik, Musik, Musik: Synthesizer (AdM)	51	12/84
Sport	Computer und Sport — Auswertung von	56	4/84
	DMM-Ereignissen Der C 64 als HandbaUtrainer (AdM)	52	1/85
	Gut Ziel mit dem C 64 (AdM)	52	3/85
	Ohne Organistaion kein Tor: Ligatab (LdM)	50	3/85
Super 8	VC 20 steuert Super8-Kamera	70	2/85
User-Port	Analoger Meßwert rein — analoger SteUwert raus	78	8/84
	Kopplung über den User-Port fVC 20)	73	8/84
Video	Video-Vorspann mit dem VC 20	80	10/84
Zeichensatz	Deutscher Zeichensatz für den VC 20	79	9/84
Algorithmus	Grafik Ein schneller Drawüne-Algorithmus	65	4/84
Axiometrie	Von allen Seiten betrachtet (SB)	69	12/84
Befehls-	Screen Change	94	9/84
erweiterung			
Elektro-	Elektrotechnisches Zeichnen mit dem VC 20	71	3/85
technik			
Funktionen	Kudiplo erfüllt Schülerträume 0Curvendiskussion auf	80	8/84
Grafik	dem VC 20) Bewegte Grafik und Text mischen	66	12/84
Hardcopy	1520-Hardcopy mit dem VC 20	87	9/84
	Der VC 1525/MPS 802 als Grafikdrucker	83	10/84
	Die mehrfarbige Hardcopy mit dem 1520-Plotter	84	10/84
	Hardcopy Epson FX-80	88	10/84
	Hardcopy Gemini-10X	85	10/84
	Hardcopy MPS 801/VC 1515	82	10/84
	Hardcopy für den Sieger (FX-80 mit Görlitz-Interface)	83	8/84
Schnitt-	Olympia compact 2: ein Centronics-Interface	86	10/84
stellen			
Sprites	Der Super-Sprite-Editor	89	9/84
	Sprites schneller bewegen	70	4/84
	Vier Pseudo-VICs mit 32 Sprites	76	1/85
Zeichnen	HI-EDDI: Ein fantastisches Zeichen und	50	1/85
Abenteuer	Malprogramm (LDM) Spiel Castle of Doom — Adventure (LdM)	66	8/84
	Das Grab des Pharao (LdM)	51	2/86
Action	Apocalypse now	106	10/84
	Q + Bert^C20)	78	2/85
Arcade	Invaders	74	4/84
Stichwort	Titel	Seite Ans-
		gabe
Denkspiel	3D-Vier gewinnt — Spielen in der dritten Dimension	96	12/84
	Mastermind als Vierzeiler	81	12/84
Generator	Spring Vogel, spring QxiM)	68	9/84
Pacman	Pac-Boy — die Herausforderung	89	8/84
Reaktion	Escape fVC 20)	86	8/84
	Rennfahrer ohne Sturzhelm fVC 20)	86	4/84
Strategie	Schiebung fVC 20)	77	9/84
Taktik	Epedemic jvC 20)	112	10/84
	Gehirntraining mit Supermemory	81	2/85
	Kämpfe wie im alten Rom — Caesar	78	4/84
Wettbewerb	Notlandung	156	2/85
	Tips & Tricks	
Auto	Automatische Zeilennumerierung	84	12/84
Autoboot	Autoboot beim C 64	86	3/85
Autostart	Autostart für den VC 20	98	8/84
Basic	Basic-Zeilen genau betrachtet	87	2/85
Basic-	PRINT AT und RESTORE N 0/C 20)	101	8/84
Erweiterung		
	Stringy: C 64-Erweiterung	86	12/84
Buchstaben	Große Buchstaben	89	1/85
Datasette	Fast Tape — die schneUe Kassette 0/C 20)	80	12/84
	Musik aus der Datasette	84	12/84
Direktmodus	Programmierter Direktmodus	82	12/84
Floppy	22 Read Error — Theorie und Praxis	41	3/85
	Auf das " I" kommt es an	92	12/84
	Disk Copy	92	4/84
	Diskette intern ^isk-Dump)	95	10/84
	Disketten-Organisation 0/C 20)	97	10/84
	Floppy-Lister	82	3/85
	Hypra-Load mal vier	82	1/85
	Kopieren mit Komfort: Super Copy	102	10/84
	Maschinenprogramme auf Diskette speichern	91	2/85
	View BAM	99	8/84
Funktionen	Kudiplo auf für den C 64 (Kurvendiskussion)	91	10/84
Grafik	Tips und Erweiterungen zu Hi-Eddi und Simons	88	3/85
	Basic	
Joystick	Cursorsteuerung leicht gemacht (mit Joystick)	86	2/85
Listing	Der große Überblick: formatiertes Listing	90	10/84
	Fehlersuche leicht gemacht: LIST-STOP	97	9/84
	Progranfmiertes LISTing: LIST X-Y	100	10/84
Listschutz	List- und Löschschutz leicht gemacht	85	12/84
Maschinen-	Maschinenprogramme auf Tastendruck	80	12/84
sprache	DATA-Wandler	102	9/84
Merge	Kleben per Software — Merge	94	4/84
Monitor	Besseres Monitorbild beim C 64	90	2/85
Opcodes	Hex-ereien: undefinierte Opcodes beim 6502	84	3/85
POKEs	Durch POKEs zum Erfolg — Die Spiele-Trickkiste	83	3/85
	POKE mal wieder: diverse POKEs	91	10/84
Parameter	Parameterübergabe an Programme in Maschinen-	88	1/85
	sprache	
Reset	Resetschalter am C 64	34	8/84
Restore	Restore für Unterprogramme	90	1/85
Retten	Erste Hilfe 0/C 20)	88	4/84
	Erste Hilfe für den C 64: RENEW	102	9/84
Schnitt-	Die RS232-Schnittstelle am VC 20	100	9/84
stellen	Verbindungsfreundlich fVC 20)	91	3/85
ScroUen	Als die Bilder laufen lernten ... (Scrollen)	88	2/85
Basic	Haben Sie den Bogen raus? (ARC bei Simons Basic)	98	9/84
	Simons Basic: Befehle die nicht im Handbuch stehen	103	9/84
Speicher	RAM-Floppy	92	2/85
Synthetische	Die Suche nach den Synthetischen	104	9/84
Tastatur	User-Port-Tastatur (Zehnertastatur)	93	10/84
Tips & Tricks	Diverse	89	10/84
	Lösung von Dallas Quest	90	1/85
Trace	Trace und Single Step für Maschinenprogramme	76	12/84
	Der C 64 als PET	87	1/85
	Die Software-Vielfalt der CBMs für den C 64 nutzen	102	8/84
	Von den Kleinen auf die Großen (C 64 - CBM)	96	8/84
User-Port	User-Pprt-Display	97	8/84
	User-Port-Tastatur (Zehnertastatur)	93	10/84
	Hardware*Test	
80-Zeichen-	Mehr Übersicht am Bildschirm 0/C 20)	20	10/84
karten		
Computer	Generationswechsel — Test C 16	6	1/85
	Plus und Minus beim Plus/4	14	2/85
Drucker	Adcomp X100 — farbig plotten und drucken	22	10/84
	Brother HR-5C: fast nicht zu hören	24	10/84
Stichwort	Titel	Seite	Ausgabe
	Ein Drucker für alle Fälle: Epson FX-80	23	10/84
	Ein Star der es in sich hat (delta-10)	25	10/84
	Olympia electronic compact 2: Schreibmaschine für den C 64	28	10/84
	Roland DXY-101 — ein Flachbettplotter im	27	10/84
	DIN-A3-Format Seikoshas Größter: Test GP-550A	26	10/84
EPROM	EPROM-Brenner: Vergleichstest	36	8/84
Expansions	Expansions über alle Grenzen hinaus	34	4/84
Floppy	Floppy mit Nachbrenner (Speeddos, Turboaccess, Computing)	26	12/84
Interface	Das macht den Kleinen größer (64-KByte-Karten) 0/C20)	112	9/84
	Digitalisierte Bilder mit dem C 64	24	1/85
	Speichertuning für VC 20: MR 64	26	1/85
Joystick	Joystick-Vielfalt (20 Joysticks im Test)	34	12/84
Monitore	Die Scharfmacher (Cable, Taxan, BMC)	20	12/84
Schnitt-	Card/Print + G — Das Allround-Interface (Centronics)	20	3/85
stellen	Das Interface mit Weitblick GVW-92000/G: Centronics)	18	3/85
	Hardware-Interface ganz weich: EC-64	23	1/85
Sprachaus-	Die Stimme des Meisters: Voice Master	19	2/85
gabe	Sprachausgabe mit dem SDP 120	22	8/84
	Hardware		
Bauanleitung	16-KByte-Erweiterung umschaltbar fVC 20)	20	2/85
	Commodore im neuen Kleid	30	8/84
	Das 30-Mark-Interface (RS232)	29	3/85
	Ihr Akustikkoppler wird zum Modem: Automodem	114	9/84
	Joystick im Selbstbau	33	3/85
	Resetschalter am C 64	34	8/84
	Richtig verbunden — Video/Audio-Kabel für den C64	22	2/85
DFÜ	Akustikkoppler und Modems: Marktübersicht	28	8/84
Drucker	MPS 801 — Ein Erfahrungsbericht	20	8/84
	Marktübersicht: Drucker (Teil 1)	29	10/84
EPROM	Nichts ist ewig (ROM-Change, verbessertes Betriebs-sytem)	30	12/84
Monitor	Richtig verbunden — Video/Audio-Kabel für den C64	22	2/85
Musik	MIDI — Glarus und Elend eines Interfaces	46	9/84
Reparatur	Geheimnissen auf der Spur: 1541 reparieren	24	8/84
Schnitt-	Erst ein IEC-Bus öffnet Tür und Tor fMarktübersicht	24	3/85
stellen	und Test) Gute Connections fRS232-, Centronics- Marktübersicht)	21	3/85
	Kurse		
Assembler	Assembler ist keine Alchimie (Teil 1)	138	9/84
	Assembler ist keine Alchimie (Teil 2)	150	10/84
	Assembler ist keine Alchimie (Teil 4)	134	12/84
	Assembler ist keine Alchimie (Teil 5)	142	1/85
	Assembler ist keine Alchimie fTeil 6)	134	2/85
	Assembler ist keine Alchimie fTeil 7)	124	3/85
Codes	Alle Tasten-, Zeichen- und Steuercodes (Teil 4)	151	8/84
Comal	Comal — Eine Einführung (Teil 2)	145	12/84
	Comal — Eine Einführung (Teil 3)	130	2/85
Eff. Prog.	Finden mit System — Eine neuartige Suchmethode fTeil3)	148	3/85
	Müllabfuhr im Computer: Die Garbagge Collection (Teil 1)	122	1/85
	Stringprogrammierung in Maschinensprache (Teil 2)	147	2/85
Floppy	In die Geheimnisse der Floppy eingetaucht fTeil 1)	153	10/84
	In die Geheimnisse der Floppy eingetaucht (Teil 3)	139	12/84
	In die Geheimnisse der Floppy eingetaucht fTeil 4)	148	1/85
	In die Geheimnisse der Floppy eingetaucht fTeil 5)	130	3/85
Grafik	Hires 3 (Teil 1)	123	2/85
	Hires 3 fTeil 2)	136	3/85
	Reise durch die Wunderwelt der Grafik fTeil 5)	142	8/84
	Reise durch die Wunderwelt der Grafik fTeil 6)	144	9/84
	Reise durch die Wunderwelt der Grafik fTeil 7)	146	10/84
Grundlagen	Geschwindigkeit durch Maschinencode — so arbeiten Compiler	39	2/85
Musik	Dem Klang auf der Spur fTeiI 1)	131	12/84
	Dem Klang auf der Spur fTeil 2)	136	1/85
Stichwort
Titel
Seite Ausgabe
Precompiler	Dem Klang auf der Spur (Teil 3) Strubs — ein Precompiler für Basic-Programme (Teil 1)	152 110	2/85 4/84
Speicher	Memory Map mit Wandervorschlägen (Teil 2)	132	12/84
	Memory Map mit Wandervorschlägen (Teil 3)	127	1/85
	Memory Map mit Wandervorschlägen (Teil 4)	150	2/85
	Memory Map mit Wandervorschlägen (Teil 5)	144	3/85
VC20	Der gläserne VC 20 (Teil 1)	155	9/84
	Der gläserne VC 20 CTeil 2)	157	10/84
	Der gläseme VC 20 fTeil 4)	130	1/85
	Der gläserne VC 20 (Teil 5)	141	2/85
	Der gläserne VC 20 (Teil 6)	155	3/85
Spiele-Test			
Abenteuer	Die Lösung von Hobbit	49	2/85
	Gordon Saga	48	2/85
	Gruds in Space	137	8/84
	House of Usher	37	10/84
	Lösung von Dallas Quest	90	1/85
	Lösung von Enchanter	44	3/85
	Lösung von The Blade of Blackpool	34	10/84
	The Quest	47	1/85
Action	Flip and Flop	48	4/84
	Impossible Mission	46	2/85
	QX 9, Catastrophes	48	12/84
	Save New York und Survivor	46	4/84
	Tom + Zaga	48	1/85
	Wizard	49	12/84
Arcade	Fire Galaxy fVC 20)	37	10/84
	Schnellboot — Rettung aus der grünen Hölle	109	9/84
Flipper	Slamball — der ellenlange Flipper	105	9/84
Grundlagen	Fantasy-Spiele	106	9/84
Sport	One on One	136	8/84
	Spiel des Jahres: International Soccer	46	12/84
	Summer Games — Los Angeles läßt grüßen	138	8/84
Taktik	Taktik- und Strategiespiele	46	3/85
So machen’s andere
Amateurfunk Datenbank Finanzen Landwirtschaft Lichttelefon
Funkende Computer
Klein aber oho — der VC 20
Geregelter Zahlungsverkehr
Der Computer im Kuhstall
132
136
164
156
4/84
4/84
9/84
8/84
Mit vier Baud über den Balkon
166
10/84
Software-Test			
Assembler	Assembler im Test (AS-64, MAE, T.EX.AS., ASSI/M)	34	1/85
	Assembler im Test: Mastercode, Profimat, Profisoft,	30	2/85
	Maschine 64 Assembler? Assembler!	32	1/85
Basic-	GBasic	28	1/85
Erweiterung			
CP/M	Erste Erfahrungen mit dem CP/M-Modul	18	4/84
Compiler	Basic-Programme auf Trab gebracht: Austro-Speed,	34	2/85
DFÜ	BASS, Exbasic, Petspeed Terminal 64 — Schwer auf Draht	24	2/85
Datenbank	ISM 64 — ohne Fleiß kein P/eis	117	8/84
Finanzen	Lohnsteuerjahresausgleich leicht gemacht	46	10/84
Floppy	Ex-DOS und Disk Doctor	48	10/84
	Quickcopy — das schnelle Kopierprogramm	28	9/84
Grafik	Elektronische Aquarelle: Paint Magic	114	8/84
	Graphics-Basic (HES)	38	12/84
Lern-	Melodienschreiber und Musik-Synhthesizer	43	12/84
programme			
	Nachhilfe auf Knopfdruck (Mathematik)	26	2/85
	SoftLearning — die weiche Welle des Lernens	40	1/85
	Vokabeltraining mit dem Computer	39	3/85
	Was bringt die Lern-Software?	42	12/84
Mathematik	Nachhilfe auf Knopfdruck (Mathematik)	26	2/85
Musik	Gute Noten für gute Noten: Extendend Synthesizer	24	9/84
	System Melodienschreiber und Musik-Synthesizer	43	12/84
	Music-Composer — Komponieren leicht gemacht	42	9/84
	Musicalc — oder was wirklich im C 64 steckt	29	9/84
	Synthimat — Das Piano für den Aktenkoffer	38	9/84
Sprachen	Die Turbo-Pascal-Story	40	12/84
	Forth ohne Floppy (C 64 und VC 20)	50	10/84
	Oxford-Pascal für den Commodore	39	12/84
	Pascal — leistungsfähiger und eleganter als Basic	44	8/84
	(Teil 2) Sechs Pascal-Versionen im Vergleich	50	8/84
Tabellenkal-	Calc Result — Dreidimensionale Kalkulation	21	9/84
kulation			
Textverarbei-	Homeword — Textverarbeitung zu Hause	36	3/85
tung	Textomat — Büroanwendung zum kleinen Preis	34	9/84
	Totl-Text — Flexibilität ist Trumpf	38	3/85
	Vizawrite 64 — Der C 64 wird zum PC	43	10/84
Vokabeln	Vokabeltraining mit dem Computer	39	3/85
Basic	Software Fehlersuche in Basic-Programmen (Teil 2)	67	9/84
Compiler	Geschwindigkeit durch Maschinencode — so	39	2/85
DFÜ	arbeiten Compiler Datex-P und ausländische Netzwerke	59	10/84
	MaiIboxprogramm für den C 64	114	9/84
EPROM	Datenbrennerei: Wie programmiere ich EPROMs?	162	9/84
Floppy	22 Read Error — Theorie und Praxis	41	3/85
Grafik	Neues vom Video-Chip beim VC 20	56	8/84
Grundlagen	Datenkreislauf: Die sequentieUe Datenspeicherung	63	8/84
	Die index-sequentieUe Datei	54	9/84
	Flußdiagramme	20	9/84
	So macht man Basic-Programme schneUer (Teil 2)	44	12/84
	Tips für den Umgang mit Sinnbildern (Fluß-	14	9/84
	diagrammen) Tips für sauberes Programmieren	38	4/84
Musik	Hard und Soft: eine kleine Marktübersicht	58	9/84
	Klangsynthese und Synthesizertechnik	62	9/84
	Markübersicht der Musikprogramme	27	9/84
Sprachen	Basic ist out — Es lebe Forth	43	1/85
	Pascal — leistungsfähiger und eleganter als Basic	44	8/84
	Was ist Comal?	41	8/84
Textverarbei-	Von der Schreibmaschine zum Textsystem	34	3/85
tung Tips	(AuswahIhUfe) DOS 5.1 (Teil 2)	16	9/84
Wettbewerbe
Einzeiler	Einzeiler-Wettbewerb: Die nächsten 14
Kreuz-	Kreuzworträtsel selber machen
worträtsel Unter-	Formatierte Eingabe
programm	Sieger mit Maske — Maskenerstellungsprogramm
157	1/85
151	12/84
156	1/85
172	10/84
Alle Beiträge sind in der Regel für den C 64, sofern nicht anders gekennzeichnet (VC 20).
Folgende Abkürzungen wurden verwendet: LDM = Listings des Monats, AdM = Anwendung des Monats, SB = Simons Basic.
TIPS&TRICKS
(1. Programm-Sonderheft) Eine wahre Fundgrube an Ideen und Programmen für Computer-Profis und aUe, die es werden wollen.
BESTELLCODE: Tips&Tips
ABENTEUERSPIELE
(2. Programm-Sonderheft) Auf mehr als 100 Seiten viele interessante Adventures, die Sie lange Zeit fesseln werden. Mit abgeschlossenem Kurs zur Programmierung eigener Abenteuerspiele und zahlreichen Lösungen profes-sioneUer Adventures.
BESTELLCODE: Abenteuerspiele
SPIELE
(3. Programm-Sonderheft) Heiße Listings für alle Spiele-Fans: Sportspiele, Schießspiele, Denkspiele, Spielegeneratoren, Abenteuerspiele, Brettspiele, Taktikspiele, Geschicklichkeitsspiele und eine Marktübersicht aller in Deutschland erhältlichen professioneUen Spiele bringen alles, was das Herz der Spiele-Fans höher schlagen läßt.
BESTELLCODE: Spiele
GRAFIK&DRUCKER
(4. Programm-Sonderheft) Randvoll mit Informationen: Rund 28 Listings der Spitzenklasse. Darunter Top-Listings zur räumlichen Darstellung von Körpem aus beliebigen Betrachtungsrichtungen.
Weiters: Prüfsummenlistings, Drucker-Anwen-dung, Basic-Erweiterung, Hardcopy-Routinen, Zeichengenerator, Grundlagen, Tips & Tricks.
BESTELLCODE: Grafik & Drucker
FLOPPY/DATASETTE
(S. Programm-Sonderheft)
Ahes zum Thema Massenspeicher: So steUt man die Datasette ein. FMON 1541: Das Werkzeug für werdende Floppy-Spezialisten. Disk-Basic 64: Fast 50 neue Befehle für komfortablen Floppy-Betrieb. Turbo Tape de Luxe: Datasette 10mal schneUer als Floppy 1541. 5fach schneUer laden mit Hypra-Copy.
BESTELLCODE: Floppy
Am besten
gleich mitbestellen: Die64'e^Sammelbox
Füralle Leser, die »64’er« regelmäßig kaufen, sammeln oder im Abonnement beziehen, gibt es jetzt ein interessantes Service-Angebot: die 64’er-Sammelbox!
Mit dieser Sammelbox bringen Sie nicht nur Ordnung in Ihre wertvollen Hefte, sondern schaffen sich gleichzeitig ein interessantes und attraktives Nachschlagewerk.
Übrigens: Die Sammelbox ist nicht nur ein praktisches Aufbewahrungsmittel: Sie J|
eignet sich auch hervorragend als Geschenk für Freunde und Bekannte zu vielen Anlässen.



Kurs
C64
2060 - 2070 - 2080 - 2090 - 2100 - 2110 - 2120 -; 2130 -; 2140 —; 2150 -; 2160 -; 2170 -; 2180 -; 2190 -Wl 2200 - 2210 - 2220 - 2230 - 2240 -; 2250 -; 2260 -;	JSR JANEIN	; BEQ WEITER3	; LDA #$6C	; LDY #$03	; STA START+1	; STY START+2	; SYSTEMMELDUNGEN (J/N)?			(JA/NEIN)? JA=>WEITER SPRUNG AUF $036C VERBIEGEN BEI S36C STEHT EINE ROUTINE, DIE DEN "RLIN"-BEFEHL SIMULIERT	10070- 10080-10090-; 10100-TEXT2 10110- 10120-10130-; 10140-TEXT3 10150- 10160-10170-; 10180-TEXT4 10190- 10200-10210-; 10220-TEXT5 10230- 10240-10250-; 10260-TEXT6 10270- 10280-10290-; 10300-TEXT7 10310- 10320- 10330- 10340- 10350-10360-; 10370-TEXT8 10380- 10390-10400-; 10410-TEXT9 10420- 10430-; 10440-; 20000-; 20010-; UNTERPf 	.	—		.TX .BY .BY .TX .BY .BY .TX .BY .BY .TX .BY .BY .TX .BY .BY .TX .BY .BY .TX .BY .TX .TX .BY . BY .TX . BY	"STARTADRESSE : " 0 13,13 "FILENAME x " 0 13,13 "GERAETENR. (1-9;0=UEBERNEHMEN) 0 13,13 "MASCHINENPROGRAMM" 0 13,13 "SYSTEMMELDUNGEN" 0 13,13 "LOAD ERROR AUSGEBEN" 0 13,13,18 "*** LOADER GENERIERT ***" 13,13 "MIT 'SAVE' SPEICHERN," " MIT 'RUN' STARTEN" 0 13,13,18 "*** PROGRAMMENDE • ***" 13 13 0		
	EITER3 JSR BNE LDA STA LOAD ERROR		PRINT(TEXT5) JANEIN	;	(JA/NEIN)? WEITER4	;	NEIN=>WEITER #$80	;	FLAG FUER SYSTEM+1	;	SYSTEMMELDUNGEN AUSGEBEN (J/N)						
xz/B — ;	 2280 -; 2290 -; 2300 -WEITER4 ...	PRINT(TEXT6) 2310 -	JSR	JANEIN	; 2320 -	BEß	WEITER5	; 2330 -	LDA	#0	; 2340 -	STA	FEHLER+1	; 2350 -; 2360 -; 2370 -; PROGRAMMENDE				(JA/NEIN)? NEIN=>WEITER FEHLERMELDUNGEN UNTERDRUECKEN					
2390 -; 2400 -; 2410 -WEITER5 2420 -; 2430 -; VEKTOR 0	7101	_ .				FUER	PRINT(TEXT7) BASIC-ENDE SETZEN			.TX .BY	" (J/N)? " 0		
2450 -; 2460 -; 2470 - 2480 - 2490 - 2500 - 2510 - 2520 -; 2530 -; 10000-; 10010-;						^OGRAMM FUER "J/N?"			
	ASCII—	LDA #<(MDFIKATOR) STA $2D	; LDA #>(MDFIKATOR) STA $2E	; JMP READY	; TABELLEN		LOW-BYTE HIGH-BYTE SPRUNG INS BASIC	20030-? 20040-; 20050-JANEIN	...	PRINT(TEXT9) 20060-	JSR	BASIN	;	EINGABE HOLEN 20070-	CMP	#"^" 20080-	BNE	JANEIN1 20090-	PLA	;	SIEHE STAPEL- 20100-	PLA	;	MANIPULATION 20110-...PRINT(TEXT8) DCAnV	.	TMQ DACTP				
,	 10030-; 10040-; 10050-TEXT1 10060-		.TX .BY	"LOADER-MAKER 13,13	I 64"	20130-JANEIN1 20140-20150-; 20160-.EN	CMP RTS	#"J"	; VERGLEICH MIT "J" ; RUECKKEHR VOM UNTERPROGRAMM		
					Listing 30 (Schluß)				
überprüft, ob die nächste Adresse schon mit der ersten Adresse nach der Endadresse ($475F), also $4760, übereinstimmt (siehe $6016 - $601D). Dieser 16-Bit-Vergleich wurde bereits im SMON vorgestellt. Bei $601E wird schließlich die Schleife beendet, falls die Abbruchbedingung (C=1) erfüllt ist
Listing 20 isteine Dekrementierschleife, die sich in derWir-kung nicht von Listing 19 unterscheidet. Da das Dekremen-tieren einer 16-Bit-Adresse beim 6510 langsamer und speicherplatzaufwendiger ist als das Inkrementieren, ist Listing 20 weniger effektiv als Listing 19.
Grundsätzlich können Sie an den Listings 19 und 20 sehen, wie man eine Typ-b-Schleife programmiert. Diese arbeitet jedoch nicht besonders schnell. Der Grund ist, daß der Bereich von $3FD2 - $475F nicht restlos in ganze Seiten (256-Byte-Bl0cke)aufgeteilt werden kann. Daher sollte man sich immer überlegen, ob die Schleifendurchlaufzahl nicht auf ganze 256-Byte-Blöcke »aufgerundet« werden kann. In unserem Fall würde dies heißen, daß mit einer schnelleren Schleife der exakt 8 x 256 Byte lange Bereich $3FD2 - $47D1 invertiert wird, anstelle des »ungeraden« Bereichs $3FD2 - $475F. An einfacheren Zahlen wollen wir nun eine solche Schleife für ganze Seiten programmieren. Der 32 x 256 Byte umfassende Bereich von $2000 bis $3FFF (einschließlich) soll invertiert werden. Mit einer solcher Routine könnte das gerade sichtbare Bild bei Hi-Eddi invertiert werden.
Die einfachste Form finden Sie in Listing 21. Zuerst wird die Anfangsadresse in $14/$15 abgelegt. Ins Y-Register kommt der Wert 0. Dann wird der Wert invertiert und das Y-Register, der Low-Zähler, erhöht. Ist der Wert noch nicht 0, wird die Schleife neu durchlaufen. Andernfalls wurde gerade eine Seite abgearbeitet. Der High-Zähler ($15) wird erhöht. Ist der Inhalt des High-Zählers = $40, wird die Schleife abgebrochen. Zu bemerken ist, daß während der Schleife die Adresse $14 unverändert 0 bleibt. Die Adresse, die invertiert wird, ergibt sich folgendermaßen:
(Y+Inhalt von $14)+256*(lnhalt von $15)
Da wir auf die Adresse über das Prozessor-Register Y Einfluß nehmen können und die Adresse $14 nicht verändert werden muß, ist die Verarbeitungsgeschwindigkeit gegenüber der »Normalform« (Listing 20) gestiegen. Das High-Byte müssen wir aber weiterhin in $15 belassen. Neu führen wir den High-Zähler X ein. Im X-Register merken wir uns, wieviele Seiten invertiert werden. Diesen Wert verwenden wir als Dekrementierzähler. In unserem Fall werden $20 Seiten invertiert. Weil $20 zufälligerweise auch das High-Byte der Anfangsadresse ($2000) ist, wird dieser Wert in Listing 22 nur einmal (6005) in den Akku geladen und dann bei 6009 ins X-Register übertragen.
Beachten Sie bitte, daß in Listing 22 die Befehle »6004 TAY« und »6009 TAX« nur bei den Werten dieses Beispiels verwendet werden können. In der Regel sind eigene »LDX # «- oder »LDY #«-Befehle erforderlich. Wenn wir zum Bei-
96
C64
Kurs
spiel den Bereich $3FD2 - $47D1 invertieren wollen, muß die Initialisierung so aussehen:
LDA # D2 Lx>w-Byte der ersten Adresse
STA 14
LDY #00 Index-Register
LDA #3F High-Byte der ersten Adresse
STA 15
LDX #08 High-Zähler ... Schleife wie ab 600C in Listing 22
Damit hätten wir eine Schleife, die den Bereich # 3FD2 -$475F (siehe Listings 19 und 20) invertiert und wesentlich schnellerals die Listings 19 und 20 arbeitet. Dawiraber »aufgerundet« haben, wird zusätzlich der Bereich $4760 -
programm : loader—maker	0801 0a38
0801	-	Ob	08	cl	07	9e	32	30	36	Oa
0809		31	00	Q0	00	a2	00	86	9d	ba
0811	-	a2	49	bd	lf	08	9d	3c	03	Of
0819		ca	10	f7	4c	3c	03	a9	01	f7
0821	:	a8	a2	00	20	ba	ff	a9	00	71
0829	:	a2	5c	aO	03	20	bd	ff	a9	c5
0831		00	20	d5	ff	bO	03	4c	00	Ob
0839		OO	a2	ld	6c	OO	03	00	00	77
0841		00	OO	00	00	00	00	00	00	42
0849		00	OO	00	00	00	00	86	2d	be
0851	-	84	2e	20	44	e5	a2	03	86	09
0859		c6	bd	83	03	9d	77	02	ca	72
0861		10	f7	4c	74	a4	52	d5	Od	5d
0869		20	44	e5	a9	21	aO	09	20	d5
0871		le	ab	20	fd	ae	20	8a	ad	9e
0879	-	20	+ 7	b7	a6	14	a5	15	8e	37
0881		38	08	8d	39	08	20	cd	bd	7c
0889		a2	Of	a9	00	9d	3f	08	ca	a7
0891	-	10	fa	8d	Oe	08	a9	03	8d	38
0899		36	08	a9	a2	8d	22	08	a9	ef
08al	:	42	aO	09	20	le	ab	a2	00	44
08a9	:	20	cf	ff	c9	Od	fO	08	9d	9e
08bl	:	3f	08	e8	eO	10	dO	fl	8e	b7
08b9	:	28	08	a9	50	aO	09	20	le	69
08cl	:	ab	20	cf	ff	38	e9	30	8d	lf
08c9		23	08	dO	Oa	a9	a6	8d	22	bO
08dl	■	08	a9	ba	8d	23	08	a9	74	10
08d9		aO	09	20	le	ab	20	lb	Oa	06
08el	-	+ 0	Oa	a9	6c	aO	03	8d	38	97
08e9		08	8c	39	08	a9	88	aO	09	fa
08+1	-	20	le	ab	20	lb	Oa	dO	05	5f
08f9		a9	80	8d	Oe	08	a9	9a	aO	81
0901	■	09	20	le	ab	20	lb	Oa	fO	fc
0909		05	a9	00	8d	36	08	a9	bl	42
0911		aO	09	20	le	ab	a9	69	85	ba
0919	-	2d	a9	08	85	2e	4c	74	a4	2e
0921		4c	4f	41	44	45	52	2d	4d	24
0929		41	4b	45	52	20	36	34	Od	4a
0931		Od	53	54	41	52	54	41	44	7a
0939		52	45	53	53	45	20	3a	20	ec
0941	■	00	Od	Od	46	49	4c	45	4e	7d
0949		41	4d	45	20	3a	20	00	Od	45
0951		Od	47	45	52	41	45	54	45	b8
0959	:	4e	52	2e	20	28	31	2d	39	93
0961	:	3b	30	3d	55	45	42	45	52	ce
0969		4e	45	48	4d	45	4e	29	20	cl
0971		3a	20	00	Od	Od	4d	41	53	44
0979	-	43	48	49	4e	45	4e	50	52	a9
0981		4+	47	52	41	4d	4d	00	Od	8a
0989		Od	53	59	53	54	45	4d	4d	40
0991		45	4c	44	55	4e	47	45	4e	89
0999		00	Od	Od	4c	4f	41	44	20	3d
09al		45	52	52	4f	52	20	20	41	b7
09a9		55	53	47	45	42	45	4e	00	aa
09bl		Od	Od	12	2a	2a	2a	20	4c	lc
09b9	-	4f	41	44	45	52	20	47	45	30
09cl		4e	45	52	49	45	52	54	20	e8
09c9		2a	2a	2a	Od	Od	4d	49	54	3e
09dl		20	27	53	41	56	45	27	20	ee
09d9		53	50	45	49	43	48	45	52	ff
09el	■	4e	2c	20	4d	49	54	20	27	fd
09e9		52	55	4e	27	20	53	54	41	cf
09fl		52	54	45	4e	00	Od	Od	12	49
09f9	-	2a	2a	2a	20	50	52	4f	47	2a
OaOl		52	41	4d	4d	45	4e	44	45	53
0a09	-	20	21	20	2a	2a	2a	Od	Od	49
Oall		00	20	28	4a	2f	4e	29	3f	fd
0al9		20	00	a9	12	aO	Oa	20	le	fd
0a21		ab	20	cf	ff	c9	5f	dO	Oc	c3
0a29		68	68	a9	f6	aO	09	20	le	le
0a31		ab	4c	74	a4	c9	4a	60	5c	dd
Listing 31
$47D1 invertiert, obwohlwirdasgarnichtwollen. Esgibtnun mehrere Möglichkeiten, dies zu verhindern:
1.	Wir verwenden die Schleife aus Listing 19, müssen aber eine deutlich höhere Arbeitsdauer hinnehmen.
2.	Wir verwenden die Schleife aus Listing 22 mit obiger Initialisierung. Dann invertiert eine Typ-a-Schleife den Restbereich $4760 - $47D1 ein weiteres Mal. Damit wären -eine Besonderheit der EOR # FF-Verknüpfung - im Restbereich die alten Inhalte wiederhergestellt. Diese Lösung eignet sich aber (fast) nur bei dieser logischen Verknüpfung und hilft bei den meisten anderen Typ-b-Schleifen nicht weiter.
3.	Dies dürfte wohl die beste Lösung sein: Wir schreiben eine »gemischte« Schleife, die aus einer Typ-a-Schleife und einer Typ-b-Schleife besteht. Dieses Verfahren ist immer (!) möglich und wird von der BLTUC-Routine ($A3BF) des Basic-Interpreters angewandt. Diese Verschiebe-Routine zerlegt den Bereich, der verschoben werden soll, in einen Bereich der aus 256-Byte-Blöcken besteht und in einen Restbereich. Beide Bereichewerden dann getrenntverscho-ben.
Folgendermaßen sieht die optimale Invertierroutine für den Bereich $3FD2 - $475F aus:
a)	Der exakt 7 Seiten umfassende Bereich 3FD2 - $46D1 wird mit einer Typ-b-Schleife wie in Listing 22 komplementiert.
b)	Der Restbereich $46D2 - $475F wird mit einer Typ-a-Schleife wie in Listing 13 komplementiert.
Wir haben nun viele verschiedene Schleifenkonstruktionen in Theorie und Praxis behandelt. Was uns noch fehlt, sind Formeln, nach denen Sie die einzelnen Parameter (zum Beispiel den Startwert für X in einer Dekrementier-Schleife vom Typ a) errechnen können. Als Zusammenfassung finden Sie in Form von Listing 23 ein Hypra-Ass-Assemblerlisting zu mehreren Schleifenkonstruktionen. An den Quelltext-Aus-drücken können Sie sehen, wie einzelne Parameter errechnet werden können.
Merke: Sofern es der Programmablauf zuläßt, sollten Sie Inkrementierschleifen verwenden.
Bei Verschiebeschleifen ist aber oft eine Dekrementier-schleife erforderlich.
Noch etwas zum Schleifen-Inhalt: Wenn mehrere Schleifen einen gleichen Innenteil haben (zum Beispiel einen Invertierbefehl), definieren Sie diesen unbedingt als Makro und nicht als Unterprogramm! JSRs sollten Sie nur beim Aufruf von ROM-Routinen verwenden.
Damit wäre das Thema »Schleifen« erst einmal abgeschlossen. Im nächsten Abschnitt(überSelbstmodifikation) werden wir uns aber wieder mit Schleifen auseinandersetzen.
10.	Selbstmodifikation
Bevor wir uns mit dieser Programmiertechnik beschäftigen, die zwar nicht strukturiert, aber sehr trickreich ist, soll der Begriff geklärt werden.
Unter Modifikation versteht man »eine Änderung, Anpassung«. Wenn Sie bei einem Spiel einen der vielen POKE-Befehle, die im 64’erschon vorgestellt wurden, eingeben, so wird dadurch das Spiel »modifiziert«. Die Änderung ist zum Beispiel eine Erhöhung der Spielfigurenanzahl.
Selbstmodifikation bedeutet, daß ein Programm sich selbst programmgesteuert verändert. Dies wäre der Fall, wenn im Spielprogramm eine Passage stünde, die den POKE ausführt.
Wenn Sie sich für die Selbstmodifikation von Basic-Programmen interessieren, finden Sie in der Zeitschrift »Happy-Computer« (Ausgabe 8/85) unter der Überschrift »Lernen Sie Ihren Commodore 64 kennen« alles, was Sie wis-
97
Kurs
C64
sen müssen. Auf simulierten Direktmodus wurde im 64’er schon mehrfach eingegangen, unter anderem in der »Memory Map mit Wandervorschlägen«.
Wir werden uns an dieser Stelle ausschließlich mit der Selbstmodifikation von Maschinenprogrammen befassen. Als erstes Beispiel nehmen wir Listing 24.'
Es handelt sich um eine selbstmodifizierende Schleife, die den Bereich $2000 - $3FFF komplementiert.
TRACEn Sie doch einmal Listing 24 mit dem SMON und vergleichen Sie die disassemblierten Befehle mit den ursprünglichen Werten, die Sie in Listing 24 finden. Sie werden erkennen, daß die Befehle »6002 LDA 2000,Y« und »6007 STA 2000,Y« aufgrund der INC-Befehle immer auf andere Adressen zugreifen. Besagte INC-Befehle erhöhen jeweils das High-Byte des Operanden. Ist dieses schon $40, so wird die Schleife beendet. In Listing 25 sehen Sie, wie unsere Schleife aus Listing 24 aussieht, wenn sie fertig durchlaufen wurde. Ein weiterer Start bewirkt, daß das Programm sich früher oder später selbst invertiert und darum abstürzt.
Was nämlich unserem Listing 24 fehlt, damit es mehr als einmal arbeitet, ist eine Initialisierung, diejedesmal den Ausgangswert ($2000) in die LDA/STA-Befehle einsetzt. In Listing 26 sehen Sie eine solche Initialisierung (6000 -600F). Die Adresse $FFFF (bei 6012 und 6017) ist ein Dummy-Wert, das heißt er dient nur zum vorläufigen Ausfüllen von Adressen und hat keine programmtechnische Bedeutung. Der Dummy-Wert wird ohnehin von der Initialisierung überschrieben; wir hätten also statt $FFFF auch $040C oder andere verwenden können. Wichtig ist nur, daß »LDA DummyY« 3 Byte belegt.
Ein besonderer Vorteil der Selbstmodifikation ist es, daß selbstmodifizierende Schleifen keine Zähler in der Zeropage benötigen, weil der Zähler praktisch im Programm selbst liegt. In puncto Geschwindigkeit sind selbstmodifizierende Schleifen den herkömmlichen aber oft unterlegen.
Ein weiterer Vorteil von ihnen ist aber, daß man außer mit weniger Zeropage-Speicherplätzen auch mit weniger Registern auskommen kann (sofern man hier Einsparungen vornehmen will). Listing 27 beispielsweise invertiert den Bereich $3FD2 - $475F. X- und Y-Register sowie die Zeropage bleiben unverändert, lediglich der Akkumulator fungiert als Arbeitsregister.
Listing 28 kopiert den Basic-Interpreter ($A000 - $BFFF) ins RAMan gleicher Adresse, wobei nur das X-Register verwendet wird (!).
Nun wollen wir sehen, wie man bei der Entwicklung selbstmodifizierender Programme unter Zuhilfenahme eines guten Assemblers (Hypra-Ass) vorgehen muß.
Zunächst einmal müssen diejenigen Stellen, an denen Modifikationen vorgenommen werden, mit Label definiert werden. Von diesen Label aus können die Stellen im Speicher die geändert werden sollen, leicht berechnet werden.
Befehlscode = LABEL + 0 = LABEL Low-Operand	=	LABEL + 1
High-Operand	=	LABEL + 2
Bei 2-Byte-Befehlen wird der Parameter wie der Low-Operand eines 3-Byte-Befehls errechnet.
Als Beispiel finden Sie in Form von Listing 29 einen Quelltext (Assembler: Hypra-Ass) für Listing 28. Während in Listing 28 der Ausgangswert bei 6010 »LDX 0000« und bei 6013 »STX 0000« ist, wurde im Quelltext $FFFF verwendet (270, 280), um den Assembler zu zwingen, den Dummy-Wert als 16-Bit-Adresse abzulegen (und nicht als Zeropage-Adresse, wodurch der Befehl nur 2 statt 3 Byte belegen würde).
Die Stellen, die modifiziert werden, wurden mit »MOD1« und »MOD2« definiert. MOD1 ist zugleich der Schleifenbeginn.
Nachdem Sie jetzt den Eingang gefunden haben, möchte ich einige Anregungen liefern, wie Sie die Vorteile der Selbstmodifikation nutzen können. Wir werden hier die Anwendung nach den verschiedenen Adressierungsarten unterteilen.
a)	Anwendung auf absolute Adressierung
Bei der Stapelmanipulation haben wir schon ein Verfahren kennengelernt, den Befehl JSR (indirekt), der im normalen 6510-Befehlssatz nicht existiert, zu simulieren.
Folgendermaßen kann über Selbstmodifikation ein Unterprogramm ab ADRESSE aufgerufen werden.
LDA # <ADRESSE
STASPRUNGBEFEHL+1 ; Low-Operand LDA # >ADRESSE
STASPRUNGBEFEHL+2;
High-Operand
SPRUNGBEFEHL
JSR $FFFF ; $FFFF=Dummy
Genauso kann man mit dem JMP-Befehl verfahren. Sogar bei den Schieber-, Dekrementier- und Inkrementierbefehlen, die im Gegensatz zu JMP die indirekte Adressierung nicht haben, ist auf diese Weise eine Simulation der indirekten Adressierung möglich.
Wird eine Sprungtabelle per Selbstmodifikation verarbeitet, müssen die Sprungadressen in der Tabelle nicht (!) dekrementiert werden.
b)	Anwendung auf lmmediate-Befehle
Oft müssen Werte, die berechnet werden, auf dem Stapel oder im Speicher abgelegt und dann, wenn sie gebraucht werden, wieder aufgenommen werden.
Ein Beispiel hierfür ist der »Basic-Start-Generator« (64’er, 7/85, Seite 74). Bei Erwähnung dieses Programms taucht natürlich die Frage auf, ob es sich hier noch um ein selbstmodifizierendes Programm handelt oder ob der »Basic-Start-Generator« nicht eher zu den Programmgeneratoren zählt. Diese Frage ist voll berechtigt. Deshalb wollen wir darauf kurz eingehen.
Der »Basic-Start-Generator« ist eindeutig den Programmgeneratoren zuzuordnen, da der generierte Programmteil nie angesprungen wird und somit ein eigenständiges Programm darstellt. Das Programm modifiziert also nicht sich selbst, sondern vielmehr ein zweites Programm, welches dann vom Benutzer gespeichert werden kann.
Die Programmierung ist aber bei Programmgeneratoren nicht anders als bei selbstmodifizierenden Programmen. Auf den Unterschied Programmgeneration/Selbstmodifikation werden wir an späterer Stelle näher eingehen.
Zunächst wollen wir aber ein praktisches Beispiel für die Anwendung der Modifikation von lmmediate-Befehlen behandeln. Oft steht man vor dem Problem, ein Register zu sichern und später wieder zu holen. Im Falle des Akkumulators sieht das so aus:
PHA	; Akku sichern
; weiteres Programm
PLA	; Akku wieder holen
Beim X-Register wird’s schon ungünstiger:
TXA	; X-Register in Akku
PHA	; Akku sichern
...........	; weiteres Programm
PLA	; Akku wieder holen
TAX	; Akku ins X-Register
Hier wird also zusätzlich der Akku beeinflußt. Wenn dies vermieden werden muß, wird folgender Weg gewählt:
STX $02	; $02 = Zwischenspeicher
; weiteres Programm
LDX $02	; X wieder holen
Für die Sicherung des X-Registers gibt es aber noch eine weitere Lösung, die den X-Wert im Programm ablegt und
C64
Kurs
dadurch nicht den Stapel oder einen Zwischenspeicher außerhalb des Programms benötigt.
STX GETX+1 ; X direkt in lmmediate-Befehl schreiben
; weiteres Programm
GETX LDX #$OO ; $00 = Dummy-Wert
Obiges Beispiel kann sehr leicht auf Akkumulator oder Y-Register umgeschrieben werden.
Folgendermaßen kann das X-Register mit dem Akkumulator verglichen werden:
STX VGL+1 ; in Vergleichsbefehl ablegen (............. ;	evtl, weitere Programme)
VGL CMP #$00	; $00 = Dummy
Als letztes Beispiel für die Anwendung auf lmmediate-
Befehle soll das Y-Register zum Akkumulator addiert werden:
STY ADD+1	; in Arithmetikbefehl ablegen
(.................... ;	evtl, weiteres Programm)
CLC	; Carry vor Addition
ADD ADC #$FF ; $FF = Dummy
Die Anwendungsmöglichkeiten sind hier unbegrenzt.
c)	Anwendung auf komplette Befehle
Bisher haben wir nur die Parameter einzelner Befehle modifiziert. Es ist selbstverständlich auch möglich, die Befehlscodes oder die kompletten Befehle zu modifizieren.
Wenn nur der Befehlscode geändert wird (zum Beispiel ein ORA #- in einen EOR #-Befehl) bleiben die Parameter erhalten. Es könnte ferner ein impliziter Befehl (SEI,CLI,CLD, DEX,INX...) geändert werden, um beispielsweise zwischen In- und Dekrementieren umzuschalten. Außerdem könnte bei einem BRANCH-Befehl die Sprungbedingung (CS,CC,VS, VC,NE,EQ) geändert werden. Aus BCS könnte also leicht BCC werden.
Weil man hier die Opcodes der Befehle kennen muß, empfehle ich das erste 64’er Extra (Ausgabe 9/85) oder die Tabelle am Ende dieser Ausgabe.
Nun lösen wir noch das häufig auftretende Problem, wie die Ausführung eines Unterprogramms verhindert wird. Dazu werden wir drei Lösungen (I - III) entwickeln.
I.	Die Adresse FLAG wird auf 0 gesetzt, wenn das Unterprogramm ausgeführt werden soll; auf einen anderen Wert, wenn es nicht ausgeführt werden soll.
LDA # 0	;	Flag für Ausführung
STA FLAG	;	Flag setzen
(.......... ;	evtl, weiteres Programm)
LDA FLAG	;	Flag testen
BNE NEIN	;	Flag < > 0, also nicht ausführen
JSR UNTER-
PROGRAMM ; Aufruf
NEIN ..... weiteres Programm
Das Flag könnte auch am Beginn des Unterprogramms abgefragt und dann (wenn FLAG < > 0) das Unterprogramm verlassen werden.
II.	Als ersten Befehl des Unterprogramms verwenden wir NOP:
UP NOP	; Beginn des Unterprogramms
........	; Fortsetzung des Unterprogramms
So wird die Ausführung des Unterprogramms gestattet:
LDA # $EA ; Opcode für NOP
STA UP	; an Anfang des Unterprogramms
schreiben
Und so wird sie verhindert:
LDA #$60	; Opcode für RTS
STA UP	; an Anfang des Unterprogramms
schreiben
Wer noch einen NOP-Befehl und damit 1 Byte sparen möchte, kann den NOP-Befehl entfallen lassen. Dann muß auch der Opcode $EA beim Erlauben des Unterprogramms in den Opcode des ersten Byte im Unterprogramm geändert
werden. Weil dies ziemlich mühselig ist, ziehe ich die ursprüngliche Lösung II trotz des um 1 Byte erhöhten Speicherbedarfs vor.
III.	Das beste Verfahren. Wir schalten den JSR-Befehl aus, indem wir ihn in einen BIT-Befehl abändern.
AUFRUF JSR Unterprogramm JSR ausschalten:
LDA # $2C ; Opcode für BIT STA AUFRUF
JSR wieder erlauben:
LDA #$20 ; Opcode für JSR STA AUFRUF
Der JSR-Opcode kann auch mit $0C überschrieben werden. $0C ist ein illegaler Opcode für ein 3-Byte-NOP und arbeitet mit allen mir bekannten Versionen des C 64. Ob er ebenfalls auf dem C 128 läuft, konnte ich noch nicht prüfen.
Im übrigen können mit dem soeben beschriebenen Verfahren auch andere Befehle ausgeschaltet werden, zum Beispiel JMP, LDA, STA und so weiter. Wenn aber der JSR-Opcode mit $2C (BIT) überschrieben wird, ist darauf zu achten, daß bei der Ausführung des BIT-Befehls die Prozessorflags gesetzt werden.
Sicherlich gibt es noch mehr Problemlösungen als I - III, aber III dürfte wohl kaum zu übertreffen sein.
d)	Anwendung auf mehrere Befehle
Selbstverständlich können ganze Befehlsfolgen, also größere Programmteile gegeneinander ausgetauscht werden. Zu beachten ist nur, daß die Routinen, die gegeneinander ausgetauscht werden, auch in dem Bereich, in den sie vom Programm aus geschrieben werden, lauffähig sind. Dies ist vor allem dann gegeben, wenn nur die relative Adressierung verwendet wird und dadurch die Routine im Speicher frei verschoben werden kann.
e)	Anwendung auf Tabellen
Dieser Anwendungsfall würde auch zum Abschnitt über »Tabellen« passen.
Wir bleiben hier bei der Theorie, denn die Umsetzung in ein Programm ist nicht mehr schwer. Vielmehr soll Ihre Kreativität nicht durch Unmengen von Beispielen gehemmt werden.
Zunächst wollen wir uns ein wenig mit dem SMON befassen. Wenn Sie den Disk-Monitor einschalten, kopiert das Programm einen Floppy-Befehl («U1 ..«) vom Ende des SMON in einen Bereichzwischen $02A0 und $02FF. Dieser Lesebefehl wird nach Bedarf modifiziert, zum Beispiel wird beim Schreiben der »U1«- in einen »U2«-Befehl umgewandelt oder die Angabe des einzulesenden Blocks wird geändert. Dies wäre ein typisches Anwendungsbeispiel für Selbstmodifikation, wenn der Lesebefehl nicht erst in einen Bereich außerhalb des Programms kopiert würde (worin ich keinen Sinn sehe), sondern am Ende des SMON (etwa bei $CFF0) bliebe und dort modifiziert würde.
Im Hi-Eddi liegt eineTabelle, die die High-Byte der Bit-Map-Anfangsadressen beinhaltet. Diese Tabelle wird von Hi-Eddi bei jedem Bildwechsel umgerechnet.
Nach den vorausgegangenen zwei Beispielen an Spitzenprogrammen aus dem 64’er möchte ich noch andere Anwendungsbeispiele nennen.
Besonders flexible Programme erlauben Eingriffe des Anwenders in die Befehls- oder Text-Tabellen. So können Bildschirmmasken editiert oder Eingabemasken erstellt werden.
Ein solches Programm braucht sich nach den Modifikationen nur selbstabzuspeichern. Weil hier unter Umständen ein erheblicher Teil des Programmschutzes verlorengeht, werden dann lediglich die Tabellen gespeichert.
Ein Adventure-Generator modifiziert in der Regel auch nur die Tabellen eines fertigen Adventureprogramms, das eigentliche Programm bleibt unverändert. In diesen Tabellen sind die einzelnen Spielsituationen enthalten.
99
Kurs
C64
Bei diesen (theoretischen) Fällen wollen wir es belassen. Letztendlich muß ja der Programmierer entscheiden, inwieweit er die Selbstmodifikation auf Tabellen anwenden kann.
f)	Das Beispielprogramm »Loader-Maker 64«
Wie aus dem Namen des Beispielprogramms schon zu entnehmen ist, handelt es sich um einen Programmgenerator. Da - wie gesagt - die Programmierung wie bei selbstmodifizierenden Programmen ist, habe ich bewußt einen Programmgenerator als Beispiel gewählt.
Als Listing 31 finden Sie ein MSE-Listing, falls Sie »Loader-Maker 64« bequem abtippen wollen und an der Anwendung des Programms interessiert sind. Deshalb zunächst eine Kurzbeschreibung für Anwender.
»Loader-Maker« ermöglicht es Ihnen, zu einem Programm ein (Maschinensprache-) Ladeprogramm zu generieren, welches normal geladen und mit »RUN« gestartet wird, worauf es das nachzuladende Programm nachlädt und startet.
Nach dem Laden von »Loader-Maker« wird dieses Programm durch SYS 2154,START gestartet. START ist eine Variable und wird durch die Startadresse des nachzuladenden Programms ausgedrückt. Soll ein Basic-Programm nachgeladen werden, hat diese Adresse keine Bedeutung (einfach SYS2154,0 eingeben). Bei einem Maschinenprogramm handelt es sich hier um die Adresse, mit der das Programm über »SYS« gestartet wird (49152 beim SMON $C000).
Das Programm meldet sich mit »Loader-Maker 64« und gibt die Startadresse aus. Dazu können Sie den Filenamen eingeben.
Bei allen weiteren Eingaben (Gerätenummer, von der geladen werden soll; Maschinenprogramm j/n; Systemmeldungen wie »SEARCHING FOR« ausgeben j/n; LOAD ERROR bei Ladefehler ausgeben j/n) können Sie das Programm durch Eingabe des Linkspfeils abbrechen. Sind alle Eingaben gemacht worden, kommt die Meldung »LOADER GENERIERT« und der Lader kann mit »SAVE« gespeichert werden.
Wenn das nachzuladende Programm von der Adresse geladen werden soll, von der auch das Ladeprogramm selbst eingelesen wurde, ist als Gerätenummer nur 0 einzugeben.
Befassen wir uns nun mit dem Programm, dessen Quelltext Sie als Listing 30 finden.
Die Zeilen bis 990 stellen das Ladeprogramm in unmodifizierter Form dar und enthalten viele Dummywerte, wie zum Beispiel die (unsinnige) Startadresse 0 in Zeile 820.
Mit 1000 beginnt die Modifikationsroutine. Nach 1120 wurde die Startadresse eingelesen, die ja per SYS übergeben wurde, und wird wieder mit dem Titel ausgegeben. 1100/1110 schreiben die Startadresse hinter den JMP-Befehl in Zeile 820.
1150 - 1350 bringen das (noch unmodifizierte) Gerüst in den Ausgangszustand, der dann nach Bedarf geändert wird.
1400 - 1550 holen den Filenamen, legen ihn bei NAME (850) ab, berechnen gleich die Länge des Filenamens und legen diese bei LAENGE (750) ab.
1600 - 1720 holen die Geräteadresse. Da diese im ASCII-Fbrmat vorliegt, muß der ASCII-Code von 0 abgezogen werden (1640/1650). Wurde 0 eingegeben, wird der LDX # DEVICE-Befehl (730) in »LDX $BA« geändert. Die Adresse $BA enthältjeweils die Adresse, von der das letzte Programm geladen wurde.
1750 - 1850 fragen, ob das nachzuladende Programm mit der per SYS übermittelten Startadresse gestartet wird (Eingabe »j«). Wurde »n« eingegeben, muß das Programm über den Basic-Befehl RUN eingegeben werden. Auf eine entsprechende Routine (870 - 980) wird die Startadresse gestellt (1810 - 1840).
1900 - 1970 ermöglichen die Einstellung, ob »SEARCHING..«, »LOADING« etc. ausgegeben werden sollen.
Soll im Falle eines Ladefehlers das Programm nicht gestartet und stattdessen »LOAD ERROR..« ausgegeben werden,
wird dies bei 2000 - 2090 festgelegt. Wird die Fehlerausgabe unterdrückt, muß der BCS-Befehl (810) unschädlich gemacht werden. Dies geschieht einfach dadurch, daß die Sprungweite auf 0 gesetzt wird (2070/2080).
Am Programmende wird noch eine Meldung ausgegeben (2140 - 2160) und der Vektor für das Ende des Basic-Programms neu gesetzt, damit das generierte Ladeprogramm mit »SAVE« gespeichert werden kann.
10000 - 10310 enthalten nur die Text-Tabellen.
Von 15000 bis zur letzten Zeile (15170) steht ein Unterprogramm, daß bei jeder J/N-Entscheidung über »JSR J,N« aufgerufen wird.
Es gibt den Text »(J/N)?« aus (15030 - 15050) und holt eine Eingabe. Ist diese »J«, so ist nach dem Verlassen des Unterprogramms (1517) das Zero-Flag gesetzt (andernfalls < nicht).
Wurde der Linkspfeil eingegeben, wird das Programm abgebrochen und eine entsprechende Meldung ausgegeben (15100- 15150).
Wie wir nun gesehen haben, handelfes sich bei »Loader-Maker« um einen Programmgenerator. Mit zwei kleinen Änderungen wird erjedoch zum selbstmodifizierenden Ladeprogramm. Wir müssen nur die beiden »JMP READY.«-Befehle (2240/15150) in »JMP SYSTEM« umwandeln, wodurch am Programmende der generierte Lader angesprungen würde. Schon hätten wir ein selbstmodifizierendes Ladeprogramm.
Um Ihnen noch die Anwendung des Loader-Maker zu erleichtern, hier zwei Eingabebeispiele:
Startadresse.................49152
Filename.....................SMON $C000
Geräteadresse................0
Maschinenprogramm............j
Systemmeldungen..............j
LOAD ERROR ausgeben..j
Startadresse.................0 (bedeutungslos)
Filename.....................HI-EDDI
Geräteadresse................8
Maschinenprogramm............n
Systemmeldungen..............n
LOAD ERROR ausgeben. .j
g)	Verbesserungen an »Tabellen-Beispiel«
Zum Abschluß des Themas »Selbstmodifikation« wollen wir noch kleine Verbesserungen am Programm »Tabellen-Beispiel« erwähnen. Ich werde hier eher Anregungen geben als fertige Änderungsvorschläge.
Zunächst soll die Adresse XSÄVE (zum Sichern des X-Registers in Schleifen) überflüssig werden. So könnte es nun gesichert werden:
XSV STX GETX
GETX LDX #$00 O=Dummy;hierwirdXwieder aufgenommen.
Auch die Sprungtabelle läßt sich - viel einfacher, finde ich -anders handhaben:
LDA J?LO,X	JMLO oder JELO
STA SPRO+1
LDA J7HI,X	JMHI oder JEHI
STA SPRG+2
SPRG JMP 0000
In den Tabellen JMLO/JMHI und JELO/JEHI (Low- und High-Bytes der Sprungadressen) dürfen die Adressen aber nicht dekrementiert werden.
Wird ein JSR (IND)-Befehl simuliert, muß nach wie vor die Rücksprungadresse auf den Stapel gelegt werden. Dies würde entfallen, wenn die Rücksprungadresse direkt auf »SPRG JMP 0000« folgen und der JMP-Befehl bei SPRG in JSR umgewandelt würde.
100

PROGRAMM
SER^'CE
Bestellungen aus anderen Ländern bitte per Auslandspostanweisung! Achtung: Nicht die eingeheftete Zahlkarte verwenden!
Bestellungen aus der Schweiz bitte direkt an: Markt&Technik Vertriebs AG, Kollerstr. 3, CH-6300 Zug, Tel. 0 42/41 56 56.
Bestellungen aus Österreich bitte direkt an: Bücherzentrum Meidling, Schönbrunnerstr. 261, 1120 Wien, Tel. 02 22/8331 96.
Mikrocomput-ique Erhard Schiller Fasangasse 21, 1030 Wien, Tel. 02 22/78 56 61.
Programme aus den früheren Ausgaben
Sonderheft: Professionelle
Anwendungen
2 Disketten
Bestell-Nr. L6 85 S7D DM 34,90*
4 KassGtton
Bestell-Nr. L6 85 S7K DM 34,90*
Sonderheft: Top-Themen
2 Disketten
Bestell-Nr. L6 85 S6 DM 34,90*
Sonderheft: Floppy, Datasette
Diskette
Bestell-Nr. L6 85 S5D DM 29,90*
KdSS6tt6
Bestell-Nr. L6 85 S5K DM 19,90*
Sonderheft: Grafik
Bestell-Nr. L6 85 S4A DM 29,90*
Sonderheft: Spiele
Beide Disketten in einem Paket!
Verwenden Sie nur diese Bestell-Nr.:
Bestell-Nr. L6 85 S3A DM 34,90*
Ausgabe 11/85
Bestell-Nr. L6 85 11A	DM 29,90*	
Commodore 64		
Checksummer V3	S.	54
MSE	S.	54
Koala-Painter Hardcopy	S.	39
Lyrik-Maschine (AdM)	s.	55
Hypra-Platos (LdM)	s.	61
Profiprint	s.	71
Apfelmännchen	s.	80
Block Out	s.	84
Spritekill	s.	86
Screen-Dump	s.	88
Pseudo-IRQ	s.	88
INPUT-Routine	s.	90
Synthetische Melodien	s.	95
Hypra-Ass Ergänzung	s.	96
Reassembler	s.	97
Vier Betriebssysteme	s.	105
Grafikwelt Teil 2	s.	149
Musikkurs Teil 10	s.	157
Sonderheft: Abenteuerspiele
Bestell-Nr. L6 85 S2 DM 34,90*
Sonderheft: Tips&Tricks
(2. ü. Auflage)
Floppy-Utilities CB 023 DM 29,90*
Hilfsprogramme CB 024 DM 29,90*
Ausgabe 12/85 Bestell-Nr. L6 85 12A DM 29,90*
Ausgabe 10/85
Leider hat sich in die Bestell-Nummer der letzten Programm-Service-Anzeige ein Druckfehler eingeschlichen. Die korrigierte Bestell-Nummer lautet:
L6 85 10A	DM 29,90*	
Commodore 64 Check V3 Dez 64	S.	54
MSEV1.0 Floppy-Adjust	S.	32
Eprom-Trans	S.	42
Schreiberling	S.	54
Cursus Latinus (AdM)	S.	57
Hypra-Text (LdM)	S.	67
Pacman	S. 76	Modulator	S. 46
Programm GEN	S. 86	REM-Killer	S. 75
SMON +	S. 87	Sound Editor	S. 136
Sequenzer	S. 129	Startgenerator	S. 74
Musik	S. 129	Ausgabe 6/85	
Alarmanlage Codeschloß	S. 132 S. 132	Bestell-Nr. L6 85 06A Commodore 64	DM 29,90*
Ausgabe 9/85		MSE	S. 54
Bestell-Nr. L6 85 09A Commodore 64 Sound-Machine Noteneingabe Sound Master Ringmod Moonlight SYNC Prüfungsfragen (AdM)	DM 29,90* S. 23 S. 24-25 S. 32 S. 32 S. 33 S. 33 S. 55-58	HI-EDDI/MPS 801 Prost E-Routine 64 GCR-HEX HEX-GCR Samurai Scroll-Machine (LdM) Crossreferenz Heapsort C 16 F-Plotter	S. 69 S. 76 S. 148 S. 117 S. 118 S. 72 S. 61 S. 155 S. 126
Schlüssel (LdM) Disk Designer	S. 59-61 S. 70-72		S. 68
Blinker Logelei-1/2 Lichtgr. Mischsort Block Busters X-Gleichung Musik-Tool	S. 73 S. 118 S. 122 S. 127 S. 159 S. 159 S. 159	Ausgabe 5/85 Bestell-Nr. L6 85 05A Commodore 64 Checksum. Schnell MSE Lader MPS 802 Format-System	DM 29,90* S. 54 S. 55 S. 31 S. 147
Ausgabe 8/85		VIC	S. 175
Bestell-Nr. L6 85 08A	DM 29,90*	6510 I	S. 71
Commodore 64		Sternenhimmel (AdM)	S. 57
Quicksort	S. 142	Assemblerkurs	S. 144
Procedure	S. 78	Direktory-Sorter	S. 77
Hypra-Save	S. 79	Trick.OBJ	S. 65
Uhr	S. 22	3D-Movie-Maker (LdM)	S. 65
NEWEA2 (AdM)	s: 6o	Modulator (Heft 4)	S. 155
Disk-Monitor	S. 84	VC 20	
Maskengenerator	S. 87	Checksummer	S. 54
Bit-Map	S. 81	Minigrafik	S. 69
HiRes3-Komplett	S. 159	Longscreen	S. 83
Forth-Compiler (LdM)	S. 63	C 16	S. 84
Vocabulary	S. 69	Help&Trace	
Schach Extern-Kurs	S. 74 S. 147	Ausgabe 4/85	
Sprites	S. 44	Bestell-Nr. L6 85 04A	DM 29,90*
Hypra-Zusatz Hi-Text 2.0	S. 25 S. 71	Ausgabe 3/85	
		Bestell-Nr. L6 85 03A	DM 29,90*
Ausgabe 7/85			
Bestell-Nr. L6 85 07A	DM 29,90*	Ausgabe 2/85	
Commodore 64 Haushaltsbuch (AdM)	S. 57	Bestell-Nr. L6 85 02A Ausgabe 1/85	DM 29,90*
Terminalprogramm	S. 152		
Centron	S. 80	Bestell-Nr. L6 85 01A	DM 29,90*
Editor Ein-/Ausgaberoutine	S. 151 S. 77	Ausgabe 12/84	DM 29,90*
Fenster (C 16)	S. 84	Bestell-Nr. CB 022	
File-Compactor	S. 82	Ausgabe 11/84	
Hypra-Assembler (LdM)	S. 66	Bestell-Nr. CB 020	DM 29,90*
lEEE-Basic	S. 46		
Logik	S. 144	Ausgabe 10/84	
Merkzettel	S. 83	Bestell-Nr. CB 019	DM 29,90*
Bedeutung der Abkürzungen *LdM = Listing des Monats *AdM = Anwendung des Monats *SB = Simons Basic *GV = Grundversion *GV> = alleSpeicherversionenkönnen	verwendet werden (einschließlich GV) *	3K	= 3-KByte-Speichererweiterung wird benötigt *	8K> = Speichererweiterunggrößerals 8 KByte wird benötigt *	UPB = Unterprogrammbibliothek
* Alle Preise inklusive Mehrwertsteuer. Bitte verwenden Sie für Ihre Bestellung nur die eingeheftete Postscheck-Zahlkarte zur Überweisung des Rechnungsbetrags.	Fehlende Hefte erhalten Sie bei: Markt&Technik Vertrieb 64'er Hans-Pinsel-Str. 2 8013 Haar	
. den USA för ftren Commodwe 64
. el,
(Speichern, Löschen, Laden)
Mari<t&Technik RUCHVERLAG =s.^SS«==
★ Deutsches _ Auswahlmenü auf Diskette Deutsches Anleitungsheft
Hinkt lJ?ita
MMhM Malwelen“ ““ **Ä-Ä
Siebrauchenmr®nuomm
Kurs
C64
Damit soll das Thema »Selbstmodifikation« abgeschlossen sein. Die vorgestellten Programmiertechniken bieten fast unbegrenzte Möglichkeiten, hier konnte ich nur einen kleinen Überblickgeben, welcheraberfürfortgeschrittene Programmierer ausreicht
11.	Mehr über relative Adressierung
So wie wir schon die Tücken der Zeropage-Adressierung zumindest teilweise beseitigen konnten, wollen wir uns mit der in vergleichbarer Weise leistungsstarken Relativ-Adressierung auseinandersetzen.
a)	So vermeidet man JMP
Oft muß eine Stelle im Programm angesprungen werden, ohne daß erst eine Bedingung geprüft wird. Diese Stelle ist nicht selten weniger als 128 Byte vom Sprungbefehl entfernt, könnte also relativ adressiert werden.
Dennoch ist es in vielen Fällen möglich, einen Branch-Befehl - obwohl diese Befehle eine Bedingung (C=0..) prüfen - zu verwenden.
Beispiel:
7050	BNE 7040
7052	JMP 708A
Kann ersetzt werden durch:
7050	BNE 7040
7052	BEQ 708A
da bei 7052 in jedem Fall das Z-Flag = 0 ist (dafür sorgt der Abfang-Befehl BNE) und somit immer verzweigt wird.
Man könnte den BEQ-Befehl als »Pseudo-Verzweigungsbefehl« bezeichnen, da die Bedingung gar nicht überprüft werden müßte (sie ist sowieso erfüllt).
Der Branch-Befehl übertrifft den JMP-Befehl deutlich an Effektivität, da ein Byte weniger verbraucht wird.
Im übrigen ist auch bei
7050	BVS 7040
7052	CLV
der CLV-Befehl überflüssig, solange vor7052 der Befehl von 7050 verarbeitet wird.
b)	Zugriff auf Befehle in »Umgebung«
Unter »Umgebung« wollen wir den Bereich um einen Programmteil verstehen, der über relative Adressierung angesprochen werden kann. Da in diesem oft ähnliche Befehlsfolgen stehen wie im anderen Programm, läßt sich hier durch gezielten Zugriff auf die »Umgebung« der Speicherplatzbedarf senken.
Beispielsweise stehen an vielen Stellen im Programm RTS-Befehle. Diese werden, wenn ein Unterprogramm verlassen werden soll, manchmal durch einen Branch-Befehl ange-
sprungen.
X1 RTS ; Ende eines im Speicher vorausgehenden Unterprogramms
UP .......	; Unterprogramm
TEST BEQ X2 ; Unterprogramm verlassen, falls Z=0 ..........	; andernfalls weiteres Programm
X2 RTS ; Ende des Unterprogramms
Wenn X1 von TEST aus relativ adressiert werden kann, können wir folgendermaßen ein Byte sparen:
X1 RTS
UP
TEST BEQ X1 ; nach X1 springen, wo auch ein RTS steht
X2 RTS ; wird nicht mehr benötigt
Noch ein Beispiel aus dem Basic-Interpreter. Bei Adresse $AF08 stehen zwei Befehle, die einen SYNTAX ERROR erzeugen.
Nun gibt es im Basic-Interpreter unzählige Stellen, an denen ein SYNTAX ERROR aufgerufen werden muß. Deshalb
steht dort nur »JMP $AF08«. Diese Stellen werden bei Bedarf relativ adressiert, so daß nicht an jeder Stelle, an der ein SYNTAX ERROR aufgerufen wird, der Befehl »JMP $AF08« stehen muß.
Zur Übung könnten Sie noch versuchen, im Programm Tabellen-Beispiel (Listing 11) die Menüroutine (insbesondere die Routinen HOME, DOWN, UP, EXEC), in der beispielsweise wiederholt STX MPT steht, durch Zugriff auf »Umgebung« zu optimieren. Besonders hilfreich dürfte es sein, zunächst statt Branch-Befehlen JMPs einzusetzen und dann zu überlegen, inwieweit die JMPs durch Branches ersetzt werden können, weil zum Beispiel nach »LDX # 0« das Z-Flag immer gesetzt ist etc.
12.	Puffer-Technik
ln der Computerei fällt der Begriff »Puffer« sehr häufig. Beim C 64 gehören der Kassetten- und der Tastaturpuffer gemeinhin zu den bekanntesten Puffern. Statt »Puffer« kann man auch Zwischenspeicher sagen. Puffer dienen nämlich immer als Zwischenspeicher.
Zunächst wollen wir klären, was zu einem Puffer gehört, a) Was benötigt ein Puffer?
- Pufferspeicher
Selbstverständlich muß ein Puffer einen bestimmten Speicherbereich belegen, in dem die Werte zwischengespeichert werden.
Ebenso muß die maximale Puffergröße festgelegt werden, damit geprüft werden kann, ob sich der Puffer schon angefüllt hat. Beim Kassettenzugriff werden vorerst alle Byte, die auf die Kassette sollen, im Puffer (ab $033C) zwischengespeichert. Ist dieser Puffer voll, würde er beim nächsten Byte, das er aufnehmen soll, überlaufen (das heißt, die maximale Puffergröße überschreiten). Deshalb wird dann Byte für Byte der Puffer entleert, indem die Bytes auf Kassette geschrieben werden. Jedes Byte, das auf Kassette geschrieben wurde, belegt keinen Speicher mehr im Puffer, so daß der Puffer wieder aufnahmefähig ist.
Damit das Programm, das den Puffer verwaltet, auch weiß, aus welcher Adresse im Puffer es sich das nächste Byte holen soll beziehungsweise wo im Puffer das nächste Byte abgelegt werden soll, gibt es noch einen
-	Pufferzeiger
Auf englisch heißt er »BUFFER-POINTER«, woher auch die Abkürzung »B-P« beim Floppy-Befehl zur Manipulation des Pufferzeigers stammt.
Dieser Pufferzeiger kann mit dem Stapelzeiger verglichen werden. Auf keinen Fall ist er mit dem
-	Puffervektor
zu verwechseln, der die Startadresse des Pufferspeichers beinhaltet. Ein Puffervektor ist nicht unbedingt erforderlich, erhöht aber die Flexibilität.
Damit wären die Fachausdrücke im Zusammenhang mit Puffern geklärt.
b) Wann verwendet man Puffer?
Puffer dienen in der Regel als Zwischenspeicher, wie zum Beispiel der Basic-Eingabepuffer (ab $0200).
Im Fall des Tastatur- oder Diskettenpuffers aber sind die Puffer als Verbindungsstelle zwischen zwei parallel arbeitenden Programmen beziehungsweise Peripheriegeräten vorgesehen (interruptgesteuerte Tastaturabfrage/Hauptpro-gramm im Computer, DOS/Betriebssystem des Computers).
Die Puffer sind in diesen Fällen ein Bereich, auf den zwei (quasi-) parallel arbeitende Programme zugreifen.
Bei Computern, die ein wirklich starkes Multitasking bieten (wie der Commodore Amiga) finden Puffer weitaus mehr Verwendung als beim C 64, der nur einen quasiparallelen Ablauf ermöglicht.
102
C64
Kurs
Daher werden bei ihm Puffer hauptsächlich im I/O-Bereich verwendet, zum Beispiel bei Druckern, Datasette, Floppy, Tastatur etc. (I/O = lnput/Output = Eingabe/Ausgabe).
13.	Pass-Technik
a)	Begriffserläuterung
Der Begriff »Pass« wurde schon mehrfach im 64’er erläutert (unter anderem Ausgabe 7/85, Seite 51).
Am einfachsten kann der Begriff als »Schritt beim Pro-grammmablauf« verstanden werden. Mit »Schritt« ist hier nicht ein einzelner Befehl, sondern ein größerer Block im Programm gemeint.
Wenn ein Programm in 3 Passes (Durchläufen) arbeitet, heißt dies, daß 3 Schleifen hintereinander abgearbeitet werden, die alle eine Teilaufgabe erfüllen, die in Verbindung mit den anderen Passes erst eine größere Aufgabe (zum Beispiel eine Assemblierung) ausfüllen kann. Jeder einzelne Pass führt eine bestimmte Tätigkeit aus, die für das Funktionieren der darauffolgenden Passes unbedingt erforderlich ist. Pass 1 wirkt also wie eine Initialisierung von Pass 2 etc.
Komplexe Programme in Schritte (Passes) zu gliedern, gehört zu den Grundregeln des strukturierten Programmierens.
b)	Beispiele von Anwendungen der Pass-Technik
Besonders umfangreiche Programme wie Assembler (Hypra-Ass), Compiler (Austro-Speed) und Interpreter (Comal) sind immer in mehrere Passes eingeteilt.
So erfolgt bei den meisten Assemblern im ersten Pass ein Syntax-Check und das Anlegen der Symbol-Tabelle. Erst im zweiten Pass wird der Objektcode generiert, wobei die bereits erstellte Symboltabelle benötigt wird.
14.	Diverse Tips zur optimalen Speichernutzung
Mit übermäßig viel RAM ist der C 64 bestimmt nicht gesegnet. Bei vielen Anwendungen (zum Beispiel Datenverarbeitung) braucht man auch das letzte Byte.
Sie werden nun mehrere Tips erhalten, wie man den wenigen vorhandenen Speicher möglichst sparsam verwenden kann.
Zu den speicherplatzaufwendigsten Einrichtungen gehören die Puffer. Der Kassettenpuffer beispielsweise belegt den RAM-Bereich $033C - $03FB, auf den man somit oft verzichten muß.
Hier wollen wir einfach den Kassettenpuffer in den Bildschirmspeicher (ab $0400 in Normaleinstellung) verlegen.
LDA #<$400
LDY #>$400
STA $B2
STY $B3
Da der Bildschirm beim Kassettenbetrieb ohnehin abgeschaltet wird, fällt dies nicht auf. Nach dem Kassettenbetrieb sollte man aber den Bildschirm unverzüglich löschen.
Ebenso kann man andere Puffer, für die es einen Vektor gibt, problemlos nach $400verlegen, sofern sie nicht größer als 1000 Byte sind.
Ein Problem für sich stellt das RAM ab $E000 (also unter dem Betriebssystem!) dar. Diesen Speicher kann man nur durch Bank-Switching nutzen, wobei man noch auf das Betriebssystem verzichten muß, solange der $E000-Be-reich auf RAM geschaltet ist.
Hier können wir uns zunutze machen, daß der VIC auch ohne Ändern des Prozessor-Ports (Adresse $0001) auf diesen RAM-Bereichzugreifen kann. FürGrafikbilderodereinen geänderten Zeichensatz ist der$E000-Bereich bestens geeignet.
Oft wird der $E000-Bereich zur Ablage verschiedener Daten verwendet, auf die nicht andauernd zugegriffen wer- ' den muß.
Man könnte aber auch das Betriebssystem ins RAM ab $E000 kopieren und diejenigen Bereiche, in denen nicht benötigte Routinen stehen (zum Beispiel für Kassettenbetrieb) einfach überschreiben. Dies ist dann sinnvoll, wenn nur ein paar Byte im $E000-Bereich gebraucht werden. Außerdem ist eine gute Kenntnis des C 64-ROMs erforderlich.
Nun wollen wir noch besprechen, wie der Speicherplatzbedarf eines Programms niedriggehalten werden kann. Dazu wurde im Laufe des Kurses schon einiges gesagt (Unterprogramme statt Makros verwenden etc.).
Jedes Programm benötigt eine Menge Flags. Meist belegt ein Flag genau 1 Byte, für dessen Inhalt es oft nur zwei mögliche Werte gibt: einen für »JA« und einen für »NEIN«.
Für diese primitive Unterscheidungsform genügt aber auch 1/8 Byte, also ein Bit.
Wenn Sie sich das 64’er Extra in der Ausgabe 10/85 ansehen, werden Sie feststellen, daß fast jedes VIC-Register mehrere Funktionen hat, weil jedem Bit eine eigene Bedeutung zukommt. Würde der VIC hier statt auf Bits auf Bytes zugreifen müssen, wäre er
1.	langsamer und
2.	würde der Speicherplatzaufwand für die Register sich vervielfachen.
Man sollte also bei Flags jedem Bit eine Bedeutung geben
und nur die Bits prüfen:
BIT FLAG
Danach ist das N-Flag gesetzt, falls das 7. Bit im FLAG gesetzt ist, und das V-Flag, falls das 6. Bit gesetzt ist. Die übrigen Flags erhält man über das Z-Flag im Prozessor-Status-Register mit Hilfe des Akkus. Angenommen, man möchte testen, ob Bit 0 im Flag gesetzt ist oder nicht, dann macht das folgendes Programm:
LDA #01
BITFIag
BNE ???	; (Bit gesetzt)
; (Bit nicht gesetzt)
Der Bit-Befehl ANDet den Inhalt des Akkus mit dem Inhalt der Speicherzelle »Flag«. Möchte man Bit 1 testen, so ist der Befehl LDA # 01 zu ersetzen durch LDA # 02 und so weiter.
Durch Selbstmodifikation können Flags bekanntlich vermieden werden. Aber auch sonst bietet die Selbstmodifikation die Möglichkeit, Speicherplatz zu sparen: die Steuerung einer Sprungtabelle belegt mit Selbstmodifikation weniger Speicher als ohne.
Auch die »Wegwerfmethode« ist sehr vorteilhaft. Programmteile werden einmal abgearbeitet und dann (zum Beispiel durch Nachladen) überschrieben.
Damit hätten wir unseren Kurs abgeschlossen. Ich hoffe, daß er Ihnen etwas Spaß gemacht hat und Sie einige interessante Informationen herausholen konnten. Sie sollten sich jedoch darüber im klaren sein, daß einige der hier vorgestellten Methoden die Lesbarkeit eines Assembler-Listings einschränken können. Also, verzichten Sie, wenn nicht unbedingt notwendig, auf allzu trickreiche Programmierung. Falls Sie noch Fragen oder Probleme haben (vielleicht erst wegen diesem Artikel), dann schreiben Sie doch einfach.
(Florian Müller/tr)



















# Schleifen mit Format [141-143]

> In manchen Pascal-Versionen geht es automatisch, beim C 64 nur mit einem Trick: das Einrücken von Schleifen. Anhand eines Programms in Maschinensprache bringen Sie Form in Ihre Listings. Wir zeigen auch, wie es geht.

Anhänger der strukturierten Programmierung haben es gelernt, selbst der in Schulungen: ein Programm modular aufbauen, in kleine Schritte zerlegen, übersichtlich gestalten. Leider ist es mit dem C 64 nicht so ganz einfach. Außer IF..THEN, GOTO, GOSUB und FOR..NEXT wird strukturiertes Codieren nicht unterstützt.

Eine Möglichkeit ist, FOR..NEXT-Schleifen einzurücken. Normalerweise macht man das, indem nach der Zeilennummer ein Doppelpunkt gesetzt wird und erst danach die gewünschte Anzahl Leerstellen. Ein kurzes Beispiel:
Schleife ohne einrücken:

10 FOR I=1 TO 10
20 A = A + 1
30 GOSUB 100
40 FOR J = 1 TO10
50 PRINT I,J,A*J
60 NEXT J
70 NEXT I
Schleife mit einrücken durch Doppelpunkte:
10 FOR I=1 TO 10
20 : A=A+1
30 : GOSUB 100
40 : FOR J=1 TO 10
50 : PRINT I,J,A*J
60 : NEXT J
70 NEXT I
Das sieht schon viel besser aus. Bei langen Listings werden Sie diese Form schätzen lernen. Allerdings, das Nonplusultra ist es auch nicht. Besser wäre es, das Listing würde so aussehen:

10 FOR I=1 TO 10
20 A=A+I 100
30 GOSUB 100
40 FOR J = 1 TO 10
50 PRINT I,J,A*J
60 NEXT J
70 NEXT I
Um das zu erreichen, müssen wir eine kleine Maschinenroutine schreiben. Aber wie?

Ein Gedanke liegt nah: Warum nicht die normale LIST-Routine des C 64 verwenden? Sie erledigt ja schon einen großen Teil der Aufgabe, nämlich das normale LISTen. Was fehlt, ist nur noch das Einrücken. Zuerst muß also ein dokumentiertes ROM-Listing her. Dort finden wir die LIST-Routine des Basic-Interpreters ab $A69C. Sie geht bis $A740. Soweit, so gut. Aber wie greifen wir in diese Routine ein? Sieht man sich die LIST-Routine etwas genauer an, findet man einen indirekten Sprung ab Adresse $A717 (JMP ($0306)). Das bedeutet, an dieser Stelle springt die LIST- Routine zu der Adresse, die sich aus dem Inhalt der Adressen $0306/$0307 (LO/HI-Byte) ergibt. Man spricht in so einem Fall auch von einem Vektor. Dort kurz spioniert, finden wir in $0306/$0307 die Zahlen $1A und $A7, zusammengesetzt also die Adresse A71 A, das heißt genau die Adresse, die dem JMP($0306) folgt. Damit haben wir genau das, was wir suchen, eine Möglichkeit, in die LIST-Routine einzugreifen. Denn $0306 steht im RAM, kann also (von uns) geändert werden.

Im Prinzip brauchen wir also nur folgendes zu machen: Wir schreiben die Anfangsadresse unserer Routine in die Speicherstellen $0306/$0307. Damit springt die Original-LIST- Routine unsere neue Routine an und führt sie aus. In »Fachkreisen« würde man sagen, der LIST-Vektor ist verbogen worden. Am Ende unseres Programms müssen wir noch dafür sorgen, daß die alte LIST-Routine wieder fortgesetzt wird und zwar machen wir das mit JMP $A71A.

Grundsätzlich kennen wir nun also das Wie. In der Zwischenzeit taucht aber noch ein Gedanke auf: Wie soll das Programm gestartet werden? Nach dem Lesen des Assembler-Kurses (Assembler ist keine Alchimie) im 64’er und einigen anderen Artikeln fällt das Stichwort: Interrupt.

Interrupt war für mich immer ein Wort, vor dem ich mich etwas gedrückt habe, aber so schlimm ist es gar nicht. Doch zuerst einmal zur Aufgabe: Die neue LIST-Routine soll mit der Funktionstaste F7 an- und mit F1 ausgeschaltet werden. Um das zu erreichen, muß noch einmal ein Vektor verbogen werden, und zwar der Interrupt-Vektor in Adresse $0314/$0315 auf unser eigenes Programm (siehe Listing 2, Zeilen 290 bis 360). Wir müssen dafür sorgen, daß die Tasten F7 und F1 dauernd abgefragt werden. Das erreicht man, indem die Interrupt-Routine erweitert wird. Auch hier hilft ein kleines Programm (Listing 2, Zeilen 364 bis 372). Im Prinzip soll unsere neue LIST-Routine so ablaufen:

1. Initialisieren des Programms mit SYS adresse (»adresse« können wir selbst festlegen)
2. mit F7 einschalten und mit F1 ausschalten.
3. mitdem ganz normalen LIST-Befehl ein beliebiges Basic-Programm auf dem Bildschirm oder Drucker ausgeben. Auf dem Drucker sollen die Basic-Befehle FOR und NEXT fettgedruckt werden.

Und damit auch zu sehen ist, ob die neue oder die normale Routine aktiviert ist, soll der Rahmen beim Drücken von F7 die Farbe wechseln (Listing 2, Zeile 452/453) und bei F1 ebenso (Listing 2, Zeile 522/523).

## Die LIST-Routine

Die eigentliche neue LIST-Routine finden Sie in Listing 2, Zeile 1000 bis 1340. Danach folgen einige Unterprogramme, zum Beispiel Fettdruck ein-/ausschalten und Leerzeichen ausgeben.

Um das Programm zu verstehen, muß man folgendes wissen:

1. Wenn die neue LIST-Routine angesprungen wird, steht im Akku ein Zeichen aus dem Basic-Listing, das wir ausgeben wollen. Das kann jedes Zeichen sein zwischen der Basic-Zeilennummer und dem Ende einer Basic-Zeile (die Zeilennummer selbst wird vorher, von der alten List-Routine selbst, ausgegeben.).
2. Der Akku-Inhalt muß am Ende unserer LIST-Routine wieder an das Original-LIST übergeben werden. Aus diesem Grund wird er sicherheitshalber am Anfang der Routine mit PHA gesichert und am Ende mit PLA zurückgeholt.
3. Jeder Basic-Befehl wird im Speicher als Token abgelegt, eine Abkürzung. Der Befehl FOR hat den Wert $81 und NEXT den Wert $82.

Der Algorithmus istjetzt nicht mehr schwer zu entwickeln. Da man FOR..NEXT-Schleifen (fast) beliebig schachteln kann, setzen wir einen Zähler ein (im Listing 2 ZAEHLER genannt), der die Anzahl der Verschachtelungen zählt: Bei jedem FOR wird ZAEHLER um 1 erhöht (Zeile 1210 bis 1240, bei jedem NEXT um 1 vermindert (Zeile 1160 bis 1180). Der Inhalt von ZAEHLER bestimmt auch die Anzahl der Leerzeichen, die am Anfang der Zeile, nach der Zeilennummer, ausgegeben werden (Zeile 1190 bis 1207). Der Anfang der Zeile wird durch eine 4 im Y-Register gekennzeichnet. Das hängt mit dem Aufbau einer Basic-Zeile im C 64 zusammen und mit der indirekt-indizierten Adressierung, die die LIST-Routine verwendet (Y=0 und Y=1 sind die Startadresse der Basic-Zeile, Y=2 und Y=3 die Zeilennummer und ab Y=4 folgt der Rest der Basic-Zeile).

Das Unterprogramm BLANKOUT (Zeile 2010 bis 2070 gibt Leerzeichen aus, und zwar so viele, wie in ZAEHLER stehen.

Die Routinen FETTDRUCK und NORMDRUCK schalten bei Ausgabe auf Drucker (mit OPEN 1,4:CMD1:LIST) Fettdruck an und aus. Interessant sind hier vielleicht die Zeilen 1510 bis 1530 oder 1710 bis 1730. Durch die Abfrage der Speicherstelle $9A (dezimal 154) kann die mit CMD gewählte Geräteadresse überprüft werden (4 steht für Drucker). Die Sequenz, diehiergewähltwurde, um Fettschrift einzuschalten, giltfür Epson-kompatible Drucker (Zeile 1630 und Normalschrift Zeile 1830). Sie können diese Routinen natürlich entfernen, es istGeschmacksache, die FOR..NEXT- Schleife auch noch fettgedruckt zu sehen (Listing 1).

### Hinweise zum Abtippen

Listing 2 ist der Quelltext oder, wie man auch sagt, der Sourcecode der neuen Listroutine. Wenn Sie wollen, können Sie ihn mit Hypra-Ass eingeben. Das hat den Vorteil, daß Sie das Programm weiterentwickeln oder verändern können. Wollen Sie das Programm lediglich benutzen, tippen Sie am besten Listing 3 mit dem MSE ab. Gestartet wird mit SYS 5*4096 oder SYS 20480. Mit F7 ist die neue LIST-Routine aktiv, mit F1 abgeschaltet. Auch während des LISTens kann umgeschaltet werden. Eine korrekte FOR..NEXT - Schleife wird daran erkannt, daß sich FOR und NEXT auf der gleichen Höhe befinden (Listing 1). Wenn Sie das Programm etwas genauer analysieren, dürfte es nicht schwerfallen, eigene Wünsche zu verwirklichen.

(H. Zwartscholten/gk)

# ÜberLISTet [143-144]

> Mit dieser Betriebssystemerweiterung wird das Schreiben von Basic-Programmen zum Vergnügen. Scrolling aufwärts und abwärts sowie einige Zusatzfunktionen machen es möglich.

Dieses Maschinenprogramm (eventuell in Verbindung mit einem Toolkit) macht das Editieren von Basic-Texten fast so komfortabel wie mit einem guten Textverarbeitungssystem. Man kann damit nämlich nicht nur, wie von vielen teuren Basic-Erweiterungen bekannt, das Listing mit den Cursortasten hinauf und hinunterscrollen, sondern auch:

- andere Erweiterungen verwenden
- einzelne Zeilen löschen und einfügen
- eine Zeile bis beziehungsweise ab Cursorposition löschen
- eine ganze Zeile mit Leerzeichen füllen
- einen Zeilenausschnitt beliebig oft an andere Positionen kopieren.

Dies alles geschieht auf einfachen Tastendruck und ohne Absturzgefahr.

Um mit möglichst vielen anderen Programmen zusammenarbeiten zu können, liegt das zirka 1300 Byte lange Programm im Bereich $7A00 - 7F20 (Hexadezimal). Dazu muß das Ende des Basic-Bereichs gegebenenfalls herabgesetzt werden (POKE 56,122:POKE 55,0: NEW). Mit »SYS 31232« wird die Erweiterung in den Interrupt eingehängt und ist dann sofort einsatzbereit. Es wird nur der IRQ-Vektor verändert.

Das Listing läßt sich im Direktmodus mit Hilfe der Cursortasten fließend hoch- und runterscrollen. Die Programmzeilen können dabei natürlich wie gewohnt geändert und mittels der RETURN-Taste übernommen werden. Stößt man jedoch mit dem Cursor gegen den oberen beziehungsweise unteren Bildschirmrand, wird der Inhalt des Bildschirms in die entsprechende Richtung gescrollt und die nächste Zeile ausgegeben.

Das Programm geht dabei so vor: Es sucht die am nächsten zum Cursor stehende Zeilennummer. Steht keine Zahl in der ersten Spalte, wird normal gescrollt (auch nach unten). Ist die gefundene Zahl größer gleich 64000, wird der Cursor auf diese Zeile gesetzt und das Scrolling verhindert. Andernfalls wird die nächsthöhere beziehungsweise nächstniedrigere Zeile aus dem Basic-Listing gesucht, der Bildschirm in die richtige Richtung gescrollt und die gefundene Zeile gelistet.

Die Erweiterung arbeitet nur im Direktmodus, das heißt wenn in einem Programm ein »INPUT«-Befehl oder ähnliches vorkommt, verhält sich der Bildschirm normal.

Zusätzlich bietet dieses Programm noch einige andere Möglichkeiten, die das Editieren erleichtern. Diese Funktionen werden durch gleichzeitiges Drücken der Control-Taste und einer Buchstabentaste aufgerufen. Zwischen zwei Anführungszeichen werden diese »Control-Codes« jedoch normal ausgegeben.

TODO TABLE

CTRL-i Einfügen (Insert) einer Leerzeile. Der untere Teil des Bildschirms wird nach unten geschoben. Dies dient zur Übersichtlichkeit, wenn eine neue Basic-Zeile eingegeben werden soll, da keine anderen Zeilen überschrieben werden brauchen.
CTRL-d Löschen (Delete) einer Zeile mit Nachrücken des unteren Bildschirmteils. Auch dies dient der Übersichtlichkeit. Soll eine Zeile gänzlich aus dem Listing gelöscht werden, muß man (wie üblich) die »leere« Zeilennummer und RETURN eingeben.
CTRL-I Füllen einer Zeile (Line) mit Leerzeichen. Nach den drei letztgenannten Funktionen springt der Cursor an den Anfang der Zeile.
CTRL-b löscht die Zeile bis ausschließlich Cursorposition
CTRL-a löscht die Zeile ab einschließlich Cursorposition
CTRL-u setzt Cursor in die linke untere Ecke
CTRL-k Kopieren eines Zeilenausschnitts. Der Bereich wird durch Invertieren angezeigt und kann mit der Cursor-right/left Taste vergrößert oder verkleinert werden. Bei Betätigen der RETURN- oder der STOP-Taste wird der vorher invertierte Bereich gespeichert.
CTRL-w schreibt (Write) vorher markierten Bereich wieder auf den Bildschirm.

Die Erweiterung läßt sich durch Normalisieren des IRQ-Vektors (zum Beispiel über die Tastenkombination RUN/STOP-RESTORE) oder CTRL-X (exit) abschalten.

Starten von »Listmaster«: Tippen Sie das Listing mit dem MSE ab und speichern Sie es auf Disk oder Kassette. Bei Bedarf laden Sie es absolut (das heißt mit ,8,1 oder ,1,1) und geben ein:

POKE 56,122: POKE 55,0:NEW
Dies ist wie gesagt notwendig, um das Ende des Basic-Bereichs herabzusetzen und das Maschinenprogramm vor der Zerstörung durch Basic-Variablen zu schützen.

Noch ein paar Informationen zu »Listmaster«: Erarbeitet mit anderen Interrupt-Programmen zusammen, da die Routine, auf die der IRQ-Vektor ($0314) vor der Initialisierung von »Listmaster« zeigte, als Unterprogramm aufrufen wird. Man darf also keinesfalls zweimal nacheinander »SYS 31232« eingeben. Das würde einen Selbstaufruf und somit Systemabsturz bewirken. Außerdem benötigt »Listmaster« einige Direkteinsprünge ins Betriebssystem, so daß es bei stark geänderten Varianten desselbigen zu Fehlfunktionen kommen kann.

An Speicheradressen verändert »Listmaster« nur einige wenige, die auch vom Standardbasic oder vom normalen Bildschirmeditor gebraucht werden. Es sind dies im Wesentlichen:

TODO TABLE

$07	;Zwischenspeicher
$14/15	;Zwischenspeicher
$22/23	;Suchzeiger
$5F/60	;Suchzeiger
$62/63	;Zwischenspeicher
$AC/AD	;Zeiger für Scrolling
$AE/AF	;Zeiger für Scrolling
$B0	;Zwischenspeicher
$CC	;Flag für Cursor blinken
$D1/D2	;Zeiger auf aktuelle Zeile
$D9-F2	;Tabelle Bildschirmzeilen
$F3/F4	;Zeiger auf Farbram
$0314/15	;Interruptvektor

Die Daten für den k-Befehl werden unmittelbar hinter dem »Listmaster«-Programm aufbewahrt (maximal 80 Zeichen).

(Matthias Meyer/tr)

# Drei »Quickies« [145]

> Einzeiler lassen sich nicht nur in Basic, sondern auch in Assembler schreiben! Tippen Sie unsere drei »Quickies« ein, und lassen Sie sich überraschen, mit welchen Tricks da gearbeitet wurde.

Die beiden Basic-Programme »Zeichensatz ändern« und »invertierte Grafik« müssen Sie mit dem MSE eingeben. Dies hat zwei Gründe: Erstens einmal lassen sich dadurch Tippfehler leichter ausschalten und zweitens wäre die Eingabe über Basic sehr mühsam. Wenn Sie die »Einzeiler« auf Diskette gespeichert haben, können Sie sie ohne weiteres wie normale Basic-Listings laden, listen und mit »RUN« starten.

## Stop!

1 fori = 828to839:reada:pokei,a:next:data72,173,141,2, 201,1,240, 249,104,76,202,241

TODO TABLE

Einschalten poke806,60:poke807,3
Ausschalten poke 806,202:poke807,241

In diesem kleinen Maschinenprogramm wird während des Listens eines Programms die Shift-Taste abgefragt und, wenn diese gedrückt ist, gewartet. Sonst wird zur Adresse 61898 (Ausgabe eines Zeichens) gesprungen. Durch die zwei POKEs wird der Ausgabe-Vektor ($F1CA) auf den Kassettenpuffer nach 828 »verbogen«.

TODO TABLE

828	pha	: Akku sichern
829	Ida 653	: Flag fürSHIFT
832	cmp#1	: gedrückt?
834	beq 829	: ja, dann warten
836	pla	: Akku wiederherstellen
837	jmp 61898	: zur Ausgaberoutine

(Ulrich Pasch/tr)

## Zeichensatz ändern

Dieser Einzeiler verschiebt den Zeichensatz in den Speicherbereich Hexadezimal $2000 - $3000. Damit können jederzeit beliebige Zeichen geändert werden; zum Beispiel, um Sonderzeichen zu definieren.

### Zum Aufbau des Programms (Listing 1a und 1b)

Ein PRINT-Befehl schreibt das Maschinenprogramm in den Bildschirmspeicher, wo es dann mit SYS 1024 gestartet wird.

Das Maschinenprogramm setzt zunächst das Interruptflag, um einen Interrupt durch den CIA 1 zu unterbinden. Das ist nötig, da der Computer sonst abstürzen würde, wenn das Zeichen-ROM eingeschaltet wird. Danach wird das ZeichenROM eingeschaltet. Jetzt wird nach der nötigen Parameterübergabe (alter Blockanfang, altes Blockende, neues Blockende) die Blockverschieberoutine des Interpreters aufgerufen. Dann wird der Zeichengenerator wieder abgeschaltet und der Zeiger auf den Zeichengenerator entsprechend geändert (Hexadezimal D018, Bit 1-3). Nach dem Löschen des Interruptflags erfolgt der Rücksprung ins Basic.

(Peter Sajonez/tr)

## Invertierte Grafik

Dieser Einzeiler (Listing 2) invertiert eine im Speicher stehende Grafik. Gegenüber dem Einzeiler, der in der 64’er, 3/85 veröffentlicht wurde, braucht er zur Ausführung nur den Bruchteil einer Sekunde. Er besteht im wesentlichen aus einer kleinen Maschinenroutine, die mittels einem PRINT-Befehl in den Bildschirm geschrieben und mit SYS 1024 gestartet wird.

(Frank Meister/tr)

# INPUT mit Pfiff [146-151]

> Einen INPUT-Befehl, der keine Wünsche mehr offenläßt, stellen wir Ihnen mit diesem Programm vor. Anhand des ausführlich dokumentierten Assembler-Listings können Sie zum Beispiel lernen, wie man eigene Befehle in den Interpreter einbaut.

Exinput 64« löst all Ihre Probleme, die Sie jemals mit dem INPUT-Befehl des Basic V2 gehabt haben. Mit dieser kleinen Erweiterung haben Sie ein Werkzeug in der Hand, das alle seitenlangen GET-Eingabeschleifen vergessen läßt. »Exinput 64« beschränkt sich nicht auf 80 Zeichen; Sie haben, wenn Sie wollen, die volle Länge eines Strings (255 Zeichen) zur Verfügung. Das Eingabefeld wird dabei durch eine Linie sichtbar gemacht. Sämtliche Zeichen können übernommen werden - auch Kommata und Doppelpunkte. Natürlich kann man die Eingabe auch auf bestimmte Tasten beschränken.

Eingabehinweis: Bitte geben Sie Listing 1 mit dem MSE ein, und speichern Sie es mit einem beliebigen Namen.

### Programmbeschreibung

Die Erweiterung steht im Speicher von $C000 bis $C51D, wird mit »LOAD ”Name”,8,1« geladen, mit »SYS 49152« gestartet und muß nur nach einem Reset wieder neu initialisiert werden. Die Routine wurde über einen Zeiger aus der Zero-Page des C 64 in das normale Basic eingebunden.

Dies ist der Zeiger für »Basic-Befehlsadresse holen« in den Adressen $308/$309 (dezimal 776/777). Der Zeiger in diesen beiden Speicherstellen wird von $A7E4 auf den Anfang der Befehlserweiterung, in diesem Fall auf $C00B geändert. Dies wird beim Start des Programms durch die vier ersten Assemblerbefehle gemacht. Danach springt das Programm wieder ins Basic zurück und die beiden zusätzlichen »Basic-Befehle« stehen zum sofortigen Gebrauch im Basic-Programm zur Verfügung (siehe auch Kasten).

Die Routine übernimmt das selektieren der neuen Befehlsworte. Wird ein INPUT- oder PRINT-Befehl gefunden, wird auf das Erkennungszeichen der neuen Befehle (>) geprüft. Ist dieses Zeichen vorhanden, so wird in die eigene Routine verzweigt, ansonsten wird die Routine des Basic-Interpreters aufgerufen.

Der INPUT-Befehl sieht auf den ersten Blick vielleicht etwas kompliziert aus, ist es aber nach ein wenig Ausprobieren nicht mehr.

INPUT> Zeile, Spalte, Länge, Farbe, Text, Code, Zeichen, Variable

### Erklärung der Parameter

TODO TABLE

Zeile:	1 bis 25	(oderVariable)
Spalte:	1 bis 40	(oderVariable)
Länge:	1bis 255(oderVariable)
Farbe:	0-15	(Farbe des Textes und des Eingabefeldes)
Text:	Beliebiger Text zwischen "", erscheint vor dem Eingabefeld
Code:	- 'A' = Alle Zeichen bei der Eingabe erlaubt
- ’B’ = Nur Buchstaben, Leerzeichen, ’.’ und ’-’ für Abkürzung und Trennung
- ’Z’ = Nur Ziffern, Minuszeichen und Dezimalpunkt
Zeichen: Einzelne Ziffern, Buchstaben oder jedes andere Zeichen zwischen " ", das bei der Eingabe erlaubt ist. (< 30 Zeichen) zum Beispiel Menüpunktabfrage zwischen 1 und 4: INPUT >20,5,1,1,"Bitte wählen: ",**Z**,"**1234**", X$
Variable: Muß eine String-Variable sein.
Einziger Nachteil: Ziffern müssen zum Rechnen mit VAL umgewandelt werden.

Ganz einfach ist der Befehl, weil man verschiedene Parameter einzeln oder zusammen weglassen kann, und zwar »Farbe«, »Text« und »Zeichen«. Dann bleibt zum Beispiel noch übrig:

INPUT>10,3,15,B,A$

Die Länge des Eingabefeldes wird durch eine Linie markiert, dessen einzelnes Zeichen (CHR$(100)) an der Adresse 49244 steht und durch »POKE 49244, CHR$-Code« beliebig geändert werden kann, zum Beispiel 32 (Leerzeichen), 46 (Punkt) etc.

Wird eine unerlaubte Taste gedrückt, oder soll der Cursor die Feldgrenze überschreiten, ertönt zur Warnung ein Piepston. Dieser kann mit »POKE 50340,0« ausgeschaltet und mit »POKE 50340,65« wieder eingeschaltet werden.

Am Ende des Eingabefeldes wird das letzte Zeichen bei weiteren Eingaben überschrieben.

### Editier-Tasten

TODO TABLE

CRSR Left	
CRSR Right	
CRSR Up	(Nur bei mehreren Zeilen)
CRSR Down INST DEL HOME CLR/HOME	(Nur bei mehreren Zeilen)
RETURN	übernimmtden Feldinhaltohne Leerstellen am Ende
SHIFT/RETURN	übernimmtauch die Leerstellen, also das ganze Feld
Ob mit oder ohne Leerstellen kann bei den beiden Tasten auch selbst bestimmt werden.
Für RETURN: »POKE 49595, 182(ohne)/208(mit)«
Für SHIFT/RETURN: »POKE 49602, 208(mit)/182(ohne)«
F8	läßt einen eventuellen Inhalt der Variablen im Eingabefeld erscheinen, jedoch nur bis zur Länge des Feldes selbst
Der zweite Befehl der Erweiterung betrifft den PRINT-Befehl.

### Die Syntax des PRINT-Befehls

PRINT > Zeile, Spalte, Farbe, String
Hier kann die Farbe weggelassen werden, der zu druckende String muß zwischen " " stehen wie beim normalen PRINT-Befehl und jeder Parameter kann durch eine Variable ersetzt werden.

Mit den Angaben der im Kasten genannten Routinen kann man leicht eine Variable erstellen. Man kopiert nur die Adresse des reservierten Bereichs und die Länge in den Stringdescriptor und den Text der Variablen schreibt man in den reservierten Bereich. Alles andere erfahren Sie, wenn Sie das Programm selbst durchlesen (Listing 2).

(Guy Mootz/og)

TODO ASIDE

### Erklärungen zu oft benötigten ROM-Routinen und zur Erstellung der Variablen.

TODO TABLE

CHRGET:	Diese Routine steht ab $E3A2 im Betriebssystem und wird beim Einschalten des Computers nach $0073 in die Zero-Page kopiert Der Zeiger in $007A/$007B zeigt immer auf das aktuelle Zeichen im Basic-Text und beim Ansprung der Routine wird jeweils das nächste Zeichen in den Akku geholt.
CHRGOT:	Dies ist nur eine andere Einsprungadresse der CHRGET-Routine. Hier wird das aktuelle Zeichen in den Akku geholt und die Flags wieder gesetzt, ohne den Zeiger in $7A/$7B vorher zu erhöhen.
CHKCOM: Hier handelt es sich um eine Basic-Routine, die das laufende Zeichen prüft. Beim Einsprung in »CHKCOM« ($AEFD) wird auf ein Komma im Basic-Text geprüft, bei $AEF7 auf »Klammer zu« und bei $AEFA auf »Klammer auf«. Stimmen die Zeichen nicht überein, wird automatisch ein »Syntax Error« ausgegeben.<br>Vor dem Rücksprung liest die Routine gleich das nächste Zeichen aus dem Basic-Text in den Akku, so daß dies beim Weiterführen des Programms entfallen kann.
GETBYT:	Diese Basic-Routine holt eine Zahl (Byte 0-255) in das X-Register. Beim Einsprung in $B79B wird zuerst durch »JSR $0073« das nächste Zeichen geholt (CHRGET). Hat man vorher jedoch mit »JSR $AEFD« auf ein Komma geprüft (CHKCOM), darf man erst bei $B79E einspringen, weil das nächste Zeichen sich bereits im Akku befindet.
GETVAR:	Diese Routine holt sich den Variablennamen aus dem Basic-Text und sucht diese Variable dann im Speicher. Wenn sie nicht vorhanden ist, wird sie angelegt. Danach stehen dann in $0D das Typflag dieser Variablen (String=$FF/Zahl = $OO), im Akku das Low-Byte und im Y-Register das High-Byte der Adresse, an der der Stringdescriptor beginnt.
FRESTR:	Mit dieser Routine wird die weitere Auswertung der mit »GETVAR« eingelesenen Variablen vorgenommen. Nachher stehen im X-Register das Low-Byte der Adresse, im Y-Register das High-Byte der Adresse und im Akku die Länge des Strings.
STRPOI:	Hiermit berechnet man den Stringzeiger und reserviert gleichzeitig Speicher für den String am Ende des Stringspeichers. Die Länge des Strings muß vorher im Akku stehen, wo sie sich nach »FRESTR« ja auch befindet. Man findet dann in $61 die Länge des reservierten Bereichs, in $62 das Low-Byte der Adresse und in $63 das High-Byte der Adresse des reservierten Bereichs.

# Directory auf Knopfdruck [152-153]

> Häufig steht man vor dem Problem, Programme direkt, also ohne SYS-Aufrufe, über einen Tastencode zu aktivieren. Wir zeigen Ihnen, wie man ein Directory auf dem Bildschirm ausgibt, ohne ein vorhandenes Basic-Programm zu zerstören.

Das Programm »Directory auf Knopfdruck« (siehe Listing 1) kann, nachdem es mit Hypra-Assassembliert wurde, mit dem Befehl SYS 49152 aktiviert werden.

Den erzeugten Maschinencode zeigt Listing 2, das auch direkt mit dem MSE eingegeben werden kann. Solange kein Reset ausgelöst oder die RUN/STOP-Taste gedrückt wird, erscheint bei der Tastenkombination »CTRL-D« das Directory auf dem Bildschirm, ohne ein eventuell im RAM stehendes Basic-Programm zu zerstören.

Der hier vorgestellte Lösungsweg, ein beliebiges Programm auf Tastendruck aufzurufen, hat den Vorteil, daß er allgemeingültig ist und nicht nur auf die Ausgabe des Direc-torys beschränkt ist.

Im allgemeinen müßte das Betriebssystem geändert werden, um eine zusätzliche Tastaturabfrage einzubinden. Aber wir haben Glück, denn einige Routinen im Betriebssystem werden über einen sogenannten Sprungvektor aufgerufen. Alle zugänglichen Sprungvektoren, die sich ändern lassen, befinden sich in der dritten Page, also im Bereich von $311 bis $333, jeweils im Low-/High-Byte-Format. Der zum Einbinden einer Tastaturabfrage geeignetste Vektor ist der Interruptvektor, denn diese sogenannte Interrupt-Routine wird 60mal pro Sekunde angesprungen. Ein Sprungvektor, der in diese Routine verzweigt, befindet sich in den Speicherzellen $314/$315. DieSpeicherzellen enthalten im Normalzustand den Wert $31/$EA. Das bedeutet, daß immer, wenn ein Interrupt ausgelöst wird, zu einer Routine verzweigt wird, die bei $EA31 liegt. Schreibt man nun in die Speicherzellen $314/ $315 einen anderen Wert, wird bei einem Interrupt nicht mehr zur Adresse $EA31, sondern zu der Adresse verzweigt, die in den Speicherzellen $314/315 steht, wobei die Adresse $314das Low- und die Speicherzelle $315 das High-Byte der anzuspringenden, neuen Interrupt-Routine enthält. Damit sich der Vektor aber verändern läßt, muß zuerst der normale Interrupt gesperrt werden, denn sonst könnte folgendes passieren: Angenommen, es wird ein Interrupt ausgelöst, nachdem erst das Low-Byte in die Adresse $314 geschrieben wurde, dann nimmt der Computer an, daß die neue Interrupt-Routine bei $EAOO plus dem in Adresse $314 stehendem Low-Byte liegt, verzweigt an diese Adresse und stürzt ab.

Mit dem Maschinenbefehl »SEI« für SEt Interruptflag läßt sich nun der prozessorinterne Interrupt ausschalten. Dies wird in der Zeile 230 im Listing 1 realisiert. Die Zeilen 240 bis 270 sorgen dafür, daß die Startadresse der neuen Interrupt-Routine in die entsprechenden Adressen kommt. Eine Bemerkung noch zu den Zeilen 240 und 270. Durch das »kleiner«- beziehungsweise »größer«-Zeichen läßt sich eine 16-Bit-Adresse (in diesem Fall »INTER«) in zwei 8-Bit-Zahlen splitten. Durch das »kleiner«-Zeichen erhält man das Low- und entsprechend für das »größer«-Zeichen das High-Byte.

Der folgende »CLI«-Befehl (CLear Interruptflag) läßt nun den normalen Interrupt wieder zu. Nur wird jetzt, wenn ein Interruptstattfindet, nichtmehrzurAdresse$EA31, sondern zur Routine »INTER« verzweigt. Die Aufgabe des Teilprogramms »INTER« ist es, die »CTRL«- und »D«-Taste abzufragen. Sind beideTasten gleichzeitig gedrückt, wird nach »DIR« verzweigt, ansonsten in der Zeile 420 zum normalen Interrupt nach $EA31. DieZeilen 370 und 380 beziehungsweise 400 und 410 sperren auch den Interrupt, aber auf eine etwas andere Art.

Sie werden sich vielleicht fragen, warum der Interrupt überhaupt gesperrt werden muß. Die Antwort auf diese Frage ist leicht zu geben. Die Bearbeitung der Routine »DIR« dauert länger als 1/60 Sekunde. Dadurch würde bereits ein neuer Interrupt ausgelöst, bevorderalteabgearbeitetwäre. DieArt, wie der Interrupt abgeschaltet wird, wurde mit Absicht so gewählt, da einige Routinen im Betriebssystem den Interrupt durch den CLI-Befehl wieder zulassen, so auch die Routine »CHROUT«, die ein Zeichen auf einem Gerät, hier dem Bildschirm, ausgibt. Durch die Befehle »LDA #TIMERAUS« und »STA ICR« wird eigentlich nicht der Interrupt abgeschaltet, sondern der Timer gestoppt, der den Interrupt auslöst. Doch nun zum eigentlichen »DIR«-Programm.

Die Zeilen 450 bis 550 entsprechen dem Basic-Befehl »OPEN 1,8,0,"$"«. Dabei liegt das Augenmerk auf der Sekundäradresse »0« und dem Dollarzeichen. Das Dollarzeichen als Filename bewirkt, daß das Directory eingelesen wird und zwar einschließlich Track 18 Sektor 0. Durch die »0« als Sekundäradresse wird das Directory schon soweit aufbereitet, daß nur noch die Zeichen, die sich nach einem »LOAD"$",8« tatsächlich im RAM befinden, zum Computer gesendet werden, inklusive Filetyp, Steuerzeichen, Leerzeichen und Anzahl der Blöcke pro File. Leider enthält ein vom Floppy-Laufwerk gesendeter Directory-Eintrag auch noch Platzhalter für die Zeilenlinkadressen, die wir natürlich nicht brauchen und folglich ausblenden beziehungsweise überlesen müssen. Eine vom Floppy-Laufwerk gesendete Directory-Zeile hat folgendes Format:

LI LI AB SP "filename SP" SP FT

LI = Linkbyte; AB = Anzahl der Blöcke pro File im Low/ High-Byte-Format; SP = Leerzeichen; FT = Filetyp im Klartext.

Das einzige, was zu tun bleibt, ist die Ausgabe »RETURN« am Ende jeder Directory-Zeile (Zeile 811/812). Außerdem muß die Information, die die Anzahl der Blöcke pro File enthält, in dezimale Schreibweise umgerechnet und auf dem Bildschirm ausgegeben werden. Das ist aber kein Problem, denn das Betriebssystem stellt eine solche Routine »INTOUT=$BDCD« zur Verfügung. Wenn sie aufgerufen wird, muß der Akku das High- und das X-Register das Low-Byte der auszugebenden Zahl enthalten. Das Low-Byte wird in Zeile 590 an das X-Register übergeben. Das High-Byte dagegen wird in Zeile 630 durch das Unterprogramm »CHRIN« eingelesen und steht automatisch im Akku.

### Zum Programmablauf

Die Zeilen 570 bis 620 überlesen 4 Byte beim ersten Durchlauf. Bei allen weiteren Durchläufen werden immer nur die ersten 2 Byte überlesen, die die Zeilenlinkadresse enthalten. Beim ersten Durchlauf wird neben der Zeilenlinkadresse auch die Startadresse ($0801) gesendet, die ebenfalls ausgeblendet werden muß, darum 4 Byte. Bei einem Sprung auf das Label »ROWOUT« enthält das Y-Register die Anzahl der Byte, die überlesen werden sollen plus 1. Wird die Schleife in Zeile 620 verlassen, enthält das X-Register das Low-Byte der Zahl, die die Anzahl der Blöcke pro File kennzeichnet. Das High-Byte wird in Zeile 630 eingelesen und an den Akku übergeben. Die nächste Schleife, die bei dem Label »NEXTCHR« beginnt, gibt den Rest eines Directory-Eintrags auf dem Bildschirm aus. Der »CMP«-Befehl in Zeile 730 überprüft, ob eine »0«, die das Ende des Eintrags kennzeichnet, gesendet wurde oder nicht. Bei einer »0« wird nach »LASTCHR« verzweigt, ein »RETURN« ausgegeben und zum Label »ROWOUT« gesprungen.

(ah)

# Tips und Tricks zu Hypra-Ass [154-155]

> Hypra-Ass, ein Assembler der Spitzenklasse beherrscht alles, was zum Programmieren in Maschinensprache erforderlich ist. Hier wollen wir Ihnen anhand vieler Beispiele zeigen, was in ihm steckt und was er wirklich leistet.

Hypra-Ass ist einer der leistungsfähigsten Assembler die zur Zeit auf dem Markt sind. Eine seiner hervorstechendsten Eigenschaften ist der integrierte Editor mit einer formatierenden LIST-Routine. Aber gerade durch diese Eigenschaft weicht die Bedienung vom normalen Basic-Editor ab. Dadurch traten bei vielen Lesern Schwierigkeiten auf, die hier im einzelnen behandelt werden.

Im Gegensatz zum Basic-Editor kann unter Hypra-Ass eine Zeile nicht dadurch gelöscht werden, daß nur die Zeilennummer eingegeben und anschließend RETURN gedrückt wird. Bei Hypra-Ass ist unbedingt darauf zu achten, daß hinter der Zeilennummer ein Minuszeichen eingegeben wird. Drückt man nun die RETURN-Taste ist die Zeile auch verschwunden. Da aber dieses Minuszeichen hinter der Zeilennummer meistens vergessen wird, ist es empfehlenswert, nicht nur Zeilenbereiche, sondern auch einzelne Zeilen mit dem Editor-Befehl »/D zeilennummer« zu löschen, bis auf die Zeile »0«, die sich mit dem »/D«-Befehl nicht löschen läßt. In diesem Fall geben Sie bitte »0-« < RETURN > ein.

Ein kleiner Fehler tritt beim Sortieren der Symboltabelle auf. Hypra-Ass stürzt ab, wenn die Symboltabelle genau 36, 73, 109 (und so weiter) Variablen oder Label enthält. Der Fehler liegt in den Speicherzellen $1EB8 bis $1EBB. Hier wurden zwei Branch-Befehle vertauscht. Es muß richtig lauten:

TODO

1EB8 90 D0	BCC 1EA8
1EBA D0 04	BNE 1EC0

Diese Änderung kann unmittelbar mit einem Monitor in die entsprechenden Speicherzellen geschrieben und anschließend gespeichert werden. Sollten Sie keinen Monitor haben, dann geben Sie bitte den folgenden Quelltext ein:

TODO

10 -.BA $C000
;STARTADRESSE = $C000
20 -	LDY #0
30 - LBL	LDA TAB,Y
;KORREKTUREN VORNEHMEN
40-	STA$1EB8,Y
50 -	INY
60 -	CPY #4
70 -	BNE LBL
80 -.EQ SOURCESTART = $1FD8 ;UND DIE KORRIGIERTE
90 -.EQ NAMLEN = 12	;VERSION SPEICHERN
100-	LDA #1
110-	LDX#8
120-	STA$FE
130-	STX $FF
140-	LDA #8
150-	JSR $FFBA
160-	LDA#NAMLEN
170-	LDX#<(NAME)
180-	LDY#>(NAME)
190-	JSR $FFBD
200-	LDA #$FE
210-	LDX #<(SOURCESTART)
220-	LDY # >(SOURCESTART)
230-	JMP $FFD8
240-;
250-NAME	.TX "HYPRA-ASS.V1 "
260-TAB	.BY $90,$D0,$D0,$04

Nach dem Assemblieren wird mit SYS 49152 < RETURN > Hypra-Ass geändert und unter dem neuen Namen »Hypra-Ass.VI« auf Diskette gespeichert.

Der »/A«-Befehl zur automatischen Zeilennumerierung reagiert auch recht sensibel. Wird mit diesem Befehl gearbeitet, darf der Cursor mit den entsprechenden Steuertasten auf keinen Fall auf eine andere Zeile gesetzt und RETURN gedrückt werden. Sollte das versehentlich doch einmal passieren, läßt sich die so entstandene, ewas seltsam aussehende Zeile mit dem »/D«-Befehl problemlos löschen.

Diskettenbefehle können mit dem Editorbefehl »/@« zum Floppy-Laufwerk gesendet werden. Hinter den Editorbefehl werden dann die Diskettenbefehle unmittelbar angehängt. So formatiert der Befehl »/@N:NEWDISK,ND« eine neue Diskette.

## Der Editor

Eine feine Sache ist auch das Arbeiten mit dem »/P«-Befehl, der dazu dient, Arbeitsseiten beziehungsweise Arbeitsbereiche anzulegen. Durch diesen Befehl, auf den sich die meisten Editor-Befehle beziehen, ist es möglich, jedem zusammenhängenden Quelltextteil (Unterprogramme oder Unterprogrammblöcke) einen Arbeitsbereich zuzuordnen. Möchte man dann in der Page 3 etwas ändern oder nachschauen, LISTet der Befehl »/3« nur diesen Bereich und nicht das komplette Listing wie bei dem »/E«-Befehl. Legt man nun die einzelnen Arbeitsbereiche gleich von vornherein so an, daß sie jeweils einen Zeilenbereich von zum Beispiel 5000 Zeilen überdecken, dürfte für die einzelnen Quelltextteile genügend Platz vorhanden sein, so daß beim Durchnumerieren der einzelnen Arbeitsbereiche keine Überlappungen auftreten können. Die Arbeitsbereiche selbst dürfen sich aber durchaus überlappen. So läßt sich zum Beispiel ein Arbeitsbereich von 0 bis 5000, ein zweiter von 10000 bis 15000 und ein dritter von 0 bis 15000 anlegen.

Bei dem Assembler selbst sind bisher keine Fehler bekannt. Deshalb möchte ich an dieser Stelle auf einige Dinge eingehen, mit denen viele Leser Schwierigkeiten hatten. Da wäre zum Beispiel das unmittelbare Erzeugen des Objektcodes auf Diskette mit dem ».OB«-Pseudo-Opcode.

Der Pseudo-Opcode ».OB "filename,P,W"« muß am Anfang des Quelltextes stehen und zwar in der ersten beziehungsweise zweiten Zeile (nach dem ».Ll«-Pseudo zur Ausgabe des Assembler-Listings). In dem Zusammenhang sei auch erwähnt, daß es unmöglich ist, den Objektcode und gleichzeitig das Assembler-Listing mit dem Befehl ».LI 2,8,2, "filename,U,W"«auf Diskette zu erzeugen. Der Grund ist der, daß zwei Kanäle zum Schreiben geöffnet werden müßten und das ist nicht möglich. Zu dem ».OB«-Pseudo gehört unmittelbar ein zweiter Pseudo ».EN«, der das mit »file-name« gekennzeichnete File schließt. Dazu muß dieser Pseudo am Ende des Quelltextes stehen. Sollten mit dem ».AP« mehrere Quelltexte verkettet werden, muß der ».EN«-Pseudo am Schluß des letzten Quelltextes auftauchen.

Bei der Anwendung von Makros gab es auch einige Schwierigkeiten. Wird zum Beispiel von einem Makro (Ordnung 1) zweimal ein weiteres Makro (Ordnung 2) aufgerufen, meldet Hypra-Ass einen »label twice error«, vorausgesetzt, im Makro zweiter Ordnung befindet sich ein Label. Zum Beispiel würde folgendes Programm zu einer solchen Fehlermeldung führen:

TODO

i o -.BA $C000
20 -.MA MAK1 ;MAKRODEFINITION 1. ORDNUNG
30 - ... MAK2 ;MAKROAUFRUF 2. ORDNUNG
40 - ... MAK2
50 -.RT
60-.MA MAK2
7O-LBL NOP
80 -.RT
90 -	... MAK1

Dabei ist Mak1 das Makro 1. Ordnung und Mak2 das Makro 2. Ordnung. Alle Label in Makros zweiter oder dritter Ordnung sind untereinander global. Das heißt, daß in Makros zweiter Ordnung nur einmal das Label mit dem Namen »LBL« definiert werden dürfte.

Im Augenblick wird an einer Erweiterung gearbeitet, die diesen Mißstand beseitigt. Denn gerade beim intensiven Arbeiten mit Makros sind Makros zweiter und sogar dritter Ordnung unabdingbar. Ganz deutlich sieht man dies an dem Artikel »Wichtige Makros für Hypra-Ass« in dieser Ausgabe. Dort wurde ein Makro mit dem Namen »INCW (adresse)« definiert. Würde man die dort stehende 16-Bit-Addition ersetzen durch:

TODO

INC ADRESSE
BNE LBL
INC ADRESSE+1 LBL

könnte dieses Makro von keinem anderen Makro aus zweimal aufgerufen werden, weil durch das Label »LBL« ein »label twice error« erscheinen würde.

Der gleiche Fehler erscheint natürlich auch dann, wenn ein anderes Makro aufgerufen wird, das »LBL« als Label oder Variable benutzt. Denn die Ordnungszahl, die den beiden Labeln »LBL« zugewiesen wird, ist identisch.

## Bedingte Assemblierung

Auch mit der bedingten Assemblierung wissen nur die wenigsten etwas anzufangen, obwohl sie gerade im Zusammenhang mit Makros eine große Rolle spielt. Dies soll an einem kleinen Beispiel demonstriert werden:

TODO

10 -.MA ADW (ADR1,ADR2,SUMME,RETTEN)		
20 -.IF RETTEN !	= ! 1	;NUR WENN RETTEN = 1, WIRD
30 -	PHA	;PHA IN DAS MASCHINENPROGRAMM
40 -.EI 50 -	CLC	;ASSEMBLIERT
60 -	LDA ADR1	
70 -	ADC ADR2	
80 -	STA SUMME	
90 -	LDA ADR1 + 1	
100-	ADC ADR2 + 1	
110-	STASUMME+1	
120 -.IF RETTEN !	= ! 1	;NUR WENN RETTEN = 1, WIRD
130-	PLA	;PLA IN DAS MASCHINENPROGRAMM
140 -.EI ; 150 -.RT		ASSEMBLIERT

Dieses Makro addiert (ADR1,ADR1+1)+(ADR2,ADR2 +1) und speichert das Ergebnis in den Speicherzellen (SUMME,SUMME+1). ADR1, ADR2 und SUMME können beliebige Speicherzellen oder Variablen sein. Soll der Inhalt des Akkumulators erhalten bleiben, wird für RETTEN eine 1, ansonsten eine beliebige andere Zahl eingegeben. Anhand des Übergabeparameters RETTEN erkennt der Assembler, ob das erzeugte Maschinenprogramm den Maschinenbefehl »PHA« beziehungsweise »PLA« enthalten soll oder nicht. Die Befehle zur bedingten Assemblierung zeigen also einzig und allein eine Wirkung beim Assemblieren. Durch sie wird bestimmt, welche Teile des Quelltextes im erzeugten Maschinenprogramm stehen und welche unter bestimmten Bedingungen übersprungen werden sollen. Schauen Sie sich nun noch einmal die Zeilen 20 und 120 an. Sie finden dort in der bedingten »,IF«-Abfrage den Operator »=«, der wie alle anderen Operatoren auch in Ausrufezeichen einzufassen ist. Durch dieses Ausrufezeichen erkennt Hypra-Ass, daß es sich bei dem Operator »=« um eine Rechenvorschrift aus dem Quelltext heraus handelt. Alle Operatoren können außer bei der bedingten Assemblierung zum Beispiel auch bei der unmittelbaren Adressierungangewendetwerden. Ein kleines Beispiel soll die Wirkung dieser Operatoren bei der unmittelbaren Adressierung verdeutlichen:

TODO

20 -.EQ VARIABLE1 = 10
30 -.EQ VARIABLE2 = 20
40 -	LDA#(VARIABLE1!0!VARIABLE2)

Der Akkumulator wird mit einer Zahl geladen, die mit der Variablen »VARIABLE1« und »VARIABLE2« wie im Basic geORt wird. Das Ergebnis ist folglich 30.

Viele Maschinensprache-Anfänger verwechseln die Befehle zur bedingten Assemblierung mit normalen Basic-Befehlen. Deshalb möchte ich an einem kleinen Beispiel zeigen, was nicht mit der bedingten Assemblierung funktioniert:

TODO

10 -.BA $cooo
20 -	INC $D020
30 -.GO 20

## Was nicht funktioniert

Das Programm sollte die Bildschirmrahmenfarbe laufend um 1 incrementieren. Wird der Assembler jedoch gestartet, ersetzt er den Befehl ».GO 20« nicht durch den Befehl »JMP adresse«. Vielmehr versucht er den gesamten Speicher von $C000 bis unendlich mit dem Befehl »INC $D020« zu füllen, denn es fehlt jegliche Abbruchbedingung. Nur mit einer Abbruchbedingung ist der ».GO«-Befehl sinnvoll. Sollte das Maschinenprogramm zehnmal hintereinander den Befehl »INC $D020« enthalten, könnte das so aussehen:

TODO

10 -.LI1,3
20 -.BA $C000
30 -.EQ A = 0
40 -.EQ A = A + 1
50 -	INC $D020
60 -.IFA!<!11
70 -.GO 40
80 -.EI
90 -	JMP $C000

Der Assembler überprüft in Zeile 60, ob die Variable »A« kleiner 11 ist. Trifft das zu, wird in Zeile 70 durch den ».GO«-Befehl zur Zeile 40 verzweigt und der Befehl »INC $D020« ein weiteres Mal assembliert. Sobald »A« gleich 10 ist, verzweigt der Assembler in die Zeile 90, übersezt den Befehl »JMP $C000« und beendet den Assembliervorgang.

Sollte Ihnen der Umgang mit Makros und der bedingten Assemblierung noch nicht klar sein, empfehle ich Ihnen den Artikel »Assemblerbedienung leicht gemacht (2)« in der 64’er Ausgabe 1/85. In diesem Artikel wird ausführlich auf den Gebrauch von Makros und eben der bedingten Assemblierung eingegangen.

(ah)

# Wichtige Makros zum Assembler Hypra-Ass [156-157]

> Der beschränkte Befehlssatz des 6502-Prozessors macht Maschinenprogramme unübersichtlich und fehleranfällig. Wir zeigen Ihnen hier, wie sich mit Hypra-Ass der Maschinen-Befehlssatz durch Makros erweitern läßt. Aber nicht nur das ist möglich, Sie können sich auch Ihre eigene, ganz persönliche Sprache basteln.

esonders dem Maschinensprache-Anfänger dürfte das Wort »Makro« gänzlich unbekannt sein. Denn weder das im C 64 implementierte noch irgendein anderes Basic kennt die Definition eines Makros. Das ist wahrscheinlich auch der Grund dafür, warum Makros nur selten angewendet werden. Sie spielen jedoch gerade beim 6502- beziehungsweise 6510-Prozessor eine wichtige Rolle. Durch Makros läßt sich nämlich der bescheiden ausgefallene Befehlssatz des Prozessors um wichtige Befehle erweitern. Es werden durch Makros prinzipiell keine neuen Maschinenbefehle geschaffen, sind aber Makros einmal definiert, lassen sie sich aufrufen wie ganz normale Maschinenbefehle. Was sind nun eigentlich Makros? Dies soll an einem kleinen Beispiel erklärt werden.

Angenommen, Sie möchten in einem Maschinenprogramm 20 verschiedene 16-Bit Adressen inkrementieren, dann müßte Ihr Programm zwangsläufig zwanzigmal folgende Befehlsfolge enthalten:

TODO

INC ADRESSE
BNE LBL
INC ADRESSE+1
LBL

Diese 20 Befehlsfolgen machen aber das Programm unübersichtlich und vor allen Dingen fehleranfällig. Genau so gut ließe sich auch ein Makro mit dem Namen »INCW (adresse)« für INCWord definieren, das dann anstelle der Befehlsfolgen 20mal im Quelltext erscheint. Das Makro selbst würde wie folgt aussehen:

TODO

10 -.MA INCW (ADRESSE)
20 -	INC	ADRESSE
30 -	BNE	LBL
40 -	INC	ADRESSE+l
50 -LBL
60 -.RT

Aufgerufen wird das Makro im Quelltext nun durch den neuen Befehl»... INCW (adresse)«.

Gefolgt von dem Makronamen und in Klammern den Übergabeparametern, diedurch Kommatagetrenntwerden, leitet der ».MA«-Pseudo-Opcode die Definition eines Makros ein. DiesgeschiehtinZeile 10. Der Pseudo-Opcode».RT«inZeile 60 schließt die Definition des Makros ab. Alle im Makro stehenden Label sind lokal. Das heißt, daß dem Programm außerhalb des Makros die internen Label unbekannt sind. Würde dies nicht so sein, dann würde der Assembler den zweiten Makroaufruf mit der Fehlermeldung »label twice error« ahnden. Was macht der Assembler, wenn er auf einen Makroaufruf stößt? Er assembliert in den Objektcode, wie man das erzeugte Maschinenprogramm auch nennt, die Befehlsfolgen, die im Makro definiert wurden. Das heißt, daß letztendlich im erzeugten Maschinenprogramm wieder zwanzigmal, um bei dem Beispiel zu bleiben, die oben stehenden Befehlsfolgen auftauchen.

Im Listing sind die wichtigsten Makros aufgeführt. Neben den »Befehlserweiterungen« ist noch eine interessante Gruppe von Makros definiert worden, die die strukturierte Programmierung durch »Repeat...Until«- und »While...Endwhile«-Schleifen unterstützt. Zu beachten istjedoch, daß die Schleifen nichtverschachteltwerden dürfen. Schleifenkonstruktionen wie

TODO

REPEAT
REPEAT
UNTIL
UNTIL

sind veboten. Die einzelnen Makros haben folgende Wirkung:
**TXY**: Das Y-Register wird mit dem Inhalt des X-Registers geladen.
**TYX**: Das X-Register wird mit dem Inhalt des Y-Registers geladen.
**PHX**: Das X-Register wird auf dem Stack abgelegt
**PHY**: Das Y-Register wird auf dem Stack abgelegt
**PLX**: Das X-Register wird vom Stack geholt.
**PLY**: Das Y-Register wird vom Stack geholt.

Die folgenden vier Makros definieren einen Userstack, der an eine beliebige Stelle gelegt werden kann. Dazu muß im Hauptprogramm eine globale Variable mit dem Namen »USER« in der Zeropage angelegt werden. Anschließend muß in die Adresse, die die Variable repräsentiert, die Startadresse des Stacks geschrieben werden. Das könnte so aussehen:

TODO

10 -.GL USER = 3
20	-	LDA	#0	;L0-BYTE
STARTADRESSE USERSTACK
30	-	STA	USER
40	-	LDA	#$C0	;HI-BYTE
STARTADRESSE USERSTACK
50	-	STA	USER+1

Hier wurde ein Userstack angelegt, der bei Adresse $C000 beginnt. DerStackpointer, alsoderZeiger, deraufdieaktuelle Stackadresse zeigt, steht in der Zeropage in den Speicherzellen 3 und 4.
**PUSHA**: Der Inhalt des Akkumulators wird auf dem Userstack abgelegt.
**PUSHAY**: Der Inhalt des Akkumulators und der Inhalt des Y-Registers werden auf dem Userstack abgelegt.
**PULLA**: Der Akkumulator wird vom Userstack geholt.
**PULLAY**: Der Akkumulator und das Y-Register werden vom Userstack geholt.
**ADW (adresse)**: 16-Bit Addition. Der Inhalt einer beliebigen Adresse wird zum Inhalt des Akkumulators (Low-Byte) und zum Inhalt des Y-Registers (High-Byte) addiert. Das Ergebnis steht anschließend im Akkumulator (Low-Byte) und im Y-Register (High-Byte).
**ADMW (adr1,adr2,summe)**: 16-Bit Addition. Der Inhalt von adr1 und adr1 + 1 wird zum Inhalt der Adresse adr2 und adr2 +1 addiert und das Ergebnis in der Adresse summe und summe+1 abgelegt.
**SBCW (adresse)**: 16-Bit Subtraktion. Der Inhalt von adresse und adresse+1 wird vom Inhalt des Akkumulators (Low-Byte) und vom Inhalt des Y-Registers (High-Byte) abgezogen. Das Ergebnis steht anschließend im Akkumulator (Low-Byte) und im Y-Register (High-Byte).
**SBCMW(adr1,adr2,diff)**: 16-BitSubtraktion. Vom Inhalt adr1 und adr1 + 1 wird der Inhalt von adr2 und adr2 + 1 abgezogen. Das Ergebnis wird in der Adresse diff und diff+1 abgelegt.
**INCW(adresse)**: Der Inhalt von adresse und adresse+1 wird inkrementiert. Das Ergebnis steht in adresse und adresse+1. DECW (adresse): Der Inhalt von adresse und adresse+1 wird dekrementiert. Das Ergebnis steht in adresse und adresse+1.
**LDAY (adresse)**: Der Akkumulator wird mit dem Inhalt von adresse und das Y-Register mit dem Inhalt von adresse+1 geladen.
**STAY (adresse)**: Der Inhalt des Akkumulators wird nach adresse und der Inhalt des Y-Registers nach adresse+1 geschrieben.
**LDAYI (wert)**: Der Akkumulator und das Y-Register wird mit »wert« unmittelbar geladen. Dabei steht das Low-Byte im Akkumulator und das High-Byte im Y-Register.
Die folgenden Makros unterstützen die strukturierte Programmierung.
**REPEAT, EXITREPEAT, UNTIL (übergabe.bedingung)**: Die Schleife wird so lange fortgesetzt, bis die Speicherzelle »übergabe« den Wert »bedingung« enthält. Beispiel:

TODO

io -	LDX #255
20 -	REPEAT
30 -	DEX
40 -	STX $FB
50 -	... UNTIL ($FB,0)

Das X-Register wird solange dekrementiert, bis es den Wert »0« enthält.
**WHILE (übergabe,bedingung), EXITWHILE, ENDWHILE:** Die Schleife wird solange fortgesetzt, bis der Inhalt der Speicherzelle »übergabe« gleich »bedingung« ist. Beispiel:

TODO

10 -	LDX #255
20 -	... WHILE ($FB,0)
30 -	DEX
40 -	STX $FB
50 -	... ENDWHILE

Solange der Inhalt der Speicherzelle $FB ungleich Null ist, wird das X-Register dekrementiert.

(ah)

# Tips & Tricks ausführlich erklärt [158-163]

> Die folgenden Programmbeispiele sollen vor allem dem Anfänger den Einstieg in die Maschinensprache des C 64 erleichtern.

Zu ihrem Verständnis sollte man wenigstens ungefähr mit dem Befehlssatz der 6510-CPU und mit der Speicherorganisation des C 64 vertraut sein. Die Beispiele stammen aus den verschiedensten Anwendungsgebieten. Ihnen allen gemeinsam ist: - eine überschaubare Kürze

- Formulierung als Hypra-Ass-Quelltext
- eine ausführliche Beschreibung der Wirkungsweise.

### 1. Ein allererster Gehversuch mit Hypra-Ass

Zu diesem und zu allen folgenden Programmen benötigen Sie den Hypra-Ass. Er wird wie ein Basic-Programm geladen und mit RUN initialisiert. Jedes weitere RUN startetjetzt einen Assemberlauf, ist aber zunächst noch wirkungslos, da noch nichts im Textspeicher des Assemblers steht. Geben Sie nun folgende vier Zeilen ein:

TODO

10 - .BA $C000
20 - LDA #1
30 - STA $400
40 - RTS

Dabei dürfen die Minus-Zeichen nach den Zeilennummern nicht vergessen werden (Eigenartvon Hypra-Ass). Auch das Leerzeichen nach den Minus-Zeichen ist wichtig. Sie werden feststellen, daß der Assember die Zeilen nach Drücken der RETURN-Taste formatiert. Listen Sie die vier Zeilen auch einmal probeweise mit
LIST (unformatiert) und
/E (formatiert)

Das Programm ist schnell erklärt:

Mit .BA $C000 wird dem Assembler die Startadresse (BAsisadresse) des Programms mitgeteilt. .BA ist ein Pseudobefehl. Ein solcher Befehl steuert die Arbeitsweise des Assemblers, bewirkt aber keine Erzeugung eines Maschinenbefehls.

LDA # 1 lädt den Akkumulator mit 1, dem Bildschirmcode des Buchstabens A.

STA $400 speichert den Akkumulatorinhalt, also die 1 an die Speicherstelle $400. $400 ist die Startadresse des Bildschirm-RAMs und entspricht der linken oberen Bildschirmecke. Dort muß also ein »A« erscheinen.

RTS (ReTurn from Subroutine) bedeutet Rücksprung aus einem Unterprogramm. Mit RTS müssen Programme abgeschlossen sein, die mit JSR (Jump to SubRoutine) oder SYS (von Basic aus) aufgerufen werden. Dies dürfte für die überwiegende Mehrheit aller Maschinenprogramme der Fall sein. Ausnahmen sind:

Programme., die von einem Monitor aus gestartet werden. Sie sollten mit einem BRK (Break) abgeschlossen sein.

Programme, die durch Interrupts aktiviert werden, werden normalerweise durch RTI (ReTurn from Interrupt) abgeschlossen.

Mit RUN wird der Assembler gestartet. Er erzeugt ein 6 Byte kurzes Maschinenprogramm ab $C000 und gibt in einer Abschlußmeldung den belegten Speicherbereich zusammen mit der Assemblierzeit bekannt. Das Maschinenprogramm kann nun mit

TODO

SYS $C000 oder SYS 12 * 4096

gestartet werden. (Wenn Hypra-Ass aktiv ist, versteht der C 64 auch Hex-Zahlen). Es müßte ein »A« in der linken oberen Bildschirmecke erscheinen. Sollte das nicht der Fall sein, so kann das zwei Ursachen haben:

1.	Das »A« wurde nach oben weggescrollt, weil Sie den SYS-Befehl zu weit unten auf dem Bildschrim eingetippt haben.
2.	Sie besitzen eine alte Version des C 64, bei der das FarbRAM mit der Hintergrundfarbe vorbesetzt wird.

Im zweiten Fall ergänzen Sie das Programm durch:

TODO

35 - STA $D800

Dieser Befehl speichert die immer noch im Akkumulator (im folgenden nur Akku genannt) stehende 1 an die Startadresse des Farb-RAMs. Dadurch erscheint das »A« in weißer Farbe.

Ergänzen Sie Ihr kleines Programm einmal durch den Pseudobefehl

TODO

5 - .LI 1,3,0

und assemblieren Sie mit RUN. Der Assembler erzeugtjetzt ein Listing, dessen Zeilen von links nach rechts wie folgt aufgebaut sind:

-	Speicheradresse des folgenden Maschinenbefehls
-	Der Code des Maschinenbefehls. Da es Maschinenbefehle mit ein, zwei oder drei Byte gibt, sind diese Einträge unterschiedlich lang.
-	Ein Doppelpunkt und die ursprüngliche Quelltextzeile. Bei Pseudobefehlen, die ja keinen Code erzeugen, entfälltder Teil bis einschließlich zum Doppelpunkt.

Das Assemblerlisting ist bei der Fehlersuche mit einem Monitor nützlich, da es zu jedem Maschinenbefehl seine Adresse enthält. Mit dem Pseudobefehl:

TODO

.11 1,4,0

erhält man ein Druckerlisting. Angenehm dabei ist, daß es bei ausgeschaltetem Drucker automatisch auf den Bildschrim umgeleitet wird.

Die abgedruckten Listings enthalten allerdings keine Speicheradressen mit zugehörigem Maschinencode. Diese Information ist zum Studieren der Programme uninteressant und zum Eintippen der Listings nicht erforderlich. Die Listings wurden mit dem Editorbefehl /E (formatiertes Listen) gewonnen, nachdem vorher die Ausgabe durch

TODO

OPEN 4,4:CMD 4

auf den Drucker umgeleitet wurde.

### 2.	Eine einfache Programmschleife

Das folgende kleine Programm (Listing 1) schreibt 240mal den Buchstaben »A« auf den Bildschirm. Zur Arbeitsweise: Akku A wird wieder mit dem Bildschirmcode des Buchstabens A geladen. Das X-Register übernimmt zwei Aufgaben: Es zählt Schleifendurchläufe und liefert Werte zur Adreßverschiebung. X wird mit 0 vorbesetzt. In Zeile 1280 ist LOOP ein Label (auch SYMBOL oder Sprungmarke). LOOP steht für die Adresse des STA-Befehls, die man an anderen Programmstellen durch den Namen LOOP ansprechen kann, ohne daß man den Wert dieser Adresse kennt. Den Assemblerprogrammierer interessieren absolute Adressen normalerweise auch gar nicht, es sei denn, es handelt sich um systemspezifische Adressen, wie zum Beispiel die Adressen der Video-Chip-Register. Eine derartige Zuordnung einer Programmadresse zu einem Label nennt man implizite Definition.

Die Zieladresse des STA-Befehls in Zeile 180 ergibt sich durch die Summe aus $400 und X. Da X am Anfang 0 gesetzt worden ist, wird also eine 1 an die Stelle $400 gespeichert. INX erhöht X um Eins. CPX # 240 vergleicht X mit der Zahl 240. Bei Ungleichheit wird das Zero-Flag im Statusregister auf 0 gesetzt. Auf dieses Zero-Flag bezieht sich dann der bedingte Sprung BNE LOOP. BNE springt dann, wenn der vorige Vergleich Ungleichheit ergeben hat. (Daher auch der Name BNE = Branch if Not Equal = verzweige, wenn ungleich). Beim nächsten Schleifendurchlauf wird die 1 aus dem Akku an die Adresse $4012 gespeichert. X wird solange inkrementiert, bis 240 erreicht ist. In diesem Fall springt BNE nicht und das Programm endet mit RTS. Bei den 240 Schleifendurchläufen werden nacheinander die Adressen $400 bis $400+239 angesprochen. Programmschleifen wie diese benützt man oft zum Löschen eines Speicherbereichs. (Akku mit 0 vorbesetzt.)

### 3.	Blockverschiebung (maximal 255 Byte)

Das Programm (Listing 2) arbeitet mit einer ähnlichen Schleife wie das vorige. In den Zeilen 150,160 und 170wer-den Label explizit definiert. Dies geschieht mit dem Pseudobefehl .EQ.

Die explizite Definition eines Labels ist praktisch dasselbe wie die Zuweisung eines Wertes an eine Variable. Hier werden die Anfangsadressen des ursprünglichen Blocks und des verschobenen Blocks sowie die Blocklänge definiert. X läuft hier rückwärts von LAENGE bis 0. Dadurch kann der CPX-Befehl eingespart werden. DEX setzt nämlich automatisch das Zero-Flag, wenn nach dem Dekrement X den Wert 0 hat. BNE LOOP springt also nur solange nach LOOP, solange X größer als 0 ist. Mit den vorliegenden Werten für QUELLE, ZIEL und LAENGE kopiert das Programm die Bildschirmzeilen 1 bis 6 auf die Zeilen 7 bis 12.

Programme zur Blockverschiebung wie dieses oder zur Blockfüllung wie das vorige sind nurfür Blocklängen bis maximal 255 Byte geeignet, da das X-Register nur 8 Bit lang ist. Wenn man größere Speicherbereiche auf diese Weise verarbeiten will, muß man mehr Aufwand treiben.

### 4.	Blockverschiebung (ohne Einschränkungen)

Das Programm (Listing 3) ist sicher nicht die kürzeste Lösung des Problems, es demonstriert dafür aber ohne verwirrende Tricks die Adressierungsart »Indirekt Indiziert«.
Beispiel: LDA (ZEIGER),Y
Bei dieser Adressierungsart enthalten zwei aufeinanderfolgende Speicherstellen der Zero-Page eine Adresse in der üblichen Reihenfolge Low-Byte - High-Byte. Im Programm wird nicht diese Adresse selbst angegeben, sondern die Adresse der ersten der beiden Zero-Page-Speicherstellen (hier ZEIGER genannt). Diese Technik nennt man indirekte Adressierung, was im Assemblertext durch die runden Klammern um die Zero-Page-Adresse zum Ausdruck kommt. Zu der aus der Zero-Page stammenden Adresse wird noch Y addiert, daher »indiziert«. Da man diese zusätzliche Indizierung oft nicht braucht, setzt man das Y-Register vorher auf O.

Das Programm verwendet für den Blocktransfer zwei Zeiger(= Zero-Page-Speicherstellenpaare). Sie werden mit der Startadresse des Quell- beziehungsweise des Zielblocks initialisiert und nach jedem Byte-Transfer hochgezählt, bis der Zeiger in den Quellblock (ZEIGER1) das Ende des Quellblocks (Adresse BIS) erreicht hat.

Das Inkrementieren eines 16-Bit Wertes verläuft nach dem Schema:

TODO

INC ZEIGER ;Low-Byte inkrementieren
BNE Weiter ;falls ungleich 0, dann fertig INC ZEIGER+l;Ubertrag ins High-Byte
WEITER (Programmfortsetzung)

Spezifisch für den Hypra-Ass ist, daß man mit

< (Adresse) beziehungsweise > (Adresse)

das Low- bezeihungsweise High-Byte einer Adresse (beziehungsweise eines Labels) gezielt ansprechen kann. Von dieser Möglichkeit wird im Programm häufig Gebrauch gemacht. So bedeutet zum Beispiel:

TODO

LDA #< (VON)

Lade den Akkumulator mit dem Low-Byte des Wertes VON.

Mit den im Program definierten Adressen VON, BIS und ZIEL kopiert das Programm einenTeilbereich aus dem Basic-Interpreter direkt auf den Bildschrim. Im Groß-/Kleinschrift-modus (Commodore-Shift drücken) kann man dann Basic-Schlüsselwörter sowie Texte von Fehlermeldungen lesen.

### 5.	Verwendung von Betriebssystem-Funktionen und Mechanismen zur Parameterübergabe

Ein Betriebssystem ist unter anderem dazu da, Standarddienste wie Ein- und Ausgabe zur Verfügung zu stellen, damit diese nicht jedesmal mühsam und fehleranfällig neu programmiert werden müssen. Die Standardfunktionen des Betriebssystems (oft »Kernel« genannt) sind im Programmierhandbuch von Commodore hinreichend erläutert. Viele weitere nützliche Routinen findet man beim Studium eines kommentierten ROM-Listings.

Die Parameterübergabe an Maschinensprache-Unterprogramme gestaltet sich leider nicht so systematisch wie bei den meisten höheren Programmiersprachen. Es werden mehrere Möglichkeiten bunt gemischt angewendet.

TODO NESTED

1. Man schreibt Parameter in vereinbarte Speicherstellen. Aus diesen holt sich dann das aufgerufene Programm die Parameter.
2. Wenn nur Ein- bis Drei-Byte-Parameter benötigt werden, kann man diese auch in den Registern A, X und Y übergeben. Auf diese Weise werden die meisten Kernel-Funktionen mit Parametern versorgt.<br>Dieser Mechanismus steht übrigens auch von Basic aus zur Verfügung: Man schreibt Registerparameter per POKE an speziell dafür vorgesehene Speicherstellen:
TODO
AkkuA	780	($30C)
IndexX	781($30D)
IndexY	782	($30E)
Status-Register 783	($30f)
Das Maschinenprogramm (Listing 4) wird nun mit SYS aufgerufen. Der Basic-Interpreter besetzt erst die Register mit den Inhalten dieser Speicherstellen und bringt dann in das Unterprogramm. Nach der Rückkehr werden die (neuen) Registerinhaltewiederin denselben Speicherstellen abgelegt, wo sie für eine eventuelle Inspektion durch das Basic-Programm zur Verfügung stehen.
3.	Man kann Parameter auch über den Stack übergeben. Diese Methode ist wegen des kleinen Stackbereichs der 6510-CPU (256 Byte) nur bedingt brauchbar und wird deshalb auch kaum praktiziert.
4.	Durch geschickte Verwendung von Unterprogrammen in Basic-ROM kann man Parameter direkt hinter den SYS-Befehl schreiben. Diese Methode ist
-	komfortabel, weil keine umständlichen POKEs nötig sind
-	schnell, weil der Interpreter weniger zu tun hat
-	flexibel, weil als Parameter auch ganze arithmetische oder Stringausdrücke geschrieben werden können.

Diese Methode wird in den Programm-Listings 5 bis 8 verwendet.


Das folgende Programm (Listing 4) nutzt die Funktionen GETIN und CHROUT. GETIN liefert den ASCII-Code einer gedrückten Taste im Akku. Falls keine Taste gedrückt wurde, wird 0 zurückgegeben. GETIN entspricht damit genau dem GET-Befehl in Basic.

CHROUT gibt ein Zeichen, dessen ASCII-Code im Akku stehen muß, auf dem Bildschrim aus. Es entspricht dem Basic-Befehl (man beachte das Semikolon):

TODO

PRINT CHR$(A);

Das Programm gibt einen Prompt aus und erwartet anschließend Eingaben. Unter einem Prompt versteht man ein (beliebig zu vereinbarendes) Zeichen am linken Bildschirmrand, das dem Benutzer mitteilt, daß Eingaben von ihm erwartet werden. Bei interaktiven Programmen (wie zum Beispiel Monitore, Editore) sind Prompts sehr nützlich, da der Benutzer daran eindeutig erkennen kann, in welchem Programm er gerade ist. Das vorliegende Programm gibt die Eingabezeichen sofort wieder aus, ohne sie weiter zu verarbeiten. Nach maximal zehn Zeichen wird automatisch ein Zeilenvorschub ausgeführt und ein weiterer Prompt ausgegeben. Das Programm ist eine Endlosschleife, die man mit der Eingabe von »X« verlassen kann.

### 6. Verwendung von Interpreter-Routinen zur Parameterübergabe

Diese Interpreter-Routinen werden in den folgenden Programmbeispielen eingesetzt:

TODO TABLE

CHKKOM ($AEFD) liest aus dem laufenden Basic-Text ein Komma. Steht an der aktuellen Stelle kein Komma, wird das Programm mit SYNTAX ERROR abgebrochen. Kommata sind nötig, um Parameter voneinander abzugrenzen.
FRMNUM ($AD8A) wertet einen beliebigen arithmetischen Ausdruck aus. Das Ergebnis wird im Fließkomma-Akkumulator 1 (kurz FAC) abgelegt. Der FAC besteht aus den Speicherstellen $61-$66. Die Bedeutung der einzelnen Byte ist hier nicht relevant.
GETADR ($B7F7) wandelt den Inhalt des FAC in ein 2-Byte-Integer-Format um, sofern diese Zahl im Bereich 0 ... 65535 liegt. Ansonsten wird ein ILLEGAL QUANTITY ERROR ausgegeben. Die Integerzahl steht in den Speicherstellen $14/$15 und zusätzlich im Registerpaar Y/A. Mit der Kombination FRMNUM und GETADR kann man also 16-Bit-Größen aus Basic-Programmen übernehmen.
XBYTE ($B79E) wertet ebenfalls arithmetische Ausdrücke aus und wandelt das Ergebnis in 8-Bit-lntegerformat, sofern es im Bereich 0 ... 255 liegt. Das Byte-Ergebnis wird im X-Register übergeben.
USR () ist eine Basic-Funktion, mit der man Werte von Maschinenprogrammen an Basic zurückgeben kann. USR wertet einen in Klammern stehenden Ausdruck aus und übergibt ihn in den FAC. Es wird ein Maschinenprogramm aufgerufen, dessen Startadresse in $311/$312 steht. (USR-Vektor). Das Maschinenprogramm kann dann im FAC einen Wert an Basic zurückgeben.

Das folgende Listing (Listing 5) ist der Programmkopf zu den vier nachfolgenden Beispielen. Diese können mit dem Kopf zusammen assembliert werden. Der Kopf enthält eine Sprungliste. Dadurch werden Einsprungstellen ($C000, $C003, etc.) für die vier aufgeführten Programme fixiert, unabhängig davon, wo die Programme dann später tatsächlich im Speicher stehen. Diese Technik ist zum Beispiel sinnvoll, wenn mehrere Leute zusammen an einem größeren Programm arbeiten. Ein Programmierer kann seinen Kollegen bereits feste Einsprungstellen für Routinen, an denen er noch arbeitet oder die noch gar nicht existieren, zur Verfügung stellen.

### PRINT AT
Das Programm (Listing 6) ermöglicht eine freie und schnelle Cursorpositionierung zusammen mit einer Druckausgabe. Mit der Definition

PR=123*4096 :REM Startadresse

kann mit

SYSPR,Zeile,Spalte,Printliste

alles ausgeben werden, was auch mit PRINT ausgegeben werden kann. Man lasse sich einmal von der Geschwindigkeit des folgenden Programms beeindrucken:

10 FOR 1=1 TO 24:SYSPR, I,I,"A":NEXT
20 FOR 1=1 TO 24:SYSPR,-I,I,"B":NEXT

Das Assemberlisting zu PRINT AT bedarf keiner großen Erläuterung. PLOT ist eine Kernel-Funktion, mit der man die Cursorposition auf dem Bildschirm setzen kann. Parameter sind Zeilen- und Spaltennnummern in den Registern X und Y. Das Programm PRINT AT ist eigentlich nicht mehr als eine geschickte Kombination der Routinen PLOT und PRINT.

### DEEK (Doppelbyte-PEEK)

Dieses Programm (Listing 7) ist eine Abänderung der PEEK-Routine. DEEK liefert einen 16-Bit-Speicherinhalt an Basic zurück. DEEK wird durch

X=USR(Adresse)

aufgerufen. Mit Adresse ist die Adresse des Low-Bytes gemeint. Da USR einen Wert zurückgibt, darf es nicht isoliert dastehen, sondern muß als rechte Seite einer Zuweisung oder als Funktionsargument eingesetzt werden. Vor dem ersten Aufruf muß der USR-Vektor auf die Startadresse des Programms gestellt werden:

POKE 785,3 :REM LOW-BYTE $03
POKE 786,192 :REM HIGH-BYTE $C0

Im Assemblerlisting steckt eine Besonderheit: Die Zugriffe auf die beiden zu lesenden Bytes (LDA ($14),Y) sind durch ein SEI/CLI-Paar eingerahmt. SEI sperrt die CPU für Interruptanforderungen. Dadurch wird garantiert, daß die beiden Lesezugriffe nicht durch ein Interruptprogramm, welches eines oder beide Bytes ändern könnte, unterbrochen werden können. CLI löst die Interruptsperre wieder.

### DOKE (Doppelbyte-POKE)

Um in Basic-Programmen 16-Bit-Größen (zum Beispiel Adressen, Vektoren) in den Speicherzu schreiben, muß man sie vorher erst umständlich in High- und Low-Byte zerlegen, um dann beide Byte POKEn zu könen. Dazu wird meistens die Sequenz:

HI=INT(X/256)
L0=X-256*HI
POKE AD,L0
POKE AD+l,HI verwendet.

Wenn man bedenkt, daß jeder Befehl interpretiert werden muß und daß jede Rechenoperation (auch »+1«) in voller Fließkomma-Genauigkeit durchgeführt wird, versteht man, daß dazu viel Rechenzeit nötig ist. Das kleine Maschinenprogramm (Listing 8), das keiner Erläuterung mehr bedarf (FRMNUM, GETADR und CHKKOM sind bekannt) zeigt, wie es einfacher geht:

SYSD0,AD,Y

(Natürlich muß man DO einmal vorher definieren: DO=12*4096+6). Auch bei DOKE werden die beiden kritischen STA-Befehle durch ein SEI/CLI-Paar untrennbar gemacht. Mit DOKE kann man daher sogar den Interrupt-Vektor ändern. Versucht man dies dagegen mit Hilfe zweier POKEs, kann es passieren, daß ein Interrupt gerade dann auftritt, nachdem das Low-Byte aber noch nicht das High-Byte geändert worden ist. Der Interrupt führt dann auf eine unbestimmte Adresse, was meistens einen Programmabsturz nach sich zieht.

DEEK und DOKE können natürlich auch verschachtelt ein-gesetz werden. So kann man mit

SYSD0,A2,USR(A1)

einen 16-Bit-Wert von der Stelle A1 nach A2 kopieren.

### Speichern beliebiger Speicherbereiche auf Diskette

Das Programm (Listing 9) realisiert das Gegenstück zum Basic-Befehl:

LOAD "Name",8,1

Aufgerufen wird es durch:

SYSSAV,Date iname,gn,s a,ea

Dabei kann bei »Dateinamen« ein Name oder ein Stringausdruck in Anführungszeichen stehen.
»gn« ist die Gerätenummer (8 oder 9)
»sa« und »ea« sind Start- und Endadresse des abzuspeichernden Bereiches. Zum Programm selbst:

Die Routine bei $E257 beschafft sich den Filenamen aus dem Basic-Text und stellt ihn der später folgenden SAVE-Routine zur Verfügung. Mit SETLFS kann man dem Betriebssystem eine logische Filenummer (im Akku), eine Gerätenummer (in X) und eine Sekundäradresse (in Y) bekanntgeben. Die Parametrisierung der Kernel-SAVE-Routine ist etwas komplizierter:

TODO

X	Endadresse Low-Byte
Y	Endadresse High-Byte
A	Zeiger auf das untere	Byte eines Zero-Page-Bytepaares, welches die Startadresse enthält.

Die SAVE-Routione kehrt mit gesetztem Carry-Flag zurück, falls beim Speichern ein Fehler aufgetreten ist. Das Programm bei $E0F9 sorgt dann für eine ordentliche Fehlermeldung.

### Multiplikation

Das Programm (Listing 10) multipliziert zwei Byte-Werte miteinander und liefert ein 16-Bit-Produkt. Es ist aber trotz seiner Kürze nicht ganz einfach zu verstehen. Die beiden zu multiplizierenden Faktoren seien mit

Multiplikator MR und Mulitplikand MD

bezeichnet. Für das Resultat ist es natürlich gleichgültig, welcher Faktor als MR und welcher als MD an das Programm übergeben wird. MR kann man sich, wie jede binäre Größe, folgendermaßen vorstellen:

MR=MR(7)*128+MR(6)*64+...+MR(1)*2+MR(0)*1

Dabei bezeichnet zum Beispiel MR(6) das Bit Nummer 6 von MR in der üblichen Zählweise von 0 bis 7 und von rechts nach links. Das Produkt MR*MD kann man nun so berechnen:
Addiere folgende Teilprodukte:
MD*128,	falls	MR(7)=1,	sonst	0
MD*64,	falls	MR(6)=1,	sonst	0
MD*2,	falls	MR(1)=1,	sonst	0
MD,	falls	MR(0)=l,	sonst	0

Die Teilprodukte erhält man einfach durch Linksverschieben von MD:

MD*128 durch 7-maligen Links-Shift
MD*64 durch 6-maligen Links-Shift

Zu addieren ist nur dann etwas, wenn das entsprechende Bit in MR= 1 ist. Wenn man MR mit dem ROL-Befehl achtmal nach links schiebt, so durchwandern alle 8 Bit nacheinander das Carry-Flag und letzteres kann leicht abgefragt werden. Der Trick des Programms besteht nun darin, daß das Berechnen von Teilproduktsummen mit dem Linksschieben von MR kombiniert wird. Zunächst wird die Zwischensumme in A mit 0 vorbesetzt. MR wird nach links geschoben. Das höchstwertige Bit von MR steht jetzt im Carry-Flag. Ist es 1, so wird MD zum Akku addiert. Eigentlich müßte jetzt der Akku um sieben Positionen nach links geschoben werden, da zum ersten Teilprodukt der Faktor 128 gehört. Diese Verschiebung ergibt sich aber automatisch im Verlauf der nächsten sieben Schleifendurchläufe.

Sowie MR nach links geschoben wird, werden rechts in MR Bits frei, die dann von den von rechts kommenden höherwertigen Bits der Zwischensumme belegt werden. Nach 8 Schleifendurchläufen ist schließlich MR nach links verdrängt worden. An seiner Stelle steht nun das High-Byte des Produkts. Das Low-Byte des Produkts steht im Akku, während MD unverändert geblieben ist.

Erwähnenswert sind hier noch die Befehle ASL und ROL: Beide schieben nach links und bei beiden wird Bit 7 ins Carry-Flag geschoben. Der Unterschied:

ASL besetzt Bit 0 mit 0
ROL besetzt Bit 0 mit dem alten Inhalt des Carry-Flags.

Mit ASL (ohne Adreßteil) wird also der Akku arithmetisch verdoppelt, während mit ROL MR zusätzlich der Übertrag aus dieser Verdoppelung in Bit O von MR gelangt.

### Schieberegister-Folgen als Pseudo-Zufallszahlen

Das Programm (Listing 11) zeigt eine interessante Anwendung von Schieberegistern. Wenn man ein Schieberegister (SR) an den »richtigen« Bitpositionen »anzapft« und das Exklusiv-Oder-Produkt dieser Bits an den SR-Eingang zurückführt, erhält man eine Folge von Bits, die vollkommen zufällig zu sein scheint. Die Folgen sind zwar periodisch, sie wiederholen sich also nach einer gewissen Zeit, die Periodenlänge kann aber beliebig lang gemacht werden. Macht man eine so erzeugte 0-1-Folge mit einem Lautsprecher hörbar, so klingt diese wie weißes Rauschen.

Die folgende Tabelle enthält geeignete Anzapfstellen für Schieberegister unterschiedlicher Länge.

TODO TABLE

Registerlänge	Rückkopplung	Periodenlänge
2	O + 1	3
3	1+2	7
4	2 + 3	15
5	2 + 4	31
6	4+5	63
7	5 + 6	127
8	1+2+3+7	255
9	4 + 8	511
10	6 + 9	1023
11	8+10	2047
12	1+9 + 10+11	4095
13	0 + 10+11 + 12	8191
14	1+11 + 12 + 13	16383
15	13+14	32767
16	10 + 12 + 13+15	65535
»+« steht hier für »EOR«

Die angegebenen Periodenlängen sind die bei der jeweiligen Registerlänge maximal möglichen. Die Schieberegisterfolgen haben die angenehme Eigenschaft, daß die Registerwerte alle Zahlen von 1 bis zur Periodenlänge in quasizufälliger Reihenfolge durchlaufen. Man darf ein solches Schieberegister allerdings nicht mit lauter Nullen vorbesetzen, da es dann seinen Zustand nicht mehr ändert (O EOR 0 =O).

Der Kern des folgenden Programms ist die kleine Routine SHIFT. Die beiden Zero-Page-Speicherstellen SR und SR+1 bilden ein 16-Bit-Schieberegister. Rückgekoppelt wird es an den Positionen 6 und 9. Es werden quasi nur 10 Bit von den 16 vorhandenen ausgenutzt. SHIFT erzeugt bei wiederholtem Aufruf eine Folge mit der Periode 1023.

Das Hauptprogramm wendet nun diese Folge in grafisch reizvoller Weise an. Zunächst wird das Low-Byte des Schieberegisters mit einem zufälligen Wert (ungleich 0) vorbesetzt. Dieser Wert stammt aus dem ständig laufenden Timer A in CIA Nummer 1. SHIFT wird nun 1023 mal aufgerufen und erzeugtdadurch alle Zahlen von 1 bis 1023 in quasizufälliger Reihenfolge. Diese Zahlen werden als Adressen relativ zum Bildschirm-RAM verwendet. Bei den adressierten Bytes wirdjeweils Bit 7 invertiert, was eine Reversdarstellung der Bildschirmzeichen bewirkt. Das Programm MAIN bewirkt also nichts anderes als eine Invertierung des gesamten Textbildschirms. Da dies aber in zufälliger Abfolge geschieht, ist der Effekt sehr auffallend. Über die Variable DELAY ($FA)=250) kann man das Tempo der Invertierung beeinflussen. Das anschließende Basic-Programm (Listing 12) erzeugt einen Flimmereffekt, indem es eine einfache Zufallsgrafik mit dem Programm MAIN invertiert.

(Thomas Krätzig/aw)

# Superhirn, einmal andersherum [164-166]

> Lassen Sie den C 64 Ihre Kombination herausfinden. Nach einem perfekten Algorithmus kann der C 64 Ihre Zahlenfolge in maximal sechs Versuchen berechnen.

Beim Spiel Superhirn geht es darum, einen von einem Q Mitspieler ausgedachten Farbcode zu erraten. Man W probiert verschiedene Farbcodes aus; der Mitspieler gibt nach einer versuchten Kombination Information über deren Richtigkeit.

Es gibt schon einige Superhirn-Programme, die eine Kombination wählen, die dann der menschliche Mitspieler erraten muß.

Superhirn II geht den anderen Weg: Der Mensch denkt sich eine Kombination aus, die dann der Computer erraten muß! Superhirn II findet jede Kombination garantiert (siehe Kasten).

Die Farben werden durch Zahlen symbolisiert. Es gibt sechs»Farbzahlen«, nämlich dieZiffern 1,2,3,4,5und6. Für die Farben gibt es vier Positionen 

### Bedienungsanleitung:

Geben Sie Superhirn II bitte mit dem MSE ein (Listing 1) und starten Sie es mit »SYS 13312«.

Sie antworten, indem Sie zuerst die Anzahl der richtigen Farbziffern an der richtigen Position eingeben und dann mit »RETURN« abschließen. Dann geben Sie die Anzahl der richtigen Farbziffern an der falschen Position ein und bestätigen wiederum mit »RETURN«.

Superhirn II gibt dann seinen neuen Lösungsvorschlag aus; Sie antworten wieder wie oben. Das Programm ist beendet, wenn

- das Programm die richtige Kombination gefunden hat (es meldet sich mit »OK«)
- oder wenn Sie eine unmögliche Antwort gegeben haben (das Programm meldet sich mit »ERROR«).

### Beispiel:

Nehmen wir die Kombination »3436«. Nach Programm-Start beginnt Superhirn II wie üblich mit seiner Startkombination »1234«.

Der Computer hat die »3« richtig als Zahl und Position; die »4« stimmt nur als Zahl.
Also wird eingegeben:

TODO

1234	- der Vorschlag des Computers.
1 < RETURN > - für die richtige »3«.
1 < RETURN > - für die »4« an falscher Position.
Jetzt sucht der Computer einen neuen Lösungsvorschlag.
Verfolgen wir die Eingaben bis zum Ende ...
2211	-der2.VersuchdesComputers.
0 < RETURN > - keine richtige Position/richtige Ziffer.
0 < RETURN > - keine falsche Position/richtige Ziffer.
4333	- der 3. Versuch des Computers.
1 < RETURN > - für die richtige »3«.
2 < RETURN > - für die »3« und »4«.
3344	- der 4. Versuch des Computers.
1 < RETURN > - diesmal stimmt die erste »3«.
2 < RETURN > - dafür sind »3« und »4« vertauscht.
3435	- der 5. Versuch des Computers.
3 < RETURN > - bis auf die fehlende »6« richtig.
0 < RETURN > - die »5« ist falsch.
3436	- der 6. Versuch des Computers.
4 < RETURN > - die Kombination ist gefunden.
OK	- Sie befinden sich wieder im Basic.

Das Programm kann mit »SYS 13312« wieder gestartet werden.

### Hinweise:

Die Eingabe unlogischer Daten führt zur Ausgabe von »ERROR«. Sie haben dann entweder eine offensichtlich falsche Eingabe gemacht (zum Beispiel bei der Eingabe einer »6« für die Anzahl der richtigen Ziffern - es kann ja nur höchstens »4« als korrekte Eingabe vorkommen!) oder eine logisch falsche Eingabe.

Was ist eine logisch falsche Eingabe? Nehmen wir unser Beispiel von oben:

Geben Sie nach dem 6. Versuch des Computers nicht die (richtige!) »4« ein, sondern »0« und nochmal »0«, antwortet Ihnen der Computer mit »ERROR«. Warum?

Nun gibt es einfach keine Ziffernkombination mehr, die allen Ihren Eingaben gerecht werden kann. Folglich müssen Sie einen Eingabe-Fehler gemacht haben.

Geben Sie in unserem Beispiel nach dem 3. Versuch des Computers nicht »1« und »2« (was nach Wahl unserer Ziffernkombination »3436« die einzig korrekte Eingabe ist), sondern »2« und »2«, kann Fehleingabe natürlich nicht miteinem »ERROR« beantwortet werden, weil nämlich jetzt noch Ziffernkombinationen vorhanden sind, die nicht im Widerspruch zu Ihren bis dahin gemachten Eingaben stehen.

### Zum Programm:

Den Quelltext des Programms entnehmen Sie Listing 2. Die Eingabe-Routine liest nur das erste Zeichen jeder Zeile - es macht also keinen Unterschied, ob man als Antwort »1« oder »123456« eingibt, da die restlichen Zeichen nicht berücksichtigt werden.

Das Programm ist leicht auf zum Beispiel 10 Positionen erweiterbar - man muß jedoch folgendes beachten: Die Abstände zwischen den Registern POS1,...., CWEISSE müssen vergrößert werden, da möglicherweise neun Versuche nicht zum Ziel führen.

Auch die Anzahl der möglichen Ziffern kann leicht von sechs auf acht erweitert werden. Möchte man mehr als acht Ziffern, muß man mit 16-Bit-Zahlen arbeiten, was größere Umschreibarbeiten zur Folge hat.

### Kombinations-Codierung:

Es bleibt noch die Frage, in welcher Art und Weise die Kombinationen gespeichert werden. Nehmen wir dazu doch wieder unsere Kombination aus dem Beispiel, also »3436«.

In POS1, POS2, POS3 und POS4 steht immer die aktuelle Kombination, die der Computer gerade als Lösungsversuch ausgegeben hat.

Ist das Problem gerade bei der Lösung angelangt, dann steht nicht etwa in POS1 die »3«, in POS2 die »4«, in POS3 wieder die »3« und in POS4 die »6« - sondern die Kombination ist folgendermaßen festgehalten:
POS1 - 2 hoch (3-1)
POS2 - 2 hoch (4-1)
POS3 - 2 hoch (3-1)
POS4 - 2 hoch (6-1)

Durch diese Darstellung ist es später leichter möglich, die Anzahl der Schwarzen (= richtige Ziffer/richtige Position) und die Anzahl der Weißen (= richtige Ziffer/falsche Position) zu bestimmen.

Der Lösungsversuch des Computers in der x-ten Runde stehtgenauso codiertin POS1+X, POS2+X, POS3+Xund POS4+X.

(A. Reiser/H. Bauschke/og)

TODO ASIDE

Das Programm gibt den ersten Lösungsvorschlag aus. Nach der Eingabe des menschlichen Mitspielers wird eine Ziffernkombination gesucht, die logisch richtig ist in bezug auf alle vorher gemachten Eingaben.

Dabei werden alle Ziffernkombinationen von »1111« bis »6666« getestet.

Ist die aktuelle Ziffernkombination logisch richtig, gibt sie der Computer aus.

Das Programm beginnt bei der nächsten Suche nach der Lösung bei der zuletzt ausgegebenen Ziffernkombination; es muß also nicht wieder bei »1111« anfangen.

Hat der menschliche Gegner nicht mit »4« bei richtiger Position/rich-tige Farbe geantwortet und ist das Programm bei »6666« angelangt, kann es sich nur um eine falsche Eingabe handeln - es wird »ERROR« ausgegeben.

Wie beurteilt das Programm nun, ob es in seiner Schleife von »1111« bis »6666« gerade bei einer logisch richtigen oder logisch falschen Ziffernkombination ist?

Dazu benutzt der Algorithmus folgenden Trick: Es wird angenommen, daß die zu prüfende Ziffernkombination die richtige ist. Dann werden alle bis dahin getätigten Eingaben mit dieser Kombination verglichen. Es wird also nach der Anzahl der richtigen Ziffer/richtige Position und nach der Anzahl richtige Ziffer/falsche Position gesucht. Das Ergebnis wird festgehalten und mit den Eingaben, die Sie gemacht haben, verglichen.

Stimmen diese Werte sämtlich überein, kann es sich bei der zu prüfenden Kombination um die Lösung handeln - sie muß es aber nicht sein!

Trifft nun das Programm auf eine solche Lösungsmöglichkeit, gibt es diese auch aus.

Ist die Prüfung negativ ausgefallen, das heißt, es gab mindestens eine Abweichung von der tatsächlichen Eingabe des menschlichen Mitspielers, wird in der großen Schleife weitergesucht - so lange, bis die Kombination gefunden ist.

So findet das Programm die Kombination

# Befehlssatz des 6510 [171-172,174-178]

> Hier finden Sie, alphabetisch geordnet, eine Auflistung aller bekannten Befehle des C64-Prozessors. Dazu gehören auch die »illegalen Opcodes«.

Zuerst ein Wort zu den illegalen Opcodes, die in Tabelle 1 enthalten sind:
Seit Erscheinen des C 64 vor ungefähr drei Jahren sind einige verschiedene Versionen des Prozessors 6510 gebaut worden. Diese sind untereinander voll kompatibel, was den normalen Befehlssatz aus Tabelle 2 anbetrifft. Die illegalen Opcodes jedoch laufen nicht auf allen Versionen der CPU 6510. Welche Befehle auf welchem Computer eine korrekte Ausführung bewirken, läßt sich nur durch Ausprobieren feststellen. Äußerst hilfreich dabei ist der SMON aus dieser Ausgabe: Er zeigt einen illegalen Opcode nicht wie die meisten Maschinensprachmonitore durch drei Fragezeichen an, sondern disassembliert den Befehl mit den in Tabelle 1 genannten Abkürzungen. Ein vorangestelltes Sternchen (*) kennzeichnet bei SMON den Befehl als illegalen Opcode (zum Beispiel *AXS).

In Tabelle 3 finden Sie eine Übersicht über die in den beiden anderen Tabellen verwendeten Abkürzungen.

(tr)

■	AXS : AND akku and X-register and subtract from data Der Wert wird von dem Ergebnis der AND-Verknüpfung zwischen Akku und X-Register subtrahiert und in das X-Register geschrieben.
Addressierungsarten:.
Assembler:	Hex-Code:	Abkürzung:	Byte:
AXS #0P	CB	IM	2
■	DCP : decrement and compare with akku
Entspricht Befehlsfolge:
DEC
CMP
Addressierungsarteni			
Assembler:	Hex-Code:	Abkürzung:	Byte:
DCP 0P	C7	ZP	2
DCP OP,X	D7	ZPX	2
DCP OP	CF	ABS	3
DCP OP,X	DF	ABX	
DCP OP,Y	DB	ABY	3
DCP (OP,X)	C3	(ZP,X)	2
DCP (OP),Y	D3	(ZP) ,Y	2
■	DOP : double NOP
Folgende Codes wirken wie der NOP—Befehl, sind aber zwei Byte lang. Das zweite Byte wird dabei übersprungen.
04, 14, 34, 44, 54, 64, 74, D4, F4, 80, 89, 93
■ISC : increment and subtract with carry Entspricht Befehlsfolge: INC SBC
Addressierungsarteni			
Assembler:	Hex-Code:	Abkürzung:	Byte:
ISC 0P	E7	ZP	2
ISC OP,X	F7	ZPX	
ISC 0P	EF	ABS	3
ISC OP,X	FF	ABX	
ISC OP,Y	FB	ABY	
ISC (OP,X)	E3	(OP,X)	2
ISC (OP),Y	F3	(OP) ,Y	2
■ All : AND register with $11
Das X- beziehungsweise Y-Register wird mit $11 AND-verknüpft und das Ergebnis X-- beziehungsweise Y-indiziert abgelegt
A d d r e s s i e r u n g s a r t e n:
Assembler; Hex-Code:	Abkürzung:	Byte:
All OP,X
All OP,Y
9C	ABX
9E	ABY
■AAX : AND akku with X-Register and store akku Entspricht befehlsfolge:
AND zwischen Akku und X-Register STA
Addressi erungsarten:
Assembler:	Hex-Code:	Abkürzung:	Byte:
■ KIL : killer codes
Folgende Codes bewirken einen Absturz des Prozessors, dem auch mit einem RUN/STOP-RESTQRE nicht mehr beizukommen ist.
02, 12, 22, 32, 42, 52, 62, 72, 92, B2, D2, F2
■LAR : load akku, AND with stackregister, transfer result to akku, X-register and stackregister Entspricht Befehlsfolge: LDA AND TAX TXS
Addressierungsarten£
Assembler:	Hex-Code:	Abkürzung:	Byte:
AAX #OP
AAX 0P
AAX OP,Y
AAX 0P
AAX <OP,X>
SB	IM
87	ZP
97	ZPY
8F	ABS
83	(OP,X)
LAR OB,Y
BB
ABY
■ ASR : AND with akku and shift right Entspricht Befehlsfolge: AND
LSR
■ LAX : load to akku and X-register Entspricht BefehlsfoJ^e: LDA TAX
Addressi erungsarten:
Assembler:	Hex-Code:
ASR #OP	6B
Abkürzung:	Byte:
IM	2
Addressierungsarten.:_
Assembler:	Hex-Cbde:	Abkürzung:	Byte:
LAX OP	A7	ZP	
LAX OP,Y	B7	ZPY	2
LAX OP	AF	ABS	
LAX OP,Y	BF	ABY	3
LAX (OP,X)	A3	(OP,X)	2
LAX (OP),Y	B3	(OP),Y	2
■ARR : AND with akku and rotate right Entspricht Befehlsfolge: AND -ROR
A d d r e s s i e r u n g s a r t e n:
Assembler:	Hex-Code:	Abkürzung:	Byte:
ARR #OP
IM
■ NOP : no operation
Folgende Codes haben wie der Code $EA die NOP-Funktion:
lA, 3A, 5A, 7A, DA, FA
Tabelle 1. Die »illegalen Opcodes« des 6510-Prozessors
171
Tabellen
C64
■	RLA : rotate left, AND with akku and store akku Entspricht Befehlsfolge: ROL AND STA Addressierungsarten^ Assembler:	Hex-Code: Abkürzung: Byte: RLA OP	27	ZP	2 RLA OP,X	37	ZPX	2 RLA OP	2F	ABS	3 RLA OP,X	3F	ABX	3 RLA OP,Y	3B	ABY	3 RLA (OP,X)	23	(OP,X)	2 RLA (OP),Y	33	(OP),Y	2 ■	RRA : rotate right and add with carry Entspricht Befehlsfolge: ROR ADC Addressierungsarteni Assembler:	Hex-Code:	Abkürzung:	Byte: RRA OP	67	ZP	2 RRA OP,X	77	ZPX	2 RRA OP	6F	ABS	3 RRA OP,X	7F	ABX	3 RRA OP,Y	7B	ABY	3 RRA (OP,X)	63	(OP,X)	2 RRA (OP),Y	73	(OP),Y	2 ■	SLO : shift left and OR with akku Entspricht Befehlsfolge: ASL ORA A d d r e s s i e r u n g s a r t e n: Assembler:	Hex-Code:	Abkürzung:	Byte: SLO OP	07	ZP	2 SLO OP,X	17	ZPX	2 SLO OP	0F	ABS	3 SLO OP,X	lF	ABX	3 SLO OP,Y	lB	ABY	3 SLO (OP,X)	13	(OP,X)	2 SLO (OP),Y	03	(OP),Y	2 ■	SRE : shift right and EOR with akku Entspricht Befehlsfolge: LSR EOR Addressierungsarteni Assembler:	Hex-Code:	Abkürzung:	Byte: SRE	OP	47	ZP	2 SRE	OP,X	57	ZPX	2 SRE	OP	4F	ABS	3 SRE	OP,X	5F	ABX	3 SRE	OP,Y	5B	ABY	3 SRE	(OP,X)	43	(OP,X)	2 SRE	(OP),Y	53	(OP),Y	2 ■	TOP : triple NOP Folgende Codes wirken wie der NOP-Befehl, sind aber drei Byte lang. Das zweite und das dritte Byte wird dabei übersprungen. 0C, lC, 3C, 5C, 7C, DC, FC Tabelle 1. Die »illegalen Opcodes« des 6510-Prozessors (Schluß)

■ ADC : add with carry addiere Adresseninhalt plus Carry-Flag zum Akkumulator Fl.ags:. N Z C I D V + + +	+ Ad dressi er ungsarten.: Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte: ADC ttOP	69	IM	2	2 ADC OP	65	ZP	2	3 ADC OP,X	75	ZPX	2	4 ADC OP	6D	ABS	3	4 ADC OP,X	7D	ABX	3	4 ADC OP,Y	79	ABY	3	4 ADC (OP,X)	61	(ZP,X)	2	6 ADC (OP),Y	71	(ZP),Y	2	5
			
■ AND : AND akku verknüpfe Speicher mit	Akku durch logische UND		
Elagsi N Z C I D V + +			
Ad d r essi erun gsart en : Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
AND #OP	29 AND OP	25 AND OP,X	35 AND OP	2D AND OP,X	3D AND OP,Y	39 AND (OP,X)	21 AND (OP),Y	31	IM ZP ZPX ABS ABX ABY (ZP,X) (ZP),Y	2 3 3	3 4 4 4 4 6 5
■ ASL : arithmetic shif schiebe Bits eines Spei	t left chers um eine	Stelle nach links	
Elagsi N z c i D v			
Addressierungsarten^ Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
ASL	0A ASL OP	06 ASL OP,X	16 ASL OP	0E ASL OP,X	lE	Akku ZP ZPX ABS ABX	1 3 3	6 6 7
■ BCC : branch if carry clear verzweige, falls das übertragsbit gelöscht ist			
Flagsi N Z C I D V kei ne			
Ad d ressi er ungsar ten:. Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
BCC 0P	90	REL	2	2
■ BCS : branch if carry set verzweige, falls das übertragsbit gesetzt ist			
Hags:. N Z C I D V kei ne			
A d d r e s s i. e r u n g s a r t e n: Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
BCS OP	B0	REL	2	2
■ BEQ : branch if equal verzweige, falls das gleich (Null) war	(to zero) Ergebnis der	1etzten	Operat i on
Ehgsi N z c i D v kei ne			
Add r ess_ierun gsar teni Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
BEQ OP	F0	REL	2	2
■ BIT : test bits verknüpfe Speicher und Akku durch AND, setze entsprechende Flags (Akku wird nicht verändert !)			
Fl.ags:. N Z C I D V + +	+			
Ad d r essier un gsar t e n:_ Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
BIT OP	24 BIT OP	2C	ZP ABS	2	4
■ BMI : branch if minus verzweige, falls das Ergebnis der kleiner Null war		1etzten	Operation
Flags?. N Z C I D V keine			
Add ressierung sar ten: Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
BMI 0P	30	REL	2	2
Tabelle 2. Die Befehle des 6510-Prozessors			
172
Gerade rechtzeitig
zum Weihnachtsfest: Der große
MMmmt ««»«BMI
186 MSMAGAZHmCOMPUrabMNS
★ Ups fur den Kauf
★ Selbstbau: besserer Ton, besseres BHd
ÄusfiMche Testberichte
★ C128D
★ Floppyl571
★ Profi-Software für C128
Markt&Technlk
Testbericht über


den brandneuen Commodorel28D im Januar-Heft von 64'er. £
Außerdem gibt Ihnen eine Marktübersicht wertvoUe Einkaufstips zum Thema Farbmonitore. Lesen Sie in weiteren Hardware-Tests aHes über Farb- und monochrome Monitore, die Floppy-Laufwerke 1570 und 1571 und zwei Drucker: Riteman II und Citizen MSP10.
Eigenbau-Spezialisten finden eine Anleitung zum Umbau eines S/W-Fernsehers in einen Monitor, und fertige Platinen-
layouts für den 64’er-Eprommer und einen Audio-Verstärker für Monitore.
Das Listing des Monats präsentiert einen superschneUen Tiny-Basic-Compüer, und unter der Anwendung des Monats finden Sie die Basic-Erweiterung Datawork-Basic: Die einfache Programmierung Ihrer persönlichen Datenbank.
In zwei Software-Tests erfahren Sie alles über Simulationen und Profi-Software für
den C 128.
64’er-Extra stellt Ihnen aUe Kemel-Routinen vor, und natürlich finden Sie — wie in jeder Ausgabe — wieder jede Menge Tips&Tricks für C 64 und C 128.
FÜR EIN KOSTENLOSES PROBEEXEMPLAR DES 64’er-MAGAZINS
JA, ich möchte das »64’er-Magazin« kennenlemen.
Senden Sie mir bitte die aktuellste Ausgabe kostenlos als Probeexemplar. Wenn mir »64’er« gefällt und ich es regelmäßig weiterbeziehen möchte, brauche ich nichts zu tun: Ich erhalte »64’er« dann regelmäßig frei Haus per Post und bezahle pro Jahr DM 78,— (Ausland auf Anfrage)

Vorname, Name
Straße
PLZ, Ort
Falls Sie 64’er noch nicht regelmäßig beziehen, starten Sie doch jetzt mit einem persönlichen Abonnement ins neue Jahr.
Wenn Sie zur Anforderung den nebenstehenden Gutschein benutzen, genießen Sie nicht nur die Abonnentenvorzüge, sondern erhalten außerdem die neueste Ausgabe kostenlos und unverbindlich als Probeheft!
Datum
1. Unterschrift
Mir ist bekannt, daß ich diese Bestellung innerhalb von 8 Tagen bei der Bestelladresse widerrufen kann und bestätige dies durch meine zweite Unterschrift. Zur Wahrung der Frist genügt die rechtzeitige Absendung des Widerrufs.
Datum
2. Unterschrift
Gutschein ausfüllen, ausschneiden, in ein Kuvert stecken und absenden an: Markt&Technik
Verlag Aktiengesellschaft, Vertrieb, Postfach 1304, 8013 Haar
64S0885
Tabellen
C64
■	BNE : branch if not equal (to zero) verzweige, falls das Ergebnis der letzten Operation ungleich (Null) war
Elagsi N Z C I D V kei ne
Addressierungsarten:
Assemblers Hex-Codes
BNE OP	D0
Abkürzungs	Bytes	Taktes
REL	2	2
■	BPL s branch if plus
verzweige, falls das Ergebnis der letzten Operation größer Null war
Elassi N Z C I D V kei ne
Add ressierun gsar teni
Assemblers	Hex-Codes	Abkürzungs	Bytes	Taktes
BPL OP	10	REL	2	2
Flags:. N Z C I D V
Addressieryngsarteni
Assembler:	Hex-Code:	Abkürzungs	Bytes	Taktes
CLV	B8	-	1	2
■	CMP s compare with akku vergleiche Speicher mit Akkuinhalt
Elagsi N Z C I D V
Addressier ungsar ten^
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
CMP #0P	C9	IM	2	7
CMP 0F	C5	ZP	2	3
CMP OP,X	D5	ZPX	7	4
CMP 0P	CD	ABS	3	4
CMP OP,X	DD	ABX	3	4
CMP OP,Y	D9	ABY	3	4
CMP (OP,X)	C1	(ZP,X)	7	6
CMP (OP),Y	Dl	(ZP),Y	2	5
■	BRK s break Programmstop und Sprung über Breakpointer
Flags! N Z C I D V
Addressierungsarteni
Assemblers Hex-Codes Abkürzungs Bytes Taktes
BRK
■	BVC s branch if overflow clear verzweige, falls das überlaufsbit gelöscht ist
Flags-. N Z C I D V keine
Addressierungsarten;.
Assemblers	Hex-Codes	Abkürzungs	Byte:	Takte:
BVC OP	50	REL	2	2
■	BVS : branch if overflow set verzweige, falls das überlaufsbit gesetzt ist
Flags:. N Z C I D V kei ne
Addressierungsarten.!
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
BVS OP	70	REL	2	2
■	CPX s compare with X-register vergleiche Speicherinhalt mit X-Register
Flags:_ N Z C I D V
Addressi erungsarten s
Assembl er:	Hex-Code:	Abkürzung:	Byte:	T a k t e:
CPX #0P	C9	IM	7	
CPX 0P	E4	ZP	7	3
CPX 0P	EC	ABS		4
■	CPY s compare with Y-register vergleiche Speicherinhalt mit Y-Register
Flags:. N Z C I D V
Addressierungsarten-^
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
CPY #0P	C0	IM	o	2
CPY 0P	C4	ZP	7	3
CPY 0P	CC	ABS	3	4
■ DEC : decrement subtrahiere Eins von Speicherinhalt
Flags:. N Z C I D V
■	CLC s clear carry lösche das Ubertragsbit
Flags:. N Z C I D V +
Add r essi er un g sar t en:
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
LLC	18	_	1	2
■	CLD : clear decimal mode
lösche das Bit für den Dezimalmodus
Elagsi N Z C I D V , +
^dressierungsarteni
Assemblers	Hex-Codes	Abkürzung:	Byte:	Takte:
CLD	D8	-	i	2
■CLI : clear interrupt flag
lösche das Interruptbit (Interrupts nun erlaubt)
Elagsi N Z C I D V +
Addressierungsarten:
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
CLI	58	-	i
■CLV : clear overflow flag lösche das überlaufbit
Addressierungsartens.
-Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
DEC 0P	C6	ZP		5
DEC OP,X	D6	ZPX		6
DEC 0P	CE	ABS	3	6
DEC OP,X	DE	ABX		7
■	DEX : decrement X-register subtrahiere Eins vom Inhalt des X-Registers
H.agsi N Z C I D V
A d d r e s s i_ e r u n g s a r t e n s
Assembler^ Hex-Code:	Abkürzung:	Byte:	Takte:
DEX	CA	-	1	2
■	DEY : decrement Y-register subtrahiere Eins vom Inhalt des Y-Registers
Flags: N Z C I D V
Addressierungsarten: Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
DEY	88	-	1	2
Tabelle 2. Die Befehle des 6510-Prozessors (Fortsetzung)
174
C64
Tabellen
■ EOR s exclusive-or verknüpfte Akku und Speicher durch logisches EXKLUSIVODER
Flags:. N Z C I D V
Addressi erungsarten:
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
EOR #0P	49	IM	2	2
EOR 0P	45	ZP		
EOR OP,X	55	ZPX		4
EOR 0P	4D	ABS		4
EOR OP,X	5D	ABX		4
EOR OP,Y	59	ABY		4
EOR (OP,X)	41	(ZP,X)		6
EOR (OP),Y	51	(ZP),Y	2	5
				
■ INC : increment addiere Eins zu Speicherinhalt Flagsi N Z C I D V Ad d ressierung sar t en:_ Assembler:	Hex-Code:	Abkürzung:			Byte:	Takte:
INC 0P	E6	ZP	2	
INC OP,X	F6	ZPX		6
INC 0P	EE	ABS		6
INC OP,X	FE	ABX		7
■ INX : increment X-register addiere Eins zu X-Registerinhalt
Flagsi N Z C I D V
Addressierungsarteni
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
INX	E8	-	1	2
■ INY : increment Y-register addiere Eins zu Y-Registerinhalt
Flags: N Z C I D V
Addressi erungsarteni
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
INY	C8	-	1	2
■	JMP : jump springe zu Adresse
Flagsi N Z C I D V kei ne
Addressierungsarteni
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
JMP OP	4C	ABS	3	3
JMP (0P>	6C	IND	3	5
■	JSR : jump subroutine
Springe in Unterprogramm
Flags: N Z C I D V kei ne
A d d r e s s i e r u n g s a r t e n :
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
JSR 0P	20	ABS	3	6
■	LDA : load akku schreibe Wert in Akku
Flags.:.. N Z C I D V
Addressierungsarteni
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
LDA #0P	A9	IM	2	2
LDA 0P	A5	ZP	2	
LDA OP,X	B5	ZPX		4
LDA 0P	AD	ABS	3	4
LDA OP,X	BD	ABX		4
LDA OP,Y	B9	ABY		4
LDA (OR,X)	Al	(ZP,X)	2	6
LDA (OP),Y	Bl	(ZP),Y	2	5
■ LDX : load X--register schreibe Wert ins X-Register		
Flagsi N Z C I D V		
+ +		
Ad d ressier un g sarteni Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
LDX #0P	A2	IM	2	2
LDX OP	A5	ZP		3
LDX OP,Y	B6	ZPY		4
LDX OP	AE	ABS		4
LDX OP,Y	BE	ABY		4
■ LDY : load Y-register schreibe Wert ins Y-Register		
Flags:. N Z C I D V		
+ +		
Ad d ressi er un g sar t en:. Assembler:	Hex-Code:	Abkürzung:	Byte:	T akte:
LDY #OP	A0	IM	2	7
LDY OP	A4	ZP	2	7.
LDY OP,X	B4	ZPX		4
LDY OP	AC	ABS	3	4
LDY OP,X	BC	ABX	3	4
■ LSR : logical shift right		
bitweises Rechtsschieben eines Speicherinhalts		
(Bit 0 wird ins Carry-Flag geschoben Null gesetzt)	, Bit 7	wird auf
Flags:. N Z C I D V		
+ + +		
Ad d ressi erung sar ten: Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
LSR	4A	Akku	1	2
LSR OP	46	ZP	2	5
LSR OP,X	56	ZPX	7	6
LSR OP	4E	ABS		6
LSR OP,X	5E	ABX	3	7
■ NOP : no operation keine Ausführung (Dummy-Befehl)		
Flagsi N Z C I D V		
kei ne		
Addressierungsarten: Assembler:	Hex-Code:	Abkürzung:	Byte:	T a k t e:
NOP	EA	1	2
■ ORA : OR akku		
verknüpfe Speicherinhalt und Akku durch logisches ODER		
Flagsi N Z C I D V		
+ +		
Addressierungsarteni Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
ORA #OP	09	IM	7	2
ORA OP	05	ZP	2	
ORA OP,X	15	ZPX	2	4
ORA OP	0D	ABS	7,	4
ORA OP,X	lD	ABX	■3	4
ORA OP,Y	19	ABY	3	4
ORA (OP,X)	01	(ZP,X)	2	6
ORA (OP),Y	11	(ZP),Y		5
■ PHA : push akku schiebe Akkuinhalt auf Stack		
Flags:. N Z C I D V		
kei ne		
Address_ierungsarten: Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
PHA	48	1	3
■	PHP : push processor-status schiebe Statusregister auf Stack
Tabelle 2. Die Befehle des 6510-Prozessors (Fortsetzung)
330?
175
Tabellen
C64
Flagsi N Z C I D V kei ne
Ad d r essierungsart en:
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
PHP	08	-	1	3
■	PLA : pull akku
lade Akku mit oberstem Stackbyte
Flags:. N Z C I D V + +
Add r essi er un g sarten:
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
PLA	68	-	1	3
■	PLP : pull processor-status
lade Statusregister mit oberstem Stackbyte
Flags: N Z C I D V + + + + + +
A d d r e s s i e r _u n g s a r t e n £
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
PLP	28	-	1	4
■	ROL : rotate left rotiere Speicherinhalt um ein Bit nach links
(Bit 7 kommt ins Carryflag, Inhalt des Carry-Flags kommt ins Bit 0)
Flags: N Z C I D V
A d d r e s s i e r _u n g s a r t e n:,				
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
ROL	2A	Akku	1	n
ROL OP	26	ZP		5
ROL OP,X	36	ZPX		6
ROL OP	2E	ABS	3	6
ROL OP,X	3E	ABX	3	7
A d d r e s s i e r u n g s a r t e n i
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
SBC #0P	E9 SBC OP	E5 SBC OP,X	F5 SBC OP	ED SBC OP,X	FD SBC OP,Y	F9 SBC (OP,X)	El SBC (OP),Y	Fl	IM ZP ZPX ABS ABX ABY (ZP,X) (ZP),Y	3 2	2 3 4 4 4 4 6 5
■ SEC : set carry setze das Ubertragsflag	auf Eins		
Fl.agsi N Z C I D V +			
E^dC.essierungsarte Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
SEC	38		1	2
■ SED : set decimal mode setze das Dezimal-Modus-	FTag auf Eins		
Flags:. N Z C I D V			
Ad d ressi er ung sar t en:. Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
SED	F8	-	1	2
■ SEI : set interrupt setze das Interruptflag auf Eins Interrupts mehr erlaubt)		(es werden keine	
Flags:. N Z C I D V +			
Add r essi erungsart en: Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
SEI	78	-	1	2
■	ROR : rotate right
rotiere Speicherinhalt um ein Bit nach rechts
(Bit 0 kommt ins Carryflag, Inhalt des Carryflags kommt ins Bit 7)
Flags:. N Z C I D V
Ad d r e s s ier un g sar ten_:				
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
ROR	6A	Akku	1	o
ROR OP	66	ZP		5
ROR OP,X	76	znx	o	6
ROR OP	6E	ABS	3	6
ROR OP,X	7E	ABX	3	7
■	STA : store akku schreibe Akkuinhalt in Speicher
Flags: N Z C I D V kei ne
A d d r e s s i e r u n g s a r t e ni
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
STA 0P	85	ZP	o	
STA OP,X	95	ZPX		4
STA 0P	8D	ABS	T	4
STA OP,X	9D	ABX	3	
STA OP,Y	99	ABY	T	5
STA (OP,X)	81	(ZP,X)	7	6
STA (OP),Y	91	(ZP),Y	7	6
■	RTI : return from interrupt
nach Ausführen eines Interupt normales Programm weiter abarbei ten
Flags:. N Z C I D V wie vor Ausführung des Interrupts
A d d r e s s i e r u n g s a r t e n:
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
RTI	40	--	1	6
■	STX : store X-register schreibe X-Registerinhalt in Speicher
FUgs:. N Z C I D V keine
A d d r e s s i e r u n g s a r t e n i
Assembler:	Hex —Code:	Abkürzung:	Byte:	Takte:
STX 0P	86	ZP		T
STX OP,Y	96	ZPY		4
STX 0P	8E	ABS	3	4
■	RTS : return from subroutine Rücksprung aus Unterprogramm
Flags:. N Z C I D V kei ne
A d d r e s s i e r u n g s a r t e n:
Assembler:	Hex-Code:	Abkürzung:
RTS	60
Byte:
■	SBC : subtract with carry
s u b t r a h i e r e S p e i c h e r i n h a 11 v o m A k k u u n t e r B e r ü c k s i c h t i -gung des Vorzeichens
■	STY : store Y-register schreibe Y-Registerinhalt in Speicher
Flagsi N Z C I D V kei ne
A d d r e s s i e r u n g s a r t e n i
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
STY OP	84	ZP	2	3
STY OP,X	94	ZPX	2	4
STY OP	8C	ABS	3	4
Flags:. N Z C I D V
Tabelle 2. Die Befehle des 6510-Prozessors (Fortsetzung)
176
C64
Tabellen
■	TAX : transfer akku to X-register schreibe Akkuinhalt ins X-Register
Flags: N Z C I D V
Addressierungaarteni
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
TAX	AA	-	1	2
■	ABY : absolut Y-indiziert
Der Operand ist eine vierstellige hexadezimale Zahl. Der Inhalt des Y-Registers wird zum Operanden addiert und ergibt die Arbeits-Adresse.
lelsßieh
LDY#$10
LDA $C000,Y
Der Inhalt der Speicherstelle $C010 ($C000	+	$0010)
wird in den Akku geladen.
■	TAY : transfer akku to Y-register schreibe Akkuinhalt ins Y-Register
Flagsi N Z C I D V
>>Byte<< : In den Tabellen 2 und 3 gibt diese Spalte die jeweilige Länge des kompletten Befehls mit Operand an.
Addressierungsarteni
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
TAY	A8	-	1	2
■	TSX : transfer stackregister to X-register schreibe Stackregisterinhalt ins X-Register
Flags.:. N Z C I D V
Addressierungsarten^
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
TSX	BA	-	1	2
■	TXA : transfer X-register to akku
Flagsi N Z C I D V
>>Flags<< : einzelne Bits des Statusregisters
N : negative flag. Zeigt an, daß bei einer Operation einer der beiden Operanden zwischen $80 (128) und $FF (255) liegt, also das letzte Bit gesetzt ist.
Z : zero flag. Zeigt an, daß das Ergebnis einer Operation im Akku gleich Null ist.
C : carry flag. Zeigt an, daß bei einer Operation ein übertrag entstanden ist.
I : interrupt flag. Durch Setzen dieses Bit lassen sich Interrupts unterbinden.
D : decimal flag. Durch Setzen dieses Bit wir der Prozessor in den Dezimalmodus geschaltet. Das bedeutet, daß zum Beispiel das Ergebnis der Addition von $09 und $01 nicht $0A, sondern $10 ergibt.
V : overflow flag (überlauf). Zeigt an, daß das Ergebnis einer Operation größer $FF (=255) war.
A d d r e s s i e r u n g s a r t e n s
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
TXA	8A	-	1	2
■	TXS : transfer X-register to stackregister schreibe X-Registerinhalt ins Stackregister
Flags:. N Z C I D V kei ne
^ddressierungsarten:
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
TXS	9A	~	1	2
■	IM : immediate (unmittelbar)
Die Adressierungsart >>immediate<< bedeutet, daß der Operand unmittelbar als Wert weiterverarbeitet wird.
Beispiel :_
LDA #$00
Die hexadezimale Zahl $00 wird direkt in den Akku geladen.
■	OP : Operand
Je nach Adressierungsart besteht der Operand eines Befehls aus einem (Adressierung >>immediate<< und >>zeropage<<) oder zwei Byte (>>absolute<x).
■ TYA : transfer Y-register to akku schreibe Y-Registerinhalt in Akku
Flagsi N Z C I D V
0ddressierungsarten:.
Assembler:	Hex-Code:	Abkürzung:	Byte:	Takte:
TYA	98	-	1	2
■ ZP : zeropage
Der Operand besteht aus einem Byte und gibt eine Adresse in der Zeropage (Speicherbereich $0000 bis $00FF) an.
Beisgieli
LDA $2B
Der Inhalt der Speicherstelle $002B wird in den Akku geladen.
Tabelle 2. Die Befehle des 6510-Prozessors (Schluß)
■ ZPX : Zeropage X-indiziert
Der Inhalt des X-Registers wird zum zweistelligen, hexadezimalen Operanden addiert. Das Ergebnis ist eine Adresse in der Zeropage (Speicherbereich $0000 bis $00FF).
Beiseieh
LDX #$05
LDA $43,X
Der Inhalt der Adresse $0048 ($0043 + $0005) wird in den Akku geladen.
■	ABS : absolute (absolut) Der Operand ist eine vierstellige, hexadezimale Adresse.
Beispiel:.
LDA $C000
Der Inhalt der Adresse $C000 wird in den Akku geladen.
_t_______________________________________________________
■	ABX : absolut X-indiziert
Der Operand ist eine vierstellige hexadezimale Zahl.
Der Inhalt und ergibt	des X-Registers wird zum Operanden addiert die Arbeits-Adresse.
Beispiel^ LDX #$10 LDA $C000,X Der Inhalt	der Speicherstelle $C010 ($C000	+	$0010)
wird in den	Akku geladen.
■	ZPY : Zeropage Y-indiziert
Der Inhalt des Y-Registers wird zum zweistelligen, hexadezimalen Operanden addiert. Das Ergebnis ist eine Adresse in der Zeropage (Speicherbereich $0000 bis
$00FF).
P§i§BL®ll
LDY #$05
LDA $43,Y
Der Inhalt der Adresse $0048 ($0043 + $0005) wird in den Akku geladen.
Tabelle 3. Diese Abkürzungen werden in den Tabellen 1 und 2 verwendet
177
Tabellen
C64
■	(ZP,X) s indiziert indirekt
Der Inhalt des X-Registers wird zum zweistelligen, hexadezimalen Operanden addiert und ergibt eine Adresse in der Zeropage (Speicherbereich $0000 bis $00FF). Deren Inhalt und der Inhalt der darauffolgenden Adresse ergibt in der Form Lo-Byte/Hi—Byte die Arbeitsadresse.
Beiseiell
Adresse $20 hat den Inhalt $00
Adresse $21 hat den Inhalt $C0
LDX #$0E
LDA ($12,X)
Der Inhalt der Zeropage-Adressen $0020 ($000E + $0012) und $0021 ergibt die Arbeits-Adresse $C000. Deren Inhalt wird in den Akku geladen.
■	(ZP),Y s indirekt indiziert
Der zweistellige, hexdezimale Operand ergibt eine Adresse in der Zeropage (Speicherbereich $0000 bis $00FF). Deren Inhalt und der Inhalt der darauffolgenden Speicherstelle ergibt in der Form Lo-Byte/Hi-Byte eine Adresse, zu der der Inhalt des Y-Registers addiert wird. Das Ergebnis ist die Arbeitsadresse.
Adresse $20 hat den Inhalt $00
Adresse $21 hat den Inhalt $C0
LDY #$10
LDA ($20),Y
Der Inhalt der Adresse $C010 ($C000 + $0010) wird in den Akku geladen.
Tabelle 3. Diese Abkürzungen werden in den Tabellen 1 und 2 verwendet (Schluß)
ROM-Routinen in eigenen Programmen
Das Rad ist schon erfunden! Ähnlich verhält es sich mit verschiedenen Routinen, die ein Assembler-Programmierer immer wieder benötigt. Aber warum soll man sich die Arbeit des Programmierens machen, wenn das Betriebssystem viele ständig benötigte Routinen schon enthält und man nur noch zu wissen braucht, ab welcher Adresse sie stehen?
Angenommen, Sie möchten in Assembler einige komplexe Dinge programmieren wie beispielsweise eine neue mathematische Funktion (wie wäre es mit dem Kotangens) und diese auf dem Bildschirm ausgeben. Das ist eine große Aufgabe, zu der zunächst einmal die Übernahme des Arguments in das Maschinenprogramm, dann einige Fließkomma-Rechenoperationen und schließlich die Ausgabe auf dem Bildschirm geschrieben werden müßten, wenn da nicht schon fast alles an verborgener Stelle als fertige Programm-Module im Computer vorhanden wäre!
Sowohl im unteren (von $A000 bis $BFFF) als auch im oberen ROM-Bereich (von $E000 bis $FFFF) liegt die Firmware fest verschachtelt vor. Der untere ROM-Abschnitt wird manchmal auch Basic-Interpreter, der obere ROM-Bereich Betriebssystem genannt, wobei diese Einteilung aber den Kern der Sache nicht genau trifft, denn Interpreter, Editor und Betriebssystem führen ein gemischtes Dasein quer durch alle genannten ROM-Bereiche hindurch.
Mindestens fünf Informationen braucht ein Assembler-Programmierer, wenn er das breite Programmangebot des ROMs nutzen möchte:
1.	Einsprungadresse
2.	Format der Eingabeparameter
3.	Adressen der Eingabeparameter
4.	Adressen der Ausgabeparameter
5.	Format der Ausgabeparameter
Nicht alle Routinen, die man benutzen kann, erfordern alle fünf Informationen, manche weniger, einige auch mehr und schließlich gibt es noch Programmroutinen, die noch den Aufruf einer oder sogar mehrerer anderer Routinen nötig machen.
In der beigefügten Tabelle sind - nach Anwendungen sortiert - die wichtigsten Firmware-Möglichkeiten mit den erforderlichen Ein- und Ausgabeparametern aufgeführt. Das sind natürlich beileibenichtalle. DieAuswahlerfolgtesubjektiv! Es sind einfach diejenigen, die mir bislang am häufigsten untergekommen sind. Außerdem wurde auf die Kernel-Routinen verzichtet: Man findet diese sehr gut dokumentiert bereits in einer Reihe von Büchern und im Assembler-Kurs.
Die Tabelle nennt den Label-Namen, die Einsprungadresse und gibt eine Kurzbeschreibung der Funktion. Das Ein- und auch das Ausgabeformat ist ebenso angegeben wie auch die Adressen, an denen diese Parameter übergeben werden. Die verwendeten Bezeichnungen halten sich eng an die im Assembler-Kurs kennengelernten. Sie sind allgemein üblich:
178
C64
Tabellen
FAC	Fließkomma-Akku 1
ARG	Fließkomma-Akku 2
A	Akkumulator
X,Y	X-, Y-Register
A/Y	2-Byte-Angabe im Format LSB/MSB
im Akku/Y-Register
FLPT	Fließkommazahl im Normalformat
MFLPT	gepacktes Fließkommaformat
Damit das alles nicht so trocken abläuft, soll noch ein kleines Beispiel vorgestellt werden! Die oben schon erwähnte Kotangens-Funktion wird in einem Maschinenprogramm erzeugt, das durch USR anzuspringen ist. In Bild 1 finden Sie ein Flußdiagramm zu dem Programm, welches hier als Hypra-Ass-Listing abgebildet ist (Listing 1). Ein kurzes Testprogramm liefert Listing 2.
Der Einsprung mittels USR bietet den Vorteil, daß der Übergabewert gleich im FLPT-Fbrmat im FAC »landet«. Es ist aber sinnvoll, den Übergabeparameter mittels der MOVMF-Routine zu »retten«, weil durch die Kosinus-Funktion der FAC verändert wird. Wenn auch das Ergebnis der Kosinus-Funktion mittels MOVMF beiseite gelegt wurde, holen wir durch MOVFM den Anfangswert wieder in den FAC und bilden mittels SIN den Sinus davon. Schließlich teilen wir den im Speicher stehenden Kosinuswert durch den im FAC befindlichen Sinuswert (unterVerwendung von FDIV). Das Ergebnis ist der Kotangens:
COTX = (COSX/SIN X)
Dieser Wert befindet sich nun im FAC und wird mit dem RTS an das Basic-Programm zurückgeliefert. Im Testprogramm weisen wir ihm dann die Variable E zu.
Dieses kurze Beispiel soll Ihnen den Mund wässrig machen. Sehr viel detaillierter werden die ROM-Routinen im Kurs »Von Basic zu Assembler« im 64’er behandelt werden.
(Heino Ponnath/hm)
Literatur:
1.	Kassera/Kassera, Programmieren in Maschinensprache, München 1985: Markt&TechnikVerlag, MT 830
2.	West, C64 Computerhandbuch, München 1984, Te-wi
3.	Babel/Krause/Dripke, Das Interface Age Systemhandbuch zum C 64, München 1983: Interface Age Verlag
4.	Ponnath, C 64 Wunderland derGrafik, München 1985: Markt&TechnikVerlag MT 756.
hypra-ass <	assemblerlisting:		
	10	.li	1,4,7
20	-	.ba ;einsprung mittels usr ;zuvor usr—vektor einstellen!			$6000
	160	- 165	- 170	- 180 - 190 - 200 - 205	-	.eq .eq . eq .eq .eq .eq .eq	cos=$e264 movfm=$bba2 movmf=$bbd4 sin=$e26b fdiv=$bb0f wert=$7000 wertl=$7010
6000 a210	:212 -start	ldx	#<(we^tl)
6002 a070	:214	-	ldy	#>(wert1)
6004 20d4bb	:216	-	jsr	movmf
6007 2064e2	:220 -	jsr	cos
600a a200	:230	-	ldx	#<(wert)
600c a070	:240 -	ldy	#>(wert)
600e 20d4bb	:250 -	Jsr	movmf
6011 a910	:252 -	lda	#<(wertl)
6013 a070	:254	-	ldy	#>(wertl)
6015 20a2bb	:256	-	jsr	movfm
6018 206be2	:260	-	jsr	sin
601b a900	:270	-	lda	#<(wert)
601d a070	:280	-	ldy	#>(wert)
601f 200fbb 6022 60 symbols in cos fdiv movfm movmf sin	: 290	- :300	- 320	- alphabetical = $e264 = $bb0f = $bba2 = $bbd4 = $e26b	jsr rts .sy order:	fdiv 1,4,7 Listing 1.
start	= $6000	Hypra-Ass-Listing der	
wert	= $7000 wertl	= $7010 end of assembly 0:25.9 base = $6000 last byte		Kotangens-Funktion at $6022	
Wert sichern durch MOVMF
orung über -Vektor
10 REM***TEST FUER COTANGENS***
20 POKE785,0:POKE786,96:REM USR-VEKTOR
30 INPUT"WINKEL";W:W=W*n/180:REM AUF BOGENMASS
40 E=USR(W):REM AUFRUF DES PROGRAMMES
50 PRINTW,E:REM ERGEBNIS IN E
60 END
READY. Listing 2. Test der Kotangens-Funktion
COS
Ergebnis sichern durch MOVMF
Anfangswert zurück in FAC mittels MOVFM
Division des Cosinus durch den Sinus mit FDIV
( RTS
1. Routinen, die die Kooperation von Basic und Assembler erleichtern:
Label Adresse Funktion	Eingabe	Ausgabe
	Format	Adresse Format	Adresse
CHRGET 0073 HoltnächstesByte	1 Byte	Basic-Text 1 Byte	A
CHRGOT 0073 Holt aktuelles Byte	1 Byte	Basic-Text 1 Byte	A
READY A474 ErzeugtREADY-Status	-	-	-
LINGET A96B Holtlntegerwert (0-63999)	ASCII-Zahl Basic-Text 2-Byte Integer		14/15
FRMNUM AD8A Holtbeliebigennume-rischen Ausdruck	Basic- Ausdruck	Basic-Text FLPT	FAC
FRMEVL AD9E Holtbeliebigen Ausdruck	Basic-Ausdruck	Basic-Text a) bei Fließkomma: FLPT	FAC b)	bei Integer: FLPT	FAC c)	bei String: Zeigerauf FAC+3, Descriptor FAC+4	
Diese Routine setzt außerdem eine Reihe von Flaggen:
VALTYP($OD) O=Zahl FF=String INTFLAG ($0E) O=FlieBkomma 80=integer
Bild 1. Flußdiagramm einer Kotangens-Funktion
179
Tabellen
C64
War Ausdruck einfache Variable, dann zeigt VARNAM ($45/6) das 1. Byte des Variablen-Namens CHKCLS	AEF7	Prüftauf»)«	ASCII	Basic-Text CHKOPN	AEFA	Prüft auf»(«	ASCII	Basic-Text CHKCOM	AEFD	Prüftauf»,«	ASCII	Basic-Text SYNCHR	AEFF	PrüftaufZeichen	ASCII	Basic-Text im Akkumulator	A Diese 4 Routinen überlesen das Zeichen, wenn vorhanden. Wenn nicht vorhanden, folgt SYNTAX ERROR ISVAR AF28 SuchtVariablenwert Name+ $45/46 a)Zahl: Kennung	FLPT FAC b) String: Descriptor-FAC+3 ORDVAR	B0E7	SuchtVariablennamen	Name+	$45/46 Kennung	Adresse $47/48 GTBYTC	B79B	HoltZahl(0-255)	ASCII	Basic-Text1Byte	X GETNUM	B7EB	Liest2lntegerzahlen	ASCII	Basic-Text 2Byte-lnt.	$14/15 (TrennungdurchKomma)	1Byte-lnt. X 1.Zahl:Obis65535 2.Zahl:0bis255 COMBYT E200 Prüftauf»,«undholt ASCII Basic-Text1Byte X folgende Zahl 2.	Routinen, die Verschiebungen im Speicher durchführen: BLTUC A3BF Verschiebt Blöcke	Adressen: Quelle Start $5F/60 Ende+1 $5A/5B Ziel Ende+1 $58/59 PUTINT	A9C4	SchiebtFACalslnteger	FLPT	FAC	2Byte- angegebene inVariable	Adresse	$49/50	Integer	Variable PTFLPT	A9D6	Schiebt FAC	FLPT	FAC	MFLPT angegebene in Variable	Adresse	$49/50	Variable GETSPT AA2C SchiebtString-	Zeiger	FAC+3 descriptor in Variable Adresse	$49/50	Descriptor angegebene Variable STRVAL	B7B5	Zahlenstringin	ASCII	ab$22	FLPT	FAC FAC einlesen	Länge	A CONUPK	BA8C	LädtARGausSpeicher	MFLPT	A/Y	FLPT	ARG MOVFM	BBA2	LädtFACausSpeicher	MFLPT	A/Y	FLPT	ARG MOVMF	BBD4	Schiebt FAC	FLPT inSpeicher	Adresse	FACX/Y	MFLPT	ange- gebener Speicher MOVFA	BBFC	ARGinFACkopieren	FLPT	ARG	FLPT	FAC MOVAF	BCOC	FAC in ARG kopieren	FLPT	FAC	FLPT	ARG ACTOFC	BC3C	Akku in FAC schieben	-	1Byte	A	FLPT	FAC 3.	Routinen zur Arithmetik: ASCADD	AA27	AddiertASCII-Ziffer	ASCII	A	FLPT	FAC zu FAC	Ziffer OROP	AFE6	FAC=(FAC)OR(ARG)	FLPT	FAC,ARG	FLPT	FAC ANDOP	AFE9	FAC=(FAC)AND(ARG)	FLPT	FAC,ARG	FLPT	FAC 0	Y FACINX	B1AA	FACwirdalslnteger	FLPT FAC	2Byte-	A/Y in A/Y abgelegt	Integer UMULT	B357	16-Bit-Multiplikation	2-Byte-lnteger Zahl1	$28/29	2Byte-	X/Y Zahl2	$71/72	Integer CIVAYF	B391	lnteger(-32768bis	2Byte-	A/Y	FLPT	FAC 32767) in FAC	Integer SGNFT	B3A2	lnteger(0bis255)	1Byte	y	FLPT	FAC inFAC GETADR	B7F7	WandeltFACzu	FLPT	FAC	2Byte- Y/A lnteger(0-65535)	Integer +$14/15 FADDH	B849	FAC = FAC + 0,5	FLPT	FAC	FLPT FAC FSUB B850 FAC=Speicherzahl MFLPT ZeigerA/YFLPT FAC -FAC FLPT FAC FSUBT	B853	FAC = ARG-FAC	FLPT	ARG,FAC	FLPT	FAC FADD	B867	FAC=Speicherzahl	MFLPT	ZeigerA/YFLPT	FAC +FAC	MFLPT	FAC FADDT	B86A	FAC = ARG + FAC	FLPT	ARG,FAC	FLPT	FAC COMPLT	B947	ErzeugtZweier-	FLPT	FAC	FLPT	FAC komplement von FAC	LOG B9EA FAC = ln(FAC)	FLPT FAC	FLPT FAC FMULT BA28 FAC=Speicherwert*FAC MFLPT ZeigerA/YFLPT FAC FLPT FAC FMULTT	BA30	FAC = ARG * FAC	FLPT	ARG,FAC	FLPT	FAC MUL10	BAE2	FAC = 10 * FAC	FLPT	FAC	FLPT	FAC DIV10	BAFE	FAC = FAC/10	FLPT	FAC	FLPT	FAC FDIVF	BB07	FAC=ARG/Speicher-	MFLPT	ZeigerA/YFLPT	FAC zahl	FLPT ARG FDIV	BBOF	FAC=Speicherzahl/FACMFLPT	ZeigerA/YFLPT	FAC FLPT FAC FDIVT	BB14	FAC = ARG/FAC	FLPT	FAC,ARG FLPT	FAC SIGN	BC28	Ermittelt Vorzeichen	FLPT	FAC	1Byte	A von FAC	1 - + 0-0 FF-- ABS	BC58	FAC = ABS(FAC)	FLPT	FAC	FLPT	FAC FCOMP	BC5B	Vergleicht FAC mit	MFLPT	Zeiger A/Y 1Byte:	A Speicherzahl	FLPT	FAC	1: FAC	> Speicher 0: FAC = Speicher FF: FAC < Speicher INT	BCCC	FAC = INT(FAC)	FLPT	FAC	FLPT	FAC AADD	BD7E	AddiertAzuFAC	FLPT	FAC	FLPT	FAC 1Byte A SQR	BF71	FAC = SQR(FAC)	FLPT	FAC	FLPT	FAC MPOT	BF78	FAC=Speicherwert	FLPT	FAC	FLPT	FAC ! FAC MFLPT Zeiger A/Y FPWRT	BF7B	FAC	=	ARG 1 FAC	FLPT	ARG,FAC	FLPT	FAC NEGOP	BFB4	FAC	=	-FAC	FLPT	FAC	FLPT	FAC EXP	BFED	FAC	=	etFAC	FLPT	FAC	FLPT	FAC POLYX	E059	Polynomberechnung	Adresse	ZeigerA/YFLPT	FAC FAC=aO+a1x+a2x2+... Zeiger weist auf Start der Konstantentabelle. 1. Byte = Polynomgrad Weitere Bytes sind die Koeffizienten des Polynoms in der Reihenfolge an	,aO im MFLPT-Format. COS	E264	FAC =	COS(FAC)	FLPT	FAC	FLPT	FAC SIN	E26B	FAC =	SIN(FAC)	FLPT	FAC	FLPT	FAC TAN	E2B4	FAC =	TAN(FAC)	FLPT	FAC	FLPT	FAC ATN	E30E	FAC =	ATN(FAC)	FLPT	FAC	FLPT	FAC
	4. Auswahl von Ein-/Ausgabe-Routinen: ERROR A437	Fehlermeldung aus-	Fehler-	X	ASCII	Bildschirm geben und READY nummer LIST A69C	Listet Basic-Programm NUMDON AABC	DrucktFACauf	FLPT	FAC	ASCII	Bildschirm Bildschirm aus STROUT AB1E GibtStringaufBild- Adresse ZeigerA/YASCII Bildschirm schirm aus. Ende=O SYNERR	AF08	AusgabeSYNTAXERROR	-	-	ASCII	Bildschirm OVERR	B97E	AusgabeOVERFLOWERR.	-	-	ASCII	Bildschirm LINPRT BDCD Druckt Integerzahl 2Byte- X/A	ASCII Bildschirm (0 bis 65535) aus. Integer FACOUT	BDD7	DrucktFACauf	FLPT	FAC	ASCII	Bildschirm Bildschirm aus FOUT	BDDD	FACwirdzuASCII-	FLPT	FAC	ASCII	ab$100 String (Ende=0).	(Ende=O) Kann direkt mit STROUT	Startadr. ausgegeben werden.	A/Y SAVET	E156	Save	ParameterausBasic-Text VERFYT	E165	Verify	ParämeterausBasic-Text LOADT	E168	Load	ParameterausBasic-Text SLPARA	E1D4	Holt Parameter für Save, Verify, Load aus dem Basic-Text PLOTK	E50A	Setzt Cursorposition Zeile	X Spalte Y HOME	E566	Cursor in Home-Position PLOTR	E56C	Setzt Cursor-Position Zeile	$D6 Spalte $D3 GETKBC E5B4 HoltZeichenaus	-	- 1Byte A Tastaturpuffer PRT	E716	GibtZeicheninA	1Byte	A	ASCII	Bildschirm auf Bildschirm aus CLRLN	E9FF	LöschtxteBild-	Zeilen-	X schirmzeile	nummer Tabelle der ROM-Routinen
180
C64
Tabellen
Die Codes des C 64
Die kompletten ASCII-, CHR$- und Bildschirmcodes und dazu noch die vollständigen Tastencodes des C 64 finden Sie in der folgenden Tabelle anwenderfreundlich, also so, daß man sie auch benutzen kann, gegenübergestellt.
Programmieren in Maschinensprache beinhaltet oft Ein-und Ausgaben, zum Beispiel für eine Benutzerführung, oder um Eingaben vom Bildschirm einzulesen. Häufig steht man vor dem Problem, daß man nur einzelne Zeichen eines Textes in einem Maschinenprogramm verändern will. In allen Fällen benötigt man dann die CHR$- oder Bildschirmcodes, von denen hier die Rede ist. Das gleiche gilt natürlich auch für die Tastatur. Das Betriebssystem stellt uns die momentan gedrückte Taste in zwei Speicherstellen zur Verfügung.
Warum verschiedene Codes?
Vergleicht man in der Tabelle 1 die Spalten, so wird man feststellen, daß es einige nicht druckende Zeichen gibt, Codes, die auf dem Bildschirm nichts schreiben. Es sind dies die ASCII- beziehungsweise die CHR$-Codes von 0 bis 31 und von 128 bis 159. Auch findet man auf dem Bildschirm Zeichen, die in der ASCII-Tabelle nicht auftauchen - die reversen Zeichen mitden Codesvon 128bis255. Umalledruckenden ASCII-Zeichen auch auf dem Bildschirm sichtbar zu machen, und dabei keine sinnlos leeren Felder mitzuführen, mußte man die Tabelle im Computer umstellen.
Ganz anders verhält es sich mit der Tastatur. Hier sieht die Codierung zunächst sehr zufällig aus. Natürlich ist dies mit der Anordnung der Tasten und der Methode, wie das Betriebssystem die Tasten abfragt, zu erklären. Uns soll es hier genügen, zu wissen, wie man von einem (Maschinen-) Programm aus einen Tastendruck registrieren kann. Man findet die zuletzt gedrückte Taste in den Speicherstellen 197 ($C5) und 203 ($CB), die mit PEEK beziehungsweise auf der Maschinensprache-Ebene mit LDA ausgelesen werden kann.
Die nachfolgende Tabelle 1 bietet auf einen Blick alle Codes, die im C64 enthalten sind. Die Tabelle ist nach den CHR$-Zeichen sortiert, also eine aufsteigende Reihe von 0 bis 255. Um das Programmieren in Maschinensprache zu erleichtern, sind neben den dezimalen Zahlen auch die hexadezimalen Werte aufgeführt.
Die Spalten drei und vier enthalten die CHR$-Zeichen des C 64. Spalte drei zeigt dabe* die Zeichen im Groß-/Grafikmo-dus, Spalte vier die entsprechenden Zeichen in Klein-/Groß-schriftmodus.
Die Zeichen von 0 bis 31 und von 128 bis 159 sind diejenigen CHR$-Codes, deren Aufruf auf dem Bildschirm kein sichtbares Zeichen hervorbringt, so zum Beispiel das Umstellen der Cursorfarbe, oder die Codes der Funktionstasten, die man nichtschreibenkann(?CHR$(133)ergibtnicht»F1«), aberfür eine Abfrage (IF A$ = CHR$(133) THEN...) nutzen kann. Hier wird nicht zwischen den Modi unterschieden, da das Ergebnis in beiden Fällen das gleiche ist. Damit derText in die
Tabelle paßt, ließen wir ihn sogar bis in die sechste Spalte übergreifen. Über den Bildschirmcode kann man nicht über diese Funktionen verfügen!
Die Bildschirmcodes der fünften und sechsten Spalte sind die Werte, die man erhält, wenn man das CHR$-Zeichen mit PRINT ausgibt und die entsprechende Bildschirmspeicherstelle mit PEEK ausliest. Für Maschinensprache ist auch hier wieder der hexadezimale Wert angegeben. Die reversen Zeichen erhält man durch Addition von 128, in Maschinensprache durch den Befehl »ORA # $80«.
Obwohl der C64 keinen echten ASCII-Zeichensatz hat, ist dieser in Spalte sieben aufgeführt. Man benötigt den ASCII-Code vor allem für die Datenfernübertragung (DFÜ) und zur Ansteuerung von nicht MPS-kompatiblen Druckern, die nicht mit einem »intelligenten« Interface betrieben werden. Die Erklärungen der verwendeten Kurzzeichen stehen in der Tabelle 2.
In den letzten beiden Spalten sind die Tastaturcodes enthalten, wie man sie beim Auslesen der Speicherstellen 197 und 203 erhält. Bitte beachten Sie, daß der Code 63 ($3F) der RUN/STOP-Taste entspricht, also dem CHR$-Code 3. Da aber PRINT CHR$(3) ein Programm nicht anhält und sich nicht abfragen läßt, ist es in der Tabelle nicht aufgeführt.
(og)
NUL = Null
SOH = Start of Heading
STX = Start of Text (Textbeginn)
ETX = End of Text (Textende)
EOT	=	End of Transmission (Übertragungsende)
ENQ = Enquiry (Testanfrage)
ACK = Acknowledge (Quittierung)
BEL = Bell (Klingelzeichen)
BS = Backspace (Zeichen zurück)
HT = Horizontal Tabulation
LF = Line Feed (Zeilenvorschub)
VT = Vertical Tabulation
FF = Form Feed (Formatanpassung)
CR = Carriage Return (Wagenrücklauf)
SO = Shift out (Shift aus)
SI = Shift in (Shift ein)
DLE	=	Data Link Escape (Datenverbindung abhalten)
DC	=	Device Control (Gerätesteuerung)
NAK	=	Negative Acknowledge (Gegenquittierung)
SYN	=	Synchronous Idle (synchronlos)
ETB = End of Transmission Block (Block Übertragungsende)
CAN = Cancel (Stornieren, zum Beispiel Puffer leeren)
EM	=	End of Medium (z. B. Papierende)
SUB = Substitute (Austausch)
ESC = Escape (übergehen, Druckercode)
FS	=	File Separator (Filetrennung)
GS = Group Separator (Trennung von Gruppen)
RS	=	Record Separator (Aufzeichnung trennen)
US	=	Unit Separator (Einheitentrenner)
SP	=	Space (Leerzeichen)
DEL	=	Delete (Löschen)
Tabelle 2. Erklärung der in Tabelle 1 abgekürzten ASCII-Zeichen
181
Tabellen
C64
Wert		CHR$-Zeichen		Bildschirmcode		ASCII-Code	Tastencode	
dez	hex	Groß/ Grafik	Klein/ Groß	dez	hex		dez	hex
a	00					NUL		
i	0i					SOH		
2	02					STX		
3	03					ETX	63	3F
4	04					EOT		
5	05	weiß				ENQ		
&	06					ACK		
7	07					BEL		
8	08	blockiert SHIFT + C				BS		
9	09	entriegelt		SHIFT +	c	HT		
10	0A					LF		
11	08					VT		
12	0C					FF		
13	0D	Carriage RETURN				CR	1	01
14	0E	Umschaltungauf Kleinschrift				SO		
15	0F					SI		
16	10					DLE		
17	11	Cursor down				DC1	7	07
18	12	Revers ein				DC2		
19	13	HOME	(Cursornach obenlinks:			DC3	51	33
20	14	DEL (ein Zeichen löschen)				DC4	0	00
21	15					NAK		
22	16					SYN		
23	17					ETB		
24	18					CAN		
25	19					EM		
26	lA					SUB		
27	18					ESC		
28	lC	rot				FS		
29	lD	Cursor right				GS	2	02
30	lE	grün				RS		
31	lF	blau				~ÜS		
32	20			32	20	SP	60	3C
33	21		i	33	21	i		
34	22			34	22	ii		
35	23	#	#	35	23	#		
36	24	$	$	36	24	$		
37	25	7.	7.	37	25	7.		
38	26	&	&	38	26	&		
39	27			39	27			
40	28	(	(	40	28	(		
41	29	)	)	41	29	)		
42	2A	*	*	42	2A	*	49	31
43	28	+	+	43	28	+	40	28
44	2C			. 44	2C	i	47	2F
45	2D	—	—	45	2D	—	43	2B
45	2E			46	2E		44	
47	2F	/	/	47	2F	/	55	37
48	30	0	0	48	30	0	35	23
49	31	1	1	49	31	1	56	38
50	32	2		50	___32_	2	59	3B
51	33	3	3	51	33	3	8	08
52	34	4	4	52	34	4	11	0B
53	35	5	5	53	35	5	16	10
54	36	6	6	54	36	6	19	13
55	37	7	7	55	37	7	24	18
56	38	8	8	56	38	8	27	lB
57	39	9	9	57	39	9	32	20
58	3A	:	:	58	3A	:	45	2D
59	38			59	38		50	32
60	3C	<	<	60	3C	<		
61	3D			61	3D		53	35
62	3E	>	>	62	3E	>		
63	3F			63	3F			
64	40	@	@	0	00	@	46	2E
65	41	A	a	1	01	A	10 ;	0A
66	42	8	b	2	02	B		
67	43	C	c	3	03	C	20	14
68	44	D	d	4	04	D	18	12
69	45	E	e	5	05	E	14	0E
70	46	F		6	06	F	21	15
71	47	8	g	7	07	G	26	lA
72	48	H	h	8	08	H	29	lD
73	49	I	i	9	09	I	33	21
74	4A	J	j	10	0A	J	34	22
75	48	K	k	11	08	K	37	25
76	4C	L	1	12	0C	I	~42		
77	4D	M	m	13	0D	M	36	24
78	4E	N	n	14	0E	N	39	27
79	4F	0	Q	15	0F	0	38	26
80	50	P		B		16	10	P	41	29
81	51	Q	q	17	11	ö	62	3E
82	52	R		18	12	R	17	11
83	53	S	s	19	13	S	13	0D
84	54	T	t	20	14	T	22	16
85	55	U	U	21	15	U	30	lE
86	56	V		22	16				
87	57	w		23	17	W	9	09
88	58	X	X	24	18	X	23	17
89	59	Y	y	25	19	Y	25	19
90	5A	z	z	26	lA	Z	12	0C
91	58	[	[	27	18	—C			
92	5C	£	£	28	lC		48	30
93	5D	]	□	29	lD	]		
94	5E	t		30	lE	T	54	36
95	5F		4-	31	lF		57	39
96	50	—	—	64	40	—@		
97	61	♦	A	65	41	a		
98	62	I	8	66	42	b		
99	63		C	67	43	c		
Wert		CHR$-Zeichen		Bildschirmcode		ASCII-Code	Tastencode	
dez	hex	Groß/ Grafik	Klein/ Groß	dez	hex		dez	hex
i00 i0i 102 103 104 105	64 65 66 67 68 69	i i	D E F G H I	68 69 70 71 72 73	44 45 46 47 48 49	d e f g h i		
106 107 108 109 110	6A 6B 6C 6D 6E	L	J K L M N	74 75 76 77 78	4A 4B 4C 4D 4E	J k 1 m n		
111 112 113 114 115	6F 70 71 72 73	• f	0 P Q R S	79 80 81 82 83	4F 50 51 52 53	o P q r s		
116 117 118 119 120	74 75 76 77 78	I d *	T U V W X	84 85 86 87 88	54 55 56 57 58	t u w X		
121 122 123 124 125	79 7A 7B 7C 7D	I ♦ 4-S I	Y Z 4- £ I	89 90 91 92 93	59 5A 5B 5C 5D	y z [		
126 127 128 129 130	7E 7F 80 81 82	ff 1 orar	$$ ige	94 95	5E 5F	r DEL		
131 132 133 134 135	83 84 85 86 87	fl f3 f5					4 5 6	04 05 06
136 137 138 139 140	88 89 8A 8B 8C	f7 f2 f4 f6 f8					3	03
141 142 143 144 145	8D 8E 8F 90 91	SHIFT RETURN Umschaltungauf Groß/Grafik schwarz Cursor up						
146 147 148 149 150	92 93 94 95 96	Revers aus CLR (Bildschirm löschen) INSERT (Zeichen einf^gen) braun hellrot							
151 152 153 154 155	97 98 99 9A 9B	grau 1 grau 2 hellgrün hellblau grau 3						
156 157 158 159 160	9C 9D 9E 9F A0	lila Cursor left gelb cyan 	96			60			
161 162 163 164 165	Al A2 A3 A4 A5	I M I	I M I	97 98 99 100 101	61 62 63 64 65			
166 167 168 169 170	A6 A7 A8 A9 AA	I r I	I I	102 103 104 105 106	66 67 68 69 6A			
171 172. 173 174 175	AB AC AD AE AF	F L 1	F L n	107 108 109 110 111	6B 6C 6D 6E 6F			
176 177 178 179 180	B0 Bl B2 B3 B4	_L 4 I	r ' 4 I	112 113 114 115 116	70 71 72 73 74			
181 182 183 184 185	B5 B6 B7 B8 B9	I I	I I	117 118 119 120 121	75 76 77 78 79			
186 187 188 189 190	BA BB BC BD BE	J ■ a J	K' ■ _i	122 123 124 125 126	7A 7B 7C 7D 7E			
191 192 193 194 195	BF C0 C1 C2 C3	♦ I	A B C	127 64 65 66 67	7F 40 41 42 43			
196	C4		D	68	44			
Tabelle 1. Die Codes des C64								
182
MtuktOchnik-Buchveriag
DM 49,-
Best-Nr. MT 710 (Beispiele auf Diskette)
DM 29,90
Das
4
Best.-Nr. MT 806, ISBN 3-89090-098-4 (sFr. 45,10/öS 382,20)
lnkl. MwSt.
unverbindliche Preisempfehlung
fis<herte<hnik
Mess®« * Stewew * Regeln
<<w <«« f »>JwlcMu,»w«
M<nkt TExhnik
(sFr. 29,90/öS 269,10)
DM 29,90
beispielen.
Best.-Nr. MT 844, ISBN 3-89090-194-8 (sFr. 27,60/öS 233,20)
S BaUoni
K. Schramm
DM 48,-
DM 52,-
Best.-Nr. MT 830 ISBN 3-89090-168-9 (sFr. 47,80/öS 405,60)
Best.-Nr. MT 736, ISBN 3-89090-136-0 (sFr. 44,20/öS 374,40)
H. L. Schneider/W. Eberl
Best.-Nr. MT 749, ISBN 3-89090-110-7 (sFr. 47,80/öS 405,60)
werden Sie ein Profi
mit dem Commodore 64

m As> UtaM Mw. Mt MNMte


H. Haberl
Mini-CAD mit Hi-Eddi plus auf dem C64
November 1985, 234 Seiten inklusive Beispieldiskette
Mit dem Programm »Hi-Eddi«, erstmals veröffentlicht in der Zeitschrift »64er«, steht ein sehr komfortables Mittel zur Erstellung von Grafiken auf dem C64 zur Verfügung. Neben den Standardbefehlen zum Setzen und Löschen von Punkten, dem Zeichnen von Linien, Kreisen und Rechtecken sowie dem Ausfüllen unregelmäßiger Flächen und dem Verschieben und Duplizieren von Bildschirmbereichen bietet Hi-Eddi auch die Möglichkeit, Text in die Grafik einzufügen, die Bildschirme zu verknüpfen oder in schneller Folge durchzuschalten, womit ein Trickfilm-Effekt entsteht.
BASIC-Grundkurs mit dem C64
März 1985, 377 Seiten
Eine grundlegende, leicht verständliche Einführung in die BASIC-Programmierung des Commo-dore64 • dieersten»Gehversuche« • einProgrammschreiben • allesüberVariablen • dieUni-versalanweisung PRINT • Sprünge und Schleifen • die Eingabe von Daten • zwei C64 kommunizieren miteinander: Erläuterung einfach gehaltener BASIC-Programme, die die Datenfernübertragung per Akkustikkoppler steuern • Übersicht aller BASIC-Befehle mit Syntax und Er-
läuterungen.
Best.-Nr. MT 633, ISBN 3-89090-045-3 (sFr. 40,50/öS 343,20)
DM 44,-
BASIC Programmierbuch
1984, 506 Seiten
Ein BASIC-Lehrbuch, das ebensoviel Spaß macht wie BASIC selbst. Locker und unterhaltsam geschrieben, mit vielen Zeichnungen und Grafiken bestückt, sagt der Text selbst dem Einsteiger alles,' was für das erfolgreiche Programmieren in BASIC erforderlich ist.
Best.-Nr. MT 658, ISBN 3-922120-92-X (sFr. 71,80/öS 608,40)
DM 78,
Programmieren unter CP/M mit dem C64
Juni 1985, 290 Seiten
Wenn Sie wissen wollen, wie das Betriebssystem CP/M 2.2 auf dem C64 implementiert ist, außerdem einiges über Turbo-Pascal, Nevada-Fortran, MBASIC-80 erfahren wollen, dann ist dieses Buch genau richtig für Sie! Mit Schaltplänen zur eigenen Fertigung des CP/M-Moduls.
Best.-Nr. MT 751, ISBN 3-89090-091-7 (sFr. 47,80/öS 405,60)
DM 52,-
Commodore 64 Listings, Band 2: Dateiverwaltung * Schule - Hobby
Oktober 1984,179 Seiten
Ein Buch mit Programmen für die ganze Familie ■ DATAVE - Eine Dateiverwaltung • mathematische Funktionen • Konjugation und Deklination in Latein • Regressionsanalyse • Bundesligatabelle. Teilweise Vorkenntnisse erforderlich.
Best.-Nr. MT 766, ISBN 3-89090-071-2 (sFr. 23,-/0S 193,40)
DM 24,80
Die angegebenen Preise sind Ladenpreise.
C64 Fischertechnik.
Messen, Steuern, Regeln
Dezember 1985, ca. 200 Seiten
Dieses Buch bietet einen ausführlichen Programmierkurs für die Entwicklung von Steuerungssoftware mit dem Fischer Computing Baukasten. Mit vielen Anwendungs-
Die Floppy 1541 April 1985, 434 Seiten
Für alle Programmierer, die mehr über ihre VC 1541-Floppystation erfahren wollen. Der Vorgang des Formatierens • das Schreiben von Files auf Diskette • die Funktionsweise von schnellen Kopier- und Ladeprogrammen.

W. Kassera/F. Kassera
C64 - Programmieren in Maschinensprache
August 1985, 327 Seiten inki.Diskette
In diesem Buch finden Sie über 100 Beispiele zur Assembler-Programmierung mit viel Kommentar und Hintergrundinformationen: Schreiben von Maschinenprogrammen ■ Rechnen und Texten mit vorhandenen Routinen ■ Bedienung von Drucker und Floppy.
Profihandbuch
Das C64-Profihandbuch
Juli 1985, 410 Seiten
Ein Buch, das alle wichtigen Informationen für professionelle Anwendungen mit dem C64 enthält. Mit allgemeinen Algorithmen, die auch auf andere Rechner übertragbar sind, und vielen Utilities, getrennt nach BASIC- und Maschinenprogrammen. Mit erweiterten PEEK- und POKE-Funktionen.
Markt &Technik-Fachbiicher erhalten Sie bei Ihrem Buchhändler.
Fragen Sie dort nach unserem Gesamtkatalog mit über 200 neuen Computerbüchern.
DM52
Bestellkarten bitte an Ihren Buchhändler oder an einen unserer Depot-Händler. Adressenverzeichnis am Ende des Heftes. Beim Markt&Technik Verlag eingehende Bestellungen werden von den Depot-Händlern ausgeliefert.
Markt&TeChnik Veriag AG, Hans-Hnsel-Straße2,8013HaarbelMünchen Schweiz: Markt&Technik Vertriebs AG, Kotterstrasse 3, CH-6300 Zug, ® 0 42/4156 56
Österreich: Rudotf Lechner & Sohn, Heizwerkstra&e 10, A-1232 Wien, ® 02 22/67 75 26
Tabellen
C64
w	)rt	CHR$-	Eichen	Bildschirmcode			Tastencode	
		Groß/	Klein/			ASCII-		
dez	hex	Grafik	Groß	dez	hex	Code	dez	hex
197	C5	-	E	69	45			
198	C6		F	70	46			
199	C7	i	6	71	47			
200	C8	i	H	72	48			
201	C9		I	73	49			
202	CA		J	74	4A			
203	CB		K	75	4B			
204	CC	L	L	76	4C			
205	CD		M	77	4D			
206	CE		N	78	4E			
207	CF	r	0	79	4F			
208	D0	i	P	80	50			
209	Dl	•	Q	81	51			
210	D2		R	82	52			
211	D3		§	83	53			
212	D4	!	T	84	54			
213	D5		U	85	55			
214	D6		V	86	56			
215	D7		W	87	57			
216	DB			88	58			
217	D9	|	Y	89	59			
218	DA	*	Z	90	5A			
219	DB	4	4	91	5B			
220	DC			92	5C			
221		i	I	93	5D			
222	DE			94	5E			
223	DF	^		95	5F			
224	E0			96	60			
225	El	i	I	97	61			
226		■	w	98	62			
227	E3			99	63			
228	E4			100	64			
229	E5	i		101	65			
230	E6			102	66			
231	^	i	I	103	67			
232	E8			104	68			
233	E9	r		105	69			
234	EA	I	I	106	6A			
235	EB	h	F	107	6B			
236				108	6C			
237	ED	L	L.	109	6D			
238	EE	~l	“1	110	6E			
239	EF			111	6F			
240	F0	r	r	112	70			
241	FI			113	71			
242	F2			114	72			
243	F3	H	H	115	73			
244	F4	I	I	116	74			
245	F5	I	I	117	75			
246	FE	I	i	118	76			
247	F7			119	77			
248	F8	mm		120	78			
249	F9	MM		121	79			
250	FA	J	P'	122	7A			
251	ra		■	123	7B			
252	FC	■	M	124	7C			
253	FD	J	_J	125	7D			
254	FE	■		126	7E			
255	FF	fr		94	5E			
Tabelle 1. Die Codes desC64 (Schluß)								
Befehlsübersicht - Zusammenfassung
Kennen Sie die Programme Hypra-Ass, Reassembler und SMON? Wenn ja, dann wird Ihnen die Befehlsübersicht bei der Arbeit mit diesen Programmen sehr hilfreich sein.
Selbst für den eingefleischten Profi ist es fast unmöglich alle Befehle von Hypra-Ass, Reassembler und SMON zujeder Zeit parat zu haben. Um aber diese Programme optimal zu nutzen, ist die Kenntnis aller Befehle und deren Wirkungsweise sehr wichtig. Die nun folgende Befehlsübersicht soll Ihnen das ewige Nachschlagen ersparen. Natürlich kann es sich bei einer Übersicht nicht um eine ausführliche Anleitung handeln. Bei Verständnisschwierigkeiten finden Sie nähere Informationen an den entsprechenden Stellen in den Artikeln.	(ak)
Quickreferenz Reassembler	
P adresse	Einsprungspunkt durch Label markieren.
T adresse, adresse	Tabelle definieren.
E (byte)	Startet den Reassembler. Die einzelnen Bits des Bytes haben folgende Bedeutung:
Bit 0 gesetzt	Alle Zeropage-Adressen durch ein Label mit drei Buchstaben markieren.
Bit 1 gesetzt	Nach RTS, RTI, BRK, JMP Kommentarzeile einfügen.
Bit 2 gesetzt	Bei unmittelbarer Adressierung ASCII-Zeichen ausgeben.
Bit 3 gesetzt	Zwischen jede zweite Tabellenzeile Kommentarzeile einfügen.
Bit 4 gesetzt	Der ASCII-Ausdruck wird bei Tabellen unterdrückt.
Bit 5 gesetzt	Externe- und Tabellenlabel kennzeichnen.
Bit 6 gesetzt	Nach Tabellen suchen.
Bit 7 gesetzt	Speicherbereiche unter dem RAM reassemblieren.
Quickreferen:	z Hypra-Ass
Editorbefehle von Hypra-Ass	
/A 100, 10	Automatische Zeilennumerierung. (Startzeile, Schrittweite)
/0	RENEW eines Quelltextes.
/D 100-200	Löschen von Zeilen und Zeilenbereichen.
/E 100-200	Listen von Zeilen und Zeilenbereichen.
TO,13;T1,24;T2,0;T3,10 Setzen von Tabulatoren. TO = Tabulator für Assemblerbefehle. T1 = Tabulator für den Kommentar. T2 = Anzahl Blanks am Anfang einer Ausgabezeile. T3 = Tabulator für Symboltabelle.	
/X	Verlassen des Assemblers.
/P1,100,200	Setzen eines Arbeitsbereichs (Page).
/ziffer (n)	Formatiertes Listen der Page.
/N1,100,10	Neu durchnumerieren einer Page mit Startnummer und Schrittweite.
184
C64
Tabellen
Quickreferenz Hypra-Ass Editorbefehle von Hypra-Ass /F1,"string "	Suchen einer Zeichenkette in einer Page. /R1, "string1", "string2 " String 2 wird innerhalb einer Page durch		WO 1234,label .TX "text" .AP "file" .OB "file,p,w"	Einfügen von Adressen in den Quelltext. Einfügen von Textblöcken in den Quelltext. Verketten von Quelltexten. Senden des Objektcodes zur Floppy.
/U 9000 /B /S"name";/L"name /G9 /1 /K /@ /CH0 /CR0 /’ /!!	ötring i erseizi. Setzen des Quelltextstartes. Anzeige der aktuellen Speicherkonfiguration. " ;/V " name " ;/M " name " Kurzform der Befehle SAVE, LOAD, VERIFY, MERGE. Geräteadresse des Floppy-Laufwerks auf 9 umstellen. Lesen des Inhaltsverzeichnisses. Lesen des Fehlerkanals. Übermittlung von Diskettenbefehlen. Setzen der Hintergrundfarbe. Setzen der Rahmenfarbe. Ausgabe der Symboltabelle (unsortiert). Ausgabe der Symboltabelle (sortiert).	.EN	Schließen des Objektfiles. .ON ausdruck,sprung Bedingter Sprung, wenn Ausdruck wahr. .GO sprung	Unbedingter Sprung. .IF ausdruck	Fortführung der Assemblierung bei .EL, falls Ausdruck falsch. Ansonsten hinter .IF bis zu .EL oder .EI. .EL	ELSE Alternative zu den Zeilen, die hinter .IF stehen. .EI	Ende der IF-Konstruktion. .CO var1,var2	Übergabe von Labeln und Quelltext an nachge- ladene Teile. .MA makro (par1,par2) Makrodefinitionszeile. .RT	Ende der Makrodefinition. ...makro(par1,par2) Makroaufruf.	
Pseudo-Opcodes von Hypra-Ass		.LI lfn,dn,ba	Senden von formatierten Listings (entspricht
.BA adresse	Definiert Startadresse des Maschinen-		OPEN-Befehl).
	programms.	.SY lfn,dn,ba	Senden der formatierten Symboltabelle.
.EQ label = wert	Weist einem Label einen Wert zu.	.ST	Beendet die Assemblierung.
.GL label = wert	Weist einem globalen Label einen Wert zu.	.DP tO,t1,t2,t3	Setzt die Tabulatoren aus dem Quelltext
.BY 1,2,"a"	Einfügen von Byte-Werten in den Quelltext.		heraus.
Quickreferenz SMON. Die Klammern dürfen nicht mit eingegeben werden. Die Werte in den Klammern			
	können, aber müssen nicht eingegeben werden.		
A4000	Zeilenassembler Startadresse = $4000.	X	Monitor verlassen.
B 4000 4200	Erzeugt Basic-DATA-Zeilen im Bereich $4000	# 49152	Dezimal umrechnen
	bis $41FF	$ 002B	Vierstellige Hex-Zahl umrechnen.
C 4010 4200 4013		% 01100100	Achtstellige Binärzahl umrechnen.
4000 4200	Verschieben eines Programmes mit Adreß-	7 0344 + 5234	Addition oder Subtraktion zweier vierstelliger
	umrechnung. Entspricht W- und V-Befehl.		Hex-Zahlen.
D 4000 (4100)	Disassembliert den Bereich von $4000 bis	= 4000 5000	Vergleicht den Speicherinhalt von $4000 bis
	$4100		$5000.
F	findet Zeichenketten (F), absolute Adressen	Z	Ruft den Diskettenmonitor auf (falls implemen-
	(FA), relative Sprünge (FR), Tabellen (FT),		tiert). Dieser verfügt über folgende Befehle
	Zeropage-Adressen (FZ) und lmmediate-	R(12 01)	Liest Track $12 Sektor $01. Fehlt die Angabe
	Befehle (Fl).		hinter »R«, wird der logisch nächste Sektor
GO 4000	Startet Maschinenprogramm (ab $4000)		gelesen.
lO 1	Ein-/Ausgabegerät auf Datasette umstellen	W (12 01)	Schreibt Track $12 Sektor $01 auf Diskette.
K AO0O (A100)	lm angegebenen Bereich nach ASCII-Zeichen		Fehlt die Angabe hinter »W«, werden die letz-
	suchen.		ten Angaben von »R« benutzt.
L"name" (4000)	Laden eines Programmes an die richtige (oder	M	Zeigt den Pufferinhalt als Hex-Dump.
	angegebene) Adresse	X	Rücksprung zum Monitor.
M 4000 (4100)	Gibt den Inhalt des angegebenen Speicherbe-	F	Weitere Diskettenbefehle initialisieren (falls
	reichs als Hex-Byte und ASCII-Zeichen aus.		implementiert). Sind die Befehle initialisiert,
0 4000 4100 12	Füllt den angegebenen Bereich mit $12.		stehen folgende Befehle zur Verfügung.
PO 5	Setzt Drucker-Geräteadresse auf 5	M (07)	Memory-Dump (Floppy-RAM/ROM) ausgeben.
R	Registerinhalte anzeigen	V 6000 0400	Verschiebt einen 256-Byte-Block von $6000
S"name" 4000 4500			ins Floppy-RAM nach $400.
	Speichert ein Programm von $4000 bis	@	Normale Diskettenbefehle senden
	$4FFF.	X	Zurück in normalen Diskettenmonitor.
TW (4000)	Einzelschrittmodus. Mit »J« können Unterpro-	Ist die Erweiterung »Neues vom SMON« implementiert, stehen	
	gramme in Echtzeit ausgeführt werden.	folgende Befehle zur Verfügung:	
TB 4010 (05)	Breakpoint setzen (nach dem 5. Durchlauf)	Z 4000 (4100)	Gibt den Speicherinhalt von $4000 bis $40FF
TQ 4000	Schnellschrittmodus. Springt beim Erreichen		binär aus (ein Byte pro Zeile).
	eines Breakpoints in die Registeranzeige.	H 4000 (4100)	Gibt den Speicherbereich von $4000 bis
TS 4000 4020	Arbeitet ein Programm ab $4000 in Echtzeit		$40FF binär aus (drei Byte pro Zeile).
	ab und springt beim Erreichen von $4020 in	N 4000 (4100)	Gibt den Speicherinhalt von $4000 bis $40FF
	die Registeranzeige.		im Bildschirmcode aus (32 Zeichen pro Zeile).
V 6000 6200 4000 4100 4200		U 4000 (4100)	Wie »N« aber 40 Zeichen pro Zeile. Änderun-
	Ändert alle absoluten Adressen $4000 bis		gen sind nicht möglich.
	$41FF, die sich auf den Bereich $6000 bis	E 4000 (4100)	Füllt den Speicherbereich von $4000 bis
	$6200 beziehen, auf den neuen Bereich		$40FF mit $00.
	$4000.	Y 40	Verschiebt den SMON nach $4000.
W 4000 4300 5000Verschiebt den Speicherinhalt von $4000 bis		Q 2000	Kopiert den Zeichensatz nach $2000.
	$42FF nach $5000.	J	Bringt letzten Ausgabebefehl zurück.
185
H. Ponnath
C 64: Wunderland der Grafik
Juli 1985, 232 Seiten inkl. Beispieldiskette
Wenn sie nicht gerade von der allereinfachsten Art sein soll, dann setzt Grafikprogrammierung auf dem C64 einige Kenntnisse des Systems voraus: man bewegt sich meist auf der Ebene der Maschinenprogrammierung. Aber keine Angst! Der Autor legt beim Leser ein solides Fundament an Wissen und
er tut dies auch noch auf so unterhalt-
same Art, daß Sie bestens gerüstet sind, um so interessante Aufgaben wie die Programmierung hochauflösender zwei- und dreidimensionaler Grafiken
anzugehen. Mit Sprites zu jonglieren ist für Sie bald kein Problem mehr, aber
auch das vertrackte Verdeckungsproblem bei dreidimensionaler Grafik
kriegen Sie jetzt endlich in den Griff.
Best.-Nr. MT 756 ISBN 3-89090-130-1
DM 49,-
W. Kassera/F. Kassera
C 64 Programmieren in Maschinensprache August 1985, 327 Seiten inkl. Beispieldiskette
Die Autoren zeigen in diesem Buch, daß jeder die Grenzen des eingebauten BASIC des C64 sprengen kann. Der Aufschwung im Programmieren stellt sich ein, wenn Sie effektiv die betriebs-system -internen ROM-Routinen nutzen können. Dazu aber müssen Sie diese Routinen kennen, müssen über ihre Funktionsweise und ihrZusammen-spiel informiert sein. Und Sie müssen die Maschinensprache Ihres C64 beherrschen. Beides ermöglicht Ihnen dieses Buch.
Best.-Nr. MT 830 ISBN 3-89090-168-9
DM 52,-
Bestellkarten bitte an Ihren Buchhändler oder an eine unserer Depotbuchhandlungen.
Markt&Technik BUCHVERLAG
Hans-Pinsel-Straße 2, 8013 Haar
Depot-Händler
Tragen Sie Ihre Buchbestellung auf eine Postkarte ein und schicken diese an einen DepothäncHer in Ihrer Nähe oder an Ihren Buchhändter.
Buchhandlung Herder, Kurfürstendamm 69
1OOO Berlin 15, Tel. (030) 883 5002, BTX *921782#
Computare Fachbuchhandlung, Keithstraße 18
1000 Berlin 30, Tel. (0 30) 2 13 90 21
Thalia Buchhaus, Große Bleichen 19
2000 Hamburg 36, Tel. (0 40) 3 00 50 50
Boysen + Maasch, Hermannstraße 31
2000 Hamburg 1, Tel. (040) 30050515
Electro-Data, Wilhelm-Heidsiek-Straße 1 2190Cuxhaven,Tel. (047 21) 512 88 Buchhandlung Muehlau, Holtenauer Straße 116 2300 Kiel, Tel. (04 31) 8 50 8 5
ECL, Norderstraße 94-96
2390 Flensburg, Tel. (04 61) 2 81 81
Buchhandlung Weiland, Königstraße 79
2400 Lübeck, Tel. (04 51) 7 40 06-09
Buchhandlung Storm, Langenstraße 10
2800 Bremen 1, Tel. (04 21) 3215 23
Buchhandlung Lohse-Eissing, Marktstraße 38 2940Wilhelmshaven, Tel. (04421) 41687 Buchhandlung Schmorl u. v. Seefeld, Bahnhofstraße 13 3000 Hannover 1, Tel. (0511) 32 76 51 Buchhandlung Graff, Neue Straße 23 3300 Braunschweig, Tel. (05 31) 492 71 Deuerlich'sche Buchhandlung, Weender Straße 33 3400Gottingen, Tel. (05 51) 5 68 68 Buchhandlung an der Hochschule, Holländische Straße 22 3500 Kassel, Tel. (05 61) 8 3807 Stern Verlag, Friedrichstraße 24-26 4000 Düsseldorf, Tel. (02 11) 37 3033 Buchhandlung Baedeker, Kettwiger Straße 33-35 4300 Essen 1, Tel. (02 01) 22 13 81 Regensberg'sche Buchhandlung, Alter Steinweg 1 4400 Münster, Tel. (02 51) 40541-5 Buchhandlung Acker, Johannisstraße 51 4500 Osnabrück, Tel. (05 41) 2 84 88 Buchhandlung Lensing, Westenhellweg 86-88 4600 Dortmund, Tel. (02 31) 1 69 80 Buchhandlung Brockmeyer, Querenburger Höhe 281/Unicenter 4630 Bochum, Tel. (02 34) 7013 60 Buchhandlung Meier + Weber, Warburger Straße 98 4790 Paderborn, Tel. (0 52 51) 6 31 72 Buchhandlung Phönix GmbH, Oberntorwall 25 4800 Bielefeld 1, Tel. (0521) 69071 Buchhandlung Gonski, Neumarkt 24 5000Koln 1, Tel. (02 21) 2105 28 Mayer'sche Buchhandlung, Ursulinerstraße 17-19 5100 Aachen, Tel. (02 41) 481 42 Buchhandlung Behrendt, Am Hof 5a 5300 Bonn 1, Tel. (02 28) 658021 Buchhandlung Cusanus, Schloßstraße 12 5400 Koblenz, Tel. (02 61) 362 39
Akad. Buchhandlung Interbook, Fleischstraße 61-65
5500 Trier, Tel. (06 51) 4 35 96
Buchhandlung W. Finke, Kipdorf 32
5600 Wuppertal 1, Tel. (0202) 4542 20
Buchhandlung Balogh, Sandstraße 1
5900 Siegen, Tel. (02 71) 5 52 98-9
Buchhandlung Naacher, Steinweg 3
6000 Frankfurt 1, Tel. (0 69) 29 80 50
Buchhandlung Wellnitz, Lautenschlägerstraße 4
6100 Darmstadt, Tel. (0 61 51) 7 65 48
Buchhandlung Feller + Gecks, Friedrichstraße 31
6200 Wiesbaden, Tel. (0 61 21) 30 49 11
Ferber'sche UNI-Buchhandlung, Seltersweg 83
6300 Gießen, Tel. (06 41) 1 2001
Sozialwissenschaftliche Fachbuchhandlung, Friedrichstraße 24
6400 Fulda, Tel. (06 61) 7 50 77
Gutenberg Buchhandlung, Große Bleiche 29
6500 Mainz, Tel. (0 61 31) 3 7011
Buchhandlung Bock + Seip, Futterstraße 2
6600Saarbrücken, Tel. (06 81) 3 06 77
Buchhandlung Wilhelm Hofmann, Bismarckstraße 98
6700 Ludwigshafen, Tel. (06 21) 51 60 01
Buchhandlung Loeffler, B 1,5
6800 Mannheim 1, Tel. (06 21) 2 8912
Buchhandlung Stehn, Bahnhofstraße 13
7000 Stuttgart 50, Tel. (07 11) 56 14 76
Buchhandlung am Markt, Kramstraße 6
7100 Heilbronn, Tel. (0 71 31) 68682
PCB Mlcro-Computer, Oskar-Kalbfell-Platz 8
7410 Reutlingen, Tel. (0 71 21) 270443
UNI Buchhandlung Kellner + Moessner, Kaiserstraße 18
7500 Karlsruhe, Tel. (07 21) 69 14 36
Buchhandlung Roth, Hauptstraße 45
7600 Offenburg, Tel. (07 81) 2 20 97
Rombach Center, Bertholdstraße 10
7800 Freiburg, Tel. (0761) 49091
Fachbuchhandlung Hofmann, Hirschstraße 4
7900 Ulm, Tel. (07 31) 6 09 49
Schauties Elektronik, Bachstraße 52
7980 Ravensburg, Tel. (07 51) 2 61 38
Buchhandlung Hugendubel, Marienplatz
8000 München 2, Tel. (0 89) 23 89-1
Computerbücher am Obelisk, Barerstraße 32-34
8000 München 2, Tel. (089) 282383
Pale's Computerbücher, Schillerstraße 17
8000 München 2, Tel. (089) 55 52 29
UnIversftätsbuchhandlung Lachner, Theresienstraße 43
8000 München 2, Tel. (089) 52 1340
Buchhandlung Schönhuber, Theresienstraße 6
8070 Ingolstadt, Tel. (0841) 3 31 46/47
Computerstudk> Gertrud Friedrich, Ludwigstraße 3
8220 Traunstein, Tel. (08 61) 1 47 67
Buchhandlung Pustet, Kl. Exerzierplatz 4
8390 Passau, Tel. (08 51) 5 69 45
Buchhandlung Pustet, Gesandtenstraße 6
8400 Regensburg, Tel. (09 41)5 30 61
Buchhandlung Dr. Büttner, Adlerstraße 10-12
SSOO Nürnberg, Tel. (09 11) 2323 18
STS Computer Vertrieb, Werner-Siemens-Straße 19
8580 Bayreuth, Tel. (09 21) 6 23 20
Computer-Center-Burger, Leimitzer Straße 11-13
8670 Hof, Tel. (09281) 40075
Sortiments- u. Bahnhofsbuchh. J. Strykowski, Bahnhofplatz 4
8700Würzburg, Tel. (09 31) 54389
Buchhandlung Pustet, Grottenau 4
8900 Augsburg, Tel. (08 21) 3 54 37
Kemptener Fachsortiment, Salzstraße 30
8960 Kempten, Tel. (08 31) 1 4413
Belgien:
Eicher Micro & Personal Computer, Hünningen 56-58
B-4780 St.Vhh, Tel. (080) 22 7393
Luxemburg:
Librairte Promocuiture, 14, rue Duchscher (PI. de Paris)
L-1011 Luxembourg-Gare, Tel. 4806 91, Telex 31 12
Schweiz:
Buchhandlung Meissner, Bahnhofstraße 41
5000 Aarau, Tel. (0 64) 24 71 51
Bücher Balmer, Neugasse 12
6300 Zug, Tel. (0 42) 21 41 41
Buchhandlung Enge, Bleicherweg 56
8002 Zürich, Tel. (01) 2 01 20 78
Buchhandlung Orell Füssli, Pelikanstraße 10
8022 Zürich, Tel. (01) 2 11 80 11
Freihofer AG, Wissenschaftliche Buchhandlung, Universitätsstr. 11
8033 Zürich, Tel. (01) 36342 82
Buchhandlung am Rößlitor, Webergasse 5
9001 St.Gallen, Tel. (0 71) 22 87 26
Markt&Technik
BUCHVERLAG
Impressum
Herausgeber: Carl-Franz von Quadt, Otmar Weber
Chefredakteur: Michael Scharfenberger
Leitender Redakteur: Albert Absmeier
Redaktion: Volker Everts, Achim Hübner, Georg Klinge (Koordination), Harald Meyer, Markus Ohnesorg, Thomas Röder, Boris Schneider, Arnd Wängler
Fremdautoren:
Ponnath, Müller, Lonczewski, Weineck, Möllmann, Mann, Zwartscholten, Meyer, Heister, Pasch, Sajonz, Mootz, Krätzig, Bauschke, Reiser, Bauer, Reetz, Rosen, Schramm, Sauer, Richters
Layout: Leo Eder (Ltg.)
Herstellung: Klaus Buck
Auslandsrepräsentation:
Schweiz: Markt & Technik Vertriebs AG, Kollerstr. 3, CH-6300 Zug, Tel. 042-41 56 56, Telex: 862 329
USA:	M&T Publishing lnc.; 2464 Embarcadero
Way, Palo Alto, CA 94303
Manuskripteinsendungen: Manuskripte und Programmlistings werden gerne von der Redaktion angenommen. Sie müssen frei sein von Rechten Dritter. Sollten sie auch an anderer Stelle zur Veröffentlichung oder gewerblichen Nutzung angeboten werden, so muß dies angegeben werden. Mit der Einsendung von Manuskripten und Listings gibt der Verfasser die Zustimmung zum Abdruck in von der Markt & Technik Verlag AG herausgegebenen Publikationen und zur Vervielfältigung der Programmlistings auf Datenträger. Mit der Einsendung von Bauanleitungen gibt der Einsender die Zustimmung zum Abdruck in von Markt & Technik Verlag AG verlegten Publikationen und dazu, daß Markt & Technik Verlag AG Geräte und Bauteile nach der Bauanleitung herstellen läßt und vertreibt oder durch Dritte vertreiben läßt. Honorare nach Vereinbarung. Für unverlangt eingesandte Manuskripte und Listings wird keine Haftung übernommen.
Leitung Marketing Vertrieb: Hans Hörl (114)
Vertriebsleitung: Helmut Grünfeldt (189)
Anzeigenverwaltung und Disposition: Michaela Hörl
Veriagsleiter M&T-Buchverlag: Günther Frank
Druck: St. Otto Verlag GmbH, Laubanger 23, 8600 Bamberg
Preis: Das Einzelheft kostet DM 14,—
Vertrieb Handelsauflage: Inland (Groß-, Einzel- und Bahnhofsbuchhandel) sowie Österreich und Schweiz: Pegasus Buch- und Zeitschriften-Vertriebs GmbH, Hauptstätter Straße 96, 7000 Stuttgart 1, Telefon (0711)64830
Urheberrecht: Alle in diesem Heft erschienenen Beiträge sind urheberrechtlich geschützt. Alle Rechte, auch Übersetzungen, vorbehalten. Reproduktionen gleich welcher Art, ob Fötokopie, Mikrofilm oder Erfassung in Datenverarbeitungsanlagen, nur mit schriftlicher Genehmigung des Verlages. Anfragen sind an Michael Scharfenberger zu richten. Für Schaltungen, Bauanleitungen und Programme, die als Beispiele veröffentlicht werden, können wir weder Gewähr noch irgendwelche Haftung übernehmen. AusderVeröffentli-chung kann nicht geschlossen werden, daß die beschriebenen Lösungen oder verwendeten Bezeichnungen frei von gewerblichen Schutzrechten sind. Anfragen für Sonderdrucke sind an Peter Wagstyl (185) zu richten.
© 1985 Markt & Technik Verlag Aktiengesellschaft
Verantwortlich:
Für redaktionellen Teil: Michael Scharfenberger
Für Anzeigen: Brigitte Fiebig
Redaktions-Direktor: Michael M. Pauiy
Vorstand: Carl-Franz von Quadt, Otmar Weber
Anschrift für Verlag, Redaktion, Vertrieb, Anzeigenverwaltung und alle Verantwortlichen:
Markt & Technik Verlag Aktiengesellschaft, Hans-Pinsel-Straße 2, 8013 Haar bei München, Telefon (0 89) 4613-0, Telex 5-22 052
186
COMPUTER-ZEITSCHROTEN
VON PROFIS FUR PROFIS
COMPUTER PERSÖNLICH
PC MAGAZIN
Das aktuelle Fachmagazin
für Personal-Computer.
★	Wenn Sie jetzt den Schritt vom Heim-Computer zur professionellen Anwendung eines Personal Computers planen
★	Wenn Sie beruflich oder privat bereits einen Personal Computer benutzen
★	Wenn Sie regelmäßig Informationen über das aktuelle Produktangebot benötigen
★	Wenn Sie selbst programmieren
★	Wenn Sie professionelle Hard-und Softwaretests suchen
★	Wenn Sie Ihr eigenes System möglichst effizient einsetzen wollen
dann ist »Computer persönlich«, das aktuelle Fachmagazin für Personal Computer, genau Ihre Zeitschrift.
Die konsequente Ausrichtung auf professionelle Anwendungen bietet Ihnen alle wichtigen Informationen.
Von Profis für Profis!
»Computer persönlich« gibt es alle 14 Tage neu bei Ihrem Zeitschriftenhändler oder im Computer-Fachgeschäft.
Einzige Wochenzeitung für Personal Computer im IBM-Standard.
Sie beschäftigen sich beruflich oder privat mit dem Einsatz und der Anwendung von Personal Computern?
Sie sind an aktuellen, professionellen Informationen über IBM-PCs, kompatible Systeme und deren professionellen Einsatz interessiert?
Dann ist das PC Magazin genau auf Ihre persönlichen Bedürfnisse zugeschnitten.
Es wird von anerkannten und erfahrenen Fachjournalisten für professionelle Anwender und Fachleute geschrieben.
Es berichtet jede Woche ausschließlich über Computer im IBM-Standard und kompatible Systeme, über Hard- und Softwareneuheiten.
Es bringt ausführliche Testberichte und gibt Ihnen wichtige Informationen über Netzwerke sowie die PC/Host-Verbindung.
Nur diese Spezialisierung ermöglicht eine gezielte Berichterstattung und bietet genügend Raum, um auf Anwenderprobleme spezifisch eingehen zu können.
Von Profis für Profis!
Und das jeden Mittwoch neu bei Ihrem Zeitschriftenhändler oder im Computer-Fachgeschäft.
G U T S C H E I N
für ein kostenloses Probeexemplar
Senden Sie mir die neueste Ausgabe der von mir
□ COMPUTERPERSÖNLICH
Wenn mir Computer persönlich zusagt und ich es regelmäßig weiterbeziehen mochte, brauche ich nichts zu tun: Ich erhalle Computer persönlich dann regelmäßig alle 14 Tage per Post frei Haus geliefert und bezahle pro Jahr nur DM 98,— Zustellung und Postgebühren übernimmt der Verlag.
Vorname/Name
Sträße	PLZ/Ort
Datum 1 Unterschrift
angekreuzten Zeitschrift kostenlos als Probeexemplar:
□ PC-MAGAZIN
Wenn mir das PC-Magazin zusagt und ich es regelmäßig weiterbeziehen möchte, brauche ich nichts zu tun: Ich erhalte mein PC-Magazin dann regelmäßig jede Woche per Post frei Haus geliefert und bezahle pro Jahr nur DM 155,—. Zustellung und Postgebühren übernimmt der Verlag.
Mir ist bekannt, daß ich diese Bestellung innerhalb von 8 Tagen bei der Bestelladresse widerrufen kann und bestätige dies durch meine zweite Unterschrift. Zur Wahrung der Frist genügt die rechtzeitige Absendung des Widerrufs
co —--------------------------------------------- <o
Datum	2. Unterschrift	co
<o
Gutschein ausfüllen, ausschneiden, auf Postkarte kleben und einsenden an: Markt&Technik Verlag Aktiengesellschaft. Vertrieb. Postfach 1304. 8013 Haar
$ofl^ffi
T-Shirt »64’er« weiß, 4farbiger, kleiner Aufdruck
T-Shirt »64'er« hellblau, 4farbiger, kleiner Aufdruck
Jogging-Anzug »64'er« weiß,	>
1farbiger, großer Aufdruck *
Polohemd »64'er« hellblau, 4farbiger.
kleiner Aufdruck
w
Jogging-Anzug »64'er« graumeliert, 2farbiger, großer Aufdruck
T-Shirt «64'er« weiß, 4farbiger, großer Aufdruck
3. T-Shirt »64'er«
4farbiger, kleiner Aufdruck, 100% Baumwolle, weiter Schnitt. Jersey, Farbe: hellblau
Größe 4 = S
Größe 5 = M
Größe 6 = L
Größe 7 = XL
Best.-Nr. TS 124S
Best.-Nr. TS 125M
Best.-Nr. TS 126L
Best.-Nr. TS 127XL
DM 22,50
DM 22,50
DM 22,50
DM 22,50
6. Jogging-Anzug »64’er«
2farbiger, großer Aufdruck. 50% Baumwolle/
50% Acryl.
Farbe: graumeliert. Lieferzeit ca. drei Wochen
1. T-Shirt »64’er«
4farbiger, großer Aufdruck, 100% Baumwolle, weiter Schnitt, Jersey, Farbe: weiß
4. Polohemd »64’er«
4farbiger, kleinerAufdruck, 100% Baumwollein Pique-Qualität, Farbe: hellblau, Lieferzeit ca. drei Wochen
Größe4 = S	Best.-Nr.TS154S	DM98,90
Größe 5 = M	Best.-Nr.	TS	155M	DM 98.90
Größe 6 = L	Best.-Nr.	TS	156L	DM 98,90
Größe 7 = XL	Best.-Nr.	TS	157XL	DM 98,90
Größe 4 = S
Größe 5 = M
Größe 6 = L
Größe 7 = XL
Best.-Nr. TS 104S
Best.-Nr. TS 105M
Best.-Nr TS 106L
Best.-Nr. TS 107XL
DM 19,90
DM 19,90
DM 19,90
DM 19,90
Größe 4
Größe 5
Größe 6
Größe 7
= XL
Best.-Nr. TS 134S
Best.-Nr. TS 135M
Best.-Nr. TS 136L
Best.-Nr. TS 137XL
DM 49,90
DM 49,90
DM 49,90
DM 49,90
2. T-Shirt »64’er«
4farbiger. kleiner Aufdruck, 100% Baumwolle, weiter Schnitt, Jersey, Farbe: weiß
5. Jogging-Anzug »64’er«
1farbiger, großer Aufdruck, 50% Baumwolle/
50% Acryl. Farbe: weiß, Lieferzeit ca. drei Wochen
Größe 4 = S
Größe 5 = M
Größe 6 = L
Größe 7 = XL
Best.-Nr. TS 114S
Best.-Nr. TS 115M
Best.-Nr. TS 116L
Best.-Nr. TS 117XL
DM 19,90
DM 19,90
DM 19,90
DM 19,90
Größe 4 = S
Größe 5 = M
Größe 6 = L
Größe 7 = XL
Best.-Nr. TS 144S
Best -Nr. TS 145M
Best.-Nr. TS 146L
Best.-Nr. TS 147XL
DM 98,90
DM 98,90
DM 98,90
DM 98,90
Alle Artikel sind vom Umtausch ausgeschlossen!
MarktTechnik BUCHVERLAG
HansPinselStra6e 2, 8013 Haar bei München
Wußten
Sie schon...
£33
... daß Sie jetzt bisher erschienene 64'er-Ausgaben und Sonderhette nachbestellen können?
.. daß es jetzt eine schöne und praktische Sammelhox für Ihre wertvollen Hefte gibt?
Bitte benützen Sie für Ihre Bestellung nur diese Postscheck-Zahlkartel
Übrigens...
... die 64’er-Sammelbox ist nicht nur praktisch für den eigenen Gebrauch, sondern auch ein heißer Geschenktip zu vielen Anlässen!
o 05
0>
05 2
05
O
05 C
05 O
c ® Ä
T3 u O Q) O C
CO 0)
's
1
Für Mitteilungen an den Empfänger
Bestellung Leser-Service w,ch,i9: Lieferanschrift (Rückseite) nicht vergessen!			
Bestell-Nr	Anzahl	x Einzelpreis	= Gesamtpreis
Sammelbox -64er.		DM 14,-	
Sonderheft		DM l4.-	
Snnrfprhpft		DM 14-	
Ausg	1984		DM 6,50		
Ausg	1985		DM 6.50	
Zzal einm. Versandkostenoauschale (DM 3 1			0M 3-
			
Summe bitte auf Vorderseite übertragen		Gesamtsumme:	0M
o c o
co o °p o> o)
w ö
ZE
u
5 ==
co o °? 05 05
HösTvör^erK

ns?

£
£
5 Q
z Q		E o o o 12 <0 o Q.	c Q o c 5
c 5 o co £	co o ? co 05 T—		
			
			
			
			
	^ Si		u. CD m
	2<		X
			co V“ O CO
2
£
2
co o cp 05 05
05 od»
«oE
5 H CD
2 °ö P
... da0 Sie alle im Heft abgedruckten Listings sowie die Listings aus alien 64'er-Ausgaben auch aut Diskette bestellen können?
Die in diesem Sonderheft abgedruckten Listings gibt es auf Diskette:
Best.-Nr. L6 85 S8D
DM 29,90*
oder auf Kassette:
Best.-Nr. L6 85 S8K
DM 19,90*
' inkl. MwSt. Unverbindliche Preisempfehlung.
Verwenden Sie daftr nw die nebenstehende Postsc*eck-ZaNkerte
Bestellungen in der Schweiz richten Sie bitte an: Markt&Technik Vertriebs AG, Kollerstrasse 3, 6300 Zug
In Österreich: Buchhandlung Bücherzentrum Meidling. SchönbrunnerstraOe 261, 020 Wien
Microcomput-ique Erhard Schiller. Fasangafle 21.
1030 Wien
Alle anderen Markt&Technik-Produkte erhalten Sie bei Ihrem Buchhändler oder bei unseren Depot-Händlern. Adressenverzeichnis am Ende des Heftes.
(nicht zu Mitteilungen an den Empfänger benutzen) Gebühr für die Zahlkarte
CD
0)
Für Mitteilungen an den Empfänger
inkl. MwSt