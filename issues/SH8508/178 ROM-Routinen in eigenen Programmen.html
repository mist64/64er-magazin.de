<!DOCTYPE html>
<html lang="de">

<head>
    <title>ROM-Routinen in eigenen Programmen</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Heino Ponnath, hm">
    <meta name="64er.issue" content="Sonderheft 8/85">
    <meta name="64er.pages" content="178-180">
    <meta name="64er.toc_category" content="Tabellen">
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="rom">
</head>

<body>
    <article>
        <h1>ROM-Routinen in eigenen Programmen</h1>
        <p class="intro">Das Rad ist schon erfunden! Ähnlich verhält es sich mit verschiedenen Routinen, die ein Assembler-Programmierer immer wieder benötigt. Aber warum soll man sich die Arbeit des Programmierens machen, wenn das Betriebssystem viele ständig benötigte Routinen schon enthält und man nur noch zu wissen braucht, ab welcher Adresse sie stehen?</p>

        <p>Angenommen, Sie möchten in Assembler einige komplexe Dinge programmieren wie beispielsweise eine neue mathematische Funktion (wie wäre es mit dem Kotangens) und diese auf dem Bildschirm ausgeben. Das ist eine große Aufgabe, zu der zunächst einmal die Übernahme des Arguments in das Maschinenprogramm, dann einige Fließkomma-Rechenoperationen und schließlich die Ausgabe auf dem Bildschirm geschrieben werden müßten, wenn da nicht schon fast alles an verborgener Stelle als fertige Programm-Module im Computer vorhanden wäre!</p>

        <p>Sowohl im unteren (von $A000 bis $BFFF) als auch im oberen ROM-Bereich (von $E000 bis $FFFF) liegt die Firmware fest verschachtelt vor. Der untere ROM-Abschnitt wird manchmal auch Basic-Interpreter, der obere ROM-Bereich Betriebssystem genannt, wobei diese Einteilung aber den Kern der Sache nicht genau trifft, denn Interpreter, Editor und Betriebssystem führen ein gemischtes Dasein quer durch alle genannten ROM-Bereiche hindurch.</p>

        <p>Mindestens fünf Informationen braucht ein Assembler-Programmierer, wenn er das breite Programmangebot des ROMs nutzen möchte:</p>

        <ol>
            <li>Einsprungadresse</li>
            <li>Format der Eingabeparameter</li>
            <li>Adressen der Eingabeparameter</li>
            <li>Adressen der Ausgabeparameter</li>
            <li>Format der Ausgabeparameter</li>
        </ol>


        <p>Nicht alle Routinen, die man benutzen kann, erfordern alle fünf Informationen, manche weniger, einige auch mehr und schließlich gibt es noch Programmroutinen, die noch den Aufruf einer oder sogar mehrerer anderer Routinen nötig machen.</p>

        <p>In der beigefügten Tabelle sind - nach Anwendungen sortiert - die wichtigsten Firmware-Möglichkeiten mit den erforderlichen Ein- und Ausgabeparametern aufgeführt. Das sind natürlich beileibenichtalle. Die Auswahl erfolgte subjektiv! Es sind einfach diejenigen, die mir bislang am häufigsten untergekommen sind. Außerdem wurde auf die Kernel-Routinen verzichtet: Man findet diese sehr gut dokumentiert bereits in einer Reihe von Büchern und im Assembler-Kurs.</p>

        <p>Die Tabelle nennt den Label-Namen, die Einsprungadresse und gibt eine Kurzbeschreibung der Funktion. Das Ein- und auch das Ausgabeformat ist ebenso angegeben wie auch die Adressen, an denen diese Parameter übergeben werden. Die verwendeten Bezeichnungen halten sich eng an die im Assembler-Kurs kennengelernten. Sie sind allgemein üblich:</p>

        <p>TODO TABLE</p>

        <p>FAC Fließkomma-Akku 1<br>
            ARG Fließkomma-Akku 2<br>
            A Akkumulator<br>
            X,Y X-, Y-Register<br>
            A/Y 2-Byte-Angabe im Format LSB/MSB im Akku/Y-Register<br>
            FLPT Fließkommazahl im Normalformat<br>
            MFLPT gepacktes Fließkommaformat</p>

        <p>Damit das alles nicht so trocken abläuft, soll noch ein kleines Beispiel vorgestellt werden! Die oben schon erwähnte Kotangens-Funktion wird in einem Maschinenprogramm erzeugt, das durch USR anzuspringen ist. In Bild 1 finden Sie ein Flußdiagramm zu dem Programm, welches hier als Hypra-Ass-Listing abgebildet ist (Listing 1). Ein kurzes Testprogramm liefert Listing 2.</p>

        <p>Der Einsprung mittels USR bietet den Vorteil, daß der Übergabewert gleich im FLPT-Fbrmat im FAC »landet«. Es ist aber sinnvoll, den Übergabeparameter mittels der MOVMF-Routine zu »retten«, weil durch die Kosinus-Funktion der FAC verändert wird. Wenn auch das Ergebnis der Kosinus-Funktion mittels MOVMF beiseite gelegt wurde, holen wir durch MOVFM den Anfangswert wieder in den FAC und bilden mittels SIN den Sinus davon. Schließlich teilen wir den im Speicher stehenden Kosinuswert durch den im FAC befindlichen Sinuswert (unter Verwendung von FDIV). Das Ergebnis ist der Kotangens:</p>

        <p>COTX = (COSX/SIN X)</p>

        <p>Dieser Wert befindet sich nun im FAC und wird mit dem RTS an das Basic-Programm zurückgeliefert. Im Testprogramm weisen wir ihm dann die Variable E zu.</p>

        <p>Dieses kurze Beispiel soll Ihnen den Mund wässrig machen. Sehr viel detaillierter werden die ROM-Routinen im Kurs »Von Basic zu Assembler« im 64’er behandelt werden.</p>

        <address class="author">(Heino Ponnath/hm)</address>

        <p class="source">Literatur:<br>
            1. Kassera/Kassera, Programmieren in Maschinensprache, München 1985: Markt &amp; Technik Verlag, MT 830<br>
            2. West, C64 Computerhandbuch, München 1984, Te-wi<br>
            3. Babel/Krause/Dripke, Das Interface Age Systemhandbuch zum C 64, München 1983: Interface Age Verlag<br>
            4. Ponnath, C 64 Wunderland der Grafik, München 1985: Markt &amp; Technik Verlag MT 756.</p>

        <p>TODO TABLES</p>
    </article>
</body>

</html>
