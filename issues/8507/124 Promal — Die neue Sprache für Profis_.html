<!DOCTYPE html>
<html lang="de">

<head>
    <title>Promal — Die neue Sprache für Profis?</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Boris Schneider, ev">
    <meta name="64er.issue" content="7/85">
    <meta name="64er.pages" content="124-125">
    <meta name="64er.head1" content="Software-Test">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="<b>Promal im Test<br>Die ideale Sprache für Profis?</b>">
    <meta name="64er.toc_category" content="Software-Test">
    <meta name="64er.index_title" content="Promal – die neue Sprache für Profis?">
    <meta name="64er.index_category" content="Software-Tests|Sprachen">
    <meta name="64er.id" content="promal">
</head>

<body>
    <article>
        <h1>Promal — Die neue Sprache für Profis?</h1>
        <p class="intro">Wir testeten eine brandneue Programmiersprache für den Commodore 64. Promal kommt direkt aus Amerika und ist schnell wie Forth, aber übersichtlich wie Pascal.</p>

        <p>Die Programmiersprachen für den Commodore 64 häufen sich, und so vergeht kaum ein Monat, an dem nicht irgendein Hersteller ein neues Produkt als »Die Sprache für den Commodore 64« anpreist. Meistens handelt es sich dann doch aber nur um mehr schlechte als rechte Implementationen altbekannter Sprachen, die vielleicht noch auf die Grafik- und Soundfähigkeiten des C 64 Rücksicht nehmen.</p>

        <p>Ein ganz neues Produkt ist dagegen die Sprache Promal, die erst letztes Jahr entwickelt wurde und nun als erstes in einer Version für den C 64 lauffähig vorliegt. Weitere Versionen für Apple- und IBM-Computer sind in Arbeit. Da Promal-Programme auch zwischen verschiedenen Computern austauschbar sind, solange nicht auf die Maschinenebene zugegriffen wird, dürfte daher bald ein breites Software-Angebot zur Verfügung stehen.</p>

        <h2>Was ist Promal?</h2>

        <p>Promal ist die Abkürzung für <strong>Pro</strong>grammers <strong>M</strong>icro <strong>A</strong>pplications <strong>L</strong>anguage und hat überhaupt nichts mit Comal zu tun. Promal bietet die Möglichkeit, strukturiert zu programmieren, ja erzwingt dieses ähnlich wie Pascal sogar, ist dabei aber gleichzeitig so schnell und maschinennah wie Forth.</p>

        <p>Promal besteht aus drei Teilen: Dem Executive, dem Editor und dem Compiler. Der Executive ist ähnlich einem Interpreter organisiert und enthält den Kern von Promal sowie die Input/Output-Routinen und die Befehle, die direkt ausgeführt werden können. Über den Executive tritt der Benutzer mit dem Promal-System in Verbindung. Editor und Compiler werden vom Executive aus aufgerufen. Eine Programmierung in Promal ist über den Executive nicht möglich, wohl aber lassen sich bereits compilierte Programme starten. Es können mehrere Programme gleichzeitig im Speicher stehen: Promal-Programme sind vollkommen relokatibel (im Speicher verschiebbar) und können so jederzeit zu den schon im Speicher stehenden Programmen hinzugeladen werden. Der Aufruf eines Programmes erfolgt einfach durch die Nennung seines Namens. Befindet sich das entsprechende Programm nicht im Speicher, wird es automatisch nachgeladen.</p>

        <p>Die Bedienung des Executive ist äußerst komfortabel: So sind zum Beispiel die Funktionstasten belegt, und es lassen sich schon einmal gemachte Befehls-Eingaben mittels Tastendruck zum Korrigieren wiederholen.</p>

        <h2>Komfortabler Editor</h2>

        <p>Soll nun ein neues Promal-Programm geschrieben werden, dann wird zunächst der Editor aufgerufen. Es handelt sich dabei schon fast um ein kleines Textsystem mit horizontalem Scrolling (80 Zeichen pro Zeile), schnellem vertikalem Scrolling in beide Richtungen, Funktionstastenbelegung, ausführlichem Befehlssatz und vielen anderen Details. Hat man eine Weile mit diesem schnellen und komfortabeln Editor gearbeitet, so ist man recht erstaunt, wenn man im Handbuch liest, daß er vollständig in Promal geschrieben wurde. Der Editor ist somit eines der besten Beispiele für die Leistungsfähigkeit von Promal.</p>

        <p>Ebenso in Promal geschrieben ist der Compiler. Es kann wahlweise auf Diskette oder im Speicher compiliert werden. Auch hier erstaunte die enorme Geschwindigkeit, zumindest solange keine Diskettenzugriffe notwendig sind.</p>

        <p>Wie sieht nun so ein Promal-Programm aus? Auf den ersten Blick glaubt man, es mit einer Mischung aus Pascal und Basic zu tun zu haben. Es gibt keinerlei Zeilennummern, aber Einrückungen. In jeder Zeile steht nur ein einziger Befehl. Zu Anfang eines jeden Promal-Programmes steht ein Deklarationsteil, in dem alle Variablen, Funktionen und Prozeduren (Unterprogramme) ähnlich wie in Pascal definiert werden müssen.</p>

        <p>Es gibt sehr viele veschiedene Kontrollstrukturen: Neben dem obligatorischen IF&hellip; ELSE (ohne THEN!) oder FOR (ohne NEXT) gibt es auch WHILE, REPEAT&hellip;UNTIL, und sogar ein CHOOSE, das in etwa dem ON&hellip;GOTO (Basic) oder dem CASE (Pascal) entspricht, aber noch flexibler ist.</p>

        <h2>Bitte einrücken!</h2>

        <p>Wer sich fragt, wo das NEXT oder das THEN hin verschwunden sind: Promal zwingt zu strukturiertem Programmieren, weil Einrückungen syntaktische Bedeutung haben! Eine IF..THEN..ELSE-Abfrage muß in Promal folgendermaßen programmiert werden:</p>

        <table class="plain">
            <tr><td colspan="2">IF &lt;Bedingung&gt;</td></tr>
            <tr><td style="size:4em"></td><td>befehl1</td></tr>
            <tr><td style="size:4em"></td><td>befehl2</td></tr>
            <tr><td style="size:4em"></td><td>&hellip;</td></tr>
            <tr><td style="size:4em"></td><td>befehlN</td></tr>
            <tr><td colspan="2">ELSE</td></tr>
            <tr><td style="size:4em"></td><td>befehl1</td></tr>
            <tr><td style="size:4em"></td><td>befehl2</td></tr>
            <tr><td style="size:4em"></td><td>&hellip;</td></tr>
            <tr><td style="size:4em"></td><td>befehlN</td></tr>
            <tr><td colspan="2">befehl1</td></tr>
            <tr><td colspan="2">befehl2</td></tr>
            <tr><td colspan="2">&hellip;</td></tr>
        </table>

        <p>Wichtig ist, daß die Befehlsgruppen, die bedingt ausgeführt werden sollen, um zwei Stellen eingerückt werden. Der Promal-Compiler nimmt an, daß die IF&hellip;ELSE-Anweisung zu Ende ist, wenn Befehle nicht mehr eingerückt sind.</p>

        <p>Dieses Prinzip gilt auch für alle anderen Kontrollstrukturen. Die aus Basic bekannten FOR-NEXT-Schleifen benötigen in Promal kein NEXT mehr, das Schleifenende wird am Fehlen der Einrückung erkannt. Promal kennt allerdings einen Befehl NEXT, der aber eine andere Bedeutung hat. Mit ihm kann an den Anfang der gerade bearbeiteten Schleife zurückgesprungen werden. Dies funktioniert nur bei REPEAT&hellip;UNTIL und WHILE, nicht bei FOR. Das genaue Gegenteil von NEXT ist BREAK. Mit diesem Befehl wird die gerade bearbeitete Kontrollstruktur ordnungsgemäß abgeschlossen und verlassen, es erfolgt sozusagen ein GOTO zur nächsten nicht eingerückten Zeile.</p>

        <p>Natürlich können Kontrollstrukturen auch beliebig ineinander geschachtelt werden, dann sind halt mehr Einrückungen notwendig.</p>

        <p>Promal kennt vier verschiedene Variablentypen: BYTE, INTeger, WORD und REAL. String-Variablen sind nicht vorgesehen, man muß sich, ähnlich wie in Forth, mit Adreßvariablen behelfen. Das bedeutet, man legt einen String als Bytefolge irgendwo im Speicher ab und weist die Anfangsadresse des Strings einer Variablen zu. Über diese Variable kann man dann im weiteren jederzeit auf den String zugreifen.</p>

        <p>Das mag auf den ersten Blick etwas umständlich erscheinen, ist aber in der Praxis sehr flexibel und schnell, insbesondere, da es von einigen Promal-Standardprozeduren unterstüzt wird.</p>

        <p>An Feldvariablen sind nur eindimensionale Arrays erlaubt. Doch damit läßt sich bereits eine ganze Menge anfangen. Arrays können nämlich an jedem vom Programmierer vorgesehenen Speicherplatz abgelegt werden. Beispielsweise kann man ein solches Array auf den Bildschirm-Speicherbereich legen. Durch einfache Zuweisung von Werten an Array-Elemente wird dann jedesmal die entsprechende Speicherstelle im Bildschirm angesprochen. Dabei ergibt sich neben einer besseren Übersichtlichkeit des Programmes auch noch ein Zeitgewinn.</p>

        <h2>Verbesserte Fließkomma-Arithmetik</h2>

        <p>Im Gegensatz zu vielen anderen Programmiersprachen für den C 64 wurde bei der Fließkomma-Arithmetik in Promal nicht auf die bereits im Basic-ROM vorhandenen Routinen zurückgegriffen. Promal verfügt über eine völlig neue Fließkomma-Arithmetik, die die des Commodore 64-Basic bei weitem übertrifft. REAL-Variablen haben 11 signifikante Stellen (9 bei Basic), dennoch erfolgen alle Berechnungen damit fast doppelt so schnell. Damit ist die reine Ausführungszeit der Rechenoperation gemeint. Da Promal-Programme immer compiliert werden, ist die tatsächliche Geschwindigkeit von Programmen noch um ein Vielfaches höher.</p>

        <p>Allerdings kennt Promal nur die vier Grundrechenarten und logische Operationen. Funktionen wie Sinus oder Logarithmus werden als Promal-Source-Code mitgeliefert. Nach der Compilation sind diese in Promal geschriebenen Routinen immer noch genauer und sogar ein wenig schneller als die Original-Commodore-ROM-Routinen, was wohl ein beeindruckender Beweis der Leistungsfähigkeit von Promal ist.</p>

        <p>Wer in einem Programm ohne REAL-Zahlen auskommt, kann die REAL-Arithmetik vollständig aus Promal entfernen und gewinnt so zusätzlich wertvollen Speicherplatz. Compilate (übersetzte Programme) können so einen Umfang von bis zu 35 KByte haben. Der Source-Code muß dann allerdings mit einigen Tricks geschrieben werden, da der garantiert nicht in den Speicher paßt. Der Compiler selbst umfaßt beispielsweise als Sorce-Code 2400 Zeilen, benötigt aber compiliert nur noch 13 KByte.</p>

        <p>Überzeugend ist auch das Konzept der Prozeduren und Funktionen. Pascal-Kenner wissen, daß Prozeduren das Gegenstück zu Unterprogrammen sind, und daß Funktionen ein spezieller Typ von Prozeduren sind, die Parameter an das Hauptprogramm zurückgeben. Wie in Pascal können Prozeduren und Funktionen lokale Variable haben, das sind Variable, die nur der Prozedur bekannt sind, und deswegen gleiche Namen wie völlig andere Variablen im Hauptprogramm haben dürfen, ohne daß Konflikte oder Fehler auftreten.</p>

        <p>In Promal gibt es noch eine Unterscheidung bei lokalen Variablen: Diese können bei Bedarf ihren Inhalt bis zum nächsten Aufruf der Prozedur behalten. Eine Prozedur kann also beispielsweise zählen, wie oft sie hintereinander aufgerufen wurde. Dies ist sehr wichtig, will man rekursive Funktionen programmieren. Rekursion bedeutet, daß eine Prozedur oder Funktion sich selbst aufruft und ist in Promal beliebig erlaubt. Allerdings ist die Rekursionstiefe auf zirka 40 Aufrufe beschränkt, sonst läuft der Prozessorstack über, und das System befindet sich in einem »undefinierten Zustand«, etwas weniger fein auch als »Absturz« bezeichnet.</p>

        <h2>Schnittstelle zur Maschinensprache</h2>

        <p>Obwohl Promal bereits unglaublich schnell ist, hat man trotzdem mehrere Schnittstellen zur Maschinensprache eingebaut, um eigene Maschinenroutinen oder solche aus dem Basic-ROM in Promal-Programme zu integrieren. Dabei ist sogar die Kontrolle über die Prozessorregister (A, X, Y und P) von Promal aus vorgesehen. Parameterübergabe kann über gemeinsam benutzte Speicherstellen, die Prozessorregister oder am aller einfachsten über den Prozessorstack erfolgen. Damit ist Promal fast genauso maschinennah wie Forth, aber dafür um einiges komfortabler.</p>

        <p>Die drei mitgelieferten Handbücher, wie üblich in Englisch, umfassen 250 DIN A4-Seiten und bieten eine umfassende Einführung in die Sprache. Da hier sehr viel mit Beispielen gearbeitet wird, fällt es leicht, sich in das Promal-Konzept einzuarbeiten.</p>

        <h2>Vorbildliche Dokumentation</h2>

        <p>Eines sei noch zur Erhältlichkeit von Promal gesagt: Es gibt drei verschiedene Promal-Versionen, die aber aufwärtskompatibel sind. Die Demo-Version umfaßt den kompletten Sprachschatz und unterscheidet sich von der End-User-Version nur dadurch, daß sie keine Druckerausgabe und kein Abspeichern von Programmen auf Diskette erlaubt. Sie ist also sozusagen nur zum »Reinschnuppern« gedacht. Dafür darf, ja soll sie sogar kopiert und an Freunde weitergegeben werden. Wer interessiert ist, kann sich dann die End-User-Version beim Hersteller kaufen und mit dem Programmieren voll loslegen. Dieses Konzept kann man anderen Anbietern von Software sicher nur zur Nachahmung empfehlen, da der Anwender die oftmals recht teuren Programme dann nicht mehr »auf Verdacht« kaufen muß, um erst hinterher enttäuscht festzustellen, daß das Programm nicht seinen Erwartungen entspricht. Für die Produzenten wirklich guter Software hätte dieses Verfahren ebenfalls nur Vorteile — der Bekanntheitsgrad erhöht sich, der Anwender kann sich ein Bild von der Qualität der Software machen.</p>

        <p>Doch wieder zurück zu Promal. Die geschriebenen und compilierten Programme benötigen immer noch den Promal-Executive-Teil, um lauffähig zu sein. Deswegen gibt es noch eine »Developer’s-Version«, die zusätzlich den Promal-Kern in die übersetzten Programme einbindet, so daß sie auch ohne Promal laufen können.</p>

        <p>Zum erstenmal gibt es mit Promal eine maschinennahe und dennoch einfache und komfortable Sprache für Mikrocomputer. Jedem, dem Forth zu unverständlich und Pascal zu langsam ist, kann Promal nur empfohlen werden, denn diese Sprache verbindet sozusagen diese zwei Programmierwelten miteinander.</p>

        <address class="author">(Boris Schneider/ev)</address>

        <p class="source">Info: Promal ist in den verschiedenen Versionen erhältlich bei Systems Management Associates, 3700 Computer Drive, PO.Box 20023, Raleigh, North Carolina N.C 27619, USA.</p>
    </article>
</body>

</html>
