<!DOCTYPE html>
<html lang="de">

<head>
    <title>HYPRA-ASS - Ein Assembler der Spitzenklasse</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Gerd Möllmann, Gerd Möllmann, ah, Gert Möllmann, ah">
    <meta name="64er.issue" content="7/85">
    <meta name="64er.pages" content="51,66-72">
    <!-- <meta name="64er.toc_category" content="XXX"> -->
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="XXX">
</head>

<body>
    <article>
        <h1>HYPRA-ASS - Ein Assembler der Spitzenklasse</h1>
        <p class="intro">Das war noch nie da. Ein Super-Assembler zum Abtippen. Mit Leistungsmerkmalen, die Sie sich schon immer gewünscht haben, übertrifft er jeden 100-Mark-Assembler.</p>

        <figure>
            <img src="51-1.png" alt="">
            <figcaption>Bild 1. Formatiertes Listing immer wieder benötigter Makros</figcaption>
        </figure>

        <p>HYPRA-ASS ist ein rein in Maschinensprache geschriebener 3-Pass-Makroassembler mit integriertem Editor für den C 64 mit Diskettenlaufwerk 1541. Er belegt etwa 6 KByte RAM-Speicher von $0801 bis $lFD7. HYPRA-ASS gehört, was Leistung und Schnelligkeit betrifft, zu einem der besten Assembler. Seine hervorstechendste Eigenschaft ist die Fähigkeit, um Befehlsfolgen, die in einem Programm immer wieder auftreten, einen Block beziehungsweise ein Makro zu legen. So definierte Befehlsfolgen können durch einen einfachen Befehl an jeder beliebigen Stelle des Programms aufgerufen werden. Diese Eigenschaft haben viele Assembler, aber nur wenige können lokale Labels beziehungsweise Sprungziele innerhalb eines Makros verarbeiten. Innerhalb eines Makros sind, wenn nicht besonders gekennzeichnet, alle Labels und Variablen lokal. Neben vielen Pseudo-Opcodes, mit denen sich zum Beispiel der Objektcode auf Diskette assemblieren läßt oder Quelltexte verketten lassen, kann auch bedingt assembliert werden. Formatierte Listings können an beliebige Geräte gesendet werden. Symboltabellen lassen sich sortiert und unsortiert ausgeben.</p>

        <p>Quelltexte werden bei HYPRA-ASS wie normale Basic-Programme erstellt. Nach der Eingabe von RETURN erscheint die soeben eingegebene Zeile formatiert auf dem Bildschirm. Die dabei benutzten Tabulatoren können durch einfache Befehle geändert werden. Um das Editieren von Quelltexten möglichst bequem zu machen, ist in HYPRA-ASS ein spezieller Editor integriert, der den normalen Basic-Editor um viele Funktionen erweitert. Neben der automatischen Zeilennumerierung können Zeilen und Zeilenbereiche formatiert gelistet werden. Auch das oft vermißte Suchen und Ersetzen, Find und Renumber sind eine Selbstverständlichkeit für diesen Editor.</p>

        <address class="author">(Gert Möllmann/ah)</address>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td><b>Label:</b></td>
                        <td>Sprungmarke</td>
                    </tr>
                    <tr>
                        <td><b>Bedingte Assemblierung:</b></td>
                        <td>Abhängig von einer Variablen können zum Beispiel Quelltextzeilen beim Assemblieren übersprungen werden. Bei unterschiedlichen Variablen erhält man folglich unterschiedlichen Objektcode.</td>
                    </tr>
                    <tr>
                        <td><b>Makro:</b></td>
                        <td>Befehlsfolgen, die im Quelltext häufiger benutzt werden. Das Makro wird in einer Definitionszeile mit einem Namen versehen, unter dem es im Quelltext beliebig oft aufgerufen werden kann. Trifft der Assembler auf einen so definierten Namen, so wird an diese Stelle die vorher definierte Folge von Befehlen assembliert.</td>
                    </tr>
                    <tr>
                        <td><b>n-Paß:</b></td>
                        <td>Für n steht eine Zahl, die die Anzahl der Assemblerläufe anzeigt.<br>Bei Assemblern, die Labels verarbeiten können, handelt es sich in der Regel um 2-Pass-Assembler. Im ersten Pass wird eine Syntaxprüfung durchgeführt und den Labels und Variablen ein numerischer Wert (Adresse) zugewiesen. (Symboltabelle wird angelegt). Im zweiten Pass wird dann der Objektcode erzeugt.</td>
                    </tr>
                    <tr>
                        <td><b>Objektcode:</b></td>
                        <td>Das vom Assembler erzeugte, lauffähige Programm</td>
                    </tr>
                    <tr>
                        <td><b>Quelltext:</b></td>
                        <td>Das mit dem Assembler erstellte Basic- oder Text-File</td>
                    </tr>
                    <tr>
                        <td><b>Symboltabelle:</b></td>
                        <td>Beim Assemblieren wird jedem Label und jeder Variable ein numerischer Wert zugewiesen. Die Symboltabelle enthält eine Liste aller im Programm vorkommenden Label und Variablen mit deren Wertzuweisungen.</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Bild 2. Definition der im Text auftretenden Fachbegriffe</figcaption>
        </figure>

        <aside>
            <h2>Lebenslauf:</h2>

            <p>Ich bin 28 Jahre alt. Nach dem Abitur im Jahre 1975 begann ich ein Mathematikstudium an der Ruhr Universität Bochum. Nun, nachdem ich den Grundwehrdienst abgeleistet habe, beabsichtige ich, in die Datenverarbeitung einzusteigen und eventuell ein Informatikstudium aufzunehmen. Weitere Pläne den C 64 betreffend liegen schon vor. So ist eine Textverarbeitung schon in Angriff genommen.</p>

            <p>Am Anfang der Entwicklung von HYPRA-ASS stand ein Editor/Assemblerpaar, das von mir Ende 1984 in Basic geschrieben wurde, um dem mangelhaften Basic des C 64 auf die Sprünge zu helfen. Doch schon bald erwies sich die Langsamkeit dieser Programme als so nervenzermürbend, daß für mich nur die Wahl bestand, entweder einen in Maschinensprache geschriebenen Assembler zu kaufen oder selbst einen zu schreiben.</p>

            <p>Da solche Assembler recht teuer sind, und weil es eine interessante Aufgabe ist, einen Assembler zu schreiben, habe ich mich für die zweite Alternative entschieden. So entstand mit Hilfe des Basic-Assemblers eine erste Version von HYPRA-ASS, die wiederum eine zweite Version assemblierte und so weiter.</p>

            <p>Die Entwicklung von HYPRA-ASS verlief also in einem »bootstrapping«-Verfahren, was außerdem noch den Vorteil hatte, daß eine Prüfung der Funktionstüchtigkeit des Programms schon zum großen Teil im Verfahren selbst stattfand.</p>

            <address class="author">(Gerd Möllmann)</address>
        </aside>

        <hr>

        <p class="intro">Machen Sie es wie die Profis. Schreiben Sie Programme in Maschinensprache. Dieser leistungsstarke Makro-Assembler macht es möglich.</p>

        <p>HYPRA-ASS ist ein rein in Maschinenesprache geschriebener Drei-Pass-Makroassembler mit integriertem Editor für den C 64 mit Floppy 1541. Er wird mit LOAD ”HYPRA-ASS”,8 geladen und durch RUN gestartet. Nach dem Start meldet sich HYPRA-ASS mit »break in 0« und »ready«. Alle Basic-Befehle sind nach dem Start noch zu verwenden, bis auf die Befehle LET und FOR, die Variable anlegen. Der Befehl RUN dient jetzt zum Starten der Assemblierung.</p>

        <h3>Der Quelltext</h3>

        <p>Der Quelltext wird vom HYPRA-ASS-Editor in Basic-Programmzeilen abgelegt. Soweit wie möglich werden unnötige Blanks dabei eleminiert. Für die einzelnen Quelltextzeilen gelten die folgenden Vereinbarungen:</p>

        <ol>
            <li>Bei der Eingabe einer Zeile wird hinter der Zeilennummer ein Minuszeichen eingegeben.</li>
            <li>Jede Zeile enthält höchstens einen Assemblerbefehl.</li>
            <li>Vor einem Assemblerbefehl darf in derselben Zeile höchstens ein Label stehen.</li>
            <li>Label beginnen direkt hinter dem Minuszeichen.</li>
            <li>Vor jedem Assemblerbefehl steht mindestens ein Blank.</li>
            <li>Label und Assemblerbefehl werden durch mindestens ein Blank voneinander getrennt.</li>
            <li>Ein Label darf nicht allein in einer Zeile stehen.</li>
            <li>Kommentar wird durch ein Semikolon vom Rest der Zeile getrennt.</li>
            <li>Reine Kommentarzeilen müssen als erstes Zeichen hinter dem Minuszeichen ein Semikolon haben.</li>
            <li>Pseudo-Ops (.ba, .eq&hellip;) können direkt hinter dem Minuszeichen beginnen.</li>
        </ol>


        <p>Beispiele:</p>

        <p>TODO</p>

        <p>100 -.ba$C000
            110 -initialisierung
            120 -; reine Kommentarzeile
            130 - Ida $14; Kommentar hinter einem Befehl
            140 -marke ldx$15; mit Label davor</p>

        <p>Zur bequemeren Eingabe und Bearbeitung des Quelltextes stellt HYPRA-ASS im Editor insgesamt 25 Befehle zur Verfügung (Bild 1).</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td>/a 100,10</td>
                        <td>Automatische Zeilennumerierung. Hier mit der Startnummer 100 und der Schrittweite 10. ~<br>Die automatische Zeilennumerierung wird ausgeschaltet, indem man direkt hinter dem ausgegebenen Minuszeichen RETURN eingibt.</td>
                    </tr>
                    <tr>
                        <td>/o</td>
                        <td>Re-New eines Quelltextes, der mit NEW gelöscht wurde, falls der Text nicht anderweitig zerstört wurde.</td>
                    </tr>
                    <tr>
                        <td>/d ; /d 100 ; /d -100 ; /d 100- ; /d 100 bis 200</td>
                        <td>Löschen von Zeilen und Zeilenbereichen. Auch für das Löschen einzelner Zeilen sollte man den /d- Befehl verwenden, da man das Minuszeichen hinter der Zeilennummer doch immer wieder vergißt.</td>
                    </tr>
                    <tr>
                        <td>/e ; /e 100 ; /e -100 ; /e 100- ; /e 100 bis 200</td>
                        <td>Formatiertes Listen von Zeilen und Zeilenbereichen.<br>Label, Assembler-Befehle werden gemäß den Tabulatoren übersichtlich untereinander geschrieben.</td>
                    </tr>
                    <tr>
                        <td>/tO,13 ; /t 1,24 ; /t2,0 ; /t3,10</td>
                        <td>setzt die Tabulatoren T0, T1, T2, T3<br>T0 = Tabulator für Assemblerbefehle<br>T1 = Tabulator für den Kommentar bei der formatierten Ausgabe<br>T2 = Tabulator für die Anzahl der Blanks, die amAn- fang einer Ausgabezeile ausgegeben werden<br>T3 = Tabulator für die Symboltabelle</td>
                    </tr>
                    <tr>
                        <td>/x<br></td>
                        <td>Verlassen des Assemblers. Beim Verlassen des Programms wird ein Reset durchgeführt.</td>
                    </tr>
                    <tr>
                        <td>/p 1,100,200</td>
                        <td>Setzen eines Arbeitsbereichs (Page). Hier Bereich 1 von Zeile 100 bis 200, beide einschließlich. Bis zu 30 solcher Arbeitsbereiche sind erlaubt. Die Parameter der Arbeitsbereiche werden im Kassettenpuffer abgelegt.</td>
                    </tr>
                    <tr>
                        <td>/ziffer(n)</td>
                        <td>Formatiertes Listen der Page.</td>
                    </tr>
                    <tr>
                        <td>/n 1,100,10</td>
                        <td>Neu Durchnumerieren einer Page mit Startnummer und Schrittweite.</td>
                    </tr>
                    <tr>
                        <td>/f 1,”string”</td>
                        <td>Suchen einer Zeichenkette in einer Page. Dabei sind im String Fragezeichen als Joker erlaubt. Das Fragezeichen ersetzt ein beliebiges Zeichen. Zu beachten ist jedoch, daß im Quelltext unnötige Blanks entfernt wurden, wie ein Vergleich mit den Befehlen /e und LIST zeigt.</td>
                    </tr>
                    <tr>
                        <td>/r 1,”string1”, ”string2”</td>
                        <td>Ersetzen von Zeichenketten.String 2 darf nicht leer sein. Überall in der Page wird die Zeichenkette aus String 2 durch die aus String1 ersetzt. Auch beim Ersetzen ist in String 2 das Fragezeichen als Joker erlaubt. Da String 1 leer sein darf, können mit diesem Befehl auch Zeichenketten gelöscht werden.</td>
                    </tr>
                    <tr>
                        <td>/u 9000</td>
                        <td>Setzen des Quelltextstartes (Programmstartes). Normalerweise ist als Startwert die Adresse 7000 eingestellt Durch Hochlegen des Startes kann man zum Beispiel einen Monitor in dem nun freien Bereich unterbringen.</td>
                    </tr>
                    <tr>
                        <td>/b</td>
                        <td>Anzeige der aktuellen Speicherkonfiguration. Es wird angezeigt:<br>a) der normale Quelltextstart 7000 als Merkhilfe<br>b) der aktuelle Quelltextstart<br>c) das Quelltextende<br>d) die Anzahl der noch verbleibenden Bytes für den Quelltext</td>
                    </tr>
                    <tr>
                        <td>/l”name” ; /s”name” ; /v”name” ; /m”name”</td>
                        <td>Kurzform der Befehle LOAD, SAVE, VERIFY und<br>MERGE</td>
                    </tr>
                    <tr>
                        <td>/g8</td>
                        <td>Die zugehörige Gerätenummer kann mit diesem Befehl eingestellt werden. Voreingestellt ist das Gerät 8.</td>
                    </tr>
                    <tr>
                        <td colspan="2">Zur Unterstützung des Umgangs mit dem Floppy-Laufwerk 1541 sind drei Befehle implementiert:</td>
                    </tr>
                    <tr>
                        <td>/i</td>
                        <td>— Lesen des Inhaltsverzeichnisses von Floppy ohne Verlust des geschriebenen Quelltextes</td>
                    </tr>
                    <tr>
                        <td>/k</td>
                        <td>— Lesen des Fehlerkanals</td>
                    </tr>
                    <tr>
                        <td>/e</td>
                        <td>— Übermittlung von Befehlen an die Floopy</td>
                    </tr>
                    <tr>
                        <td colspan="2">Diese drei Befehle entsprechen denen des DOS 5.1.<br>Auch zur Farbgebung des Bildschirms sind zwei Befehle vorhanden, die die Hintergrund- und die Rahmenfarbe setzen.</td>
                    </tr>
                    <tr>
                        <td>/ch O</td>
                        <td>— Setzen der Hintergrundfarbe</td>
                    </tr>
                    <tr>
                        <td>/cr O</td>
                        <td>— Setzen der Rahmenfarbe</td>
                    </tr>
                    <tr>
                        <td colspan="2">Nach erfolgter Assemblierung kann nun die erzeugte Symboltabelle mit zwei Befehlen ausgegeben werden:</td>
                    </tr>
                    <tr>
                        <td>/!</td>
                        <td>— Ausgabe in unsortierter Form</td>
                    </tr>
                    <tr>
                        <td>/!!</td>
                        <td>— Ausgabe sortiert</td>
                    </tr>
                </tbody>
            </table>
            <p>Es werden nur Label ausgegeben, die entweder global oder von der Ordnung Null sind.</p>
            <p>Beide Dumps können mit der CTRL-Taste verlangsamt und mit der STOP-Taste angehalten werden.</p>
            <p>Mit OPEN..., CMD... können die Dumps an andere Geräte gesendet werden.</p>
            <p>Als Ergänzung zum Basic-Befehl PRINT, der aufgrund der Torkenbildung nicht alle Labelnamen verarbeiten kann, kann der Befehl — verwendet werden.</p>
            <p>Basic-Funktionen wie PEEK sind nur über den PRINT-Befehl erreichbar. Die Funktionen <(...) und>(...) sind außerhalb des Quelltextes nur durch ← zu verwenden. Mit dem ←—Befehl kann genau wie im Quelltext gerechnet werden.</p>
            <figcaption>Bild 1. Die Editorbefehle</figcaption>
        </figure>

        <h3>Rechnungen im Quelltext</h3>

        <p>HYPRA-ASS erlaubt die vier Grundrechenarten plus Potenzierung, die logischen Operationen NOT, AND und OR, die Vergleiche »gleich«, »kleiner« und »größer«, sowie den Einsatz der Funktionen &lt; (&hellip;) und > (&hellip;), die das Low- beziehungsweise Highbyte eines Argumentes liefern. Die logischen Operatoren und die Vergleiche werden wie folgt abgekürzt: !n! = not !a! = and !o! = or ! = ! = gleich ! &lt;! = kleiner als ! >! = größer als</p>

        <p>Das Ergebnis eines Vergleiches ist —1, falls wahr, 0, falls nicht wahr: (1! = !2)=0 (1! = !1)=-1</p>

        <p>Auch die NOT-Verknüpfung arbeitet wie in Basic: !n!1 = —2. Das Argument in den Low-/Highbyte-Funktionen muß im Bereich 0 &lt; Argument &lt;65535 liegen.</p>

        <p>Außer Dezimalzahlen sind Hex-Zahlen erlaubt, die durch ein vorangestelltes Dollarzeichen kenntlich gemacht werden: $C000 = 49152 $10 = 16 $a = 10&hellip;</p>

        <p>Die Hexzahlen können auch in den Basic-Befehlen verwendet werden.</p>

        <h3>HYPRA-ASS-Variable (Label)</h3>

        <p>Der Wert einer HYPRA-ASS-Variablen kann zwischen 0 und $FFFF liegen. Variablennamen können beliebig lang sein, wobei das erste Zeichen des Variablennamens ein Buchstabe sein muß. Weitere Zeichen können Buchstaben, Ziffern oder das Hochkomma sein. Alle Zeichen des Namens sind signifikant.</p>

        <p>Im Zusammenhang mit der Verwendung von Makros muß zwischen globalen und lokalen Variablen unterschieden werden. Jede Variable erhält beim Anlegen eine sogenannte Ordnungszahl, die tatsächlich angibt, im wievielten Makroaufruf das Anlegen stattfand. Befinde ich mich in gar keinem Makro, ist die Ordnungszahl entsprechend Null.</p>

        <p>Variable mit unterschiedlicher Ordnungszahl sind trotz gleichen Namens nicht gleich. Man kann also davon sprechen, daß Variable gleicher Ordnungszahl lokal sind.</p>

        <p>Die Konstruktion mittels Ordnungszahlen dient dazu, Fehler durch doppelte Benutzung von Labeln bei mehrmaligem Aufruf von Makros zu verhindern, indem Makros bei jedem Aufruf sozusagen einen komplett neuen Satz von Labeln erhalten.</p>

        <p>Andererseits sind aus einem Makro »herausgesehen« alle Variablen mit anderer Ordnungszahl als im Makro selbst »unsichtbar«. Um aber bequem Makros in Makros aufrufen und bequem Label verwenden zu können, die in mehreren Makros benutzt werden sollen (etwa Betriebssystemroutinen), gibt es die globalen Variablen.</p>

        <p>Globale Variable sind, wie der Name schon verrät, im Gegensatz zu den lokalen Variablen unabhängig von der Ordnungszahl überall definiert.</p>

        <p>Alle Makronamen sind per Definition global.</p>

        <p>Alle Variablen sind bei HYPRA-ASS redefinierbar gehalten, das heißt alle Variablen können durch eine Wertzuweisung jederzeit verändert werden.</p>

        <p>Eine dopelte Benutzung von Labeln vor Assemblerbefehlen wird jedoch durch einen »Label twice«-Error (Bild 2) geahndet, da dies zu einem falschen Ergebnis der Assemblierung führen würde.</p>

        <figure>
            <p>Zusätzlich zu den Fehlermedlungen, die von Interpreterroutinen wie »illegal quantity« oder »syntax« stammen, gibt HYPRA-ASS folgende Meldungen aus:</p>
            <ol>
                <li><b>can’t number term — </b>ein Ausdruck kann von HYPRA- ASS nicht berechnet werden. Möglicher Grund kann die falsche Abkürzung eines Operators sein.</li>
                <li><b>end of line expected — </b>bei der Abarbeitung einer Zeile wurde statt des Zeilenendes etwas anderes gefunden.</li>
                <li><b>no mnemonic — </b>ein Mnemonic kann nicht identifiziert werden.</li>
                <li><b>unknown pseudo — </b>ein Pseudo-Op wurde falsch abgekürzt.</li>
                <li><b>illegal register — </b>ein Assemblerbefehl existiert in der gewählten Adressierungsart nicht mit dem gewählten Register.</li>
                <li><b>wrong adress — </b>ein Assemblerbefehl existiert nicht in der gewählten Adressierungsart.</li>
                <li><b>illegal label — </b>das erste Zeichen eines Labels war kein Buchstabe.</li>
                <li><b>unknown label — </b>in Pass 2 wurde ein unbekannter Labelname entdeckt</li>
                <li><b>branch too far — </b>eine Verzweigung führt über eine zu große Distanz.</li>
                <li><b>label declared twice — </b>ein Labelname wurde zweimal benutzt.</li>
                <li><b>too many labels — </b>Label und Quelltext passen zusammen nicht mehr in den Speicher.</li>
                <li><b>no macro to close — </b>die Anzahl der .ma-Anweisungen stimmt nicht mit der Anzahl der .rt-Anweisungen überein.</li>
                <li><b>parameter — </b>im Makroaufruf stimmt die Parameterliste nicht mit der Parameterliste der Definition überein.</li>
                <li><b>return — </b>es liegt keine Rückkehradresse auf dem Stack, als eine .rt-Anweisung ausgeführt werden sollte.</li>
            </ol>
            <p>Hinzuweisen ist noch auf eine einfache Möglichkeit, den »label twice-error« zu vermeiden:</p>
            <p>Legt man eine Makrodefinition um einen beliebigen Block des Quelltextes, so sind alle Label in dem Block automatisch lokal. Auf diese Weise kann schon vorhandener Quelltext in neuen eingefügt werden, ohne daß man sich um doppelt verwendete Labelnamen kümmern muß.</p>

            <figcaption>Bild 2. Fehlermeldungen von HYPRA-ASS</figcaption>
        </figure>

        <h3>Die Makros von HYPRA-ASS</h3>

        <p>Makros sind meist kürzere Befehlsfolgen, die im Quelltext häufiger vorkommen, und deshalb unter einem Makro zusammengefaßt werden. Zu jedem Makro gehört ein Makroname, mit dem es aufgerufen werden kann. An jedes HYPRA-ASS-Makro können beliebig viele Parameter übergeben werden, deren aktueller Wert dann bei der Assemblierung im Makro eingesetzt wird. Makros können bei HYPRA-ASS an beliebiger Stelle im Quelltext definiert werden. Alle Makronamen sind global, alle Parameter und makrointernen Label sind lokal. Das heißt verschiedene Makros können durchaus Label beziehungsweise Parameter gleichen Namens verwenden.</p>

        <p>Ein Beispiel für ein einfaches Makro:</p>

        <p>Es wird immer wieder die Befehlsfolge benötigt, Akkumulator und X-Register mit dem Inhalt zweier aufeinanderfolgender Speicherzellen zu laden. Ein Makro dazu könnte folgendermaßen aussehen:</p>

        <p>TODO</p>

        <p>100 -.ma ldax (adresse)
            110 - lda adresse
            120 - ldx adresse+1
            130 -.rt</p>

        <p>Der .ma-Pseudobefehl wird gefolgt von einem Variablennamen, dem Makronamen, und einer Parameterliste in runden Klammern, falls Parameter vorhanden sind. Hier ist es ein Parameter, die Adresse der Speicherzelle, die in den Akku soll. Sind mehrere Parameter vorhanden, werden sie durch Kommata getrennt. In die Parameter setzt der Assembler bei jedem Aufruf den aktuellen Wert, der im Aufruf steht. Rufe ich also ldax (2) auf, so entsteht bei der Assemblierung des Makro die Folge Ida 2, ldx3, entsprechend führt der Aufruf mit ldax (label) zu lda label, ldx label+1.</p>

        <p>Die Parameterliste darf in der Definitionszeile eines Makro nur aus einer Folge von Variablennamen bestehen, während im Aufruf als aktuelle Parameter beliebige Ausdrücke erlaubt sind. Hinter der Definitionszeile mit dem .ma-Pseudo folgt dann der eigentliche Makroinhalt, das heißt das, was bei einem Aufruf des Makro assembliert werden soll.</p>

        <p>Natürlich sind hier nicht nur einfache Befehle wie im Beispiel gestattet. Genausogut können im Makro Verzweigungen und Sprünge ausgeführt werden, es kann bedingt assembliert werden, und weitere Makros können aufgerufen werden. Für die Schachtelung von Makros besteht keine Grenze außer der Fassungskapazität des Prozessorstacks.</p>

        <p>Als Beispiel — wird ein Makro mit zehn internen Labeln 100 mal aufgerufen, ergibt sich schon für die dadurch erzeugten lokalen Label ein Platzbedarf von genau 7 000 Byte.</p>

        <p>Sollte irgendwann der Fall eintreten, daß Label und Quelltext zusammen nicht mehr ins RAM passen, erhalten Sie den »too many labels«-Error (Bild 2). Dies ist allerdings mehr ein theoretischer Fall, denn auch bei der Assemblierung von HYPRA-ASS selbst wurden trotz extensiver Benutzung von Labels nicht einmal 500 gebraucht. Sie können aber davon ausgehen, daß Ihnen immer mindestens Platz für 1 170 Label zur Verfügung steht — in den allermeisten Fällen sogar erheblich mehr.</p>

        <p>Selbstaufrufe von Makros sind auch nicht verboten. Inwieweit eine solche Konstruktion überhaupt sinnvoll sein kann, bleibt jedem selbst zu prüfen.</p>

        <p>Zurück zur Makrodefiniton: Jede Makrodefinition muß unbedingt mit dem Pseudo .rt (return) abgeschlossen sein. Trifft der Assembler bei der Abarbeitung eines Makro auf .rt, so heißt das für ihn, die Assemblierung hinter dem Aufruf fortzusetzen. Vor der .ma und .rt-Anweisung dürfen in derselben Zeile keine Label stehen. Die Makrodefinition selbst wird in Pass 1 und Pass 2 überlesen. Es zählen also nur die Makroaufrufe bei der Assemblierung.</p>

        <p>Der Aufruf eines Makro erfolgt durch den Pseudobefehl &hellip;, gefolgt vom Makronamen und der aktuellen Parameterliste in runden Klammern.</p>

        <h3>Wertzuweisung an Label</h3>

        <p>Zwei Pseudobefehle stehen zur Verfügung, um Label einen Wert zuzuweisen:</p>

        <p>TODO</p>

        <p>.eq — weist einem Label einen Wert zu, ohne die Ordnungszahl des Labels dabei zu verändern.
            .gl — erklärt gleichzeitig das Label als global.</p>

        <p>Beide Pseudos werden der eigentlichen Wertzuweisung vorangestellt, so wie LET in Basic:</p>

        <p>TODO</p>

        <p>100 -.eq marke = $FFC0
            110 -.gl label = $200</p>

        <p>Bei der Wertzuweisung an Label ist immer der Bereich einzuhalten in dem ein Labelwert liegen darf (0 bis $FFFF).</p>

        <h3>Einfügen von Tabellen und Text</h3>

        <p>Drei Pseudo-Ops erleichtern das Einfügen von Tabellen und Text in den Quelltext. Dies sind:</p>

        <p>TODO</p>

        <p>.by — erlaubt das Einfügen von Bytewerten (Werten zwischen 0 und $FF). Einzelne Bytewerte werden durch Kommata voneinander getrennt. Auch Strings der Länge 1 sind als Bytewerte erlaubt. Beispiel:<br>100 -.by 0, ”a”, 123, ”x”, $fa
            .wo — erlaubt das Einfügen von Adressen (Werten zwischen 0 und $FFFF). Mehrere Adressen werden durch Kommata voneinander getrennt. Die Adressen werden in der Folge Low/Highbyte in den Objektcode aufgenommen. Beispiel: 100 -.wo marke-1, label\*2-1
            .tx — erlaubt das Einfügen von Text in den Quelltext. Die einzelnen Zeichen des Textes werden als ASCII-Code im Objektcode aufgenommen. Beispiel:<br>100 -.tx ’’beispieltext”</p>

        <p>Überall im Quelltext, wo Bytewerte erwartet werden, etwa bei der unmittelbaren Adressierung, können Strings der Länge 1 verwendet werden. Ein Befehl Ida #’ä” ist also erlaubt.</p>

        <h3>Die bedingte Assemblierung</h3>

        <p>Zur Unterstützung der bedingten Assemblierung bietet HYPRA-ASS ein IF/ELSE/ENDIF-Konstrukt und ein IF/THEN-Konstrukt. Außerdem steht ein unbedingter Sprungbefehl zur Verfügung.</p>

        <p>TODO</p>

        <p>.on — entspricht dem IF/THEN von Basic. Hinter .on folgt ein Ausdruck, ein Komma und ein zweiter Ausdruck. Ist der erste Ausdruck wahr, wird zu der Zeilennummer gesprungen, die der zweite Ausdruck angibt. Beispiel:<br>100 -.on switch ! = ! 7, 400<br>Es wird die Assemblierung in Zeile 400 fortgesetzt, wenn switch gleich 7 ist.
            .go — ergibt einen unbedingten Sprung zu der Zeile, die der Ausdruck hinter .go angibt. Beispiel:<br>100 -.go 1000
            .if — wird gefolgt von einem Ausdruck. Ist der Ausdruck wahr, wird die Assemblierung hinter der .if-Zeile fortgesetzt, bis
            .el — gefunden wird. Daraufhin wird
            .ei — gesucht und dahinter die Assemblierung fortgesetzt.</p>

        <p>Entsprechend erfolgt die Assemblierung von .el bis .ei, falls der Ausdruck hinter .if falsch ist. .el kann auch fehlen, es wird dann direkt hinter .ei fortgefahren.</p>

        <p>Auf eine Schachtelung von IF-Konstrukten wurde wegen des Zwecks der bedingten Assemblierung verzichtet. Beispiel:</p>

        <p>TODO</p>

        <p>100 -.if switch! = !6
            110 - lda#0
            120 -.el
            130 - lda#2
            140 -.ei</p>

        <p>Wenn switch gleich 6 ist, erhält man lda#0, sonst wird Ida # 2 erzeugt. Vor den Pseudos .if, .el und .ei dürfen keine Label in derselben Zeile stehen.</p>

        <h3>Verkettung von Quelltexten</h3>

        <p>Mit dem Pseudo .ap (append) kann ein weiterer Quelltext am Ende des Pass 2 automatisch nachgeladen werden, wobei der Programmzähler aus der vorangegangenen Assemblierung erhalten bleibt.</p>

        <p>Hinter .ap muß der Name des nachzuladenen Files in Anführungszeichen stehen.</p>

        <p>Eine Besonderheit von HYPRA-ASS bildet im Zusammenhang mit verketteten Quelltexten der Pseudo-Opcode .co (common).</p>

        <p>Dieser Befehl bewirkt zunächst, daß alle Variablen/Label, die hinter der .co-Anweisung in einer Liste stehen, an den nachgeladenen Teil übergeben werden.</p>

        <p>Zweitens bleiben alle Quelltextzeilen bis zur common-Zeile beim Nachladen erhalten. Steht also etwa ein Makro vor der common-Zeile, wird auch das Makro übergeben. Zu beachten ist dabei:</p>

        <p>a) Es sollten keine Makroaufrufe im common-Bereich stehen, es sei denn innerhalb eines Makro.
            b) Die .ba-Anweisung, die die Startadresse des Objektcodes bestimmt, sollte außerhalb des common-Bereiches liegen, damit nach dem Nachladen nicht wieder mit der gleichen Startadresse assembliert wird.
            c) Wertzuweisungen an Label sollten ebenfalls außerhalb des common-Bereiches liegen, um Platz für den nachgeladenen Quelltext zu gewinnen.</p>

        <h3>Direktes Senden des Objektcodes zur Floppy</h3>

        <p>Der Pseudobefehl .ob (object), gefolgt vom Filenamen ,p,w in Anführungszeichen, sendet den erzeugten Objektcode direkt zur Floppy.</p>

        <p>Geschlossen wird das so erzeugte Objektfile durch den Pseudobefehl .en.</p>

        <p>Sollte während der Assemblierung ein Fehler entdeckt werden und das Objektfile nicht schon durch die HYPRA-ASS-Fehlerroutine geschlossen worden sein, geben Sie bitte CLOSE 14 ein.</p>

        <h3>Ausgabe von formatierten Listings</h3>

        <p>TODO</p>

        <p>1) .li 1,3,0 sendet ein formatiertes Listing des Quelltextes unter der logischen Filenummer 1 an das Gerät 3 mit der Sekundäradresse 0 (Bildschirm). Die Parameter hinter .li entsprechen denen des OPEN-Befehls. So ist es auch möglich, mit .li 2,8,2, ”test,u,w” das Listing auf eine Userdatei zu leiten und so weiter.</p>

        <p>Der .li-Pseudobefehl muß der erste Befehl im Quelltext sein, wenn alle Zeilen gelistet werden sollen. Die Zeilen bis einschließlich .li werden nicht ausgegeben. Die gelisteten Zeilen haben folgendes Format:
            c000 a0b0c0: 1000 -marke befehl ;kommentar</p>

        <p>Die Steuerung der Formatierung erfolgt mit dem Editorbefehl /t. Bei Zeilen, die Pseudobefehle enthalten, wie .eq&hellip; werden keine Adressen und Opcodes ausgegeben.</p>

        <p>TODO</p>

        <p>2) .sy 1,3,0 sendet am Ende von Pass 2 die sortierte Symboltabelle. Die Formatierung wird hier durch /t3,&hellip; gesteuert. Die Labelwerte werden hexadezimal ausgegeben.</p>

        <p>Eine Zeile der Symboltabelle sieht dann folgendermaßen aus:
            sprungziel = $ffd2</p>

        <p>Das Listing des Quelltextes erhält die Kopfzeile »HYPRA-ASS Assemblerlisting:«. Die Symboltabelle erhält die Kopfzeile »Symbols in alphabetical order«.</p>

        <p>TODO</p>

        <p>3) .dp
            t0,t1,t2,t3 setzt aus dem Quelltext heraus die Tabulatoren t0 = Tabulator für Assemblerbefehle t1 = Tabulator für den Kommentar bei der formatierten Ausgabe
            t2 = Tabulator für die Anzahl der Blanks, die am Anfang einer Ausgabezeile ausgegeben werden.
            t3 = Tabulator für die Symboltabelle
            4) .st beendet die Assemblierung</p>

        <p>Am Ende des zweiten Passes wird immer die Meldung »end of assembly« gefolgt von der Assemblierungsdauer in Minuten, Sekunden und Zehntelsekunden ausgegeben. Dahinter folgt die Zeile »base = $XXXX last byte at $YYYY«.</p>

        <p>Eine Zusammenfassung aller Pseudobefehle finden Sie in Bild 3.</p>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td>1)</td>
                        <td>.ba $C000</td>
                        <td>gibt die Startadresse der Assemblierung an. Bei anderen Assemblern heißt dieser Befehl auch org oder * = .</td>
                    </tr>
                    <tr>
                        <td>2)</td>
                        <td>.eq label=wert</td>
                        <td>weist einem Label einen Wert zu</td>
                    </tr>
                    <tr>
                        <td>3)</td>
                        <td>.gl label=wert</td>
                        <td>weist einem globalen Label einen Wert zu</td>
                    </tr>
                    <tr>
                        <td>4)</td>
                        <td>.by 1,2,”a”</td>
                        <td>Einfügen von Byte-Werten in den Quelltext</td>
                    </tr>
                    <tr>
                        <td>5)</td>
                        <td>.wo 1234,label</td>
                        <td>Einfügen von Adressen in der Folge low/high</td>
                    </tr>
                    <tr>
                        <td>6)</td>
                        <td>.tx”text”</td>
                        <td>Einfügen von Text als ASCII-Werte</td>
                    </tr>
                    <tr>
                        <td>7)</td>
                        <td>.ap ”file”</td>
                        <td>Verketten von Quelltexten</td>
                    </tr>
                    <tr>
                        <td>8)</td>
                        <td>.ob "file,p,w”</td>
                        <td>Senden des Objektcodes zur Floppy</td>
                    </tr>
                    <tr>
                        <td>9)</td>
                        <td>.en</td>
                        <td>Schließen des Objektfiles</td>
                    </tr>
                    <tr>
                        <td>10)</td>
                        <td>.on aus- druck,sprung</td>
                        <td>bedingter Sprung, wenn Ausdruck wahr</td>
                    </tr>
                    <tr>
                        <td>11)</td>
                        <td>.go sprung</td>
                        <td>unbedingter Sprung</td>
                    </tr>
                    <tr>
                        <td>12)</td>
                        <td>.if ausdruck</td>
                        <td>Fortführung der Assemblierung bei ELSE, falls Ausdruck falsch. Ansonsten hinter .if bis zu ELSE oder ENDIF</td>
                    </tr>
                    <tr>
                        <td>13)</td>
                        <td>.el</td>
                        <td>Alternative zu den Zeilen, die hinter .if stehen</td>
                    </tr>
                    <tr>
                        <td>14)</td>
                        <td>.ei</td>
                        <td>Ende der IF-Konstruktion</td>
                    </tr>
                    <tr>
                        <td>15)</td>
                        <td>.co var1,var2</td>
                        <td>Übergabe von Labeln und Quelltext an nachgeladene Teile</td>
                    </tr>
                    <tr>
                        <td>16)</td>
                        <td>.ma makro (par1,par2)</td>
                        <td>Makrodefinitionszeile</td>
                    </tr>
                    <tr>
                        <td>17)</td>
                        <td>.rt</td>
                        <td>Ende der Makrodefinition</td>
                    </tr>
                    <tr>
                        <td>18)</td>
                        <td>...makro<br>(par1,par2)</td>
                        <td>Makroaufruf</td>
                    </tr>
                    <tr>
                        <td>19)</td>
                        <td>.li lfn, dn, ba</td>
                        <td>sendet formatiertes Listing unter der File- Nummer lfn zum Gerät dn mit der Sekundäradresse ba</td>
                    </tr>
                    <tr>
                        <td>20)</td>
                        <td>.sy lfn, dn, ba</td>
                        <td>sendet formatierte Symboltabelle unter der File- Nummer lfn zum Gerät dn mit der Sekundäradresse ba</td>
                    </tr>
                    <tr>
                        <td>21)</td>
                        <td>.st</td>
                        <td>beendet die Assemblierung</td>
                    </tr>
                    <tr>
                        <td>22)</td>
                        <td>.dp t0, t1, t2, t3</td>
                        <td>setzt die Tabulatoren T0, T1, T2, T3 aus dem Quelltext heraus</td>
                    </tr>
                    <tr>
                        <td colspan="3">Vor den Anweisungen 12, 13, 14, 16 und 17 dürfen in derselben Zeile keine Label stehen.</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Bild 3. Zusammenfassung aller Pseudobefehle</figcaption>
        </figure>

        <h2>HYPRA-ASS-Editor</h2>

        <p>Eines der Ziele bei der Entwicklung von HYPRA-ASS war es auch, die Editierung von Quelltexten möglichst bequem zu machen. Dazu wurden etliche Funktionen, die im normalen Basic-Editor stets gebraucht, aber nie vorhanden sind, in den HYPRA-ASS-Editor eingebaut.</p>

        <p>Als Grundlage des HYPRA-ASS-Editors blieb dabei der Basic-Editor erhalten.</p>

        <p>Ein HYPRA-ASS-Quelltext wird also im Prinzip genauso eingegeben wie ein Basic-Programm. Allerdings muß hinter der Zeilennummer immer ein Minuszeichen eingegeben werden, das den Beginn der Quelltextzeile bildet. So eingegebene Quelltextzeilen werden als ASCII-Zeilen in den Speicher übernommen. Alle überflüssigen Blanks werden entfernt.</p>

        <p>Jede eingegebene Zeile wird sofort nach der Übernahme formatiert ausgegeben, um die Übersichtlichkeit des Quelltextes zu gewährleisten. Eine Tabelle aller Editorbefehle finden Sie in Bild 1.</p>

        <address class="author">(Gerd Möllmann/ah)</address>

        <figure>
            <table>
                <tbody>
                    <tr>
                        <td>$0000</td>
                        <td>Zeropage</td>
                    </tr>
                    <tr>
                        <td>$033e</td>
                        <td>Bandpuffer als Zwischenspeicher</td>
                    </tr>
                    <tr>
                        <td>$0400</td>
                        <td>Video-RAM</td>
                    </tr>
                    <tr>
                        <td>$0800</td>
                        <td>Hypra-ASS</td>
                    </tr>
                    <tr>
                        <td>$1fd7</td>
                        <td>Raum für Quelltext und Label. Quelltext bis maximal $a000</td>
                    </tr>
                    <tr>
                        <td>$a000</td>
                        <td>Basic-Interpreter — darunter von c000 abwärts die Symboltabelle</td>
                    </tr>
                    <tr>
                        <td>$c000</td>
                        <td>frei!</td>
                    </tr>
                    <tr>
                        <td>$d000</td>
                        <td>I/O und so weiter</td>
                    </tr>
                    <tr>
                        <td>$c000</td>
                        <td>Kernal</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Bild 4. Speicherbelegung von HYPRA-ASS</figcaption>
        </figure>
    </article>
</body>

</html>
