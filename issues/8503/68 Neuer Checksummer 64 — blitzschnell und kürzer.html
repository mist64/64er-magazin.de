<!DOCTYPE html>
<html lang="de">

<head>
    <title>Neuer Checksummer 64 — blitzschnell und kürzer</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Frank Lonczewski, Werner Wenzel, gk">
    <meta name="64er.issue" content="3/85">
    <meta name="64er.pages" content="68-70">
    <meta name="64er.head1" content="Anwendung">
    <meta name="64er.head2" content="C 64/VC 20">
    <meta name="64er.toc_category" content="Listings zum Abtippen|Anwendung">
    <meta name="64er.index_title" content="Neuer Checksummer 64 — blitzschnell und kürzer">
    <meta name="64er.index_category" content="Listings zum Abtippen|Anwendung|Abtippen">
    <meta name="64er.id" content="checksummer">
</head>

<body>
    <article>
        <h1>Neuer Checksummer 64 — blitzschnell und kürzer</h1>
        <p class="intro">Das Programm Checksummer kennen die meisten unserer Leser bereits aus dem 64’er Sonderheft und den Ausgaben 1 und 2/85. Der Checksummer überprüft jede eingegebene Basic-Zeile und erspart Ihnen deshalb eine langwierige Fehlersuche. Und neu ist der Checksummer, weil die Initialisierung zirka einhundertmal schneller vonstatten geht als bei der alten Version.</p>

        <p>Es gab eine riesige Resonanz auf den Checksummer und zwar ausschließlich positiv. Jedoch brauchte das Programm eine ganze Weile, bis es initialisiert war, eine Herausforderung für eine Unmenge von Lesern! Der nebenstehende Leserbrief setzt sich drastisch, aber nicht ganz so ernst gemeint, mit diesem Problem auseinander und gibt eine Lösung, die zirka einhundertmal schneller ist als die bisherige Version. Dieser Brief und der neue, schnelle Checksummer steht übrigens für eine ganze Reihe von Leserzuschriften, die auch entsprechende Verbesserungen eingeschickt haben.</p>

        <p>Der Checksummer 64 ist ein kleines Maschinenprogramm, das, wenn es aktiviert ist, Sie sofort davon unterrichtet, ob Sie die jeweilige Programmzeile korrekt eingegeben haben.</p>

        <ol>
            <li>Tippen Sie den Basic-Lader sorgfältig ein. Es gibt zwei Versionen: Eine für den Commodore 64 und eine für den VC 20.</li>
            <li>Vergessen Sie nicht das Abspeichern vor dem Start (RUN)!</li>
            <li>Wenn Sie den Checksummer 64 zwischenzeitlich nicht benutzen, können Sie ihnjederzeit mit »POKE 1,55« desaktivieren. Auch durch Drücken der Run-Stop- und der Restore-Taste wird der Checksummer 64 desaktiviert.</li>
        </ol>


        <p>Wollen Sie den Checksummer 64 wieder einschalten, so geben Sie bitte »POKE 1,53« ein.</p>

        <p>Das Maschinenporgramm bleibt solange erhalten, bis der Computer ausgeschaltet, oder, wenn von anderen Programmen auf das hinter dem ROM liegende RAM zugegriffen wird.</p>

        <p>Alle veröffentlichten Listings sind mit einer Checksumme versehen, die am Ende jeder Programmzeile steht. Diese Checksumme steht zwischen &lt; und &gt;. Sie wird beim Eintippen des Programms nicht mit eingegeben. Die Zahl zwischen den beiden Zeichen stellt lediglich eine Information für Sie dar. Wenn Sie diese Checksumme dennoch mit eintippen, werden Sie schnell bemerken, daß Sie etwas falsch gemacht haben. Bei aktiviertem Checksummer 64 wird nämlich nach Eingabe einer Basic-Zeile, die mit Return beendet wird, in die linke obere Bildschirmecke die Checksumme eingeblendet, die mit der Summe aus dem veröffentlichten Listing übereinstimmen muß. Ist das nicht der Fall, haben Sie die Zeile anders eingegeben, als sie im Listing dargestellt ist. Vergessen Sie also bitte nicht, daß die am Ende einer Zeile in &lt; und &gt; stehende Prüfsumme nicht mit eingegeben werden darf.</p>

        <p>Der Checksummer 64 ist so ausgelegt, daß er abhängig von der Zeilennummer und dem Text der Zeile eine Checksumme ausgibt. Beim Bilden dieser Checksumme werden Spaces (Leertaste) überlesen, was für Sie bedeutet, daß es egal ist, wieviel Leerzeichen Sie zwischen den Worten lassen, da Sie für den Programmablauf ohnehin keine Bedeutung haben.</p>

        <h3>Hinweise zum Lesen von Listings</h3>

        <p>Die Listings haben sich ein wenig im Ausdruckformat verändert, um Ihnen das Eingeben von Programmen wesentlich zu erleichtern.</p>

        <ul>
            <li>Cursorsteuerzeichen und andere Steuerzeichen, die schwer zu lesen sind, werden von nun an in Klartext in speziellen geschweiften Klammern gesetzt.
            <p>Tritt mehrmals hintereinander dasselbe Steuerzeichen auf, so wird diese Steuerzeichen-Sequenz zusammengefaßt, indem zuerst die Anzahl der Wiederholungen dieses Steuerzeichens und dann das Steuerzeichen in Klartext ausgegeben wird.</p>
            </li>
            <li>Alle Commodore-Grafikzeichen, die über Shift zu erreichen sind, werden nicht mehr als Grafikzeichen, sondern als Klartextzeichen dargestellt. Dabei wird aus dem Zeichen, das Sie auf dem Bildschirm sehen, Wenn Sie die Tastenkombination Shift und »A« ansprechen, wieder ein »A« (nur im abgedruckten Listing). Um dieses »A« vom normalen »A« unterscheiden zu können, ist es etwas kleiner als das gewöhnliche »A« und ist außerdem mit einem Unterstreichungszeichen versehen. Diese Vereinbarung gilt auch für sämtliche andere Commodore-Grafikzeichen, die über Shift zu erreichen sind.</li>
            <li>Entsprechendes gilt für sämtliche Commodore-Grafikzeichen, die über die Commodore-Taste zu erreichen sind. Hier wird jedoch das jeweilige Klartextzeichen nicht unterstrichen, sondern überstrichen.</li>
        </ul>


        <h2>Checksummer VC 20</h2>

        <p>Der Checksummer VC 20 ist im Prinzip genauso aufgebaut wie der Checksummer 64. Da beim VC 20 jedoch nicht die Möglichkeit besteht, das ROM softwaremäßig zu modifizieren, mußte ein anderer Weg als beim Commodore 64 gewählt werden, um die Checksumme zu generieren.</p>

        <p>In ihrer Funktionsweise unterscheiden sich der Checksummer VC 20 und der Checksummer 64 nicht. Es gelten folgende Sonderregelungen bei der Benutzung des Checksummer VC20:</p>

        <ul>
            <li>Da der Basic-Bereich nicht belegt werden soll, ist das Programm im Kassettenpuffer abgelegt.</li>
            <li>Angeschaltet wird der Checksummer VC 20 mit »SYS 955« und abgeschaltet mit »SYS 58459«.</li>
        </ul>


        <p><strong>ACHTUNG</strong>: Nehmen Sie keine Kassetten-Operationen vor, wenn der Checksummer VC 20 eingeschaltet ist. Da das Betriebssystem den Kassettenpuffer mit Daten belegt, kann der Checksummer VC 20 überschrieben werden, was zur Folge hat, daß sich der Rechner bei aktiviertem Checksummer VC 20 »aufhängt«. Wollen Sie deshalb ein Programm auf (von) Kassette abspeichern (laden), so müssen Sie erst den Checksummer VC 20 abschalten (SYS 58459).</p>

        <p>Daraufhin kann der Kassettenpuffer mit Daten überschrieben werden, ohne daß der Rechner »aussteigt«.</p>

        <p>Als Sicherung wird bei der Initialisierung geprüft, ob das zuletzt angesprochene Peripherie-Gerät der Kassettenrecorder war. Ist das der Fall, so werden die Betriebssystemroutinen LOAD und SAVE für die Benutzung gesperrt. Der Rechner meldet bei Aufruf einer dieser beiden Routinen READY, ohne weitere Aktionen durchzuführen. Diese Sicherung kann man nach der Tipparbeit aufheben, wenn man den Checksummer VC 20 mit SYS 58459 abschaltet. Dadurch wird der Kassettenpuffer für andere Daten freigemacht</p>

        <p>Weiterhin wird dann durch gleichzeitiges Drücken der Tasten »Run-Stop &amp; Restore« erreicht, daß die Betriebssystemroutinen LOAD und SAVE wieder eingerichtet werden.</p>

        <ul>
            <li>Bei Benutzung einer Diskettenstation brauchen Sie nicht darauf zu achten, daß bei LOAD beziehungsweise SAVE der Checksummer VC 20 überschrieben wird, da der Kassettenpuffer für die Diskettenstation normalerweise nicht genutzt wird. Deshalb können Sie die beiden Routinen weiterhin normal nutzen, sofern der Rechner bei der Initialisierung des Checksummer VC 20 feststellt, daß das zuletzt angesprochene Peripherie-Gerät nicht der Kassettenrecorder war.</li>
            <li>Bedingt durch den anderen Aufbau des Checksummer VC 20 wird anders als beim Checksummer 64 nach der LOAD-Routine keine Checksumme ausgegeben.</li>
            <li>Wird eine Zeile gelöscht, also eine Zahl zwischen 0 und 63999 eingegeben, und danach Return gedrückt, so wird eine Checksumme ausgegeben, die aber keine Bedeutung hat.</li>
        </ul>


        <p>Viel Spaß beim Eintippen von Programmen mit dem neuen Checksummer!</p>

        <address class="author">(F. Lonczewski/gk)</address>

        <aside>
            <p>Herrschaften!</p>

            <p class="noindent">(Nehmen Sie mir den Ton dieses Schreibens bitte nicht übel; ich meine es nicht so ganz ernst!)</p>

            <p class="noindent">&hellip;da veröffentlicht Ihr in Eurer Zeitschrift Programme wie HYPRA-LOAD und so weiter, weil die geschätzten Fans, überwiegend wohl Hobbyisten, nicht genug Zeit haben (O tempora, omores!), auf die lahme, dafür aber billige 1541 zu warten, und dann schockt Ihr einen mit einer für den Genuß Eures Magazins lebenswichtigen Utility, nämlich dem Checksummer, während deren Setup man einen ausgedehnten Mittagsschlaf halten kann. Mein C 64-Interpreter (der übrigens Wert darauf legt, auf der 2. Silbe betont zu werden, was einerseits richtig, andererseits wenig bekannt ist) behauptet jedenfalls, er brauche für den Programmlauf 1 Minute 18 Sekunden&hellip;</p>

            <p class="noindent">Wenn Ihr Euch jetzt auf die Füße getrampelt fühlt und um konstruktive Kritik bittet, bitte:</p>

            <p class="noindent">Der erste Blick ins Listing entlarvt den ersten Übeltäter in den Zeilen 130 und 140 (wohlgemerkt: die C 64-Version!):</p>

            <p>16 KByte in einer Basic-Schleife kopieren! Puh! Warum nicht gleich von Hand ein POKEn?! Dieser Anschlag auf die Geduld des geneigten Lesers und Anwenders ist um so verwerflicher, als daß doch der Interpreter ab Adresse dezimal 41912 ($A3B8) eine Block-Verschiebe-Routine anbietet, mit der man nur umzugehen wissen muß.</p>
            
            <p class="noindent">Also:</p>

            <p>Die ersten 3 Befehle der Routine vergessen wir — die werden nur gebraucht, wenn die Routine in der üblichen Weise verwendet wird. Der richtige Einsprung-Punkt für unsere Zwecke ist also dezimal 41919 ($A3BF).</p>

            <p class="noindent">Die Routine verlangt nun folgende Übergabe-Parameter (in der üblichen Reihenfolge low — high):</p>

            <ol type="a">
                <li>Startadresse des zu verschiebenden (hier bloß in das darunterliegende RAM zu kopierenden) Blocks in dezimal 95/96 ($5F/60),</li>
                <li>Endadresse+1 des zu verschiebenden Blocks in dezimal 90/91 ($5A/5B),</li>
                <li>Endadresse+1 des Bereichs, in den verschoben werden soll, in dezimal 88/89 ($58/59).</li>
            </ol>

            <p>Getrennt für jeden ROM-Bereich POKEn wir also die Parameter in die angegebenen Adressen, wobei</p>

            <ol type="a">
                <li>in unserem speziellen Falle die Endadresse des Quell- und Zielbereichs (+1) natürlich identisch ist.</li>
                <li>wir im 2. Falle anstelle der richtigen, aber leider unmöglichen, Endadresse+1 einfach naßforsch 0 eingeben, getreu dem — in diesem Falle richtigen — Motto: Für den Computer ist dezimal 65535 ($FFFF) + 1 = 0!</li>
            </ol>

            <p>Aber &hellip; (vor den Ruhm haben die Götter die Schweißfüße gesetzt!) das funktioniert natürlich (von Basic aus) nicht! Der Grund ist für den Kundigen klar: Der Aufruf der SYS-Routine mißhandelt in brutalster Weise die gerade mühsam gePOKEte Startadresse. Das entmutigt unsjedoch in keinster Weise. Wir übergeben die Startadresse in dezimal 780/781 ($030C/030D) an Akku und X-Register und springen zunächst eine selbstgestrickte Mini-Maschinenroutine von insgesamt 7 Byte Länge an, die die Startadresse abliefert und dann die eigentliche Routine anspringt: STA $5F, STX $60, JMP $A3BF. Diese 7 Byte, die wir natürlich im Programm vorher mittels einer READ-Schleife einPOKEn, verstecken wir nichtstörend vor dem Kassetten-Puffer ab dezimal 820 ($0334). Wem dieses stille Örtchen nicht paßt: lm beigefügten Listing (Checksummer für den C 64) habe ich diese Startadresse netterweise parametrisiert.</p>

            <p>That’s all! Hört sich komplizierter an, als es ist!</p>

            <p>Fragt sich (mit Fug und Recht): Was bringt’s?</p>

            <p>Antwort: Das so verunstaltete Programm behelligt den Computer für nur noch 7 Sekunden anstelle von vorher 1 Minute 18 Sekunden.</p>

            <p>Das ist natürlich noch viel zu lang!!!</p>

            <p>Ein zweiter Blick ins ursprüngliche Listing entlarvt den zweiten Übeltäter. Die Hex-Zahlen in den DATAs samt den dazugehörigen Programmzeilen. Was Ihr Euch dabei gedacht habt, wißt Ihr und die Götter — ich nicht! Jedenfalls sind hier die Nebenwirkungen schlimmer als der Heileffekt.</p>

            <p class="noindent">Also.</p>

            <p>Wir ersetzen die Hex-Zahlen durch stinknormale Dezimalzahlen, schmeißen natürlich die dann überflüssige Umwandlungs-Routine weg und entledigen uns letztlich (spätestens, nachdem wir die korrekte Eingabe der Zahlen gecheckt haben) der Prüfsummen-Befehle.</p>

            <p>Ich verweise den entsetzten Leser auch insoweit auf das abgedruckte Listing.</p>

            <p class="noindent">Was bringt’s?</p>

            <p>Das Programm vergeudet nun nur noch zirka 1 Sekunde!</p>

            <p>Und damit wollen wir es genug sein lassen.</p>

            <address class="author">(Werner Wenzel)</address>
        </aside>

        <figure>
            <table class="plain">
                <tr class="separator">
                    <td>Wenn Sie lesen</td>
                    <td>drücken Sie</td>
                </tr>
                <tr>
                    <td colspan="2">CTRL steht für Control-Taste, so bedeutet [CTRL-A], daß Sie die
                        Control-Taste und die Taste »A« drücken müssen. Im folgenden steht:</td>
                <tr>
                    <td>[down]</td>
                    <td>Taste neben rechtem Shift, Cursor unten</td>
                </tr>
                <tr>
                    <td>[up]</td>
                    <td>Shift-Taste &amp; Taste neben rechtem Shift, Cursor hoch</td>
                </tr>
                <tr>
                    <td>[clear]</td>
                    <td>Shift-Taste &amp; 2. Taste ganz rechts oben</td>
                </tr>
                <tr>
                    <td>[inst]</td>
                    <td>Shift-Taste &amp; Taste ganz rechts oben</td>
                </tr>
                <tr>
                    <td>[home]</td>
                    <td>2. Taste von ganz rechts oben</td>
                </tr>
                <tr>
                    <td>[del]</td>
                    <td>Taste ganz rechts oben</td>
                </tr>
                <tr>
                    <td>[right]</td>
                    <td>Taste ganz rechts unten</td>
                </tr>
                <tr>
                    <td>[left]</td>
                    <td>Shift-Taste &amp; Taste unten rechts</td>
                </tr>
                <tr>
                    <td>[space]</td>
                    <td>Leertaste</td>
                </tr>
                <tr>
                    <td>[f1]</td>
                    <td>grauer Tastenblock rechts</td>
                </tr>
                <tr>
                    <td>[f3]</td>
                    <td>grauer Tastenblock rechts</td>
                </tr>
                <tr>
                    <td>[f5]</td>
                    <td>grauer Tastenblock rechts</td>
                </tr>
                <tr>
                    <td>[f7]</td>
                    <td>grauer Tastenblock rechts</td>
                </tr>
                <tr>
                    <td>[f2]</td>
                    <td>grauer Tastenblock rechts &amp; Shift</td>
                </tr>
                <tr>
                    <td>[f4]</td>
                    <td>grauer Tastenblock rechts &amp; Shift</td>
                </tr>
                <tr>
                    <td>[f6]</td>
                    <td>grauer Tastenblock rechts &amp; Shift</td>
                </tr>
                <tr>
                    <td>[f8]</td>
                    <td>grauer Tastenblock rechts &amp; Shift</td>
                </tr>
                <tr>
                    <td>[return]</td>
                    <td>Shift-Taste &amp; Return</td>
                </tr>
                <tr>
                    <td>[black]</td>
                    <td>Control-Taste &amp; 1</td>
                </tr>
                <tr>
                    <td>[white]</td>
                    <td>Control-Taste &amp; 2</td>
                </tr>
                <tr>
                    <td>[red]</td>
                    <td>Control-Taste &amp; 3</td>
                </tr>
                <tr>
                    <td>[cyan]</td>
                    <td>Control-Taste &amp; 4</td>
                </tr>
                <tr>
                    <td>[purple]</td>
                    <td>Control-Taste &amp; 5</td>
                </tr>
                <tr>
                    <td>[green]</td>
                    <td>Control-Taste &amp; 6</td>
                </tr>
                <tr>
                    <td>[blue]</td>
                    <td>Control-Taste &amp; 7</td>
                </tr>
                <tr>
                    <td>[yellow]</td>
                    <td>Control-Taste &amp; 8</td>
                </tr>
                <tr>
                    <td>[rvson]</td>
                    <td>Control-Taste &amp; 9</td>
                </tr>
                <tr>
                    <td>[rvoff]</td>
                    <td>Control-Taste &amp; 0</td>
                </tr>
                <tr>
                    <td>[orange]</td>
                    <td>Commodore-Taste &amp; 1</td>
                </tr>
                <tr>
                    <td>[brown]</td>
                    <td>Commodore-Taste &amp; 2</td>
                </tr>
                <tr>
                    <td>[ligred]</td>
                    <td>Commodore-Taste &amp; 3</td>
                </tr>
                <tr>
                    <td>[grey 1]</td>
                    <td>Commodore-Taste &amp; 4</td>
                </tr>
                <tr>
                    <td>[grey 2]</td>
                    <td>Commodore-Taste &amp; 5</td>
                </tr>
                <tr>
                    <td>[lig.green]</td>
                    <td>Commodore-Taste &amp; 6</td>
                </tr>
                <tr>
                    <td>[lig.blue]</td>
                    <td>Commodore-Taste &amp; 7</td>
                </tr>
                <tr>
                    <td>[grey 3]</td>
                    <td>Commodore-Taste &amp; 8</td>
                </tr>
                <tr>
                    <td colspan="2">Wenn Sie sich erst einmal an die in Klartext geschriebenen Steuerzeichen gewöhnt haben, werden Sie den Vorteil dieser Schreibweise erkennen. Der zu dem jeweiligen Steuerzeichen gehörende Klartext ist so verfaßt, daß Sie leicht die Taste beziehungsweise die Tastenkombination finden, die Sie drücken müssen.</td>
            </table>
        </figure>

        <figure>
            <pre data-filename="checksummer vc20" data-name="Checksummer (VC 20)"></pre>
            <figcaption>Der Checksummer für den VC 20</figcaption>
        </figure>
        <figure>
            <pre data-filename="checksum.schnell" data-name="Neuer Checksummer (C 64)"></pre>
            <figcaption>Der neue Checksummer für den Commodore 64</figcaption>
        </figure>
    </article>
</body>

</html>