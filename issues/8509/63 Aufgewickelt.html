<!DOCTYPE html>
<html lang="de">

<head>
    <title>Aufgewickelt</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Fred Behringer, ev">
    <meta name="64er.issue" content="9/85">
    <meta name="64er.pages" content="63-64">
    <meta name="64er.head1" content="Tips und Tricks">
    <meta name="64er.head2" content="VC 20">
    <meta name="64er.toc_category" content="Listings zum Abtippen|Tips und Tricks">
    <meta name="64er.index_title" content="Aufgewickelt – Listingscrolling für den VC 20">
    <meta name="64er.index_category" content="Listings zum Abtippen|Tips & Tricks">
    <meta name="64er.id" content="aufgewickelt">
</head>

<body>
    <article>
        <h1>Aufgewickelt</h1>
        <p class="intro">Die LIST-Funktion des VC 20 hat bekanntlich eine Reihe von Nachteilen. Das hier vorgestellte Programm ermöglicht Endloslistings vorwärts und rückwärts und soll als Anregung zur eigenen Beschäftigung mit Betriebssystemroutinen dienen.</p>

        <p>Wie unendlich langwierig kann es doch sein, wenn man im Listing eine Stelle sucht, von der man nur ungefähr weiß, wo sie liegt! Manche Basic-Erweiterungen bieten die Möglichkeit, das LISTing per Cursor hin- und herzuschieben. Das gleich zu beschreibende Programm leistet ähnliches. Mehr noch! Es läßt sich durch leichte Ergänzung des einbettenden Basic-Programms beliebig komfortabel gestalten. Im einzelnen bewirkt das Programm nach Listing 1 folgendes:</p>

        <ol>
            <li>Ansprung per GOSUB 500. Nach Drücken der Return-Taste Rücksprung ins Ausgangsprogramm oder, falls der Ansprung vom Direktmodus aus erfolgte, in den Direktmodus. Solange das in den Kassettenpuffer gelegte Maschinenprogramm nicht durch andere Operationen (LOAD, SAVE, VERIFY) zerstört wurde, kann jeder weitere Ansprung per GOSUB 580 vorgenommen werden, was eine Einlesezeit von 2,5sec einspart.</li>
            <li>Das LISTing läuft mit der von LIST her bekannten Geschwindigkeit über den Bildschirm (Anfang zufällig), und zwar endlos: Nach Erscheinen der letzten Basic-Zeile erscheint wieder die erste und so weiter. (Die CTRL- und Run/Stop-Taste haben die üblichen Funktionen, sind hier aber überflüssig.)</li>
            <li>Das LISTing stoppt nach Drücken der * -Taste und nimmt seinen Lauf nach abermaligem Drücken der * -Taste wieder auf. Alle weiteren Operationen (einschließlich Rückkehr per Return-Taste) können nur am gestoppten LISTing vorgenommen werden.</li>
            <li>Drücken der Cursor-Down-Taste läßt die jeweils nächste Basic-Zeile erscheinen (mit der üblichen Repeat-Funktion der Cursor-Taste und dem Bildschirm-Scrollen nach oben bei vollem Bildschirm).</li>
            <li>Drücken der Cursor-Right-Taste sucht diejenige Basic-Zeile auf, die auf die letzte auf dem Bildschirm befindliche Zeile folgt, addiert zur Zeilennummer den Wert 4 x 256 und läßt, angefangen bei der sich so ergebenden Zeile, nach Löschung des Bildschirms, fünf aufeinanderfolgende Basic-Zeilen erscheinen. (Der Wert 4 in 256 kann im Programm nach Listing 1 in Zeile 630 abgeändert werden.) Das Ganze bewirkt also, grob gesagt, ein schnelles Durchsuchen des Listings in Sprüngen von 1024 (oder einem vom Benutzer abgeänderten Vielfachen von 256). Ist die Zeile mit der um den Wert 1024 erhöhten Nummer gar nicht vorhanden, was den Normalfall darstellt, da ja 1024 für das Listing als willkürlich gewählter Wert erscheint, wird die darauffolgende Zeile als erste der fünf auszugebenden Zeilen genommen. Genauer gesagt, werden nur vier ausgegeben, da die Suchschleife in diesem Fall einen Leerlaufschritt macht.</li>
            <li>Drücken der Cursor-Up-Taste (Cursor mit Shift) löscht den Bildschirm und läßt, ausgehend von der jeweils letzten Basic-Zeile auf dem Bildschirm (genauer: von der auf diese folgenden Zeile), fünf aufeinanderfolgende Basic-Zeilen erscheinen. (Die Zahl 5 kann im Programm nach Listing 1 in Zeile 770 abgeändert werden.) Jedes weitere Drücken der Cursor-Up-Taste nimmt die zur ersten auf dem Bildschirm befindlichen Basic-Zeile vorhergehende Zeile und läßt fünf aufeinanderfolgende Zeilen erscheinen (mit der üblichen Repeat-Funktion der Cursor-Up-Taste). Bei Erreichen der absolut ersten Zeile des LISTings wird dieser Vorgang mit der absolut letzten Zeile fortgesetzt und so weiter. (Rückwärtsverschieben des LISTings über die Anfangszeile hinaus).</li>
        </ol>

        <p>Alle verwendeten Cursor-Tasten behalten ihre Repeat-Funktion bei. Das Rückwärtslisten ist dreimal langsamer als das Vorwärtslisten über die * - oder Cursor-Down-Taste und nur zum Einpendeln gedacht: Überblick mit *, Grobabstimmung mit Cursor right, Feinabstimmung mit Cursor down, Korrektur mit Cursor up, endgültige Feinabstimmung mit Cursor down.</p>

        <p>Will man das LISTing mit einer vorgegebenen Zeilennummer Y*256+X beginnen lassen, was wegen der oben erwähnten schnellen Durchsuchungsmöglichkeit in Schritten von 1024 an sich nicht nötig ist, so ersetze man den Aufruf GOSUB 500, beziehungsweise GOSUB 580, durch POKE 780, Y:POKE 781, X:GOSUB 500, beziehungsweise POKE 780, Y: POKE 781, X: GOSUB 580.</p>

        <p>Für das Maschinenprogramm wird der Trick verwendet, geeignete Teile des Betriebssystems in den Kassettenpuffer zu kopieren und dort durch einige wenige POKE-Anweisungen abzuändern und miteinander zu verbinden. Es werden keine DATA-Zeilen benötigt, wodurch die bekannten Schwierigkeiten mit dem im VC 20-Basic nicht vorhandenen »RESTOREn« umgangen werden.</p>

        <p>Neben der eben beschriebenen langen Form des Programms zum Endloslisten nach Listing 1 schlagen wir in Listing 2 noch eine kurze Form vor. Für diese gelten die oben beschriebenen Punkte 1 bis 5 (* -Taste: Lauf, *-Taste: Stillstand, Cursor-Down-Taste: Zeile für Zeile — endlos, Cursor-Right-Taste: Schrittweite 1024, Return-Taste: Rückkehr). Sowohl das Maschinenprogramm als auch das einbettende Basic-Programm sind wesentlich kürzer. Der Hauptaufand wurde im Programm nach Listing 1 für die Organisation des Rückwärtslaufes benötigt.</p>

        <address class="author">(Fred Behringer/ev)</address>

        <figure>
            <table class="plain nobreak0">
                <tr>
                    <td>Zeile</td>
                    <td></td>
                </tr>
                <tr>
                    <td>510-570</td>
                    <td>Aufbau des Maschinenprogramms im Kassettenpuffer durch Aneinanderreihung von Teilen des Betriebssystems und leichte Ergänzungen und Abänderungen.</td>
                </tr>
                <tr>
                    <td>510</td>
                    <td>Übergabe der X/A-Register (dort steht die Nummer der zu listenden Basic-Zeile) an $0014/$0015 (20/21).</td>
                </tr>
                <tr>
                    <td>520</td>
                    <td>$C163-$C636 (50707-50742). Startadresse einer Basic-Programmzeile berechnen. Zeilennummer in $0014/$0015 (20/21).</td>
                </tr>
                <tr>
                    <td>530</td>
                    <td>$X708-$C711 (50952-50961). Festhalten der jeweils erreichten Zeilennummer in der Suchschleife und Ablegen nach $00FD/$00FE (6253/254). Nach Erreichen der Adresse der gesuchten Zeilennummer in $0014/$0015 (20/21) steht in $00FD/$00FE (253/254) die Nummer der vorhergehenden Zeile. Ist die Nummer in $0014/$0015 (20/21) nicht größer als die erste Zeile des zu listenden Programms, dann wird $C708-$C711 übersprungen und $00FD/$00FE (253/254) behält seinen alten Wert bei.</td>
                </tr>
                <tr>
                    <td>540</td>
                    <td>$C637-$C63F (50743-50751). Weiter in der Suchschleife zur Berechnung der Adresse derjenigen Zeile, deren Nummer in $0014/$0015 (20/21) steht. Die Adresse wird an $005F/$0060 (95/96) ausgegeben. Existiert diese Zeile nicht, dann erscheint die Adresse der nächstfolgenden Zeile. In den X5A-Registern steht jeweils die Nummer (Low-Byte, High-Byte) derjenigen Zeile, welche auf die Zeile folgt, deren Adresse in $005F/$0060 (95/96) gelegt wurde. Ist die in $0014/$0015 (20/21) eingegebene Zeilennummer nicht kleiner als die Nummer der größten Zeile des zu listenden Programms, dann werden X/A mit (für unsere Zwecke) unbrauchbaren Werten belegt; jedoch erhält dann (und nur dann) das Y-Register den Wert 1 (siehe unten Zeile 780). Das Basic-Rahmenprogramm erhält die jeweiligen A-, X-, Y-werte über $030C-$030E (780-782).</td>
                </tr>
                <tr>
                    <td>550</td>
                    <td>$C6C9-$C741 (50896-51009). Eigentliches Programm zum Auflisten der gewünschten Zeile. Normalerweise Zeilenvorschub, der in 790 (siehe unten) korrigiert wird. Bei Erreichen der letzten Zeile Austritt ohne Zeilenvorschub, was in Zeile 780 (siehe unten) steht.</td>
                </tr>
                <tr>
                    <td>560</td>
                    <td>Abänderungen von Sprungadressen und Korrektur der Zeilennummer, so daß bei der letzten Zeile in $00FD/$00FE (253/254) abgelegt wird (siehe unten Zeile 530).</td>
                </tr>
                <tr>
                    <td>570</td>
                    <td>Ergänzung um einen DEY-Befehl $0088 (136). Abänderung zweier Sprungadressen. Sorge dafür, daß nach LISTen der betreffenden Zeile nicht zum Basic-Warmstart gesprungen wird, sondern an die SYS-Rücksprungadresse des aufrufenden Basic-Programms. Das wird durch Überschreiben des Inhalts von $C714 (50964) (natürlich in der Kassettenpuffer-Kopie) mit dem RTS-Befehl $0060 (96) erreicht.</td>
                </tr>
                <tr>
                    <td>580</td>
                    <td>Listen, solange nicht *.</td>
                </tr>
                <tr>
                    <td>590-600</td>
                    <td>Sonst: Wenn {Cursor down}, dann eine Zeile listen.</td>
                </tr>
                <tr>
                    <td>610</td>
                    <td>Wenn wieder *, dann listen, solange nicht abermals *.</td>
                </tr>
                <tr>
                    <td>620-630</td>
                    <td>Wenn {Cursor right}, dann Sprung um 1024.</td>
                </tr>
                <tr>
                    <td>640</td>
                    <td>Wenn {Return}, dann zurück.</td>
                </tr>
                <tr>
                    <td>650</td>
                    <td>Wenn nicht {Cursor up}, dann Neubeginn der Eingabeschleife.</td>
                </tr>
                <tr>
                    <td>660</td>
                    <td>Nummer der vorhergehenden Zeile in X/Y.</td>
                </tr>
                <tr>
                    <td>670-680</td>
                    <td>Wenn größer, dann Korrektur für Null und fünf Zeilen listen.</td>
                </tr>
                <tr>
                    <td>690</td>
                    <td>Neubeginn der Eingabeschleife.</td>
                </tr>
                <tr>
                    <td>700-720</td>
                    <td>Wenn nicht {Cursor up}, dann Korrektur für Nulldurchgang und fünf Zeilen listen.</td>
                </tr>
                <tr>
                    <td>740</td>
                    <td>Abermaliger Beginn der Eingabeschleife.</td>
                </tr>
                <tr>
                    <td>750-760</td>
                    <td>Wenn {Cursor up}, dann Vorgänger der Zeile, deren Nummer in X/Y liegt (Anfangszeile des angegebenen Fünferblocks) als Anfangszeile des neuen Fünferblocks nehmen und fünf Zeilen ausgeben.</td>
                </tr>
                <tr>
                    <td>770</td>
                    <td>Ausgabe von fünf aufeinanderfolgenden Zeilen.</td>
                </tr>
                <tr>
                    <td>780-800</td>
                    <td>Ausgabe einer Zeile</td>
                </tr>
                <tr>
                    <td>790</td>
                    <td>und Korrektur für Programme.</td>
                </tr>
            </table>
            <figcaption>Beschreibung des Programms zum Endloslisten nach
                Listing 1 (»lange Form«, mit Rückwärtslisten).</figcaption>
        </figure>

        <figure>
            Das Programm Listing 2 ist eine verkürzte Form des Programms nach Listing 1. In Zeile 920 von Listing 2 werden die Zeilen 520 bis 540 von Listing 1 zusammengefaßt. Die Einschubzeile 530 in Listing 1, die die Nummer der jeweils vorhergehenden Zeile zwischenspeichert, wird in Listing 2 nicht benötigt. Die Zeilen 650 bis 760 in Listing 1 organisieren das Rückwärtslisten und werden im Programm nach Listing 2 nicht benötigt.
            <figcaption>Beschreibung des Programms zum Endloslisten nach Listing 2 (kurze Form, ohne Rückwärtslisten).</figcaption>
        </figure>

        <figure>
            <pre data-filename="endlos lang" data-name="Endloslisting (lang)"></pre>
            <figcaption>Listing 1. Programm für Endloslisting, »lange Form« (vorwärts und rückwärts). Ansprung per GOSUB 500. Einlesezeit für Maschinenprogramm in den Kassettenpuffer 2,5 sec. Jeder weitere Ansprung per GOSUB 580.</figcaption>
        </figure>

        <figure>
            <pre data-filename="endlos kurz" data-name="Endloslisting (kurz)"></pre>
            <figcaption>Listing 2. Programm für Endloslisting, »kurze Form« (nicht rückwärts). Ansprung per GOSUB900. Einlesezeit wie in Listing 1. Jeder weitere Ansprung per GOSUB950.</figcaption>
        </figure>
    </article>
</body>

</html>
