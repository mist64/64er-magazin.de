<!DOCTYPE html>
<html lang="de">

<head>
    <title>Assembler ist keine Alchimie — Teil 12</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Heimo Ponnath, gk">
    <meta name="64er.issue" content="9/85">
    <meta name="64er.pages" content="109-111,131">
    <!-- <meta name="64er.toc_category" content="XXX"> -->
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="XXX">
</head>

<body>
    <article>
        <h1>Assembler ist keine Alchimie — Teil 12</h1>
<blockquote><p>Wie macht man Programme Reset-fest? Außerdem schauen wir dem »Rasterzeilen-Interrupt« etwas genauer auf die Finger und entwickeln ein Programm dazu.</p></blockquote>

<h2>Die Sache mit dem Modulstart</h2>

<p>Sowohl beim RESET als auch beim NMI haben wir festgestellt, daß der Modulstart-Bereich ab $8000 eine besondere Rolle spielt. In Bild 5 finden Sie nochmal zusammengefaßt, was sich dort findet wenn ein Modul vorhanden ist.</p>

<p>Wir wollen im folgenden Beispielprogramm (Listing 1) ein Modul simulieren, indem wir den SMON mittels des RESET anspringen. Der NMI — also die RUN/STOP-RESTORE-Tastenkombination — soll dabei wirkungslos gemacht werden.</p>

<p>Bild 6 zeigt ein Flußdiagramm dieses Beispielprogrammes:</p>

<p>Achten Sie bitte darauf, daß Sie nach dem Eintippen des Programmes abspeichern und — natürlich — daß die SMON-Version ab $C000 im Speicher vorliegt. Mit SYS 24576 starten Sie unser Programm, in dem durch diesen SYS-Befehl zunächst nach $8000/1 die Startadresse einer neuen RESET-Serviceroutine geschrieben wird und nach $8002/3 die der neuen NMI-Routine. Außerdem wird die Modulkennung in die vorgeschriebenen Speicherplätze eingetragen. Wenn Sie nun mal die RESTORE-Taste — oder RUN/STOP und RESTORE — drücken, passiert offensichtlich nichts. Das liegt daran, daß unser Programm lediglich die auf den Stapel gelegten Register wieder zurückholt und aus der Unterbrechung mit RTI ins normale Geschehen zurückkehrt.</p>

<p>Haben Sie einen RESET-Taster eingebaut? Dann drücken Sie doch mal drauf. Zunächst erkennen Sie den normalen RESET-Verlauf. Dann meldet sich aber nicht wie gewohnt die Nachricht CBM-Ba-sic&hellip;, sondern der SMON mit einer Registeranzeige. Das RESET-Pro-gramm ab $602E folgt dem Firmware-Programm. Lediglich der letzte Sprungbefehl ist anders und führt statt ins Basic in den SMON. Der SMON wird fehlerfrei funktionieren&hellip; solange Sie nicht versuchen, mit dem X-Kommando wieder ins Basic zurückzukehren. Dann wird Unsinn passieren, denn auf einen Start mittels RESET ist der SMON nicht gefaßt gewesen und in den Speicherstellen, die sonst eine Rückkehradresse enthalten, befindet sich nichts Sinnvolles. Es ist daher auch nicht möglich, den SMON wieder zu verlassen — außer durch Speicherstellenmanipulationen oder die Notbremse: Aus- und wieder Einschalten. Auf diese Weise (und mittels eines AUTOSTART) sichern sich Softwarehäuser manchmal gegen unbefugtes Kopieren ihrer Programme.</p>

<h2>Nutzung der Unterbrechungen</h2>

<p>Sowohl was die Hardware als auch die Firmware für die Unterbrechungsbehandlung angeht, haben wir nun einen guten Überblick gewonnen. Es ist jetzt an der Zeit, daß wir uns ansehen, auf welche Weise man dieses Reservoir an vielfältigen Möglichkeiten für sich nutzen kann. Dazu soll uns ein Überblick dienen:</p>

<p>I)  Auslösung der Unterbrechung durch Hardware-Einwirkungen.</p>

<p>Da hätten wir beispielsweise den Userport oder den Expansion-Port, über die wir per CIAs Unterbrechungen anfordern können. Um es gleich zu sagen: Damit werden wir uns nicht auseinandersetzen. Meine Kenntnisse auf diesem Gebiet sind zu dünn. Aber vielleicht verstehen Sie das auch mal als Aufforderung, Ihre Versuche dazu anderen zu offenbaren? Also: Schreiben Sie doch mal!</p>

<p>II) Unterbrechungsauslösung per Software:</p>

<p>Damit haben wir immer noch ein weites Feld von Möglichkeiten vor uns:</p>

<p>IIa) Vorgesehene Nutzungen des IRQ</p>

<ul>
<li>mittels des VIC-II-Chips.</li>
</ul>


<p>Da können wir uns auf den Rasterzeileninterrupt, die Spri-te/Hintergrund- oder die Sprite/Sprite-Kollision stützen.</p>

<ul>
<li>oder mit Hilfe des CIA1</li>
</ul>


<p>Da ist es vor allem der 60mal pro Sekunde auftretende Timer A-Unterlauf, der uns interessieren soll.</p>

<p>IIb) Vorgesehene Nutzungen des NMI</p>

<ul>
<li>CIA2: Läßt man die RS232C-Schnittstellenbehandlung außer acht, dann gibt es keine vorgesehene Nutzung.</li>
<li>RESTORE: Zusammen mit der RUN/STOP-Taste kann man die vorgegebene Routine verändern, wie wir es schon in einigen Beispielen gezeigt haben.</li>
</ul>


<p>Wir können außerdem noch unterscheiden zwischen Nutzungen, die periodisch stattfinden sollen (zum Beispiel eine spezielle Tastaturabfrage) und solchen, die stochastisch (= zufallsabhängig) oder willkürlich erfolgen (zum Beispiel Drücken der RESTORE-Taste). Beides ist auch durchführbar bei:</p>

<p>IIc) Nicht vorgesehene Nutzung der Unterbrechungen.</p>

<p>Da bietet sich vor allem der meistens völlig brach liegende CIA2 an mit seinen beiden Timern und der Alarmfunktion.</p>

<p>Wenn Sie aber erst einmal vertraut sind mit der Unterbrechungs-Programmierung und auch etwas Zeit zum Tüfteln investieren, finden Sie bestimmt noch eine ganze Menge weiterer Möglichkeiten.</p>

<p>Bei mehreren gleichartigen Unterbrechungsanforderungen (zum Beispiel IRQs) muß noch ein Weg gefunden werden, wie zwischen den dann vielleicht anfallenden unterschiedlichen Service-Routinen differenziert werden kann. Denkbar wären beispielsweise Aufgabenstellungen wie:</p>

<p>Jeder 3. Timer-IRQ soll denJoystick abfragen, oder RESTORE + h soll den Hilfsbildschirm zeigen, RESTORE + z soll den aktuellen Bildschirm wieder restaurieren, etc.</p>

<p>Sie sehen, eine große Menge Arbeit wartet auf uns. Nicht zu allen Möglichkeiten werde ich hier Beispielprogramme zeigen. Außerdem dürfen die dann auch nicht zu undurchsichtig sein und man sollte möglichst den Erfolg eines solchen Demo-Programmes auf dem Bildschirm erkennen können. Trotzdem hoffe ich, daß die nachfolgend und noch in der nächsten Folge gezeigten Programmlösungen ausreichen, Ihnen die Unterbrechungs-Behandlung mit eigenen Routinen durchschaubar zu machen. Ich will Ihnen aber nicht verschweigen, daß auch mir noch längst nicht alle Geheimnisse der Unterbrechungsprogrammierung offenbar geworden sind. Oft finde ich mich unversehens in Programm-Sackgassen wieder. Das soll Ihnen als kleiner Trost dienen, wenn Sie mal nach dem 1001. Absturz müde und mit rauchendem Kopf vor Ihrem Commodore-Ungeheuer sitzen.</p>

<h2>Ein Programm zum VIC-II-IRQ</h2>

<p>Sehr schöne Effekte lassen sich durch eine periodische IRQ-Anforderung per Rasterzeileninterrupt mittels des VIC-II-Chip erzielen. Deshalb ist sowas auch ein beliebtes Objekt für Demos von Unterbrechungsprogrammen. Als Ziel setzen wir uns, einen Bildschirm zu konstruieren, dessen Rahmen in allen Farben schillert.</p>

<p>Leser der Grafikserie werden diese Möglichkeit des VIC-II-Chip schon kennen: Man kann dem Kathodenstrahl, der über den Monitor huscht, um das Bild zu erzeugen, über zwei Register folgen, die Rasterregister, wo jede Rasterzeile mitgezählt wird. Ohne an dieser Stelle allzusehr in die Einzelheiten einzugehen, soll hier nur bemerkt werden, daß die Numerierung dabei etwa von 0 bis 280 geht, weil auch der Rahmen und nicht sichtbare Teile des Bildschirmes vom Strahl überstrichen werden. Wo das Textfeld anfängt, ist von Monitor zu Monitor (oder Fernseher) etwas unterschiedlich. Bei mir beginnt es oben in Rasterzeile 50 und endet unten bei Zeile 248. Sollten die im Beispielprogramm 2 (Listing 2) nachher voreingestellten Randwerte bei Ihnen also anders sein, können Sie sie durch einige später noch angegebenen POKEs ändern. Die beiden Rasterzeilenregister sind:</p>

<p>$D012 (53266)<br/>
$D011 (53265)</p>

<p>Von $D011 allerdings ist nur das Bit 7 als msb der Rasterzeilenzahl für uns von Bedeutung. Bild 7 soll diese Belegung deutlich machen:</p>

<p>Das Interessante an diesen Registern ist nun, daß man auch in sie schreiben kann. Die auf diese Weise festgelegte Rasterzeile ist dann der Auslöser des IRQ, falls dieser im Interrupt-enable-Register $D01A freigegeben wurde (das kennen wir noch aus der letzten Folge).</p>

<p>Damit kann also unsere primäre Unterbrechungsquelle (der VIC-II-Chip) programmiert werden. Halten wir die zwei Schritte dazu nochmal fest:</p>

<p>1)  Rasterzeile festlegen, bei der ein IRQ ausgelöst werden soll, durch Einschreiben in die Register $D012 und Bit 7 von $D011.</p>

<p>2)  Freigeben des Rasterzeileninterrupts durch Einschreiben von 1000 0001 in das Interrupt-enable-Register $D01A.</p>

<p>Der nächste Schritt betrifft die Bearbeitung des IRQ durch die CPU. Wie wir vorhin sahen, springt das Programm beim IRQ mittels eines indirekten Sprunges, der auf den Vektor 788/9 ($314/5) zugreift. Dieser Vektor muß nun auf die eigene Routine verbogen werden, also:</p>

<p>3)  Vektor $314/5 auf die IRQ-Service-Routine richten.</p>

<p>Damit wären alle Vorbereitungen getroffen. Der Rest liegt nun ganz bei uns — beziehungsweise bei dem von uns zu schreibenden Service-Programm. Als Bild 8 finden Sie ein Flußdiagramm unseres Beispielprogrammes 2.</p>

<p>Gehen wir nun an die Realisierung. Zunächst also die Initialisierung, die wir bei $6000 (also durch SYS 24576zu starten) beginnen lassen:</p>

<p>TODO</p>

<p>6000    SEI Sperren von IRQs<br/>
Schritt 3:<br/>
6001    LDA #$28    LSB der IRQ-Routine<br/>
6003    STA 0314    in IRQ-Vektor-LSB<br/>
6006    LDA #$60    MSB der IRQ-Routine<br/>
6008    STA 0315    in IRQ-Vektor-MSB<br/>
Schritt 1:<br/>
600B    LDA #$F8    Rasterzeile, bei der das Textfenster endet. Von da an soll der Rahmen schwarz sein.<br/>
600D    STA D012    in Rasterzeilen-Register (LSB) schreiben.<br/>
6010    LDA D0l1    Register mit dem msb des Rasterzeilenzählers<br/>
6013    AND #$7F    0111 1111 löscht das Bit7<br/>
6015    STA D011    Zurückschreiben. Damit ist die Rasterzeile, die den IRQ auslösen soll, festgelegt.<br/>
Schritt 2:<br/>
6018    LDA #$81    1000 0001 wird nun<br/>
601A    STA DOlA    ins IRQ-enable-Register geschrieben, um den Rasterzeilen-IRQ zuzulassen.<br/>
Festlegen einiger Startwerte:<br/>
601D    LDA #$00    Farbe schwarz<br/>
601F    STA D020    in Rahmen schreiben<br/>
6022    LDA #$04    Streifenbreite in<br/>
6024    STAO2   Merkregister schreiben.<br/>
6026    CLI IRQ freigeben<br/>
6027    RTS Ende der Initialisierung.<br/>
Von nun an laufen alle IRQs über unsere eigene Routine, die bei $6028 beginnt.<br/>
Zunächst müssen wir prüfen, ob die Unterbrechung vom VIC-II-Chip kommt oder vom CIA1:<br/>
6028    LDA D019    IRQ-Request-Register des VIC-II-Chip (siehe letzte Folge). Dort ist Bit 7 gesetzt, wenn die Anforderung vom VIC-II-Chip kam.<br/>
602B    STA D019    Zurückschreiben<br/>
602E    BMI 6037    Sprung, falls VIC-IRQ, sonst CIA-IRQ.<br/>
Bearbeiten eines CIA-IRQ:<br/>
6030    LDA DCOD    Löschen des CIA1 Unterbrechungs-Kontrollregisters.<br/>
6033    CLI IRQ zulassen. Damit können innerhalb eines CIA- IRQ auch unsere VIC-IRQs geschehen.<br/>
6034    JMP EA31    Bearbeitung des CIA-IRQ durch die normale Routine.<br/>
Unser Programm für VIC-II-IRQs:<br/>
6037    LDA D012    Rasterzeilen-Register laden um festzustellen, welche Zeile den IRQ auslöste.<br/>
603A    CMP #$F8    Vergleich mit Ende des Textfensters.<br/>
603C    BCS 604F    Wenn unterhalb des Textfensters,<br/>
Sprung.<br/>
Der folgende Programmteil ist wirksam, wenn der IRQ-Auslöser eine Zeile in Höhe des Textfensters war:<br/>
603E    CLC Addition vorbereiten.<br/>
603F    ADC 02  Streifenbreite aus dem Merkregister addieren.<br/>
6041    STA D012    Neuen Wert in Rasterzeilen-Register schreiben.<br/>
Damit wird eine neue Rasterzeile als IRQ-Auslöser festgelegt, die um die Streifenbreite tiefer liegt als die vorhergegangene.<br/>
Es folgt eine kleine Verzögerungsschleife, die aber nur zum Experimentieren eingebaut wurde:<br/>
6044    LDY #$03    Schleifen-Startwert<br/>
6046    DEY Herunterzählen<br/>
6047    BNE 6046    NEXT Y, bis Y= 0.<br/>
Ändern der Rahmenfarbe bis zum nächsten Raster-IRQ:<br/>
6049 INC D020   Farbcode + 1. Wenn Code im Rahmenfarbregister größer als 15 wird, fängt wieder Farbcode 0 an, weil die Bits 5-7 keine Funktion haben.<br/>
Abschließend erfolgt der Rücksprung in den Rest der normalen IRQ-Routine:<br/>
604C JMP EA81 Siehe unsere Untersuchung der IRQ-Firmware.<br/>
Damit ist der Rahmen in Höhe des Textfensters behandelt. Es schließt sich nun der Teil an, der die Rahmenbereiche unter- und oberhalb bearbeitet:<br/>
604F    LDA #$00    Farbcode schwarz<br/>
6051    STA D020    in Rahmenfarb-Register.<br/>
6054    LDA #$32    Rasterzeile, bei der oben das Textfenster beginnt.<br/>
6056    STA D012    In Rasterzeilen-Register schreiben<br/>
6059    JMP EA81    Abschluß durch Sprung zum Ende der normalen IRQ- Routine.<br/>
Damit ist festgelegt, daß ober- und unterhalb des Textfensters die<br/>
Rahmenfarbe schwarz wird.<br/>
Unsere eigene Routine ist jetzt abgeschlossen. Zum guten Ton gehört es, dem Benutzer auch die Möglichkeit zu öffnen, diese Routine wieder abzuschalten. Das erfolgt im letzten Programmteil, der mittels SYS24688 aktiviert werden kann:<br/>
605C    SEI IRQ sperren<br/>
605D    LDA #$00    Raster-IRQ<br/>
605F    STA D01A    abschalten<br/>
6062    LDA #$31    IRQ-Vektor<br/>
6064    STA 0314    restaurieren<br/>
6067    LDA #$EA<br/>
6069    STA 0315<br/>
606C    LDA #$0E<br/>
606E    STA D020<br/>
6071    CLI<br/>
6072    RTS</p>

<p>Unser Programm ist komplett. Speichern Sie es bitte vor dem Starten ab. Nach dem SYS 24576 finden Sie einen hübschen bunten Rahmen vor, oberhalb und unterhalb des Textfensters ist er schwarz. Besonders gut — finde ich — sieht das Ganze aus, wenn man die Hintergrundfarbe des Textfensters auch auf Schwarz setzt. Das Programm erlaubt noch einige Experimente:</p>

<p>Durch POKE-Kommandos in die Speicherstelle 2 kann die aktuelle Streifenbreite variiert werden, durch POKEs in die Zelle 24645 der Startwert der Verzögerungsschleife. Probieren Sie’s doch mal aus. Eine Erkenntnis werden Sie gewinnen: In der Unterbrechungs-Programmie-rung spielt die Zeit eine wichtige Rolle. Das zeigt sich auch, wenn man zum Beispiel Cursorbewegungen durchführt: Die Streifen fangen an zu wandern.</p>

<p>Weitere Möglichkeiten zum Experimentieren sind gegeben, wenn Sie die Rasterzeilen verändern, die den oberen und unteren Rand des Textfensters markieren:</p>

<p>Durch POKE 24661,Zahl verschieben Sie die obere, durch POKE 24635,X:POKE 24588,X die untere Rasterzeile, von der an alles schwarz ist. Wie schon vorhin erwähnt, habe ich im Programm diese Werte auf 50 beziehungsweise 248 fixiert, weil genau dort auf meinem Monitor das Textfenster liegt.</p>

<p>Mit diesem Beispiel und dem aus der Grafikserie sollte es Ihnen nun möglich sein, auch andere Unterbrechungsprogramme zu schreiben, die sich der Rasterzeilen-Unterbrechung per VIC-II-Chip bedienen. Eine Bemerkung sollte ich Ihnen noch auf den Weg Ihrer eigenen Versuche mitgeben: Der Elektronenstrahl, der über den Bildschirm saust und beim Erreichen des von uns bestimmten Rasterzeilenwertes zum Auslösen des IRQ führt, ist enorm schnell. Die Serviceprogramme dürfen deshalb nicht zu lang sein, sonst steht der nächste IRQ schon wieder an, bevor der ’vorangegangene bearbeitet ist.</p>

<p>In der kommenden Folge sollen Beispiele für andere Unterbrechungsformen vorgestellt werden, die durch die CIAs und die RESTORE-Taste angesprochen werden. Danach soll es um die Anwendung des bisher Gelernten gehen, wobei wir uns wieder mehr den Interpreter-Routinen und auch den Kernal-Möglichkeiten zuwenden wollen.</p>

<address class="author">(Heimo Ponnath/gk)</address>
    </article>
</body>
</html>
