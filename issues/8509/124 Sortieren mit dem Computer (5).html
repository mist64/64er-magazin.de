<!DOCTYPE html>
<html lang="de">

<head>
    <title>Sortieren mit dem Computer (5)</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="K. Schramm, gk">
    <meta name="64er.issue" content="9/85">
    <meta name="64er.pages" content="124-127,130-131">
    <meta name="64er.toc_title" content="Sortieren mit dem Computer (Teil 5)">
    <meta name="64er.toc_category" content="Kurse">
    <meta name="64er.id" content="effektiv">
</head>

<body>
    <article>
        <h1>Sortieren mit dem Computer (5)</h1>
        <p class="intro">Ein ausführlicher Geschwindigkeitsvergleich aller bisher erarbeiteten Sortieralgorithmen soll die Spreu vom Weizen trennen. Und ein weiteres Sortieralgorithmus wird vorgestellt.</p>

        <p>Entgegen der anderslautenden Vorhersage im letzten Teil unseres Kurses, soll heute noch einmal auf Sortieralgorithmen in Basic eingegangen werden. Dieser Entschluß wurde aus mehreren Gründen gefaßt.</p>

        <p>Erstens trafen nach Erscheinen der letzten Ausgabe mehrere interessante Beiträge zum Thema Sortieren in der Redaktion ein. Zweitens soll noch einmal ein grafischer Vergleich sämtlicher Routinen stattfinden, und drittens werden wir uns heute noch ein wenig mit den Vor-und Nachteilen der einzelnen Sortiermethoden beschäftigen.</p>

        <p>Als erstes soll eine Verbesserung an den Mann gebracht werden. Heinrich Studer schickte der Redaktion einen Sortieralgorithmus, der dem schon bekannten Straight Selection stark ähnelt, wegen seines einfacheren Aufbaus jedoch weniger Speicherplatz benötigt. Der Einfachheit halber soll dieser Sortieralgorithmus den Namen Minisort bekommen.</p>

        <p>Wie Sie aus dem Flußdiagramm in Bild 1 sehen können, besteht Minisort aus zwei geschachtelten FOR-NEXT-Schleifen. In der äußeren Schleife wird jeweils der Reihe nach ein Element genommen und mit sämtlichen Elementen der inneren Schleife verglichen. Wird während eines Vergleichs festgestellt, daß das andere Element aus dem Restfeld kleiner als unser Vergleichswert ist, so werden beide Variablen vertauscht.</p>

        <p>Ist die innere Schleife also einmal durchlaufen worden, so befindet sich das kleinste Element des Gesamtfeldes nun an erster Stelle.</p>

        <p>Jetzt wird in der äußeren Schleife zum nächsten Element übergegangen, wobei dieses wiederum mit dem Restfeld verglichen wird&hellip; und so weiter, bis man beim letzten Element angekommen ist. Es muß sich hierbei dann zwangsläufig um den größten Wert handeln.</p>

        <p>Für Minisort (Listing 1) wie auch für unsere übrigen Sortieralgorithmen gilt, daß sie das Hauptprogramm für ihren Betrieb benötigen. Das Hauptprogramm dient der Erstellung der verschiedenen Arrays und der Anzeige der erstellten und sortierten Felder. In Listing 2 wurde auch diesmal wieder das Hauptprogramm abgedruckt, da es um ein paar Sachen erweitert wurde. Es ist jetzt mit der Option »von Hand erstellen« zusätzlich möglich, jeweils vorwärts und rückwärts sortierte Felder zu erstellen, um die »Testkandidaten« (sprich: Sortierprogramme) auf Herz und Nieren zu testen.</p>

        <p>Um Ihnen jedoch einen großen Teil der Arbeit abzunehmen, habe ich für diese Folge unseres Kurses noch einmal sämtliche Sortierprogramme, die bisher besprochen wurden, in den drei Bereichen »Feld unsortiert«, »Feld vorwärts sortiert« und »Feld rückwärts sortiert« untersucht. Wir werden nachher noch ausführlich auf die Ergebnisse dieses »Monstertests« eingehen.</p>

        <p>Jetzt jedoch noch zu einem anderen Sortierprogramm, das uns Horst Armin Kosog eingesandt hat. Es trägt den Namen »Mischsort« und wurde von besagtem Absender anhand einer Aufgabenstellung aus einem Informatikbuch (H. Balzert, Informatik 1, Hueber-Holzmann Verlag, München 1976, Seite 210) erstellt und selbständig weiterentwickelt.</p>

        <p>Das Prinzip dieses Sortieralgorithmus ist folgendes:</p>

        <p>Ähnlich wie bei Quicksort wird das zu sortierende Array bei Mischsort in Untereinheiten (Teilfelder) untergliedert. Diese Teilfelder fangen bei der Größe 2 an und nehmen dann im Quadrat an Umfang zu (4,8,16,&hellip;).</p>

        <p>Zuerst werden die Untereinheiten der Größe 2 jeweils für sich sortiert, so daß wir A/2 (A ist die Anzahl der Elemente im Gesamtfeld), sortierte Teilfelder erhalten.</p>

        <p>Jeweils zwei benachbarte Teilfelder werden nun »zusammengemischt« und wiederum sortiert.</p>

        <p>Setzt man dies durch das gesamte Array fort, so erhalten wir nun A/4 sortierte Teilfelder der Länge 4.</p>

        <p>Als nächstes werden jeweils zwei benachbarte Teilfelder der Länge 4 zusammengemischt und sortiert&hellip; und so weiter, bis schließlich nur noch ein (Teil) Feld übrigbleibt, nämlich das Gesamtfeld.</p>

        <p>Diese Arbeitsweise sei noch einmal in Bild 2 grafisch dargestellt.</p>

        <p>Damit Sie beim Abtippen von Listings nicht aus der Übung kommen, haben wir auch zu Mischsort ein Programm (Listing 3). Es muß, wie alle übrigen Algorithmen auch, in unser Hauptprogramm eingefügt werden.</p>

        <p>Ein dokumentiertes Flußdiagramm zu Mischsort ist in Bild 3 abgedruckt.</p>

        <h2>Schneller als Quicksort!</h2>

        <p>Mit dieser Überschrift stellte kürzlich eine Zeitschrift für Personal Computer (Computer persönlich, Ausgabe 14/85) ein neues Sortierverfahren vor. Das Programm lief ursprünglich auf einem CBM 8032 und machte also keine Mühe bei der Umstellung auf den Commodore 64. Ein derartiger Beitrag darf natürlich in unserem Kurs nicht unerwähnt und unbesprochen bleiben, weshalb ich das Programm in unsere Reihe der Sortiermethoden aufgenommen habe.</p>

        <p>Das interessante an Supersort (so heißt das Wunderprogramm) ist sicherlich die Art und Weise, wie bei diesem Programm Zeit gespart wird. Wir haben es hier nämlich eigentlich mit zwei Sortierprogrammen zu tun.</p>

        <p>Das eine Sortierprogramm davon kennen wir bereits. Es handelt sich um Bubblesort 2, also die verbesserte Version des ursprünglichen Bubblesort. (Wir erinnern uns: die Verbesserung von Bubblesort bestand im Einführen eines Zeigers, der dafür sorgte, daß Bubblesort mit der Arbeit aufhört, sobald keine Vertauschungen mehr stattfinden. Dieser »Kunstgriff« sorgte dafür, daß Bubblesort 2 bei Feldern, die insgesamt schon sortiert sind, einige wenige Elemente aber neu eingeordnet werden müssen, äußerst schnell wird und die kürzesten Sortierzeiten überhaupt erreichen kann.).</p>

        <p>Bei Supersort nutzt man nun die Tatsache, daß Bubblesort bei Feldern bis maximal zehn Elementen sehr schnell arbeitet. Es wird also das Gesamtfeld einfach in Teilfelder mit maximal zehn Elementen aufgeteilt, die dann alle einzeln von Bubblesort nachsortiert werden.</p>

        <p>Damit die Teilfelder dann auch in der richtigen Reihenfolge stehen, wird das Gesamtfeld vorsortiert, wobei die Teilfelder entsprechend der Anfangsbuchstaben der Feldelemente zusammengestellt werden.</p>

        <p>Das Flußdiagramm von Supersort sehen Sie in Bild 4, wobei auf die detaillierte Darstellung von Bubblesort verzichtet wurde.</p>

        <p>Auf unser Hauptprogramm zugeschnitten können Sie Super-sort in Listing 4 finden. Es kann ohne weitere Änderungen mit den anderen Routinen dieses Kurses zusammenarbeiten.</p>

        <p>Nachdem wir nun eine ziemliche Menge von verschiedenen Sortieralgorithmen kennen, sollen diese jetzt auch einmal im Vergleich betrachtet werden. Für den Anwender stellt sich in der Regel nur die Frage, welches Sortierprogramm er für seine Problemlösung am besten verwenden kann, und diese Frage ist mitunter nicht so leicht zu beantworten.</p>

        <p>Für den Vergleichstest habe ich folgende Sortierprogramme verwendet:</p>

        <p>Straight Insertion, Straight Selection, Bubblesort 2, Shellsort, Heapsort, Quicksort, Supersort und Mischsort.</p>

        <p>Fangen wir mit den Bedingungen des Tests an. Die einzelnen Programme wurden mit vorsortierten und unsortierten Feldern getestet, wobei nur Stringarrays verwendet wurden. Während des Tests wurde die Anzahl der Elemente jedesmal vergrößert, damit sich anschließend ein Kurvendiagramm darstellen ließ.</p>

        <p>Die ersten fünf Algorithmen wurden mit 10,20,50,100 und 200 Elementen gemessen (Bubblesort nur bis 100). Die drei schnelleren Methoden Quicksort, Supersort und Mischsort wurden auch noch mit 500 Elementen geprüft.</p>

        <p>Höhere Anzahlen von Feldelementen waren aus mehreren Gründen nicht nötig.</p>

        <p>Erstens steigt die Sortierzeit einiger Routinen nach kurzer</p>

        <p>Zeit enorm an, was zu Werten außerhalb der Grafikskala führt.</p>

        <p>Zweitens kommt es zu Konflikten mit der Geduld des Testers, wenn zu viele Elemente verwendet werden (Bubblesort 2 benötigte beispielsweise bei 1000 rückwärts geordneten Elementen sage und schreibe 6702 Sekunden; das sind 1 Stunde 51 Minuten und 42 Sekunden!). Und drittens kommt ab einer gewissen Zahl an Feldelementen noch ein ganz anderes Problem zum Tragen, das sich Garbage Collection nennt und auch den schnellsten Sortieralgorithmus zur Verzweiflung bringt.</p>

        <p>Nun also zur Besprechung der Testergebnisse:</p>

        <p>Sehen Sie sich einmal Bild 5 an, es enthält die Testergebnisse von Bubblesort einmal grafisch dargestellt.</p>

        <p>Auf der X-Achse ist dabei die Anzahl der Elemente und auf der Y-Achse die benötigte Sortierzeit in Sekunden angeführt.</p>

        <p>Wie man erkennen kann, steigt die Sortierzeit dabei exponentiell an, was auf lange Wartezeiten hoffen läßt. Eine Ausnahme bilden jedoch die schon sortierten Felder. Hier zeigt sich Bubblesort von seiner besten Seite. Es stellt innerhalb von wenigen Sekunden fest, ob ein Feld schon sortiert ist und eignet sich deshalb hervorragend zum Einordnen weniger Elemente in ein großes sortiertes Feld.</p>

        <p>Bild 6 zeigt Straight Insertion in Aktion. Dieses Sortierprogramm zeigt ein ähnliches Verhalten wie Bubblesort und ist sogar noch ein wenig schneller. Die Anwendungsgebiete liegen also auf der gleichen Ebene wie bei Bubblesort: Einordnen weniger Elemente in ein großes vorsortiertes Feld (vielleicht ließe sich durch Straight Insertion Supersort noch ein wenig mehr »aufmöbeln« ?!?).</p>

        <p>Bild 7 macht uns mit der Charakteristik von Straight Selection vertraut, und man kann nicht verhehlen, daß dieser Sortieralgorithmus auf allen Gebieten langsam und uneffektiv arbeitet. Er lohnt sich der Einfachheit halber bei sehr kleinen Feldern mit unterschiedlichen Sortierungen.</p>

        <p>Bild 8 zeigt uns den ersten effektiven Algorithmus, der durchaus schon praktisch eingesetzt werden kann. Es handelt sich um Shellsort, und wir können unschwer erkennen, daß diese Kurve im Gegensatz zu der von Straight Selection schon ziemlich flach verläuft, was einen langsameren Anstieg der Sortierzeiten bei steigender Anzahl von Elementen zur Folge hat.</p>

        <p>Die Kurve in Bild 9 hat einen ganz ähnlichen Verlauf zur Kurve in Bild 8, nur ist die Steigung wieder um ein Stück flacher geworden. Heapsort läßt also durchaus auch praktische Anwendungen zu, es wird jedoch wegen seiner komplizierten Struktur kaum eingesetzt.</p>

        <p>Bild 10 zeigt den Zeitverlauf bei Quicksort. Das Erstaunliche an den höheren Sortieralgorithmen ist, daß sich alle Sortierzeiten, sowohl die von völlig unsortierten Feldern als auch die von sortierten Feldern ständig aneinander annähern, was auf einen sehr breit gefächerten Anwendungskreis dieser Sortiermethoden schließen läßt.</p>

        <p>Eine Sache sollte im Zusammenhang von Quicksort nicht unerwähnt bleiben: Supersort bedient sich Bubblesort zur Endsortierung seiner Teilfelder. Diese Methode ist auch bei Quicksort üblich, wenngleich wir das in unserem Kurs nicht berücksichtigt haben. Es zeigt sich nämlich in der Praxis, daß die »großen« Sortiermethoden bei kleiner werdenden Teilfeldern mitunter sehr schwerfällig arbeiten, weshalb es besser ist, diese Teilfelder (zirka 10 Elemente) an kleine (und bei diesen Größen auch schnelle) Sortieralgorithmen zu übergeben.</p>

        <p>Bild 11 macht uns mit der Geschwindigkeit von Supersort vertraut und bringt schon die erste Überraschung:</p>

        <p>Bei unsortierten Feldern bis zu 400 Elementen und bei aufwärts sortierten ist der Sortieralgorithmus schneller als Quicksort, bei abwärts sortierten langsamer. Außerdem zeigte sich Supersort im Test wenig entgegenkommend, was seine Zuverlässigkeit betrifft.</p>

        <p>Erstens baut Supersort seine Teilfelder mit Hilfe einer Stringvariable auf, die bekanntermaßen nur 255 Zeichen lang werden kann. Das hat den Haken, daß Supersort mit einer »?STRING TOO LONG«-Meldung ausstieg, sobald eine ganze Reihe von gleichartigen Elementen verarbeitet werden mußten. Das ist jedoch bei einem vorsortierten Feld leider oft der Fall. Aus diesem Grund mußte ich bei einer Zahl ab 100 sortierten Elementen mit dem Test aufhören.</p>

        <p>Zweitens fiel bei Supersort unangenehm auf, daß diese Sortierroutine nicht in der Lage ist, Strings zu sortieren, die Zahlen enthalten, was auf die Beschränkung auf 26 Zeichen des Alphabets zurückzuführen ist.</p>

        <p>Hätte Supersort, abgesehen von den obigen Schwächen, einwandfrei gearbeitet, so hätte man sicher auf interessante Meßwerte kommen können. Es zeigte sich jedoch schon bei den zufallssortierten Elementen, daß Supersort auf ganz andere Schwierigkeiten stößt, wenn die Zahl der Elemente über 500 hinaus geht. Auch hier wieder das berüchtigte Wort Garbage Collection. Supersort benötigt nämlich mehr Zwischenspeicher als Quicksort und wird somit von diesem überholt, sobald bei Supersort die Garbage Collection in Aktion tritt (und das tut sie natürlich früher als bei Quicksort).</p>

        <p>Natürlich kann man jetzt den Entwickler dieses Programms nicht des Lügens bezichtigen, wenn er behauptet: »Supersort ist schneller als Quicksort!«. Supersort ist nämlich ursprünglich auf einem CBM 8032 geschrieben worden, und dieser verfügt über eine andere Stringverwaltung als der C 64, was eine erheblich schnellere Garbage Collection zur Folge hat</p>

        <p>Für den C 64 gilt jedoch (leider): Supersort ist nur bedingt brauchbar, da es einige Schwächen aufweist, die Quicksort nicht hat.</p>

        <p>Nun zu Bild 12. Es zeigt den letzten der Sortieralgorithmen, nämlich Mischsort. Und hier erlebte ich die große Überraschung: Auch Mischsort ist schneller als die Normalversion von Quicksort (ohne Tricks mit kleineren Sortierroutinen). Mischsort zeigte im Test wahrhaftig traumhafte Zeiten für Basic-Sortierprogramme, die teilweise nur 50 Prozent der Zeiten von Quicksort betrugen. Es wurde auch deutlich, daß bei Mischsort die Garbage Collection noch später einsetzte als bei Quicksort (das Einsetzen der Garbage Collection ist an den »Knickstellen« der Graphen zu erkennen), was die guten Zeiten aber nur teilweise rechtfertigte.</p>

        <p>Mischsort ist genauso einsatzfähig wie Quicksort (ohne »Macken«) und kann deshalb als bestes Sortierprogramm dieses Tests betrachtet werden. Haben Sie viele große Felder zu sortieren, so spielt es bei diesem Algorithmus fast keine Rolle, ob die Felder vorsortiert sind oder nicht; schnell ist er auf jeden Fall.</p>

        <p>Noch eine Randbemerkung zum Schluß: Vielleicht haben Sie auch schon Methoden entwickelt, wie sie die Garbage Collection »in den Griff bekommen«. Haben Sie vielleicht als »Maschinensprachefreak« ein neues Basic-ROM geschrieben (mit besserer Stringverwaltung) oder haben Sie anhand unseres Vorkurses über Strings die Lösung des Problems gefunden?</p>

        <p>Die 64’er-Redaktion würde sich über Beiträge aus dem Leserkreis freuen. Vielleicht möchten Sie dazu beitragen, daß auch andere Anwender in den Genuß entsprechender Verbesserungen kommen?</p>

        <p>Schreiben Sie uns doch! Bestimmt können wir dann den einen oder anderen Trick mit in unsere Reihe aufnehmen.</p>

        <p>Bis zum nächsten Mal.</p>

        <address class="author">(K. Schramm/gk)</address>
    </article>
</body>

</html>
