<!DOCTYPE html>
<html lang="de">

<head>
    <title>Soft-Scrolling auf dem C 64</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Frank Barcikowski + Holger Vocke, ah">
    <meta name="64er.issue" content="Sonderheft 4/85">
    <meta name="64er.pages" content="110-111">
    <meta name="64er.toc_category" content="Grundlagen">
    <meta name="64er.id" content="scrolling">
</head>

<body>
    <article>
        <h1>Soft-Scrolling auf dem C 64</h1>
        <p class="intro">Soft-Scrolling in eigene Programme einzubauen, kann oft zum Problem werden. Wie es gemacht wird, zeigt Ihnen dieser Beitrag.</p>

        <p>Jeder kennt bestimmt Defender oder ähnliche Arcade-Games, bei denen die Hintergrundlandschaft über den Bildschirm zieht. Gemeint ist das sogenannte Smooth- oder Soft-Scrolling. Der Unterschied zwischen normalem und Soft-Scrolling ist, daß der Bildschirm beim Soft-Scrolling in Einerschritten (um ein Pixel) und beim normalen in Achterschritten (immer um acht Pixel gleichzeitig) verschoben wird.</p>

        <p>Beim Achterscrolling werden einfach die Speicherstellen des Video-RAMs (ab 1024/$0800) um jeweils eine Stelle nach links, rechts, oben oder unten verschoben.</p>

        <p>Zum Achterscrolling ein Beispiel in Basic:</p>

        <pre>10 REM Beispiel Nr. 1
20 PRINT CHR$(147);TAB(14);
30 PRINT "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
40 FOR I=1064 T0 1024 STEP -1
50 POKE I,PEEK (I-1)
60 NEXT
70 GOT0 40</pre>

        <p>Dieses Programm arbeitet zwar noch relativ schnell, aber wir werden später diese Aufgabe einem Assemblerprogramm übergeben.</p>

        <p>Das Alphabet wird nach dem Eintippen dieses Programms nach rechts herausgeschoben. Dieses Achterscrolling ist aber zu sprunghaft, und falls es schneller läuft, ist die gescrollte Schrift unleserlich.</p>

        <p>Das Soft-Scrolling bewirkt, daß die Schrift gleichmäßig fließend und damit leserlich gemacht wird. Wie scrollt man denn nun aber den Bildschirm um nur ein Pixel?</p>

        <p>Die Hauptrolle hierbei spielen die Speicherstellen 53248+17 (53248 = Basisadresse des Video-Chips +17 für das vertikale und 53248+22 für das horizontale Scrolling).</p>

        <p>Befassen wir uns zunächst mit dem horizontalen Scrolling. Die Speicheradresse 53248+22 ist folgendermaßen aufgebaut:</p>

        <p>Bit 7 bis 5 : Sind nicht benutzt</p>

        <p>Bit 4 : Zur Umschaltung auf Multicolor<br>
            Wichtig sind für unsere Anwendung nur:</p>

        <p>Bit 3 : Umschalten von 40 auf 38 Spalten</p>

        <p>Bit 0 bis 2 : Horizontales Scrolling</p>

        <p>Dazu ein Versuch:<br>
            POKE 53248+22,PEEK (53248+22) AND 248 OR 3</p>

        <p>Nun müßte sich der Bildschirm um drei Pixels nach rechts verschoben haben.</p>

        <p>Einige werden sich jetzt fragen, warum die ANDs und ORs?</p>

        <p>Nehmen wir einmal an, im Register 22 des VIC würde die Zahl 107 stehen. Diese Zahl wird mit 248 AND-verknüpft. Beide Zahlen müssen binär aufgeschlüsselt werden:</p>

        <table class="plain">
            <tr>
                <td style="text-align:right;">107 =</td>
                <td>01101011</td>
            </tr>
            <tr>
                <td style="text-align:right;">AND 248 =</td>
                <td>11111000</td>
            </tr>
            <tr>
                <td style="text-align:right; border-top:1px solid black;">ergibt</td>
                <td style="border-top:1px solid black;">01101000</td>
            </tr>
        </table>

        <p>Durch diese AND-Funktion werden also die Bits 0 bis 2 gelöscht. Die Bits 3 bis 7 ändern sich nie. Durch die OR-Funktion werden die entsprechenden Bits gesetzt:</p>

        <table class="plain">
            <tr>
                <td></td>
                <td style="text-align:right;">01101000</td>
            </tr>
            <tr>
                <td>OR 3</td>
                <td style="text-align:right;">00000011</td>
            </tr>
            <tr>
                <td style="border-top:2px solid;">ergibt</td>
                <td style="text-align:right; border-top:2px solid;">01101011</td>
            </tr>
        </table>

        <p>Die Bits für das horizontale Scrolling enthalten jetzt den Wert 3. Der höchste mit den Bits 0 bis 2 zu erreichende Wert ist 7, der niedrigste ist 0. Je größer der Wert in diesen drei Bits, desto weiter wird der Bildschirm nach rechts verschoben! Mit dieser Erkenntnis können wir den Bildschirm um sieben Pixels nach rechts rollen!</p>

        <pre>10 REM Beispiel Nr. 2
20 FOR 1=0 T0 7
30 POKE 53248+22,PEEK (53248+22) AND248 OR I
40 FOR T=0 T0 1000:NEXT T
50 NEXT I
60 RUN</pre>

        <p>Dieses Programm verschiebt den Bildschirm langsam von der normalen Position um sieben Pixel nach rechts. Dann wird er wieder auf die normale Position zurückgesetzt und rollt wieder nach rechts. Wie macht man es nun, daß der Bildschirm über das 7. Pixel hinausscrollt?</p>

        <p>Dies ist ganz einfach: Nachdem das 7. Pixel erreicht wurde, machen wir ein Achterscrolling, das heißt wir verschieben einen Bildschirmcode um ein Zeichen nach rechts. Gleichzeitig setzen wir das Scrollregister wieder auf Null und haben jetzt das 8. Pixel erreicht.</p>

        <figure>
            <img src="110-1.png" alt="">
            <figcaption>Bild 1. Grafische Erläuterung des Soft-Scrolling</figcaption>
        </figure>

        <p>Jetzt können wir die Prozedur wieder von vorne beginnen (dazu ein Flußdiagramm).</p>

        <p>S = SCROLLREGISTER</p>

        <p>Dieses Flußdiagramm muß nun noch in ein Programm umgesetzt werden. Würde das gesamte Programm in Basic geschrieben, wäre es ziemlich langsam. Deshalb wird im nachstehenden Listing das Achterscrolling in Assembler realisiert. Es scrollt die erste Zeile in Achterschritten nach rechts. Zuerst die Darstellung in Maschinensprache und dann in DATA-Zeilen:</p>

        <table class="plain">
            <tr>
                <td></td>
                <td>LDA $0427</td>
                <td>; STA $FB Speicherstelle 1063 merken</td>
            </tr>
            <tr>
                <td></td>
                <td>LDX #38</td>
                <td>; Bei Spalte 38 anfangen</td>
            </tr>
            <tr>
                <td>V</td>
                <td>LDA $0400,X</td>
                <td>; Bildschirmcode laden</td>
            </tr>
            <tr>
                <td></td>
                <td>INX</td>
                <td>; Um 1 erhöhen</td>
            </tr>
            <tr>
                <td></td>
                <td>STA $0400,X</td>
                <td>; DEX Und abspeichern</td>
            </tr>
            <tr>
                <td></td>
                <td>DEX</td>
                <td>; Um 2 erhöhen</td>
            </tr>
            <tr>
                <td></td>
                <td>CPX #$FF</td>
                <td>; Schon fertig ?</td>
            </tr>
            <tr>
                <td></td>
                <td>BNE V</td>
            </tr>
            <tr>
                <td></td>
                <td>LDA $FB</td>
                <td>; STA $0400 1063 wieder nach 1024</td>
            </tr>
            <tr>
                <td></td>
                <td>LDA $D016</td>
                <td>; Scrollregister laden</td>
            </tr>
            <tr>
                <td></td>
                <td>AND #248</td>
                <td>; Scrollbits löschen</td>
            </tr>
            <tr>
                <td></td>
                <td>STA $D016</td>
                <td>; RTS Zurückspeichern</td>
            </tr>
        </table>

        <p>Dieses Maschinenprogramm schiebt die Zeilen, die in der ersten Zeile des Bildschirms stehen, nicht nur nach rechts, sondern macht ein Rundum-Scrolling. Die rechts verschwundene Schrift erscheint also wieder am linken Bildschirmrand. Dies wird durch die ersten und letzten beiden Maschinenprogrammzeilen ermöglicht. Startet man dieses Programm, so ist ab und zu ein leichtes Zucken zu erkennen. Dies liegt daran, daß der Elektronenstrahl, der den Bildschirm 25mal in der Sekunde aufbaut, die erste Zeile schreibt, während sie gescrollt wird. Wie kann man das vermeiden?</p>

        <p>Es ist das Register 53248+18, das benötigt wird. In ihm steht die Zeile, in der sich der Elektronenstrahl befindet (nähere Informationen siehe 64’er, Ausgabe 11/84).</p>

        <p>Wir brauchen also nur dieses Register auszulesen und die erste Zeile erst dann zu scrollen, nachdem sie vollständig vom Elektronenstrahl aufgebaut wurde.</p>

        <p>Die Abfrage muß in Assembler geschehen, da ein Basic-Programm im Verhältnis zur Geschwindigkeit des Elektronenstrahls zu langsam ist. Der richtige Zeitpunkt für den Beginn des Scrollings ist ungefähr dann gegeben, wenn der Strahl die Rasterzeile 100 erreicht hat.</p>

        <p>Wir müssen das obige Maschinenprogramm also noch etwas erweitern. Ganz am Anfang muß stehen:</p>

        <table class="plain">
            <tr>
                <td>X</td>
                <td>LDA 53248+18</td>
                <td>; Rasterzeile auslesen</td>
            </tr>
            <tr>
                <td></td>
                <td>CMP #160</td>
                <td>; Vergleiche auf 160</td>
            </tr>
            <tr>
                <td></td>
                <td>BMI X</td>
                <td>; Wenn kleiner dann nach X</td>
            </tr>
            <tr>
                <td></td>
                <td>CMP #190</td>
                <td>; Vergleiche auf 190</td>
            </tr>
            <tr>
                <td></td>
                <td>BPL X</td>
                <td>; Wenn größer dann nach X</td>
            </tr>
            <tr>
                <td></td>
                <td>RTS</td>
            </tr>
        </table>

        <p>Und nun das gesamte 1-Zeilen-Soft-Scrolling in Basic: (Das dazugehörige Maschinenprogramm ist so geschrieben, daß es in jeden Bereich ge-POKEt werden kann!)</p>

        <pre>10 REM Beispiel Nr. 3
<a href="#fehlerteufelchen" class="fehlerteufelchen_link">20 PRINT CHR$(147);GOSUB 100</a>
30 PRINT "Beliebiger Text kleiner als 40 Zeichen"
40 REM Farbe = schwarz
50 FOR I=55296 TO 55296+39:POKE I,0:NEXT
60 FOR I=1 TO 7
70 POKE 53248+22,PEEK (53248+22) AND 248 OR I
80 FOR T=0 TO 5:NEXT
90 NEXT I
100 FOR T=0 TO 3:NEXT
110 SYS32768:REM Achterscrolling
120 GOTO 60
130 REM Masch.PRG einlesen
140 FOR 1=32768 TO 32768+44:REM 44 DATAs
150 READ G:S=S+G:POKE I,G:NEXT
<a href="#fehlerteufelchen" class="fehlerteufelchen_link">160 IF S=6044 THEN 180</a>
170 PRINT"FEHLERINDATAS!":STOP
180 RETURN
190 DATA 173,18,208,201,160,48,249,201
<a href="#fehlerteufelchen" class="fehlerteufelchen_link">200 DATA 190,16,245,173,39,4,141,255,207
210 DATA 162,38,189,0,4,232,157,0,4,202
220 DATA 202,224,255,208,243,173,255,207
230 DATA 141,0,4,173,22,208,41,248,9
240 DATA 0,141,22,208,96</a></pre>

        <p>Man stellt fest, daß die Zeichen am rechten Rand langsam herauswandern; aber am linken Rand plötzlich auftauchen. Dies läßt sich verhindern, indem man den Bildschirm seitlich verengt (Bit 3 des Registers 53248+22 löschen). Das kann man mit<br>
            POKE 53248+22,PEEK(53248+22)AND247 erreichen. Platz dafür wäre zum Beispiel in Zeile 45.</p>

        <figure>
            <img src="110-2.png" alt="">
            <figcaption>Bild 2. Das Flußdiagramm erläutert die verwendete Scroll-Routine</figcaption>
        </figure>

        <p>Basic reicht nicht aus, um eine angemessene Geschwindigkeit zu erreichen. Deshalb steigen wir nun ganz auf Assembler um! Schreiben wir zunächst die Zeilen 60 bis 90 des Beispiels Nummer 3 in Assembler:</p>

        <table class="plain">
            <tr>
                <td>M</td>
                <td>LDA 53248+22</td>
                <td>; Scrollregister laden</td>
            </tr>
            <tr>
                <td></td>
                <td>AND #7</td>
                <td>; Scrollbits ausfiltern</td>
            </tr>
            <tr>
                <td></td>
                <td>CMP #7</td>
                <td>; Schon 7 ?</td>
            </tr>
            <tr>
                <td></td>
                <td>BNE N</td>
                <td>; Wenn nicht dann Einerscrolling</td>
            </tr>
            <tr>
                <td></td>
                <td>JSR ACHTSC</td>
                <td>; Achterscrolling</td>
            </tr>
            <tr>
                <td></td>
                <td>JMP M</td>
                <td>; Nächste Verschiebung</td>
            </tr>
            <tr>
                <td>N</td>
                <td>INC 53248+22</td>
                <td>; Scrollreg. erhöhen</td>
            </tr>
            <tr>
                <td></td>
                <td>LDX #$FF</td>
                <td>; Verzögerungsschleife</td>
            </tr>
            <tr>
                <td>Q</td>
                <td>LDY #$30</td>
            </tr>
            <tr>
                <td>A</td>
                <td>INY</td>
            </tr>
            <tr>
                <td></td>
                <td>BNE A</td>
            </tr>
            <tr>
                <td></td>
                <td>INX</td>
            </tr>
            <tr>
                <td></td>
                <td>BNE Q</td>
            </tr>
            <tr>
                <td></td>
                <td>JMP M</td>
                <td>; Nächste Verschiebung</td>
            </tr>
        </table>

        <p>Diese Routine müssen wir nur noch in das obige Achterscrolling einbauen. Für die Basic-Fans haben wir einen Basic-Lader dieses Programms am Schluß abgedruckt. Kommen wir nun zum vertikalen Scrolling:</p>

        <p>Im Prinzip funktioniert es wie das horizontale, es wird nur ein anderes Register benutzt.</p>

        <p>Das Register für das vertikale Scrolling ist: 53248+17.</p>

        <p>Für das Scrolling sind wie beim horizontalen Scrolling die Bits 0 bis 2 verantwortlich.</p>

        <p>Einzeilen Soft-Scrolling (DATA-Lader):</p>

        <pre>0 DATA173,22,208,41,7,201,7,208,6,32,34,128,76,0,128,32,68,128,238,22,208
1 DATA162,255,160,160,200,208,253,232,208,248,76,0,128,173,39,4,133,251
2 DATA162,38,189,0,4,232,157,0,4,202,202,224,255,208,243,165,251,141,0
3 DATA4,173,22,208,41,248,141,22,208,96,173,18,208,201,160,48,249,201,190
4 DATA16,245,96,255
10 FOR I=32768 TO 32768+5*16
20 READA:POKEI,A
30 NEXT
40 PRINT"(CLR} HIER KOENNTE EIN TEXT STEHEN.
50 SYS32768
READY</pre>

        <address class="author">(Frank Barcikowski + Holger Vocke/ah)</address>

        <aside class="fehlerteufelchen" id="fehlerteufelchen">
            <h2>Fehlerteufelchen</h2>
            <p>Das Programm »Beispiel Nr. 3« ist so, wie es veröffentlicht wurde, nicht lauffähig. Folgende Zeilen sind zu ändern:<br>
                20 PRINT CHR$(147);:GOSUB 140<br>
                160 IF S = 6149 THEN 180<br>
                200 DATA 190, 16, 245, 173, 39, 4, 133, 251<br>
                220 DATA 202, 224, 255, 208, 243, 165, 251<br>
                230 DATA 141, 0, 4, 173, 22, 208, 41, 248<br>
                240 DATA 141, 22, 208, 96</p>
            <!-- 64'er 11/1985 -->
        </aside>
    </article>
</body>

</html>