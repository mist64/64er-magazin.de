

;arith.src.prg ; integer arithmetic routines
;
; richard l. rylander    8/12/84
;
; revised 10/29/84 to add full double
; precision arguments in divide routine
;
;*****************************************
;
; use page zero locations where possible for
; iterative procedure work space
;
mlpcnd =$ac    ; multiplicand
mlpler =$ad    ; multiplier
prod   =$ae    ; product
;
dvdnd  =$fd    ; dividend/quotient
dvsor  =$fb    ; divisor
rmndr  =$b4    ; remainder
;
radcnd =$ac    ; radicand
root   =$033c  ; square root
;
temp   =$fb
;
; set up seed values for pseudo-random numbers
      *=$c000
rndm   .byte $ff,$55
rtemp  .byte $00,$00
;
;
;*****************************************
;
; multiply single precision multiplicand
; by single precision multiplier giving
; double precision product (enter at "mult")
;
; special case: enter at "square" to find
; square of signed 8-bit number
;
square lda mlpcnd  ; entry to square
       bpl positv  ; use absolute value
       sec         ; negate if needed
       lda #$00
       sbc mlpcnd
       sta mlpcnd
positv sta mlpler
mult   lda #$00    ; entry to multiply
       ldx #$08
mloop  lsr mlpler
       bcc noadd
       clc
       adc mlpcnd
noadd  ror a
       ror prod
       dex
       bne mloop
       sta prod+1
       rts
;
;*****************************************
;
; divide double precision dividend
; by double precision divisor giving
; double precision quotient
;
; dividend is replaced by quotient
; in the process
;
; quotient is rounded to nearest integer
;
divide lda #$00
       sta rmndr
       sta rmndr+1
       ldx #$10
dloop  rol dvdnd
       rol dvdnd+1
       rol rmndr
       rol rmndr+1
       sec
       lda rmndr
       sbc dvsor
       tay
       lda rmndr+1
       sbc dvsor+1
       bcc deccnt
       sty rmndr
       sta rmndr+1
deccnt dex
       bne dloop
       rol dvdnd     ; check if remainder
       rol dvdnd+1   ; is >= 1/2 of dividend
       asl rmndr     ; for rounding
       rol rmndr+1
       bcs round
       sec
       lda dvsor
       sbc rmndr
       lda dvsor+1
       sbc rmndr+1
       bcs nochng
round  inc dvdnd
       bne nochng
       inc dvdnd+1
nochng rts
;
;*****************************************
;
; take integer square root of a
; double precision radicand giving
; single precision root ( <= real root )
;
sqrt   ldx #$08
       lda #$00
       sta root
       sta root+1
       sta temp
       sta temp+1
sqrt1  asl root
       rol root+1
       inc root    ; assume current lsb of
       bne next1   ; root will be 1
       inc root+1
next1  asl radcnd  ; shift radicand left
       rol radcnd+1 ; twice into temp
       rol temp
       rol temp+1
       asl radcnd
       rol radcnd+1
       rol temp
       rol temp+1
       sec         ; subtract root estimate
       lda temp    ; from temp
       sbc root
       tay
       lda temp+1
       sbc root+1
       bcc restor
       sta temp+1  ; subtraction ok
       sty temp
       inc root
       bne next2
       inc root+1
next2  dex
       bne sqrt1
       jmp fini
restor sec         ; ignore subtraction
       lda root    ; and reset lsb of root
       sbc #$01
       sta root
       bcs next3
       dec root+1
next3  dex
       bne sqrt1
fini   ror root+1  ; final /2 to normalize
       ror root
       rts
;
;*****************************************
;
; generate pseudo-random bytes
; exit with p-r byte in accum.
;
random lda rndm
       sta rtemp
       eor rndm+1
       rol rtemp+1  ; rtemp+1 preserves
       ror a        ; carry bit for cycling
       ror rtemp+1  ; random numbers
       sta rndm
       lda rtemp
       sta rndm+1
       rts
.end

