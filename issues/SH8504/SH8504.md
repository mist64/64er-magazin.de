# Beeindruckende Grafik \[3\]

Zwei Themen interessieren den Anwender eines C 64 besonders: Grafik und Drucker. Die Grafik zum einen, weil der C 64 dafür die besten Voraussetzungen bietet, der Drucker zum anderen, da man seine Kunstwerke nicht nur auf dem vergänglichen Bildschirm betrachten möchte, sondern auch etwas »in Händen« halten will.

Deshalb wurden beide Themen in diesem vierten Sonderheft der 64’er zusammengefaßt. Drucker und Grafik haben auch für sich alleine betrachtet ihre Existenzberechtigung, gemeinsam sind sie jedoch unschlagbar.

Was die Grafik anbelangt, finden Sie hier einige Programme, die das Herz höher schlagen lassen. Ein Schwerpunkt liegt in der dreidimensionalen Darstellung von Körpern auch auf einem Heimcomputer. Zwei Programme verdienen dabei Ihr besonderes Augenmerk: »3D-Supergrafik« und »Räumliche Grafik auf dem C 64«.

Erzeugen Sie räumliche Körper, betrachten sie von allen Seiten, lassen das Licht von verschiedenen Richtungen einfallen und geben das Ganze auf einem Drucker aus.

Um »normale« Grafik auf dem C 64 betreiben zu können, bieten wir Ihnen eine Reihe von Basic- und Grafikerweiterungen. Eine mit reiner Software erzeugte 80-Zeichen-Darstellung ist ebenso Bestandteil wie komfortable Befehlserweiterungen für Drucker.

Hardcopy-Routinen für die verschiedensten Drucker mit Leistungsmerkmalen wie vierfache Größe oder Umsetzung der Farben in Graustufen sind in einer eigenen Rubrik zusammengefaßt.

Wer sich seine eigene Hardcopy-Routine basteln will, aber noch keine Ahnung hat wie das geht, erfährt im Abschnitt Grundlagen, wie man das macht. Außerdem werden die Grundzüge der Spriteprogrammierung und des Fein-Scrolling behandelt.

Alles in allem erhalten Sie wieder rund 28 Listings der Spitzenklasse. Alle Programme wurden mit Prüfsummen versehen, um Ihnen das Abtippen zu erleichtern. Geben Sie daher bitte vorher die beiden Listings »Checksummer 64 V3« und »MSE« in Ihren C 64 ein. Damit können Sie dann alle anderen Listings sicher und bequem abtippen.

(Albert Absmeier)

TODO ASIDE

## Listing-Service

Wer keine Zeit oder keine Lust hat, alle Programme selbst in mühevoller Kleinarbeit abzuschreiben, kann wieder auf den bewährten Leserservice zurückgreifen. Alle Listings befinden sich auf einer Diskette mit der Bestellnummer L6'85S4A. Die Diskette kostet 29,90 Mark.

Bitte verwenden Sie für Ihre Bestellung die beigefügte Postscheck-Zahlkarte zur Überweisung des Rechnungsbetrags. Sie erleichtern uns die Auftragsabwicklung und Sie **sparen** sich die **3,- DM** Versandkosten!

**Bestell-Nr.: L6'85 S4A / DM 29,90**

# Checksummer 64 — Neu \[6-7\]

> Der Checksummer 64 V3 überprüft jede Basic-Zeile direkt nach der Eingabe, erkennt Fehleingaben und auch Vertauschungen von Zahlen und Ziffern, und erspart deshalb eine aufwendige Fehlersuche.

Der Checksummer 64 V3 ist ein kleines Maschinenprogramm, das Sie sofort unterrichtet, ob Sie die jeweilige Programmzeile korrekt eingegeben haben.

So gehen Sie vor:
1.	Programm abtippen und speichern.
2.	Starten mit RUN
3.	Nach kurzer Zeit sehen Sie am Bildschirm:<br>CHECKSUMMER 64, CHECKSUMMER AKTIVIERT, AUSSCHALTEN MIT POKE 1,55, ANSCHALTEN MIT POKE 1,53, READY.
4.	Anschalten des Checksummer 64 V3 mit POKE 1,53.
5.	Test: Geben Sie in einer freien Zeile ein: »1 REM« und drücken die RETURN-Taste. Am Bildschirm oben links sollten Sie die Prüfsumme < 63 > sehen.
6.	Geben Sie ein Listing aus unserem Heft ein. Nach jeder Zeile wird die Zahl, die im Listing in Klammern < > steht, in den Bildschirm eingeblendet. Stimmen die Zahlen nicht überein, so liegt vermutlich ein Eingabefehler vor. Die Zahl in den Klammern, und auch die Klammern selbst, dürfen beim Abtippen nicht mit eingegeben werden!
7.	Dieser neue Checksummer 64 V3 bemerkt, im Gegensatz zu den bisherigen, auch Vertauschungen von Zahlen und Buchstaben.
8.	Unsere Basic-Listings enthalten keine Steuerzeichen mehr. Diese werden ersetzt durch Klartext und stehen zwischen geschweiften Klammern. Deshalb sind weder die Klammern noch was dazwischen steht, abzutippen, sondern die in Tabelle 1 aufgeführten Tasten zu drücken. Auf Ihrem Bildschirm erhalten Sie dann wieder die entsprechenden Grafikzeichen (siehe Bild 1 und 2).
9.	Alle Grafikzeichen werden ebenfalls ersetzt durch unterstrichene oder überstrichene Großbuchstaben. Unterstrichene Buchstaben bedeuten, daß Sie die SHIFT-Taste und den angegebenen Buchstaben drücken müssen, überstrichene jedoch die Commodore-Taste mit dem Buchstaben. Auch hier erhalten Sie am Bildschirm das entsprechende Grafikzeichen und nicht etwa das im Listing erkennbare Zeichen (siehe Bild 1 und 2).

## Checksummer VC 20 V3

Der Checksummer VC 20 V3 ist im Prinzip genauso aufgebaut wie der Checksummer 64. Da beim VC 20 jedoch nicht die Möglichkeit besteht, das ROM softwaremäßig zu modifizieren, mußte ein anderer Weg als beim Commodore 64 gewählt werden, um die Checksumme zu generieren.

In ihrer Funktionsweise unterscheiden sich der Checksummer VC 20 und der Checksummer 64 nicht. Es gelten folgende Sonderregelungen bei der Benutzung des Checksummer VC 20:

- Da der Basic-Bereich nicht belegt werden soll, ist das Programm im Kassettenpuffer abgelegt.
- Angeschaltet wird der Checksummer VC 20 mit »SYS 955«.
- Abschaltung des Checksummer VC 20 wird mit »SYS 58459« vollzogen.

Achtung: Nehmen Sie keine Kassetten-Operationen vor, wenn der Checksummer VC 20 eingeschaltet ist. Da das Betriebssystem den Kassettenpuffer mit Daten belegt, kann der Checksummer VC 20 überschrieben werden, was zur Folge hat, daß sich der Computer bei aktiviertem Checksummer VC 20 »aufhängt«. Wollen Sie deshalb ein Programm auf (von) Kassette abspeichern (laden), so müssen Sie erst den Checksummer VC 20 abschalten (SYS 58459).

Daraufhin kann der Kassettenpuffer mit Daten überschrieben werden, ohne daß der Computer »aussteigt«.

Als Sicherung wird bei der Initialisierung geprüft, ob das zuletzt angesprochene Peripherie-Gerät der Kassettenrecorder war. Ist das der Fall, so werden die Betriebssystemroutinen LOAD und SAVE für die Benutzung gesperrt. Der Rechner meldet bei Aufruf einer dieser beiden Routinen READY, ohne weitere Aktionen durchzuführen. Diese Sicherung kann man nach der Tipparbeit aufheben, wenn man den Checksummer VC 20 mit SYS 58459 abschaltet. Dadurch wird der Kassettenpuffer für andere Daten freigemacht. Weiterhin wird dann durch gleichzeitiges Drücken der Tasten »Run-Stop & Restore« erreicht, daß die Betriebssystemroutinen LOAD und SAVE wieder eingerichtet werden.

- Bei Benutzung einer Diskettenstation brauchen Sie nicht darauf zu achten, daß bei LOAD beziehungsweise SAVE der Checksummer VC 20 überschrieben wird, da der Kassettenpuffer für die Diskettenstation normalerweise nicht genutzt wird. Deshalb können Sie die beiden Routinen weiterhin normal nutzen, sofern der Rechner bei der Initialisierung des Checksummer VC 20 feststellt, daß das zuletzt angesprochene Peripherie-Gerät nicht der Kassettenrecorder war.
- Bedingt durch den anderen Aufbau des Checksummer VC 20 wird anders als beim Checksummer 64 nach der LOAD-Routine keine Checksumme ausgegeben.
- Wird eine Zeile gelöscht, also eine Zahl zwischen 0 und 65999 eingegeben, und danach Return gedrückt, so wird eine Checksumme ausgegeben, die aber keine Bedeutung hat.

Sie können die Programme auch weiterhin ohne den Checksummer eintippen.

(F. Lonczewski/gk)

**Hinweis: {13 SPACE} bedeutet 13mal die Leertaste drücken**

TODO TABELLE "Die Steuerbefehle im Klartext"

# MSE – Abtippen sicher und leicht gemacht \[8-9\]

> Ähnlich wie der »Checksummer« ist auch der MSE ein Hilfsmittel bei der Eingabe von Listings, diesmal jedoch bei reinen Maschinensprache-Programmen.

Im Gegensatz zum »Checksummer« aber ist die Eingabe nicht ohne den MSE möglich. Der MSE verringert die Tipparbeit um ein Drittel und schließt Fehleingaben vollkommen aus. Außerdem können Sie die Werte blind eingeben, ohne andauernd auf den Bildschirm schauen zu müssen. Dies wird durch akustische Meldungen realisiert.

MSE ist ein Maschinenspracheditor, mit dem ein Vertippen ausgeschlossen ist. Eine abgetippte Zeile wird nur angenommen, wenn sie richtig ist. Eine Checksumme am Ende jeder Zeile prüft, ob die richtigen Werte in der richtigen Zeile an der richtigen Stelle stehen. Wenn nicht, ertönt ein Warnsignal, und man beseitigt den Fehler.

War die Zeile korrekt, erklingt ein Gong, und die nächste Zeilennummer wird ausgegeben. Damit ist also auch »blindes« Eintippen möglich; Sie können sich voll auf den Text konzentrieren.

### So arbeitet man mit MSE

Laden und starten Sie MSE. Zuerst wird der Programmname und die Start- und Endadresse erfragt. Diese Angaben entnehmen Sie dem Kopf des jeweiligen abgedruckten Listings. MSE meldet sich dann mit der Zeilennummer der ersten Zeile. Wenn Sie die Zeile richtig eingegeben haben, erscheint die nächste Zeilennummer und so weiter bis zum Ende. Zum Schluß wird das fertige Programm mit »CTRL-S« auf Diskette oder Kassette abgespeichert. Dazu sind keine weiteren Angaben mehr erforderlich. Das Programm kann dann ganz normal wieder geladen und gestartet werden. Wenn Sie nicht alles auf einmal tippen wollen, können Sie jederzeit unterbrechen und den eingetippten Teil mit »CTRL-S« abspeichern. Wollen Sie weiterarbeiten, laden und starten Sie MSE wieder.

Geben Sie auf die Frage nach der Startadresse aber jetzt »CTRL-L« ein, um Ihr Teilprogramm zu laden. Jetzt können Sie mit »CTRL-N« die Adresse eingeben, an der Sie weitertippen müssen. Wenn Sie sich nicht gemerkt haben, wie weit Sie gekommen sind, geben Sie nach dem Laden »CTRL-M« ein.

Auf die Frage nach der Startadresse antworten Sie mit der Anfangsadresse, die links in der Kopfzeile auf dem Bildschirm steht. Nun wird Ihr Programm aufgelistet. Mit »SPACE« wird das Listen fortgesetzt, mit »STOP« abgebrochen. Das Ende Ihres Programmteils erkennen Sie sehr einfach daran, daß nur noch der Wert »AA« in der Zeile steht. Die Adresse dieser Zeile müssen Sie anschließend mit »CTRL-N« eingeben. Das Programm ist nur mit »STOP/RESTORE« zu verlassen. Speichern Sie aber vorher unbedingt immer Ihren Text ab.

### Hinweise zum Abtippen

Vor dem Abtippen oder späteren Wiederladen des MSE-Laders müssen Sie unbedingt folgende Zeile eingeben:
**POKE 43,1: POKE 44,32: POKE 8192,0: NEW**

Starten Sie das Programm mit RUN. Fehlerhafte Zeilen werden angezeigt und müssen korrigiert werden, bis der Lader zum »READY« durchläuft. Jetzt müssen Sie das fertige MSE-Programm abspeichern. Dazu brauchen Sie nur »RETURN« zu drücken, weil die erforderlichen Angaben schon auf dem Bildschirm stehen. (Kassettenbesitzer müssen in Zeile 343 die letzte Zahl in »1« abändern.) Ab jetzt können Sie »MSE V1.0« direkt, also ohne den DATA-Lader, benutzen. MSE V1.0 wird ganz normal mit »,8« geladen (keine POKEs notwendig).

(N. Mann / D. Weineck / gk)

TODO ASIDE

MSE-Befehle:
DEL löscht die letzte Eingabe.
CTRL-S speichert das eingetippte Programm ab.
CTRL-L lädt ein Programm. Start- und Endadresse werden automatisch ermittelt.
CTRL-M listet den Speicherinhalt. Abbruch mit STOP-Taste, weiter mit Leertaste.
CTRL-N erlaubt die Eingabe einer neuen Adresse zum Weitertippen.
CTRL-P gibt ein MSE-Listing auf dem Drucker aus.

# Centronics-Schnittstelle für Seikosha GP-550A \[10-12\]

> Mit diesem Software-Interface können Sie auf einem Seikosha GP-550A die Steuer- und Grafikzeichen des C 64 listen und drucken. Der Wert der Schnittstelle wird dabei durch eine Hardcopy-Funktion noch um ein Vielfaches erhöht.

Der Seikosha-Drucker GP-550A besitzt in der Grundversion eine Centronics-Schnittstelle. Zum Anschluß an den C 64 ist deshalb ein Interface notwendig. Unser Leser Pius Nippgen wollte sich aber die hohen Kosten für ein Hardware-Interface sparen. Er dachte sich, was mit einem Epson funktioniert, muß auch mit dem GP-550A gehen. Er nahm sich dazu kurzerhand die Eyssele-Schnittstelle aus Ausgabe 7/84 (auch in diesem Sonderheft) vor und schrieb sie auf den GP-550A um. Diese Schnittstelle besteht aus einem Programmteil und einem Kabel vom User-Port des C 64 an den Centronics-Eingang des Druckers.

Die gesamte Ansteuerung (Sekundär- und Geräteadressen) wurde beibehalten. Die Adressen und die Verbindungsvorschrift des Kabels können Sie bei der Eyssele-Schnittstelle nachschlagen.

Der GP-550A wird mit anderen Befehlssequenzen angesteuert als ein Epson-Drucker. Diese Sequenzen sind nötig, um beispielsweise den Grafikmodus des Druckers einzuschalten. Deshalb war die erste Aufgabe, alle Steuer-Codes der Eyssele-Schnittstelle dem GP-550A entsprechend zu ändern. Aber nicht nur das. Ein Epson-Drucker ordnet, beginnend mit der untersten der acht Nadeln, steigende binäre

Wertigkeiten zu, der GP-550A aber fallende:

TODO TABLE

Epson	Nadel	Gp-550A
128	8	1
64	7	2
32	6	4
16	5	8
8	4	16
4	3	32
2	2	64
1	1	128

Zusätzlich zu diesen Änderungen wurde eine Hardcopy-Funktion (Ausdruck des Grafikspeichers) in die Eyssele-Schnittstelle aufgenommen. Die Hardcopy-Routine wird nach dem Öffnen des Druckerkanals, beispielsweise mit OPEN 19,19 mit SYS 52223 aufgerufen. Der Aufruf kann sowohl innerhalb eines Programms, als auch im Direktmodus erfolgen. Es können alle Grafikseiten gedruckt werden, auch solche im RAM unterhalb des ROMs.

Mit ein paar POKE-Befehlen läßt sich die Hardcopy variieren. Durch POKE 52236,224 wird der Speicherbereich von $E000 bis $FFFF selektiert. 224 ist das Highbyte von $E000 (57344). Erfolgt kein POKE-Befehl, wird vom Programm der normale Grafikbereich von $2000 (8192) bis $3FFF (16383) angenommen. Verschiedene Hardcopies können stufenlos aneinander gedruckt werden, indem man einfach mehrmals nacheinander mit SYS 52223 die Routine aufruft. Vorher muß man nur mit POKE 52236,X den gewünschten Grafikbereich einstellen.

## Flexible Hardcopy

Über die Speicherzelle 52242 läßt sich die Zeilenzahl der Hardcopy einstellen. POKE 52242,25 bedeutet, daß die gesamte Grafikseite (25 Zeilen) ausgedruckt wird.

Einen invertierten Ausdruck erreichen Sie durch POKE 52296,165. Durch POKE 52310,0:POKE 52239,50:POKE 52340,51 wird die Hardcopy-Breite auf die Hälfte reduziert, das Bild also gestaucht.

Initialisiert wird die Schnittstelle mit SYS 51456. Sowohl nach dem Laden als auch nach RUN/STOP-RESTORE.

Geben Sie das Listing mit dem MSE ein. Danach können Sie mit LOAD "name",8,1 oder 1,1 laden. Nach dem Laden sollten Sie noch NEW eingeben, damit die Basic-Vektoren wieder vernünftig gesetzt werden. Ohne NEW erhalten Sie bei der nächsten Anweisung einen »Out of Memory Error«. Wie Sie das Druckerkabel bauen müssen, entnehmen Sie bitte dem Artikel über die Eyssele-Schnittstelle.

(Pius Nippgen/hm)


# 160 Spalten mit dem 1526 oder MPS 802 \[12-14\]

> Dieses Unterprogramm läßt den Commodore 1526-Drucker 128 oder sogar 160 Zeichen pro Zeile drucken. Der Druck von breiten Tabellen wird zum Vergnügen!

Der 1526 kommt durch dieses Programm an die Leistungen von teuren Druckern mit Kleinschriftmodus nahe heran. Mit 160 Zeichen pro Zeile übertrifft er diese Drucker sogar.

Wie Sie wissen ist der 1526 (MPS 802) nur bedingt grafikfähig. Es lassen sich selbstdefinierte Zeichen ausdrucken. Das macht auch dieses Programm. Es setzt zwei zu druckende Buchstaben in ein selbstdefiniertes Zeichen um, das der Drucker zu Papier bringt. Der 1526 druckt also immer zwei Buchstaben gleichzeitig (160 Zeichen pro Zeile). Im 128-Zeichenmodus ist es etwas komplizierter. Hier werden aus acht Buchstaben fünf Druckerzeichen zusammengesetzt (Bild 1). Das Aussehen der Zeichen wird über die DATA-Werte im Programm bestimmt. Acht DATAs für ein Zeichen. Ein DATA-Wert bestimmt, welche Nadeln einer vertikalen Punktreihe angeschlagen werden.

Die einzelnen Nadeln haben die folgenden Wertigkeiten:

TODO TABLE

oben . 128
. 64
. 32
. 16
. 8
. 4
• 2
unten . 1

Ein Zeichen ist aus acht solchen Punktreihen zusammengesetzt. Die binären Wertigkeiten der einzelnen Punktspalten werden über die CHR$()-Funktion in einem String addiert und an den 1526 gesandt, der das selbstdefinierte Zeichen druckt.

Das folgende kleine Programm druckt einen senkrechten Strich:
10 open5,4,5
20 a$=chr$(255): rem eine Punktreihe
30 for i=1 to 7 : rem Rest des Zeichens
40 a$=a$+chr$(0): rem mit Leerraum
50 next i :rem auffüllen
60 print#5,a$
70 close5

### Tips zur Benutzung

Das eigentliche Programm beginnt ab Zeile 60000. Der Teil vorher dient nur zur Demonstration der 128- und der 160-Zeichendarstellung. Ab Zeile 60000 zerlegt das Programm den zu druckenden String (XX$) in seine Einzelteile, baut daraus die selbstdefinierten Zeichen zusammen und schickt diese an den Drucker.

Wenn Sie das Unterprogramm in einem Basic-Programm verwenden, übergeben Sie einfach die zu druckenden Zeichen in der Variablen XX$ an das Unterprogramm. Das Unterprogramm wird, wie üblich, mit einem GOSUB gestartet. GOSUB 60000 bewirkt eine 160-Zeichendarstellung, GOSUB 60810 eine »Druckbreite« von 128 Zeichen.

Beachten Sie bitte, daß vor dem Aufruf des 128-Zeichenmodus erst einmal der 160-Zeichenmodus aktiviert werden muß. Warum? Nun, beim ersten Durchlauf des Programmes werden alle DATAs in Variablenfelder (V1$() und V2$()) eingelesen. Da der READ-Befehl grundsätzlich mit dem ersten Datum im ganzen Programm beginnt, müssen zur 128-Zeichendarstellung die 160-Zeichen-DATAs überlesen werden. Das geschieht mit einem GOSUB 60000. Danach sind beide Variablenfelder definiert. Sie können dann beliebig den 128- oder 160-Zeichenmodus aufrufen. Würde zuerst der 128-Zeichenmodus aufgerufen, würden die falschen DATAs gelesen und den Variablen zugeordnet. Ein reichlich seltsames Aussehen der Zeichen wäre die Folge.

Eine detaillierte Programmbeschreibung finden Sie in Tabelle 1.

(Martin Riethmüller/hm)

# Etiketten wie gedruckt \[15-20\]

> Mit diesem Programm sind Sie in der Lage, professionell beschriftete Etiketten herzustellen. Und das mit allen ASCII-Zeichen des C 64. Das Programm hat einen eigenen Editor zur Eingabe der Beschriftung. Fertige Labels können gespeichert und geladen werden.

Eine saubere Diskettenbeschriftung macht einiges her. Verschieden gestaltete Labels schaffen Ordnung; nicht nur bei Disketten.

Das Programm ist für einen 1526-Drucker konzipiert, ist aber leicht auf andere Drucker anzupassen. Vorausgesetzt, der Drucker kann die C 64-Grafikzeichen drucken. Wenn nicht, läßt sich das Programm trotzdem einsetzen, wenn man sich auf die Verwendung von Buchstaben beschränkt.

Mit einem Commodore 1526-Drucker können Sie Ihre Aufkleber mit sämtlichen alphanumerischen und C 64-eigenen Zeichen verwenden. Auch reverse und doppelt breite Schrift ist möglich. Das Programm ist für die Verwendung von Endlosetiketten der Größe 88,9x35,5 mm gedacht.

## Komfortable Hilfsroutinen

Sehr gut am Programm ist die Tatsache, daß einmal erstellte Aufdrucke gespeichert und wieder geladen werden können. Aber damit sind die Möglichkeiten, die das Programm »Etiketten 64« bietet, noch lange nicht erschöpft. Einige Hilfsfunktionen zur Arbeit mit Disketten runden die »ganze Sache« ab. Man kann sich das Directory zeigen lassen und Befehle an das Diskettenlaufwerk senden. Zum Beispiel "R:" für Rename, "V" für Validate oder "I" zum Initialisieren. Das Programm ist weitestgehend absturzsicher (Ausnahme: Device not Present Error). Fehleingaben können leicht wieder rückgängig gemacht werden: Man gelangt ohne Datenverlust immer wieder ins Hauptmenü zurück.

»Etiketten 64« ist vollständig in Basic geschrieben, um die Anpassung auf andere Drucker zu erleichtern. Deshalb wurde auch der Programmteil DRUCKEN an das Programmende gelegt.

Wenn Sie einen Compiler besitzen, sollten Sie das Basic-Programm damit behandeln. Der Editor wird dann so schnell, daß die Eingabegeschwindigkeit nichts mehr zu wünschen übrigläßt. Das soll aber keinesfalls heißen, das Programm würde ohne Compiler nur bedingt funktionieren. »Etiketten 64«ist auch in nicht compilierter Form ein sehr gutes Programm.

Wenn Sie das Programm starten (sicherheitshalber nach dem Eintippen erst speichern), erscheint das Hauptmenü mit dem Eingabefeld.

Die Menüpunkte:

**F1 — Editieren**; der Aufdruck kann erstellt werden.

Während des Editierens behalten die Cursortasten ihre volle Funktion bei. Allerdings nur innerhalb des Eingabefeldes. Ebenso funktionieren auch alle anderen Tasten des C 64 zum Editieren. **HOME** setzt den Cursor in die linke obere Ecke, **CLR** löscht das Eingabefeld, **DEL** löscht das Zeichen unterhalb (!) des Cursors. **INST** fügt einen Leerraum an der Cursorposition ein.

Ein Untermenü am unteren Bildschirmrand erleichtert das Editieren noch mit folgenden Funktionen:

**Revers** schaltet den Reversmodus ein und aus. Der aktuelle Modus wird angezeigt.

**Breit** schaltet die Breitschrift ein und aus. Doppelt große Zeichen werden durch einen vorangestellten Pfeil gekennzeichnet.

**Zeile löschen** — eine Zeile wird ab Cursorposition gelöscht. Alle anderen Zeilen rücken nach. Eine komplette Zeile wird gelöscht, wenn der Cursor am Anfang der jeweiligen Zeile steht.

**Zeile einfügen** — eine Leerzeile wird ab Cursorposition eingefügt. Eine ganze Zeile wird eingefügt, wenn der Cursor, wie bei »Zeile löschen« am Zeilenanfang steht.

**Ende** — Rücksprung ins Hauptmenü.

**F3 — Drucken**; das Eingabefeld wird gedruckt. Zum Druck müssen die Etiketten beim 1526-Drucker linksbündig eingelegt werden. Die obere Kante des Aufklebers soll gerade über dem Farbband sichtbar sein.

**F5 — speichern**; das Eingabefeld wird auf Diskette gespeichert. Wurde der Menüpunkt irrtümlich angewählt, kommt man mit F8 ins Hauptmenü zurück. Vor dem Speichern muß der Bildschirm eingegeben werden. Diskettenfehler werden angezeigt und werden mit RETURN bestätigt. Sollte bereits ein Etikett mit dem eingegebenen Namen auf der Diskette vorhanden sein, so muß man ein Überschreiben mit »J« bestätigen.

**F7 — laden**; ein Etikett-Design wird von Diskette geladen.

**F2 — Directory**; die auf einer Diskette gespeicherten Aufkleberbeschriftungen werden aufgelistet.

**Weiter** holt den nächsten Directory-Eintrag.

**Ende** stoppt die F2-Funktion. Der zuletzt sichtbare Etikettenname wird in die Ladefunktion übernommen.

**F4 — Befehle an das Diskettenlaufwerk.**

Hier können Sie Direktbefehle ans Floppylaufwerk schicken. Mit F8 kann diese Funktion abgebrochen werden.

**F8 — Ende**; beendet einen Programmteil oder das ganze Programm.

## Leichte Druckeranpassung

Tabelle 1 zeigt die Variablenliste des Etikettendruckprogramms. Möchten Sie das Listing auf einen anderen Drucker als dem Commodore 1526 anpassen, müssen die Sekundäradressen und Steuercodes entsprechend geändert werden. Sollte eine Anpassung Ihres Druckers bezüglich der Grafikzeichen und doppelt breiter Schrift nicht möglich sein, können Sie das Programm dennoch verwenden. Denn ohne Grafik- und Steuerzeichen sollte das Programm auf jedem Drucker laufen, wenn der Drucker eine Einstellung des Zeilenabstandes zuläßt.

(Gerhard Zinner/hm)

# Die entscheidende Verbesserung \[20-21\]

> Erweitern Sie die Eyssele-Schnittstelle um eine Hardcopy-Funktion. Sie können dann mit einem einfachen Befehl genau das drucken, was am Bildschirm zu sehen ist.

Diese Erweiterung verbessert die Eyssele-Schnittstelle (auf Seite 22) gewaltig. Denn es wird nicht nur eine Text-Hardcopy implementiert, sondern die Eyssele-Schnittstelle kann damit auch einfach auf andere Drucker als den Epson RX/FX-Typen angepaßt werden. Die abgedruckte Version läuft mit einem CP-80 über den Centronics-Eingang. Zur Anpassung auf die Epson-Drucker sind folgende Änderungen nötig:
60 DZ=5
61 D(1)=27:D(2)=42:D(3)=4:D(4)=8:D(5)=0

Zum Anschluß an den C 64 müssen Sie sich nur ein Verbindungskabel vom User-Port zum Centronics-Eingang des Druckers herstellen (lassen). Welche Pins Sie mit welchen verbinden müssen, lesen Sie bitte im vorhergehenden Artikel.

### So ist die Erweiterung zu verwenden

Tippen Sie die Eyssele-Schnittstelle (»Die billigste Centronics-Schnittstelle ...«) mit dem MSE ab und speichern Sie das Maschinenprogramm auf Kassette oder Diskette. Dann laden Sie es mit LOAD "CENTRONICS",8,1 und geben NEW ein, damit die Basis-Vektoren wieder ordentlich gesetzt werden. Dann können Sie diese Erweiterung mit dem Checksummer aus dieser Ausgabe in den C 64 eingeben. Bevor Sie allerdings RUN eintippen, sollten Sie das Basic-Programm sicherheitshalber speichern.

Während des Programmlaufs werden Sie gefragt, ob eine lauffähige Version der erweiterten Schnittstelle als Maschinenprogramm auf Diskette oder Kassette gespeichert werden soll. Reagieren Sie bitte mit D (Diskette), K (Kassette) oder N (nicht speichern). Das erzeugte Programm bekommt den Namen »Druckertreiber«. Es muß mit LOAD " DRUCKER-TREIBER",8,1 oder 1,1 geladen werden. Danach ist wieder das gewohnte NEW erforderlich, die Schnittstelle wird mit SYS 52200 aktiviert.

Bevor Sie den Computer und Drucker einschalten, sollten Sie erst das Käbel anschließen. Denn beim Aufstecken des User-Port-Steckers kann man leicht einen Kurzschluß erzeugen. Im Glücksfall brennt dann die Sicherung im C 64 durch. Meist verabschiedet sich aber einer der beiden CIA-Bausteine und eine nicht billige Reparatur ist die Folge.

Es gelten die Geräte- und Sekundäradressen der Eyssele-Schnittstelle. Lesen Sie diese bitte dort in Tabelle 1 nach.

### Originalgetreue Kopie des Bildschirmes

Nun zur Praxis. Durch Aufruf des Hardcopy-Programmteils wird eine absolut originalgetreue Kopie des normalen Text-Bildschirms gedruckt. Auch reverse Zeichen werden berücksichtigt. Sie können den Abstand zwischen den Druckzeilen wählen. Ohne Abstand, wie am Bildschirm (ideal für Blockgrafiken), oder mit Abstand wie in einem Listing. Die Befehle für die Hardcopy:
SYS 52270,page:druckt mit
SYS 52408,page:ohne Abstand

Bei Page müssen Sie angeben, welche Speicherseite gedruckt werden soll. Der Bildschirmspeicher muß sich nämlich nicht immer zwischen den Adressen 1024 und 2023 (Page=4) befinden. Durch Aufruf der Hardcopy wird die Schnittstelle gleichzeitig auch initialisiert. Sie können sich dann also SYS 52200 (auch SYS 51456 ist möglich) sparen.

### Reverse Zeichen sind kein Problem

Es werden auch reverse Grafikzeichen im Groß-/Kleinschriftmodus gedruckt. Das sind alle Grafikzeichen, die über die CBM-Taste erreichbar sind.

Zeichen mit einem Code von 91 bis 95 werden im Grafikmodus gedruckt, wie andere Sonderzeichen auch. Der Grund dafür ist, daß die C 64-Zeichen in diesem Bereich meist nicht mit den Druckerzeichen in diesem Bereich übereinstimmen.

(Dipl.-Ing. Wilhelm Meierhofer/hm)

# Die billigste Centronics-Schnittstelle für den C 64 \[22-14\]

> Diese Schnittstelle übertrifft mit ihren Leistungsmerkmalen viele käufliche Hardware-Schnittstellen um ein Vielfaches. Nicht aber im Preis: Nur etwa 15 Mark kostet diese »Selbstbau«-Centronics-Schnittstelle.

Leser des 64’er Magazins, die schon »seit Anfang dabei sind«, erkennen diese Schnittstelle bestimmt wieder. In Ausgabe 7/85 wurde sie unter dem Namen Eyssele-Schnittstelle vorgestellt.

Wie im Fernsehen! Jetzt fangen die auch schon mit Wiederholungen an! Diese Vermutung trifft nur in diesem speziellen Fall zu. Wir haben guten Grund, das Programm zu der Eyssele-Schnittstelle nochmals abzudrucken. Denn viele unserer Lesereinsendungen—auch einige Listings in diesem Sonderheft — beziehen sich auf diese Software-Schnittstelle. Die alten Hasen unter Ihnen mögen uns verzeihen. Aber seit einem Jahr wuchs unsere Leserzahl so gewaltig, daß ein großer Teil die Eyssele-Schnittstelle einfach noch nicht kennt.

Es handelt sich hierbei um ein Maschinenspracheprogramm mit 726 Byte Länge, das den Adreßbereich C900-CBD1 (dezimal: 51456 bis 52182) belegt (Listing 1). Damit kann zum Beispiel das DOS 5.1 auf der Demodiskette ohne Probleme zusätzlich geladen werden.

Das Programm ist ohne Einschränkung für alle Epson-kompatiblen Drucker anwendbar, die über einen Bitmustermodus verfügen. Dieser Modus wird für die Ausgabe der Commodore-eigenen Grafikzeichen benötigt. Das Programm besteht aus mehreren Programmteilen, von denen die meisten Erweiterungen bestehender Ein-/Ausgaberoutinen des Betriebssystems sind und bei der Initialisierung in diese eingebunden werden. Dadurch können schon bestehende Basic-Befehle wie OPEN und PRINT # zum Drucken benutzt, und Programme müssen nicht umgeschrieben werden. Zur Ansteuerung verschiedener Druckmodi wurden jedoch zusätzliche Gerätenummern definiert, deren Bedeutungen in Tabelle 1 erklärt sind. Gerätenummer 16 realisiert einen sogenannten Direktmodus, mit dem die internen Commodore-Zeichencodes ohne Wandlung an den Drucker gelangen. Der Direktmodus ist zur Ausgabe von Steuerzeichen oder bei der Verwendung des Druckers als Plotter zur Einzelnadelsteuerung beziehungsweise zur Ausgabe von Bitmustern geeignet. Der Textmodus (Groß- und Kleinschreibung) ist unter Gerätenummer 18 und, weil er wohl am häufigsten bei bereits bestehenden Programmen benutzt wird, unter Gerätenummer 4 ansprechbar. Die Gerätenummer 19 realisiert den Großschrift/Grafik-Modus, wie er beim C64 gleich nach dem Einschalten voreingestellt ist Der wichtige Modus zum Listen von Programmen wurde mit Gerätenummer 17 realisiert. Es läßt sich über die Sekundäradresse, wie in den Musterlistings (Bild 1 bis 3) gezeigt, noch zwischen vier Fällen unterscheiden. Einmal kann ausgewählt werden, ob das Listing, wie vom Bildschirm her gewohnt, mit Großbuchstaben und Grafikzeichen oder im Textmodus mit großen und kleinen Buchstaben gedruckt wird. Zum anderen kann man auswählen, ob die Steuerzeichen wie bei der Bildschirmausgabe als inverse Zeichen oder durch Abkürzungen wie <CRD> (Cursor down) im Klartext gedruckt werden. Durch all diese Möglichkeiten kann der Anwender zum einen auf seinem Drucker Ausgaben erzeugen, wie man sie von Commodore-Druckern her gewohnt ist, zum anderen auch alle Möglichkeiten seines Druckers voll nutzen.

## Commodoreeigene Grafikzeichen

Die Ausgabe von Grafikzeichen erfolgt in der Routine OUTGEN ab Adresse $CAC4. Zu diesem Zweck wird der Zeichengenerator des C 64 ausgelesen. Die Zeichen, die aus einer 8x8- Punktmatrix bestehen, sind dort in je 8 Byte abgelegt. Jedes Byte repräsentiert das Punktmuster einer Zeile der Matrix. Ein Matrixdrucker druckt die Zeichen, indem er sie ebenso als Muster von matrixartig angeordneten Punkten zu Papier bringt. Jedoch gibt er die Punktmatrix nicht wie der Bildschirm zeilenweise, sondern spaltenweise aus. Deshalb wird in OUTGEN die im Zeichengenerator in 8 Zeilenbyte gespeicherte Zeichenmatrix zunächst in 8 Spaltenbyte umorganisiert. Nach Umschalten des Druckers in den sogenannten Bitmustermodus, in dem er jedes ankommende Datenbyte nicht mehr als ASCII-Zeichen, sondern als Musterbyte für eine Matrixspalte interpretiert, gibt OUTGEN die acht geänderten Zeichenbyte an den Drucker aus. Dieser fügt sie wieder zu einem 8x8- Punktmatrixzeichen zusammen. So ist es möglich, auf einem Matrixdrucker exakte Kopien der C 64-Bildschirmzeichen herzustellen, obwohl dieser nicht über den entsprechenden Zeichensatz verfügt.

### So benutzen Sie das Programm

Das Listing sollten Sie mit dem MSE eingeben und auf Diskette oder Kassette speichern, bevor Sie es starten. Bevor Sie es allerdings laden, sollten Sie sich das Verbindungskabel User-Port-Centronics-Buchse zusammenlöten. Dazu ist in Tabelle 2 ein Verbindungsplan angegeben. Das Kabel sollte für eine störungsfreie Funktion nicht länger als ein Meter lang sein und aus einem abgeschirmten, mehradrigen Steuerkabel bestehen, das man in (fast) jedem Elektronik-Bastelgeschäft findet Dort sind auch meist der Centronics-Stecker und der Stecker für den User-Port erhältlich.

Initialisiert wird die geladene Treiberroutine mit SYS 12*4096+9*256 beziehungsweise SYS 51456.

Hierbei wird die Routine in das Betriebssystem eingebunden. Jedoch Vorsicht: Nach einem Break, zum Beispiel durch die Betätigung der Tasten RUN/STOP und RESTORE ausgelöst, muß die Routine erneut initialisiert werden, da die l/O-Vektoren vom Betriebssystem zurückgesetzt wurden.

Die einzelnen Druckmodi spricht man mit den üblichen Basicbefehlen an. Geöffnet wird der Ausgabekanal mit:

OPEN log. Dateinummer, Geräteadr. \[.Sekundäradr.\]

Die eckigen Klammern kennzeichnen optionale Angaben. So kann dann auf den geöffneten Kanal mit PRINT # log. Dateinummer ausgegeben werden. Ein Programmlisting (Bild 2) wird zum Beispiel erzeugt mit den Befehlen

OPEN17,17 \[,Sekundäradr.\]:CMD17:

LIST

PRINT#17:CLOSE17

Der PRINT-Befehl vor dem CLOSE ist notwendig, damit der CMD-Modus aufgehoben wird.

## Umstellen auf beliebige Drucker mit Centronics-Schnittstelle

Das Programm wurde für einen Epson-Drucker geschrieben. Unverändert ist es für jeden anderen Drucker verwendbar, sofern auf die Ausgabe von Commodore-eigenen Grafikzeichen verzichtet wird. Für diese Funktion muß der Drucker vorübergehend in den Bitmustermodus zurückgeschaltet werden, was während einer normalen Textausgabe möglich sein muß. Diese Umschaltung erfolgt im Programm in der Schleife ab Adresse $CB10. Die Anzahl der auszugebenden Steuerzeichen ist unter Adresse $CB18 gespeichert und die Steuerzeichen selbst stehen ab Adresse $CBD2 am Ende des Programms. Für einen Epson-Drucker wird die Folge

ESC*480

ausgegeben, wobei mit4 der Bitmustermodus »CRT-Grafik« ausgewählt wird, 8 das niederwertige Byte und 0 das höherwertige Byte der Anzahl auszugebender Punktmatrixspalten darstellt. Der Epson-Drucker kehrt nach der Ausgabe der spezifizierten Anzahl Musterbytes wieder in den Textmodus zurück.

(H. Eyssele/hm)

# Epson-Support \[26-30\]

> Epson-Support läßt die Herzen eines jeden FX/RX-80-Besitzers höher schlagen. Mit einfachen Befehlen und kurzen Programmen können Sie jetzt komplizierte Grafiken auf Ihrem Drucker erstellen. Und das mit einer Auflösung, die fast siebenmal so hoch ist wie die des C 64, nämlich bis zu 800 mal 552 Punkten.

Epson-Support ist eine Basic-Erweiterung und belegt den Speicherbereich ab $C000 (49152). Der Programmstart erfolgt durch SYS 49152; jetzt stehen einige leistungsfähige Befehle zur Verfügung, um Grafiken zu erstellen und auf den Epson FX/RX-Druckern auszugeben. Die Grafiken liegen im Speicher des Commodore 64 ab $2000 (8192). Wegen des enormen Speicherplatzbedarfs wird auch das RAM unter dem Basic, dem Betriebssystem und unter dem Zeichen-ROM verwendet. Die Bitmap wird über Koordinaten adressiert, dabei liegt der Punkt (0,0) in der linken Ecke oben wie bei den normalen HiRes-Grafiken auf dem Bildschirm. Die X-Werte laufen von 0 bis 799, die Y-Werte von 0 bis 551, so daß 800x 552 = 441600 Dots adressiert werden können. Die Bitmap ist so organisiert, daß der Ausdruck relativ schnell geht.

Die Ausgabe mit dem Drucker läuft über ein User-Port-Kabel, die nötige Treibersoftware ist im Epson-Support schon enthalten. Der Ausdruck erfolgt in der sogenannten doppelten Zeichendichte, also mit 960 Punkten pro Zeile, aus Speichermangel können aber nur 800 Punkte pro Zeile verwendet werden. Listing 1 und Listing 2 sind zwei Beispielprogramme. Als Ergebnis liefern sie Bild 1 und Bild 2. Bevor Sie diese Beispiele probieren, muß das Listing 3 mit dem MSE (siehe Seite 7) eingegeben werden und mit SYS 49152 initialisiert werden.

### Epson-Support Bedienungsanleitung

Das Programm Epson-Support wird absolut geladen mit LOAD"EPSON-SUPPORT",8,1 und durch SYS 49152 gestartet. Dem Basic-Programmierer stehen dann einige neue Befehle zur Verfügung, um die grafischen Fähigkeiten des Epson-Druckers besser auszunutzen, denn im Speicher des C 64 wird eine Grafik-Bitmap von 800 x 552 Punkten verwaltet. Die Auflösung ist also wesentlich höher als bei normalen Bildschirm-Grafiken.

Die einzelnen Befehle werden im folgenden erläutert:

##&CLEAR**

Damit wird die Grafik-Bitmap gelöscht. Dieser Befehl sollte unbedingt am Anfang eines jeden Programms stehen, sonst stehen in der Bitmap wirre Muster.

**&DOTX,Y**

Dieser Befehl setzt einen Punkt an der Position (X,Y). Der X-Wert liegt zwischen 0 (links) und799 (rechts), der Y-Wert zwischen 0(oben) und551 (unten). Für X und Y kann ein beliebiger numerischer Basic-Ausdruck stehen;

**&RESETDOTX,Y**

Dieser Befehl löscht einen Punkt an der Position (X,Y). Der X-Wert liegt zwischen 0 (links) und 799 (rechts), der Y-Wert zwischen 0 (oben) und 551 (unten). Für X und Y kann ein beliebiger numerischer Basic-Ausdruck stehen.

**&INVDOT X,Y**

Dieser Befehl invertiert einen Punkt an der Position (X,Y). Der X-Wert liegt zwischen 0 (links) und 799 (rechts), der Y-Wert zwischen 0 (oben) und 551 (unten). Für X und Y kann ein beliebiger numerischer Basic-Ausdruck stehen.

**&LINE X1,Y1,X2,Y2**

Dieser Befehl zieht eine Linie zwischen den Punkten (X1 ,Y1) und (X2,Y2). Der Wertebereich der Koordinaten ist der gleiche wie bei den Dot-Befehlen. Für die Parameter können beliebige Basic-Ausdrücke stehen.

**&RESETLINE X1,Y1,X2,Y2**

Dieser Befehl löscht eine Linie zwischen den Punkten (X1,Y1) und (X2,Y2). Der Wertbereich der Koordination ist der gleiche wie bei den Dot-Befehlen. Für die Parameter können beliebige Basic-Ausdrücke stehen.

**&INVLINE X1,Y1,X2,Y2**

Dieser Befehl invertiert die Punkte einer Linie zwischen den Punkten (X1,Y1) und (X2,Y2). Der Wertebereich der Koordinaten ist wiederum der gleiche wie bei den Dot-Befehlen. Für die Parameter können beliebige Basic-Ausdrücke stehen.

**&SCANLINE X1,Y1,X2,Y2**

Dieser Befehl setzt eine Linie zwischen den Punkten (X1,Y1) und (X2,Y2). Falls jedoch auf einen schon gesetzten Punkt auf dem Linienzug getroffen wird, so wird nicht mehr weitergezeichnet. Der Wertebereich der Koordinaten ist der gleiche wie bei den Dot-Befehlen. Für die Parameter können beliebige Basic-Ausdrücke stehen.

**&PRINT**

Durch diesen Befehl wird die HiRes-Bitmap auf dem Drucker ausgegeben. Das Programm ist für Epson FX/RX-80-Drucker ausgelegt. Bei Verwendung eines anderen Druckers müssen einige Stellen im Assemblerlisting (Listing 4) beim &PRINT-Befehl geändert werden. Siehe dazu auch die Kommentare im Listing bei diesem Befehl.

**&EXIT**

Führt zum Verlassen von Epson-Support und bewirkt danach einen Basic-Neustart. Basic-Programme sollten vorher unbedingt abgespeichert sein, weil sie sonst gelöscht werden.

**&TEXT X,Y,**"blablabla..."

Dieser Befehl setzt den Text, welcher in Anführungszeichen steht, in die Bitmap an der Position (X,Y). Diese Position gibt die Koordinaten der linken unteren Ecke des ersten Buchstabens an.

**&RESETTEXT, X,Y,**"blablabla..."

Dieser Befehl löscht den Text, welcher in Anführungszeichen steht, in die Bitmap an der Position (X,Y). Diese Position gibt die Koordinaten der linken unteren Ecke des ersten Buchstabens an.

**&INVTEXT X,Y,**"blablabla..."

Dieser Befehl invertiert den Text, welcher in Anführungszeichen steht, in die Bitmap an der Position (X,Y). Diese Position gibt die Koordinaten der linken unteren Ecke des ersten Buchstabens an.

(Alexander Del Pino/gk)

# Plotter-Basic \[31-36\]

> Plotter-Basic ist eine Basic-Befehlserweiterung für den Printer/Plotter 1520 von Commodore. Es ermöglicht eine starke Vereinfachung der normalen Plotterbedienungen und erlaubt zusätzlich zum Beispiel räumliche Zeichnungen zu erstellen und beliebig zu drehen.

Außerdem verfügt es über die Möglichkeit Kreise beziehungsweise Ellipsen zu zeichnen, Blockdiagramme zu erstellen oder komfortable Funktionen-Plot-Programme zu schreiben.

Die Befehlserweiterung funktioniert nach dem Prinzip, daß jedes Befehlswort auf einen vorangestellten Punkt untersucht wird, der einen Plotter-Basic-Befehl kennzeichnet, zum Beispiel .RESET.

Nach dem Start mit SYS 12*4096 initialisiert sich das Programm (Listing 1) und gibt eine Einschaltmeldung aus. Die Initialisierung besteht darin, daß auf eventuelle andere Spracherweiterungen Rücksicht genommen wird und die Zeiger so verändert werden, daß die andere Erweiterung funktionstüchtig bleibt. Voraussetzung dafür ist natürlich, daß der Speicherbereich, den Plotter-Basic benötigt, nicht von fremden Programmen gebraucht wird. Es handelt sich hierbei um den Bereich $C000 bis $C8F5 beziehungsweise 49187 bis 51445.

Die Zeiger, die verändert werden mußten, sind die Vektoren $308/$309 und $300/$301 (Warmstart-Vektor). Normalerweise zeigt der Vektor $308/$309 auf die Routine $A7E4 (Basic-Befehlsadresse holen). Nach der Initialisierung zeigt er nun auf eine Routine, die auf einen vorangestellten Punkt testet und den gegebenenfalls erkannten Befehl ausführt.

Die Veränderung des Warmstartvektors ermöglichte es bei dem Befehl .PROG, der das Programmlisting zum Drucker schickt, die READY-Meldung wieder auf dem Bildschirm auszugeben und den Druckkanal ordnungsgemäß zu schließen. Außerdem besteht durch Veränderung dieses Zeigers die Möglichkeit, Fehlermeldungen zu unterdrücken beziehungsweise zu kontrollieren, ohne den Programmablauf abbrechen zu lassen.

### Befehlsbeschreibung:

Die allgemeine Syntax der Befehle sieht folgendermaßen aus:
a)	.BEFEHLSWORT keine Parameter erforderlich

oder
b)	.BEFEHLSWORT,Parameter1,Parameter2,...,Parameter n

Sieht der Befehl also eine Parameterübergabe vor, so müssen diese vom Befehlswort durch Kommata getrennt werden. Die Parameter können sowohl Variablen als auch Zahlen sein. Ausnahmen sind bei den entsprechenden Beschreibungen erklärt.

Grundsätzlich muß jedem Plotter-Basic-Befehlswort ein Punkt vorangestellt werden. Mehrere Befehle in einer Zeile müssen durch einen Doppelpunkt voneinander getrennt sein.

Beispiel: .BLAU:.SUPER

Eine Besonderheit sei hier noch erwähnt. die ihre Ursache darin hat, daß die neuen Befehlsworte nicht als Tokens codiert wurden. Die neuen Befehle werden im Speicher nämlich Buchstabe für Buchstabe abgelegt. Basic-Befehle dagegen besitzen jeweils einen Ein-Byte-Code (Token), in den sie nach der Eingabe umgewandelt werden. Bevor aber nun der Basic-Interpreter die einzelnen Tokens erkennt, wird eine Untersuchung auf Plotter-Basic-Befehle durchgeführt. Diese Methode hat ihre Schwachstelle bei einer IF...THEN-Abfrage. Sobald nämlich der Befehl hinter THEN abgearbeitet werden soll, wird nicht mehr zur umgelenkten Interpreterschleife zurückgesprungen, sondern sofort der nächste Befehl als Token interpretiert. Falls dieser Befehl aber aus Plotter-Basic stammt, kommt es zu einem Syntax-Error. Dieses Problem läßt sich jedoch lösen, indem man dem THEN einen Doppelpunkt folgen läßt.

Beispiel: IF A=99 THEN:.TEXT, "neunundneunzig"

Möchte man Plotter-Basic mit einer anderen Spracherweiterung gleichzeitig betreiben, so muß Plotter-Basic als letztes geladen werden. Da unter Umständen manche Befehlsworte mit der anderen Sprache identisch sind, kann es zu Fehlermeldungen kommen, die man dadurch unterdrückt, daß man nur die ersten Buchstaben des Plotter-Basic-Befehls eingibt. Es wird dann der Befehl ausgeführt, der die entsprechenden Anfangsbuchstaben besitzt und als erstes im Speicher steht. Bei den meisten Befehlen reicht es, nur die beiden ersten Buchstaben zur Identifizierung anzugeben.

TODO

Beispiel: .RO = .ROT
.PR,10 = .PROG,10

Die Parameter können also auch schon nach zwei Buchstaben folgen. Die Reihenfolge, in der die Befehlsworte im Speicher abgelegt sind, und ihre Startadressen sind am Ende der Beschreibung aufgeführt. Dadurch ist es möglich, die Befehle über SYS-Aufrufe ausführen zu lassen.

Nun aber zur Erklärung der Befehle im Einzelnen:

### 1.	Farbwahl

TODO

.BLAU
.ROT
.GRÜN
.SCHWARZ
stellt die entsprechende Farbe ein
.FARBE,f wählt die Zeichenfarbe gemäß f.

Der Parameter f entspricht der Farbnummer, wie es in der Plotter-Anleitung erklärt ist.

### 2.	Wahl der Zeichengröße

.KLEIN entspricht 80 Zeichen/Zeile
.MITTEL entspricht 40 Zeichen/Zeile
GROSS entspricht 20 Zeichen/Zeile
.SUPER entspricht 10 Zeichen/Zeile
.SIZE,g wählt die Zeichengröße gemäß g.

(Näheres siehe Plotter-Anleitung.)

### 3.	Ausdruck von ASCII-Daten

.TEXT,a$ druckt den String a$
TEXT erzeugt eine Leerzeile (Carriage Return)
.PROG
.PROG,10
.PROG,40-
.PROG,100-556

Dieser Befehl entspricht dem LIST-Befehl in Basic. Ohne Parameter wird das gesamte Programm gelistet, mit Parametern wird entsprechend eine Zeile oder mehrere Zeilen ausgedruckt.

### 4.	Wahl der Schriftarten

.GG stellt den Groß/Grafik-Modus ein.
.GK stellt den Groß/Klein-Modus ein.

### 5.	Zeichendrehung

.DREH,r stellt für r=0 den Horizontalbetrieb ein und verursacht bei r=1 eine Zeichendrehung um 90 Grad nach rechts.

### 6.	Druckerrückstellung und Speicherlöschung

.RESET setzt den Printer/Plotter zurück und löscht seinen Speicher.

### 7. Wahl der Linienart

.STRICH,I bestimmt die Linienart. Für I gelten die Angaben der Plotteranleitung.

### 8. Zeichnen von X/Y-Daten

TODO

.HOME bewegt zum Startpunkt (0/0).
.INIT legt den relativen Nullpunkt auf die derzeitige X/Y-Position.
.MOVE,x,y bewegt zur Position (x/y) relativ zum absoluten Nullpunkt (0/0).
.DRAW,x,y zeichnet zur Position (x/y) relativ zum absoluten Nullpunkt (0/0).
.RMOVE,x,y bewegt zur Position (x/y) relativ zum relativen Nullpunkt (x0/y0).
.RDRAW,x,y zeichnet zur Position (x/y) relativ zum relativen Nullpunkt (x0/y0).
.LINIE,x1,y1,x2,y2 zeichnet eine Linie von Position (x1/y1) zu Position (x2/y2).
.RAHMEN,x,y,b,h zeichnet einen Rahmen ab dem Eckpunkt (x/y) mit der Breite b und der Höhe h.
.KREIS,x,y,xr,yr zeichnet eine Ellipse um den Mittelpunkt (x/y) mit einem Radius in x-Richtung von xr und einem Radius in y-Richtung von yr. Gilt xr=yr so entsteht ein Kreis.
.RADIUS,x,y,xr,yr,w zeichnet in die entsprechende Ellipse einen Radius, der mit der positiven X-Achse den Winkel w (in Grad!) bildet.

Erklärung zum KREIS- und RADIUS-Befehl:

TODO

### 9. Zeichnen von X/Y/Z-Daten

Die folgenden Befehle dienen dazu, dreidimensionale Grafiken zu erzeugen. Im wesentlichen transformieren sie drei Raumkoordinaten auf zwei Ebenenkoordinaten. Allen Berechnungen liegen diese Formeln zugrunde:
x=f*\[xr+yr*cos(w)\]+xv
y=f*\[zr+yr*sin(w)\]+yv

yr und zr sind Raumkoordinaten, w ist der Betrachtungswinkel des Punktes in Grad, und f stellt einen Vergrößerungs- (für f größer als 1) beziehungsweise Verkleinerungsfaktor (für f zwischen 0 und 1) dar.

xv und yv dienen dazu, den Punkt im zweidimensionalen Koordinatensystem zu verschieben.

Die Achsen des räumlichen Koordinatensystems sind entsprechend der Abbildung bezeichnet:

TODO

.TRANSM,xr,yr,zr,xv,yv,f,w bewegt zur Position (x/y) relativ zum absoluten Nullpunkt, die sich durch Einsetzen aller Parameter in die obige Formel ergibt.

.TRANSD,xr,yr,zr,xv,yv,f,w zeichnet zur entsprechenden Position (x/y) relativ zum absoluten Nullpunkt.

.TRANSL,xr1,yr1,zr1,xv,yv,f,w,xr2,yr2,zr2 zieht eine Linie von (x1/y1) nach (x2/y2) entsprechend den Parametern.

Möchte man also beispielsweise das räumliche Koordinatensystem zeichnen, so wählt man als Ursprung der drei Achsen den Nullpunkt, also xr1 =yr1 =zr1=0. Je nachdem, welche Achse gezeichnet werden soll, setzt man für die xr-Achse xr2=1, yr2=0, zr2=0, für die yr-Achse dann xr2=0, yr2 = 1, zr2=0 und für die zr-Achse xr2=0, yr2=0 und zr2 = 1. Um das Bild in die Mitte des Papiers zu bringen, setzt man die x-Verschiebung xv=240 und die y-Verschiebung yv=0. Da als Länge für die Achsen »eins« zu klein ist, könnte man den Faktor f=50 wählen. Der Betrachtungswinkel sei w=45 (Grad). Somit ergibt sich für die Zeichnung des Koordinatensystems:

10 .TRANSL,0,0,0,240,0,50,45,1,0,0:REM xr-Achse

20 .TRANSL,0,0,0,240,0,50,45,0,1,0:REM yr-Achse

30 .TRANSL,0,0,0,240,0,50,45,0,0,1:REM zr-Achse

### 10.	Drehung von x/y/z-Koordinaten

Um einen Körper von allen Seiten darstellen zu können, müssen die Raumkoordinaten gedreht werden. Dabei ist es natürlich möglich, um jede beliebige Raumachse und um jeden beliebigen Winkel zu drehen. Macht man sich eine solche Drehung am Koordinatensystem deutlich, so bemerkt man, daß sich jeweils die Komponente nicht verändert, um deren Achse gedreht werden soll. Bei einer Drehung um die xr-Achse verändern sich nur die yr- und die zr-Komponente, bei einer Drehung um die yr-Achse verändern sich nur xr und zr etc.

Der Befehl .TURN,k1,k2,w benötigt daher außer der Angabe des Drehwinkels w in Grad nur die zwei Komponenten k1 und k2. Hierbei muß es sich um Variablen handeln! Vor dem Befehlsaufruf befinden sich in den Variablen die räumlichen Koordinaten eines Punktes und nach der Befehlsausführung stehen in den Variablen die Koordinaten des neuen (gedrehten) Punktes.

Angenommen, in den Variablen xr, yr und zr befinden sich die Koordinaten eines Punktes, so könnte man ihn folgendermaßen um den Winkel w drehen:

TODO

Drehung um die xr-Achse: .TURN,yr,zr,w
Drehung um die yr-Achse: .TURN,xr,zr,w
Drehung um die zr-Achse: .TURN,xr,yr,w

Anhand der Formeln zur Drehung läßt sich erkennen, warum der Befehl für alle drei Drehrichtungen richtige Ergebnisse liefert:

TODO

Drehung um die xr-Achse:
xr'=xr yr'=yr*cos(w)+zr*sin(w) zr'=-yr*sin(w)+zr*cos(w)
Drehung um die yr-Achse:
yr'=yr xr'=xr*cos(w)+zr*sin(w) zr'=-xr*sin(w)+zr*cos(w)
Drehung um die zr-Achse:
zr'=zr xr'=xr*cos(w)+yr*sin(w) yr'=-xr*sin(w)+yr*cos(w)

Ein kleines Beispielprogramm (Listing 2) demonstriert die Möglichkeiten dieses und des TRANSL-Befehls anhand der Drehung eines Körpers.

### 11.	Fehlerbehandlung

Um zum Beispiel ein Programm zu schreiben, das jede beliebige Funktion plottet, ist es erforderlich, mathematische Fehlermeldungen zu unterdrücken. Sobald nämlich eine Funktion Definitionslücken besitzt, steigen die meisten Programme mit einem »division by zero« oder ähnlichem aus.

Der Befehl .ERRJUMP,ze setzt die Programmausführung in der Zeile ze fort, sobald ein arithmetischer Fehler aufgetreten ist. Es handelt sich hierbei um die Fehler division by zero, illegal quantity und overflow. Sollte innerhalb einer FOR-NEXT-Schleife oder in einem Unterprogramm ein Fehler auftreten, so kann nicht wieder zu NEXT beziehungsweise RETURN gesprungen werden, da nun die notwendige Rücksprungadresse nicht mehr gefunden wird. FOR-NEXT-Schleifen und Unterprogrammsprünge lassen sich in solchen Fällen jedoch auch mit GOTO programmieren.

Der Befehl ist nur während des Programmablaufs wirksam, um zu verhindern, daß bei Fehlern im Direkt-Modus das Programm neu gestartet wird.

Sollen grundsätzlich alle Fehler unterdrückt werden, so muß hinter der Zeilennummer noch eine Sekundärvariable folgen:

.ERRJUMP,ze,s setzt die Programmausführung in der Zeile ze fort, sobald irgendein Fehler auftritt. Die Variable s ist nur eine Scheinvariable, das heißt sie wird weder verändert noch spielt ihr Typ eine Rolle. Am einfachsten ist es hier, eine Zahl anzugeben.

.ERRNUM,x schreibt in die Variable x die Fehlernummer des zuletzt aufgetretenen Fehlers. Bei x muß es sich um eine Variable handeln! Die Fehlernummer ist nur einmal lesbar und wird danach wieder auf Null gesetzt, bis der nächste Fehler auftritt. Innerhalb der Variablen bleibt die Fehlernummer natürlich erhalten. Die Fehlermeldungen besitzen folgende Nummern:

TODO

1	too many files
3	file not open
5	device not present
7	missing filename
9	illegal dev. number
11 syntax
13 out of data
15 overflow
17 undef’d statement
19 redim’d array
21 illegal direct error
23 string too long
25 form, too complex
27 undef’d function
29 load
2	file open
4	file not found
6	not input file
8 missing filename
10 nextwithoutfor
12 return without gosub
14 illegal quantity
16 outofmemory
18 bad subscript
20 division by zero
22 type mismatch
24 file data
26 can’t continue
28 verify

.ERROUT schaltet innerhalb des Programms die Fehlerunterdrückung wieder aus. Dieser Befehl wird zum Beispiel dann nötig, wenn am Ende des Programms ein Listing ausgedruckt werden soll, da beide Befehle den Warmstartvektor ändern. Grundsätzlich wird die Fehlerunterdrückung mit Ende des Programms abgeschaltet.

### 12.	Ausschalten von Plotter-Basic

.AUS setzt alle Zeiger wieder so, wie sie vor dem Start von Plotter-Basic standen und schaltet somit die Spracherweiterung ab. Erneutes Einschalten geschieht mit SYS 12*4096.

### Die Befehlsadressen im Speicher

Um sämtliche Zeiger unverändert zu lassen, kann man Plotter-Basic auch ohne Startaufruf benutzen. Nach dem Laden lassen sich alle Befehle über SYS-Aufrufe ausführen. Zum Beispiel: .KREIS,240,0,80,50 entspricht SYS 50184, 240,0,80,50

Parameter werden wie gewöhnlich durch das Komma getrennt.

Die Reihenfolge entspricht der Reihenfolge, in der die Befehlsworte erkannt werden. .KREIS wird also schneller erkannt als .FARBE.

TODO

INIT	= 49916	RADIUS	= 50644
SIZE	= 49783	ERROUT	= 51290
MOVE	= 49926	TRANSM	= 50729
DREH	= 49833	ERRNUM	= 51379
DRAW	= 49974	TRANSD	= 50751
STRICH	= 49888	AUS	= 49157
RMOVE	=49987 	TRANSL 	=	50764 
GG	=	49807	TURN	=	51091
RDRAW	=	50000	BLAU	=	49695
GK	=	49815	ROT	=	49703
HOME	=	49906	GRUEN	=	49711
PROG	—	50413	SCHWARZ	=	49719
RAHMEN	=	50471	FARBE	=	49727
TEXT	=	49851	KLEIN	=	49751
LINIE	=	50013	MITTEL	=	49759
RESET	—	49823	GROSS	=	49767
KREIS	=	50184	SUPER	=	49775
ERRJUMP	=	51233

(Stephan Schäfer/gk)

# 29 Druckerbefehle für Epson \[36-37\]

> Oft ist es recht mühsam, die vielen Fähigkeiten der Epson-Drucker auszunutzen. »Epson 29« macht das ständige Nachschlagen im Handbuch überflüssig.

Diese kurze, aber doch recht wirkungsvolle Erweiterung ermöglicht es auf einfachste Weise, Steuercodes an einen Epson-Drucker zu senden. Es belegt den freien RAM-Bereich zwischen den Speicherzellen 50000 und 50503, und arbeitet auch mit dem Centronics-Interface, das Sie in dieser Äusgabe finden, zusammen. Doch hier zuerst eine alphabetisch geordnete Übersicht:

TODO TABELLE

←A — Adresse: ←A, gefolgt von einer Zahl, legt fest, über welchen Kanal die folgenden Kommandos zum Drucker gesendet werden sollen. Beispiel: ←A4, die nachfolgenden Befehle werden über Kanal 4 zum Drucker geschickt. Wird dieser Befehl nicht gesendet, geht der Computer davon aus, daß Sie Kanal 1 benutzen.
←B — Breitschrift an
←D — Doppeldruck an
←E — Eliteschrift an
←F — Fettdruck an
←G — Glocke, sendet Bell-Code an Drucker, um zum Beispiel den Druckbeginn akustisch anzukündigen.
←I — Indexschrift an
←K — Kursivschrift an
←L — Linken Rand setzen. Beispiel: — L15 setzt linken Rand auf die 15. Druckposition.
←N — unidirektionaler Ausdruck (verbessert Qualität des
Schriftbildes).
←O — Potenzieren an
←P — Pica an
←R — Rechten Rand setzen (parallel zu «- L)
←S — Schmalschrift an
←U — Unterstreichen an
←6 — Zeilenabstand auf 1/6 Zoll
←7 -Zeilenabstand auf 1/72 Zoll
←8 — Zeilenabstand auf 1/8 Zoll
←2 — Zeilenabstand auf n/216 Zoll. Beispiel: ←2 159 setzt Zeilenabstand auf 159/216 Zoll.
←@ — Drucker-Reset
←0B — Breitschrift aus
←0D — Doppeldruck aus
←0F — Fettdruck aus
←0I — Indizieren aus
←0K — Kursivschrift aus
←0N — unidirektionaler Druck aus
←0O — Potenzieren aus
←0S — Schmalschrift aus
←0U — Unterstreichmodus aus

Als Kennzeichen für einen neuen Befehl steht ein Pfeil nach links (Taste in der linken oberen Ecke der Tastatur). Anstelle dieses Pfeiles kann man jedoch auch ein anderes Zeichen verwenden (zum Beispiel»!«), indem man in die Speicherzelle 50020 den ASCII-Wert dieses Zeichens POKEt. Falls Sie einen nicht definierten Wert senden, dies wäre zum Beispiel ←*, gibt der Computer die Fehlermeldung »PRINTER COMMAND ERROR« aus.

### Hier noch zwei weitere Vorteile des Programms:

1.	Die Befehle sind bis zu 6mal schneller. Um auf Breitschrift umzuschalten, benötigt der C 64 mittels CHR$-Codes zirka 0,013 Sekunden, mit dem Befehl — B sind es nur noch 0,002 Sekunden.
. 2. Der Basic-Speicherplatzbedarf ist wesentlich geringer! So benötigt das Demoprogramm 1 (Listing 2) im Vergleich zu dem in Standard-Basic geschriebenen Demoprogramm 2 (Listing 3) 66 Bytes weniger, dies sind nur 57% des benötigten Speicherplatzes von Listing 2.

Ich empfehle Ihnen zum besseren Verständnis, sich einmal die Listings der Demoprogramme anzuschauen, um den Umgang mit den neuen Befehlen kennenzulernen.

### Achtung:

Wenn einem Druckerbefehl kein PRINT#-Befehl folgt (eigentlich unlogisch, denn warum sollte man einen Befehl an den Druckersenden, wenn man gar nichts ausdrucken will?), . befindet man sich im CMD-Modus. Angenommen, Sie geben ←F und danach LIST ein, erscheint das Listing auf dem Drucker statt auf dem Bildschirm.

Wollen Sie einen dieser neuen Befehle innerhalb einer IF...THEN-Schleife verwenden, so müssen Sie nach THEN einen Doppelpunkt setzen (Beispiel: IF A=1 THEN:←S)

Haben Sie den Basic-Lader eingetippt, können Sie das Programm als reinen Maschinencode auf Diskette oder Kassette abspeichern; geben Sie dazu folgendes im Direktmodus ein:

POKE 43,80

POKE 44,195

POKE 45,22

POKE 46,197

SAVE "DRUCKERBEF.MC",8,1 (für Diskette)

oder

SAVE "DRUCKERBEF.MC",1,1 (für Kassette)

(Olaf Amblank/gk)

# Mit dem Drucker sprechen \[37-40\]

> Mit sinnvollen Kurzbefehlen erleichtert PROS V2.1 nicht nur die Arbeit mit dem Commodore 64 und dem Drucker MPS 802 ganz erheblich, es hält auch noch ein paar andere, ganz besondere Leckerbissen bereit. Und dabei arbeitet es sogar mit dem DOS V5.1 zusammen.

OPEN 1,4,7:CMD 1:LIST und dann PRINT#1:CLOSE 1, das ist es, was der gequälte Druckerbesitzer eingeben muß, bloß um ein paar eingegebene Basic-Programmzeilen schwarz auf weiß in den Händen halten zu können. Und da diese Eingabe nur im Direktmodus ohne weiteres möglich ist, fällt die endlose Tipperei jedesmal von neuem an.

Das hat jetzt ein Ende! Das PROS V2.1 nämlich bietet MPS802-Benutzern für solch umfangreiche Befehlssequenzen sehr einfache Abkürzungen an. Aber auch Besitzer anderer Drucker, besonders des MPS 801, sollten ruhig weiterlesen. Denn wenn das Programm Anklang findet, ist eine baldige Entwicklung eines Zwillings für diese Drucker nicht auszuschließen.

Das Format der PROS-Befehle dürfte Floppy-Besitzern in ähnlicher Form bereits vom DOS V5.1 auf der Demo-Diskette bekannt sein. Sie alle bestehen lediglich aus dem Pfund-Symbol (oben rechts, die dritte Taste) und einem weiteren Zeichen. Das oben genannte Listen sähe mit dem PROS zum Beispiel ganz einfach so aus:

£+ (Pfund) und (Plus)

um die Ausgabe auf den Drucker zu lenken,

LIST

um das Programm zu listen und

£— (Pfund) und (Minus)

um die Ausgabe wieder auf den Bildschirm zu holen.

Dem LIST-Befehl können Sie selbstverständlich auch Zeilenangaben beifügen, ganz wie Sie es bisher gewohnt waren.

Außer der normalen Ausgabeumleitung besteht noch die Möglichkeit, den Ausdruck zu formatieren. In der vorliegenden Version ist ein 40 Zeichen breites Ausgabefeld in Papiermitte eingestellt. Dieses Format ist zum Beispiel beim Ausdruck von Disk-Directories und disassemblierten Maschinenprogrammen sehr nützlich. Wie Sie die entsprechenden Parameter im PROS bereits bei der Eingabe ändern können, lesen Sie bitte weiter hinten.

Die Ausgabebefehle sind natürlich längst noch nicht alles, was das PROS zu bieten hat. Die Befehlsübersicht informiert Sie über die Einsatzmöglichkeiten der restlichen zehn PROS-Befehle.

Doch ich sprach eingangs von einigen besonderen Leckerbissen. Ich habe nämlich bei der Erstellung des Programms die Gelegenheit beim Schopfe ergriffen, noch einige andere Unbequemlichkeiten aus dem Weg zu räumen. So stört es zum Beispiel oft genug, daß beim Commodore 64 auf den Einbau einer Escape-Taste verzichtet wurde. Im PROS wird deshalb die Commodore-Taste zusätzlich mit dieser Funktion belegt, ohne dadurch in sonstigen Funktionen eingeschränkt zu werden.

Außerdem bekamen noch die beiden Funktionstasten F1 und F3 einen Auftrag zugewiesen: die Stop-Funktion. Wenn Sie in Zukunft einen ganz bestimmten Teil Ihres Basic-Programms suchen, sind Sie nicht mehr auf die CTRL-Taste angewiesen, um den LIST-Befehl zu verlangsamen. Sie brauchen nur F1 zu drücken und schon »schläft« der Computer. Erwecken Sie ihn dann mit der F3-Taste zu neuem Leben, so setzt er seine Arbeit genau dort fort, wo er sie zuvor unterbrochen hat.

Die Funktion dieser beiden Routinen beruht auf dem »Verbiegen« des Interrupt-Vektors in der Zeropage (Adresse 788/789). Bei Betätigung der Tasten RUN/STOP-RESTORE wird dieser Vektor jedoch automatisch wieder mit seinen Ursprungswerten versehen, das heißt die beiden Funktionen sind nicht mehr ohne weiteres verfügbar. Um Ihnen nun einen Neuaufruf des PROS (SYS 51555) zu ersparen, kann mit Hilfe von \[Pfund\] \[Pfund\] \[Return\] der entsprechende Programmteil neu aktiviert werden.

Ebenfalls neu aktiviert werden dabei der Kleinschriftmodus und die Repeat-Funktion für alle Tasten. Wollen Sie auf eine der beschriebenen Funktionen von vornherein verzichten, finden Sie auch hier die notwendigen Angaben zur Änderung weiter hinten.

Das Funktionsprinzip der eigentlichen PROS-Befehle basiert auf einer Veränderung des Vektors, der auf den Anfang jener Schleife zeigt, die einen Basic-Befehl holt und ausführt (Speicherstellen 776/777). Wann immer der Computer eine Basic-Zeile liest, im Programm oder im Direktmodus nach Drücken der Return-Taste, wird er nun zunächst prüfen, ob das jeweils gelesene Zeichen ein Pfundzeichen ist. Ist es das nicht, so wird der Prüfvorgang in der normalen Basic-Befehlstabelle fortgesetzt und gegebenenfalls der entsprechende Basic-Befehl ausgeführt. War das Zeichen hingegen tatsächlich ein »Pfund«, so wird jetzt in die PROS-Befehlstabelle gesprungen, um anhand des zweiten Zeichens den richtigen PROS-Befehl herauszusuchen.

Die Arbeitsgeschwindigkeit des Computers wird also kaum verringert, denn zunächst wird ja nur auf ein Zeichen mehr als üblich geprüft. Mit den zusätzlichen Befehlscodes wird erst verglichen, wenn feststeht, daß das PROS tatsächlich angesprochen werden soll.

Für die Abfragetechnik diente mir übrigens der Artikel »Maschinenprogramme auf Tastendruck« von P. Fleig in der 64’er, Ausgabe 12/84, Seite 80, als nützliche Vorlage.

Kommen wir nun zur Speicherbelegung des PROS V2.1. Es belegt die 648 Bytes von $C963 (dez. 51555) bis einschließlich $CBEA (dez. 52202). Daß ich genau diesen Speicherplatz gewählt habe, hat mehrere Gründe:

Erstens läßt das PROS so mehr als dreiviertel des Maschinenspeichers ($C000 - $CFFF) zusammenhängend frei.

Zweitens ist die Startadresse (51555) beim SYS-Aufruf denkbar leicht und entsprechend schnell einzutippen.

Und drittens beträgt der Abstand zum DOS 5.1, das sich ja bei Floppy-Benutzern großer Beliebtheit erfreut, nur genau 22 Bytes. So lassen sich das PROS, das DOS und sogar noch ein weiteres Programm, zum Beispiel das (verschobene) UNNEW (siehe D. Kossmann: Die Ebenen des Absturzes, 64’er, Ausgabe 11/84, Seite 92), mit Hilfe eines Maschinensprachemonitors hintereinander auf Diskette abspeichern und später auch zusammen wieder laden, ohne viel Speicherplatz zu verschwenden.

Um ein solches Kompaktprogramm noch besser nutzen zu können, enthält das PROS noch ein weiteres Extra: Die Speicherstellen $C96D-C96F (MSE-Listing: zweite Zeile, dritte bis fünfte Zahl) enthalten die Werte 4C, 70 und C9. Sie bewirken lediglich einen Sprung in die nächste Speicherstelle. Und doch liegt genau darin der Sinn dieser drei Bytes: Wenn Sie sie nämlich durch die Werte 20, 00 und CC ersetzen, wird beim Aufruf des PROS mit SYS 51555 das DOS (das Sie ja gleich mitgeladen haben) von hier aus mit aufgerufen. Sie sparen sich durch diese kleine Änderung also jedesmal den Aufruf des DOS.

Das PROS besteht aus zwei Teilen. Im ersten Abschnitt, das ist der, welcher beim Aufruf angesprungen wird, werden die erwähnten Vektoren in der notwendigen Weise geändert. Die ebenfalls bereits angesprochenen Interrupt-Routinen werden aktiviert und das Titelbild wird auf den Bildschirm gebracht.

## Automatische Grundeinstellung

Auch mit diesem Titelbild hat es eine besondere Bewandtnis: Neben dem Namen des Programmierers, ich spreche von mir, enthält es eine Zeile, in der sich bereits einige PROS-Befehle, durch Doppelpunkte voneinander getrennt, befinden. Wenn sich der Computer nun nach dem Aufruf mit »READY« wieder meldet, befindet sich der Cursor genau in dieser Zeile. Sie brauchen also nur noch »RETURN« zu drücken und schon haben Sie ein paar notwendige Grundeinstellungen für den Drucker getroffen.

Diese Grundbefehle sind im einzelnen folgende:

1.	Drucker in Grundstellung setzen
2.	Fehlermeldungen des Druckers ermöglichen
3.	zu druckende Zeilen pro Seite festlegen und
4.	Seitenaufteilung anschalten.

Auch hier erhalten Sie weiter unten die notwendigen Informationen, die für eine Änderung beziehungsweise eine Ergänzung der Grundeinstellung notwendig sind.

Der zweite Abschnitt des PROS V2.1 beginnt bei $C974 (dez. 51572). Hier wird zunächst der Befehl geprüft und dann zu der entsprechenden Unterroutine gesprungen.

Das Programmlisting wurde mit Hilfe des MSE erstellt und wird mit ihm eingegeben.

Die Änderungen können mit einem Maschinensprachemonitor, zum Beispiel dem SMON, eingegeben werden.

## Bedienungsanleitung

### 1.	Aufruf

Das PROS V2.1 muß absolut geladen werden. Danach genügt die folgende Eingabe zum Aufruf:

NEW \[Return\]

SYS 51555 \[Return\]

Danach können die Grundeinstellungen durch nochmaliges Drücken der Return-Taste aktiviert werden.

### 2.	Sonderfunktionen

Durch die Inbetriebnahme des PROS werden gleichzeitig einige besondere Funktionen eingeschaltet. Diese Funktionen werden durch die Tastenkombination RUN/STOP-RESTORE desaktiviert, können aber durch \[Pfund\] \[Pfund\] \[Return\] wieder aufgerufen werden.

Die Funktionen sind im einzelnen folgende:

### Stop-Funktion

Ein Druck auf die Funktionstaste F1 läßt den Computer augenblicklich seine derzeitige Arbeit unterbrechen.

Durch Betätigen der Taste F3 wird der Arbeitsvorgang an der gleichen Stelle fortgesetzt, an der er unterbrochen wurde.

### Escape-Taste

Die Commodore-Taste bekommt zusätzlich die Funktion einer Escape-Taste zugewiesen. Wird sie gedrückt, so verläßt der Computer den Quote-Modus (Hochkomma-Modus), das heißt, innerhalb von Anführungszeichen werden bei Benutzung der Cursortasten nicht mehr die Steuerzeichen ausgegeben.

### Repeat-Funktion

Alle Tasten werden mit der Repeat-Funktion ausgestattet. Das einer Taste entsprechende Zeichen wird solange immer wieder ausgegeben, wie diese Taste gedrückt ist.

### Groß-/Kleinschrift

Der Groß-/Kleinschriftmodus wird eingeschaltet.

### 3.	Befehle

Alle PROS-Befehle beginnen mit dem Pfundzeichen. Dem folgt ein weiteres Zeichen und gegebenenfalls ein Parameter mit Werten zwischen 1 und 127.

Als PROS-Befehle werden anerkannt:
**£S**, <Parameter>
Festlegen des Zeilenabstandes. Drei Schritte entsprechen einer Punktbreite.
**£P**, <Parameter>
Festlegen der zu druckenden Zeilen pro Seite. Europäische Norm für Endlospapier: 66 Zeilen. Amerikanische Norm: 60 Zeilen.

Bei verändertem Zeilenabstand muß auch die Zahl der Zeilen pro Seite geändert werden, um eine saubere Seitenaufteilung zu erreichen. Es bieten sich dabei folgende Kombinationen an:
S24 - P102; S27 - P90; S32 - P75
S36 - P66 (Grundstellung)
S48 - P48; S54 - P42; S72 - P36
(bezogen auf die europäische Norm)
**£(, £)**, \[runde Klammer auf beziehungsweise zu\]

Seitenaufteilung an- oder ausschalten. Bei angeschalteter Seitenaufteilung wird die festgelegte Zahl der Zeilen pro Seite gedruckt. Dann erfolgt ein Zeilenvorschub von sechs Zeilen und der Druck wird auf der nächsten Seite fortgesetzt.
**£\[ ,£ \]** ,\[eckige Klammer auf beziehungsweise zu\] Fehlermeldungen des Druckers ermöglichen beziehungsweise unterdrücken (Grundstellung).
**£+**, \[Plus\]
Ausgabe auf den Drucker lenken. Dieser Befehl entspricht in Basic der Befehlsfolge
OPEN 1,4,7:CMD 1
**£F**

Formatierte Ausgabe auf den Drucker lenken. In der Grundversion des PROS V2.1 ist ein 48 Zeichen breites Ausgabefeld in der Papiermitte, wie es zum Ausdruck von Disk-Direktories und disassemblierten Maschinenprogrammen nützlich ist.

Achtung: Soli der Ausdruck mit Hilfe eines Maschinensprachemonitors erfolgen, empfiehlt es sich, vorher die Ausgabe von Fehlermeldungen zu unterdrücken, da unter Umständen der Ausgabeabschluß nicht korrekt erfolgen kann. Auf die Arbeitsweise mit dem Drucker hat diese Fehlermeldung sonst keine Auswirkungen.
**£—**, \[Minus\]
Aufheben des durch £ + oder £ F erreichten Ausgabemodus. Nach diesem Befehl erfolgt die Datenausgabe wieder auf dem Bildschirm.
**£#**, (Doppelkreuz)
Wiederherstellung der Druckergrundstellung (Einschaltzustand).
**££** \[Pfund\]
Wiederaktivieren der PROS-Sonderfunktionen.
**£Q**
Verlassen des PROS V2.1. Nach Eingabe dieses Befehls sind alle PROS-Befehle außer Betrieb. Um wieder mit dem Programm arbeiten zu können, muß es mit SYS 51555 neu aufgerufen werden.
Die Sonderfunktionen werden durch diesen Befehl nicht aufgehoben.

## Änderungsvorschläge

### 1.	PROS-Befehlscode \[Pfund\] ändern

Sollen die PROS-Befehle mit einem anderen Zeichen als dem »Pfund« beginnen, so muß der ASCII-Code des gewünschten Zeichens in der Speicherstelle $C978 (dez. 51576) stehen. In der Normalversion lautet dieser Wert $5C (dez. 92).

### 2.	Änderung beziehungsweise Ergänzung der Grundbefehle in der Titelseite

Die Grundbefehle befinden sich in den Speicherstellen $CA58 - $CA7c (dez. 51800 - 51836). Die Befehle müssen als hexadezimale ASCII-Codes eingegeben werden. Der Code für das Pfundzeichen lautet $5C (92).

### 3.	Ausschalten der Kleinschrift

Um beim PROS-Aufruf den Großschriftmodus beizubehalten, müssen die Bytes $CA90 - $CA95 mit dem Wert $EA (Befehlscode für NOP) aufgefüllt werden.

Um auch im Ausgabemodus (PROS-Befehl \[Pfund\] und \[Plus\]) im Großschriftmodus zu bleiben, muß die Speicherstelle $CBA5 (dez. 52133) statt $07 den Wert $00 erhalten.

### 4.	Ausschalten der Repeatfunktion für alle Tasten

Um diesen Effekt zu vermeiden, sind die Bytes $CA8B -$CA8F mit dem Wert $EA aufzufüllen.

### 5.	Ausschalten der Stop-Funktion und der Escape-Taste

Die entsprechenden Routinen lassen sich umgehen, indem in den Speicherstellen $C9E7 (dez. 51687) und $CB9F (dez. 52127)jeweils der Wert $7F durch $8B ersetzt wird.

Der Bereich $CA7F - $CA8A (dez. 51839 - 51850) wird dadurch übersprungen und kann zum Beispiel für individuelle PROS-Erweiterungen als Speicherplatz dienen.

### 6.	Änderung der Tastenbelegung der Stop-Funktion

Um die Tastenbelegung für die Stop-Funktion (normalerweise F1 und F3) zu ändern, müssen die Tastaturcodes der gewünschten Tasten in die Speicherstellen $CA9A (statt F1-Taste) und $CAB3 (statt F3-Taste) geschrieben werden. Die Dezimalwerte der Adresse: 51866 und 51891.

### 7.	Escape-Taste verlegen

In der PROS V2.1 Normalversion versieht die Commodore-Taste zusätzlich den Dienst einer Escape-Taste. Ersatzweise können auch die Taste \[CTRL\] oder \[Pfeil nach links\] mit dieser Aufgabe betraut werden. Dazu muß die Stelle $CABB den Wert $FB (dez. 251) beziehungsweise $FD (dez. 253) bekommen.

### 8.	Änderung der Gerätenummer

Das PROS V2.1 kann der Gerätenummer des benutzten Druckers angepaßt werden, indem der neue Wert in die Stelle $CACE (dez. 51918) geschrieben wird.

### 9.	Verändern des formatierten Ausgabefeldes

Das in der Normalversion festgelegte formatierte Ausgabefeld (40 Zeichen breit in Papiermitte) kann wie folgt verändert werden:

Die gewünschte Breite des linken Randes ist in der Speicherstelle $CBC8 (dez.52168), die des Ausgabefeldes in $CBD2 (dez. 52178) abzulegen.

Hinweis: Auf der Leserservice-Diskette befindet sich einmal das PROS V2.1 selbst und zusätzlich mit integriertem DOS V5.1 und dem Programm UNNEW. Aufruf von UNNEW: SYS 53166.

(Peter T. Schmidt/gk)

# Sprite+Grafik-Basic \[42-54\]

> Diese für den C 64 geschriebene Basic-Erweiterung wurde speziell für das Programmieren von Sprites und hochauflösender Grafik entwickelt, enthält jedoch auch zusätzliche, nicht grafikbezogene Befehle.

Sprite+Grafik-Basic wurde für den Commodore 64 ohne besondere Peripherie geschrieben. Das Programm wird mit LOAD geladen und mit RUN gestartet.

»Das für den Commodore 64 geschriebene Sprite+Grafik-Basic ist eine Basic-Erweiterung, die speziell das Programmieren von Sprites und hochauflösender Grafik unterstützt. Selbstverständlich werden auch Befehle zum Editieren der Programme und die nötigsten strukturierenden Befehle zur Verfügung gestellt.

Sprite+Grafik-Basic erweitert das bescheidene V2-Basic um mehr als 100 Befehle. Davon sind 32 Befehle zur Programmierung der Sprites vorgesehen.

Außer den üblichen Parametern der Spriteprogrammierung können Sie die Sprites spiegeln, drehen und noch vieles mehr. Durch die vielseitigen Befehle zur Definition der Spritematrix kann selbst der Anfänger ohne einen zusätzlichen Spriteeditor hervorragende Sprites erstellen. Die Spritematrixblöcke — es stehen maximal 144 davon zur Verfügung — benötigen natürlich keinen Basic-Programmspeicher.

Auch zum Erstellen von ansprechenden Bildschirmmasken bietet Sprite+Grafik-Basic 14 neue Befehle. Es ist zum Beispiel möglich, den Bildschirm in alle vier Richtungen zu scrollen oder bestimmte Flächen mit Zeichen zu füllen.

Für die Programmierung von hochauflösender Grafik und Multicolorgrafik stehen natürlich die Befehle, um Punkte und Linien zu setzen zur Verfügung. Darüber hinaus können Ellipsen, Ellipsenbogen, Radien, Rechtecke und Blöcke mit einfachen Befehlen definiert werden. Eine der Besonderheiten von Sprite+Grafik-Basic ist der GPRINT-Befehl, der es ermöglicht — annähernd so komfortabel wie der PRINT- Befehl der Blockgrafik — Text in die Grafik einzubauen. Bei jedem dieser Befehle kann natürlich gewählt werden, ob ein Punkt gesetzt, gelöscht oder invertiert werden soll.

Nach dem Ausschalten der Grafik und dem Wiedereinschalten bleibt diese vollständig erhalten. Hierdurch kann sie auch im ausgeschalteten Zustand durch zwei Befehle abgespeichert oder geladen werden.

Über einen SYS-Befehl und wenige POKEs läßt sich sogar ein Textfenster in die Grafik einblenden.

Insgesamt bietet Sprite+Grafik-Basic 16 High-Resolution-Befehle. Diese Grafikmöglichkeiten werden durch das Erzeugen von blinkenden Zeichen oder durch Blinken des Rahmens zusätzlich verstärkt. Die Programmierung von Sprites und Grafik läßt also kaum Wünsche offen.

Damit diese Sprite+Grafik-Programmierung möglichst einfach und übersichtlich wird, gibt es in Sprite+Grafik-Basic knapp zehn Befehle zur Strukturierung der Programme. Dies sind alle üblichen Befehle wie zum Beispiel REPEAT ... UNTIL, CASE ... THEN ... ELSE und den mit Labeln arbeitenden Sprungbefehlen. Außerdem existiert ein Befehl, mit dem Sie die letzte IF-Bedingung noch einmal abfragen können.

Um all diese Befehle platzsparend und einfach in ein Programm einbauen zu können, stehen etwa 20 weitere Befehle zur Verfügung. Man kann damit sofort editieren oder auch nach Zeichenketten und Befehlen im Programm suchen. Es ist ebenfalls möglich, ein Programm zeilenweise abzuspeichern oder ein Programm nachzuladen.

Zur Vereinfachung der Programmierung können die Funktionstasten mit beliebigen Zeichenketten belegt werden.

Falls ein Programm nicht funktioniert, findet man mit dem TRACE-Modus sehr leicht den Fehler. Dieser Modus zeigt immer die aktuelle Zeile an — natürlich auch in High-Resolution-Grafik. Um Fehler bei den neuen Befehlen besser zu verstehen, sind noch einige neue Fehlermeldungen implementiert. Außerdem wird die fehlerhafte Zeile angezeigt und die fehlerhafte Stelle markiert.

## Blockgrafikbefehle (40x25 Auflösung)

TODO TABLE

## Besonderheiten

Beim FILL/ZFILL/FFILL-Befehl muß die linke obere Ecke auch wirklich die linke obere Ecke des Rechtecks sein, da der Computer sonst unweigerlich »abstürzt«.

Der TRACE-Befehl verträgt sich leider nicht mit den Befehlen, die den Interrupt beeinflussen (VEC, OLDVEC, B/G/BG FLASH). Dies läßt sich aber einfach durch Drücken der RUN/STOP-RESTORE-Taste, nachdem TRACE eingegeben wurde, ändern. Die Unverträglichkeit des TRACE-Befehls und der »Interrupt-Befehle« resultiert aus der Umlenkung des Interrupts auf einen Rasterzeileninterrupt beim TRACE-Befehl. Dieser Rasterzeileninterrupt sorgt dafür, daß beim TRACE-Befehl die obersten drei Zeilen immer in Blockgrafik angezeigt werden.

Aber auch ohne TRACE-Modus kann man den Rasterzeileninterrupt nutzen. Er wird mit SYS 31851 aktiviert. Zuvor müssen Sie allerdings in die Speicherstellen 31889 und 31903 jeweils die Rasterzeile (0 bis 255), in der auf hochauflösende Grafik umgeschaltet wird, POKEn. Außerdem muß die Speicherstelle 31929 die Rasterzeile (0 bis 255) enthalten, in der wieder auf Textmodus zurückgeschaltet wird. Das Ausschalten dieses Rasterzeileninterrupts ist nur durch NRM oder RUN/STOP-RESTORE möglich.

Im TRACE-Modus funktioniert auch der GET-Befehl nicht mehr, da die Speicher der zuletzt gedrückten Taste ständig gelöscht werden.

Die Funktion TEST setzt wie alle anderen Grafikbefehle den Grafikcursor. Hiermit können Sie also vor jedem GPRINT den Grafikcursor an die gewünschte Position setzen.

Den Befehl @ sollten Sie nicht alleine verwenden. Der Computer könnte abstürzen. Das gleiche kann passieren, wenn Sie bei Befehlen einen oder mehrere Parameter vergessen.

Wenn ein HiRes-Bild auf Diskette gespeichert wird, blinkt die Floppy-LED, da das Programm hauptsächlich für Datasette geschrieben wurde. Das HiRes-Bild kann zwar später wieder geladen werden, jedoch nur in Schwarz-Weiß. Die Farb-Informationen sind verloren.

## Fehlermeldungen

Ist ein Programm beendet oder tritt eine Fehlermeldung auf, wird der hochauflösende Grafikmodus ausgeschaltet. Bei einem Fehler wird die fehlerhafte Zeile gelistet. Bei den meisten Fehlern wird der ungefähre Fehlerpunkt negativ (invers) gekennzeichnet.

### Zusätzliche Fehlermeldungen zum Basic V2:

### UNTIL WITHOUT REPEAT

Tritt auf, wenn der Computer auf UNTIL trifft, ohne daß ein REPEAT vorausging.

### LABEL NOT FOUND

Tritt auf, wenn ein Sprunglabel nicht vorhanden ist.

### SUBEND WITHOUT CALL

Tritt auf, wenn der Computer auf SUBEND trifft, ohne daß ein CALL vorausging.

### ILLEGAL SPRITE NUMBER

Tritt auf, wenn die Spritenummer sn größer als 7 ist.

### ILLEGAL SPRITE STRING

Der String des DESIGN-Befehls enthält einen Fehler.

### SPRITE DESIGNING COORDINATE

Tritt auf, wenn beim SPLOT-Befehl falsche x/y-Koordinaten angegeben werden.

(Jens Schwarz/ah)

# Hardcopy CP-80X mit Simons Basic \[55\]

> Mit diesem Programm können Sie Hardcopies von HiRes-Grafiken in Simons Basic erstellen.

Das Programm erstellt eine Hardcopy der HiRes-Grafik von Simons Basic. Dem CP-80X ist zwar ein Heft mit mehreren Routinen für den C 64 beigelegt, doch die darin aufgeführte Hardcopy für Simons Basic funktionierte leider nicht. Da der Drucker noch relativ neu auf dem Markt und nicht ganz Epson-kompatibel ist (wegen des eingebauten Interfaces), ist bisher noch keine Hardcopy erschienen. Dieses Programm schafft »schnelle« Abhilfe (Maschinensprache, Druckzeit: 58 Sekunden).

Nach dem Abtippen des Programms (Abspeichern nicht vergessen!) wird es mit RUN gestartet.

Es liest dann die Daten ein und überprüft diese auf ihre Richtigkeit. Da in jeder Zeile Prüfsummen eingebaut sind, können eventuelle Fehler auf eine Zeile genau lokalisiert werden.

Danach wird das Maschinenspracheprogramm gestartet, dieses löscht das Ladeprogramm und schützt das Maschinenprogramm vor dem Überschreiben durch Basic.

Dann kann durch »SYS 32000« jederzeit eine Hardcopy der Grafikseite erstellt werden. Die Hardcopy wird in der Mitte des Blattes ausgedruckt, nach dem Drucken wird der Zeilenabstand zurück auf 1/6 inch gestellt.

(Stephan Arndt/rg)

# »Multicolor« auf dem FX/RX-80 \[56-57\]

> Hardcopy-Programme für den Epson FX gibt es viele. Doch dieses Programm ermöglicht eine Umsetzung der Farben in verschiedene Graustufen.

Die meisten Drucker-Besitzer werden sich schon geärgert haben, daß »normale« Hardcopies von Multicolor-Grafiken kaum als solche zu erkennen waren. Besitzer eines Epson-RX/FX-80 sind jetzt fein raus.

Ich habe mich geärgert, als ich das erste Mal die Hardcopy einer Strip-Poker-Grafik auf meinem FX-80 ausdrucken wollte. Als ich dann noch den Test des PRINT-64-Interfaces in der 64’er, Ausgabe 12/84, gelesen habe, das den Ausdruck von Multicolor-Grafiken mittels Grauschattierungen erlaubt, habe ich mir gedacht: Das muß doch auch softwaremäßig machbar sein.

Gesagt, getan. Eines Abends nahm ich mir eine Flasche Cola und etwas Knabberkram und fing an zu programmieren. Nach mehreren erfolglosen Anläufen und stapelweise bedrucktem Papier war ich am Ziel: »M-C-HRDCPY«lief. Doch nun zum eigentlichen Programm.

## Das Prinzip

Eine Multicolor-Grafik ist ja im wesentlichen genauso wie eine normale Grafik aufgebaut, nur repräsentieren jetzt zwei statt einem Bit einen Punkt auf dem Bildschirm. In dieser Kombination aus den beiden Bits steckt jetzt noch eine Farbinformation: Sind beide Bits 0, so wird der Punkt in der Farbe des Hintergrundregisters gesetzt, sind sie jedoch 01, 10 oder 11, wird der Punkt in der Farbe aus den Registern 33 bis 36 des VIC gesetzt. .

Ich verfahre nun so, daß ich jeden Bildschirmpunkt in einer Matrix von 2x12 Punkten auf dem Drucker darstelle. Durch die Anordnung der Punkte in dieser Matrix kann ich nun verschiedene Graustufen darstellen — die Grundlage ist damit gegeben.

## Die Bedienung

Die Bedienung mag auf den ersten Blick etwas kompliziert erscheinen, erlaubt dafür aber auch optimale Variationsmöglichkeiten.

Vorjeder Anwendung kommt aber leider noch das Abtippen von 438 DATAs. Wenn Sie das gemacht haben, sollten Sie das Programm vorsichtshalber vor dem Starten speichern (so mancher mußte wegen eines Tippfehlers noch einmal anfangen ...). Nach dem Starten sollte sich das Programm nach zirka vier Sekunden mit der Frage »Startadresse?« melden. Geben Sie nun ein, wo Sie das Programm im Speicher haben wollen. Eine kleine Hilfe hierzu gibt die Tabelle, die günstige Startadressen für verschiedene Programme nennt.

Dann wird die Floppy anlaufen (falls Sie nur eine Datasette besitzen — bei Vorhandensein eines Epson-Druckers recht unwahrscheinlich — müssen Sie die Zeilen 1250 bis 1280 herausnehmen und zum Arbeiten immer wieder den Basic-Lader benutzen) und ein File namens »M-C-HRDCPY (Startadresse)« wird auf Diskette erzeugt. Gleichzeitig wird das Programm adressenangepaßt in den Speicher ab (Adresse) geschrieben. Wenn Sie »M-C-HRDCPY« nun noch eventuell durch POKE 55,(adresse) INT(adresse/256)*256:POKE 56,INT(adresse/256): CLR schützen, kann der erfolgreichen Hardcopy eigentlich nur noch das Dreckfuhlerteufelchen im Wege stehen.

Nun zum Aufruf der Hardcopy-Routine. Generell hat er die Form:

SYS (adresse),(filenummer),(page),a,b,c,d

**(adresse)** ist die Startadresse des Programms — die, die Sie auf die Frage »Startadresse?« eingegeben haben —, für

**(filenummer)** setzen Sie eine 0 ein, falls Sie Ihren Drucker am User-Port angeschlossen haben oder die Filenummer eines Files, das Sie vorher auf den Drucker zur Übergabe von Grafikdaten geöffnet haben.

**(page)** ist die Speicherseite, auf der die Grafik beginnt — also INT(Adresse der Grafik/256) und

**a,b,c,d** sind die Masken für die Graustufen der Hardcopy.

Wie bereits erwähnt, kennt der VIC vier Möglichkeiten für die Darstellung eines Punktes, nämlich die Kombinationen 00, 01, 10 oder 11. Andererseits kennt die Hardcopy-Routine vier Graustufen. Die Parameter a, b, c und d geben nun an, wie die Bitkombinationen den Graustufen zugeordnet werden. a gibt an, welche Bitkombination auf dem Drucker ganz hell, b, welche hellgrau, c, welche dunkelgrau und d, welche schwarz dargestellt werden, a, b, c und d müssen dabei den dezimalen Wert der Bitkombinationen annehmen, das heißt, 0 für 00, 1 für 01, 2 für 10 und 3 für 11. Ein Beispiel hierzu gibt der Hardcopy-Ausdruck.

Hier noch einmal zur Übung:

Angenommen, Sie haben eine Simons Basic-Multicolor-Grafik und wollen diese so ausdrucken, daß die 00-Punkte Schwarz, die 01-Punkte hellgrau, die 10-Punkte weiß und die 11-Punkte dunkelgrau dargestellt werden.

Also laden Sie den Basic-Lader, sehen in der Tabelle nach, welche Startadresse günstig ist, geben diese ein und tippen dann, nachdem sich der Computer wieder mit READY gemeldet hat, ein:

POKE 55,44:POKE 56,126:CLR

um M-C-HRDCPY vor dem Überschreiben zu schützen und dann weiter:

SYS 32300,0,224,2,1,3,0

falls Sie den Drucker am User-Port betreiben beziehungsweise

OPEN xx,(Druckeradresse),(Grafiksekundäradresse)

SYS 32300,xx,224,2,1,3,0

falls Sie ein Hardware-Interface besitzen.


Das Programm wurde auf einem FX-80 sowohl mit Software- als auch mit Data-Becker- und Görlitz-Hardwareinterface und auf einem RX-80 mit Software- und Görlitz-Hardwareinterface getestet und lief in allen Fällen problemlos. Vermutlich ist das Programm auch auch dem MX-80 und anderen Epson- und Epson-kompatiblen Druckern lauffähig. Im Zweifelsfall müssen Sie daher ausprobieren, ob auch Ihr Drucker für dieses Programm geeignet ist, kaputt kann eigentlich nichts gehen. Benutzt werden folgende Steuersequenzen: ESC 1, um den Drucker auf 7/72 Inch Zeilenvorschub zu schalten, ESC (Klammeraffe), um ihn zu initialisieren und ESC Z, um ihn in 1920 Punkte/Zeile-Grafikmodus zu bringen.

## Die Kompatibilität

Da das Programm also recht viele Drucker unterstützt, frei verschiebbar ist, den Ausdruck von Grafiken aus den versteckten RAMs erlaubt und sowohl Hard- als auch Software-Interfaces unterstützt, sollte meiner Meinung nach ein Höchstmaß an Kompatibilität gewährleistet sein.

Ansonsten viel Spaß und gut Druck!

(Karsten Klenz/rg)

# Große Hardcopy auf Star Gemini \[57-59\]

> Posterähnliche Hardcopies können die Star Gemini-Besitzer mit diesem Programm erzeugen.

Geben Sie das Programm genau nach Programmlisting, von Basic aus ein, vergleichen Sie es und speichern Sie es ab. Danach können Sie den Basic-Lader mit RUN starten. Das Programm sollte sich mit »Datas OK !«, »AUFRUF ; SYS 49152,ADR,FN,GN,SA,INV« melden und ist nun ab sofort startbereit.

Sollte diese Meldung nicht erscheinen und »Fehler in Datas !!!« gemeldet werden, so ist eine Diskrepanz in der Prüfsumme aufgetreten. Die DATA-Zeilen sind fehlerhaft. Kontrollieren Sie das Programm noch einmal genau anhand des Listings und starten Sie es erneut.

Ist das Programm bereit, so können Sie den Basic-Lader mit NEW aus dem Arbeitsspeicher löschen. Laden Sie nun eine bereits abgespeicherte Grafik, oder erzeugen Sie per Programm den gewünschten HiRes-Bildschirm. Zum Poster-Ausdruck starten Sie die Routine mit »SYS 49152, ADR, FN, GN, SA, INV«. ADR gibt dabei die Startadresse des 8-KByte-Bereiches an. Oft ist dies die Adresse 8192 ($2000), es ist jedoch auch möglich, Bildschirme, die unter dem ROM stehen, auszudrucken. Für Simons Basic wäre dies zum Beispiel die Adresse 57344 ($D000). Die drei nächsten Parameter entsprechen den Angaben des OPEN-Befehls. Sie beinhalten die Filenummer, eine Zahl zwischen 1 und 255, die für den Ausdruck belanglos ist, die Geräteadresse des Druckers, die im allgemeinen auf 4 eingestellt ist und die Sekundäradresse für die Drucker- beziehungsweise Interface-Ansteuerung. Für das Universal-Interface (WW Interface 92000/G, C 64/Centr.) muß diese gleich eins sein. Der letzte Parameter gibt den Druckmodus an. Eine »0« steht für normale Darstellung; eine »1« für inverse.

Das Poster kann auf beliebiges Papier gedruckt werden. Für die Verwendung von Einzelblättern wird allerdings die Papierende-Kennung ausgeschaltet, damit die gesamte Hardcopy ohne Unterbrechung ausgedruckt werden kann. Nach dem Drucken wird durchein Form-Feed das Papieraus dem Drucker geschoben, der Drucker in den Einschaltzustand versetzt und das entsprechende File geschlossen. Wird die Hardcopy mit der Stop-Taste abgebrochen, so wird ebenso ein Druckerreset ausgeführt und das Druckerfile geschlossen. Das Papier wird allerdings nicht transportiert. Der Computer sollte sich mit »BREAK«, »READY« wieder melden.

Mit Hilfe eines Monitors oder eines modifizierten Laders kann die Hardcopy auch direkt abgespeichert werden (Achtung: Der Monitor darf nicht bei 49152 ($C000) liegen). Die Adressen, die das Programm belegt, reichen von 49152 bis 49590.

Natürlich kann die Routine in eigene Grafikprogramme eingebettet werden. Die Filenummer sollte dann einen noch unbelegten Kanal verwenden.

Arbeitet man mit Simons Basic zusammen, so ist folgendes zu beachten: Simons Basic belegt den Speicherbereich von $C000 bis $C400 mit der Farbinformation der Grafik. Das heißt, unsere Routine würde durch den HiRes-Befehl gelöscht. Um trotzdem mit der Erweiterung arbeiten zu können, ist die Grafik nach Beendigung der Bilderstellung mit »CSET0« auszuschalten. Jetzt erst können wir unsere Routine mit dem Basic-Lader nach 49152 ($C000) kopieren und starten. Achtung: Durch das Kopieren und Starten der Routine geht die Farbinformation der ersten Bildhälfte verloren. Will man die Farbe wieder setzen, so muß der veränderte Bereich nach der Hardcopy wieder mit der Farbinformation gefüllt werden (FOR i=49152 TO 49600:POKE i,PEEK(49700):NEXT i).

Die Arbeit mit dem »64’er«-Programm »Hi-Eddi« ist am besten möglich, indem man die Grafikseite abspeichert und nach Verlassen des Programmes wieder lädt. Die Zusammenarbeit mit anderen professionellen Programmen sollten Sie selbst erproben.

Abschließend noch ein Wort zur Anpassung an andere Drucker. Der Drucker muß auf alle Fälle Epson- beziehungsweise Star-kompatibel sein und Blockgrafikcharakter besitzen. (Für Profis: die acht Charakter beginnen in der vorletzten Zeile, mit der vierten Zahl von hinten.)

Weiterhin ist zu beachten, daß die Sekundäradresse so gewählt werden muß, daß alle Grafikbefehle angenommen werden (beim Universal-Interface zum Beispiel 1).

Das ist doch eine Hardcopy, die wirklich Format zeigt!

(Thomas Hohenberger/rg)

# Hardcopy Itoh 8510 mit Hi-Eddi \[59-61\]

> Besitzern des Itoh 8510 bietet dieses Programm die Möglichkeit, von Hi-Eddi Hardcopies zu erzeugen.

Mit dem Hi-Eddi aus der Ausgabe 1/85 vom 64’er lassen sich mit minimaler Hardware-Ausrüstung (C 64, Diskettenlaufwerk 1541, Joystick) sehr komfortable Grafiken erzeugen. Doch was nützt die schönste Grafik auf Bildschirm oder Diskette, wenn man sie nicht ausdrucken kann?

Die in Ausgabe 1/85 veröffentlichte Druckroutine Hi-Print arbeitet leider nur mit Epson-Druckern zusammen. Da der Itoh 8510 ein verbreiteter und guter Drucker ist, wurden für ihn die im folgenden beschriebenen Programme erstellt. Er wird über eine Centronics-Schnittstelle via User-Port am C 64 angeschlossen.

Zusätzlich wurden einige Features eingebaut, die die Epson-Hardcopy-Routine nicht besitzt. So wäre die Vorgabe von Leerspalten vom linken Rand aus (falls noch Platz ist) eine nützliche Sache. Um zwei Grafiken in der Horizontalen aneinander zu setzen, wurde dazu die volle Bildschirmbreite in 40 Spalten zu je 8 (40 x 8 = 320) Punkten (wie im Textmodus) organisiert. Um jetzt zwei Grafiken nebeneinander zu plazieren, kann dazu die Startspalte (wird mitgedruckt) der links stehenden Grafik (Grafik Nr. 1) und die Endspalte (wird nicht mitgedruckt) der rechts stehenden Grafik (Grafik Nr. 2) vorgewählt werden.

Die Ausdruckbreite wird dazu in drei Sektoren von links nach rechts aufgeteilt.
0. Sektor: Abstand (SPC) in Punkten vom linken Papierrand.
1. Sektor: Grafik Nr. 1 (Bild-Nr.; Startspalte)
Bild-Nr. = 0 = > kein Bild, Startspalte = 48
Bild wird rechtsbündig gedruckt
0 < = Startspalte < = 39
Startspalte = 0 = > volle Hardcopy von Grafik Nr. 1
2. Sektor: Grafik Nr. 2 (Bild-Nr.; Endspalte)
Bild-Nr. = 0 = > kein Bild, Endspalte = 8
Bild wird linksbündig gedruckt
1 < = Endspalte < = 40
Endspalte = 40 = > volle Hardcopy von Grafik Nr. 2

Insgesamt kann folgende Formel für die Aufteilung der drei Sektoren angegeben werden:

SPC + (40-Startspalte)*8 + Endspalte*8 = 640

Im Steuerprogramm werden nacheinander die Bild-Nr. von Sektor 1, dann (falls Bild-Nr. < > 0)die Startspalte von Grafik-Nr. 1, dann die Bild-Nr. von Sektor 2 und (falls Bild-Nr. < > 0) die Endspalte von Grafik-Nr. 2, und schließlich die Anzahl der Leerspalten vor Grafik-Nr. 1 abgefragt.

Die Maximalwerte werden stets durch das Steuerprogramm vorgegeben, so daß in vielen Fällen ein einfaches RETURN genügt.

Um die Druckroutine namens »HI-P(ITOH8510)« für den ITOH 8510 in das Steuerprogramm Hi-Eddi einzubilden, mußte dieses auf die Bedürfnisse der Druckroutine angepaßt werden und heißt nun >>HI-E(ITOH8510)<<.

Dazu wurden (aus Speicherplatzgründen) alle Zeilen neu numeriert und die Textausgabepassagen verkürzt. In den Programmzeilen 24 und folgende befindet sich das Drucksteuerprogramm.

Es wird hierbei dringend davor gewarnt, das neue Steuerprogramm HI-E(ITOH8510) zu erweitern oder zu ändern, da sonst das Steuerprogramm (inklusive Variablen) nicht mehr in den verfügbaren Basic-Speicherplatz paßt. Dies gilt auch für den eingebauten Parametercheck, da in der Druckroutine selber keine Plausibilitätsprüfung mehr vorgenommen wird.

Für die Initialisierung des Druckers und die Ausgabe der Hardcopy sollte sich der Drucker im SELECT-Modus befinden, da sonst das Programm hängenbleibt (Acknowledge-Signal wird erwartet).

Falls aus irgendeinem Grunde (Drucker beziehungsweise Kabel defekt, falsch oder gar nicht angeschlossen) dieser Fall eintritt, kann mit RUN/STOP-RESTORE die Druckroutine beendet werden. Hi-Eddi kann dann wieder mit RUN gestartet werden. (Das RUN ist notwendig, um HI-EXE nachzuladen, da aus Speicherplatzgründen nach der Anwahl des Drucksteuerprogramms immer die Druckroutine über HI-EXE nachgeladen wird.)

Der Drucker sollte mittels der DIP-Schalter auf CR = CR und 8-Bit-Data eingestellt sein. Da am Anfang kein Carriage Return ausgegeben wird, sollte man dafür sorgen, daß der Druckkopf sich auf einer freien Zeile befindet. Außerdem sollte das Papier zentriert werden, da sich der Ausdruck über die volle Papierbreite erstrecken kann.

Die Anpassung des ITOH 8510A an Hi-Eddi besteht im wesentlichen aus zwei Schriften:

1. HI-P(ITOH8510).L abtippen und starten. Dieses ist ein Ladeprogramm, das die Druckroutine HI-P(ITOH8510) auf Diskette ablegt. Es wird (nach erfolgreichem Test) zum Arbeiten mit Hi-Eddi nicht mehr benötigt.
2. Hi-E(ITOH8510) abtippen und speichern. Es ist das angepaßte Steuerprogramm und ersetzt das alte Hi-Eddi,

So, das wär's eigentlich. Hi-Eddi mit Itoh 8510A ist nun lauffähig. Mir bleibt nur noch, viel Erfolg mit Hi-Eddi zu wünschen.

(Frank Ziesche/rg)

# Hardcopy von Hi-Eddi auf dem Plotter VC 1520 \[61-62\]

> Mit diesem Programm ist es möglich, Hardcopies von Hi-Eddi mit dem VC 1520 zu erstellen.

Geben Sie zuerst »Copy 1520« (Listing 1) mit dem MSE ein und speichern Sie es ab. Jetzt muß noch das Steuerprogramm geändert werden. Bei dem Steuerprogramm (Listing 2) sind die Zeilen 600 bis 750 zu ändern.

Die Hardcopy kann jetzt von Hi-Eddi per Tastendruck oder Menü nachgeladen werden. Es ist möglich, mehrere Bilder (nahtlos) untereinander oder übereinander (Overlay) zu drucken.

(Stephan Paetzold/rg)

# Hardcopy MPS802/1526 \[62\]

> Hardcopies in der vierfachen Größe erstellt dieses Programm auf dem MPS 802.

Dieses Programm druckt den HiRes-Grafikbildschirm in vierfacher Vergrößerung auf dem MPS 802 aus. Durch die Papierbreite bedingt, muß das Bild jedoch in zwei Teile zerlegt und anschließend zusammengeklebt werden, was sich jedoch nicht nachteilig bemerkbar macht.

Die Schnelligkeit der Druckroutine (komplett zirka 8 bis 13 Minuten) wird durch zwei Faktoren bewirkt:

1.	Adreßberechnung und Datenumwandlung in Maschinensprache;
2.	Keine Verwendung von selbstdefinierten Sonderzeichen, das heißt die gedruckten Zeichen sind die Standard-Grafikzeichen des Commodore 64 (es handelt sich hierbei um folgende 16 Zeichen:

CHR$(160),(161),(162),(172),(187),(188),(190),(191)

(in normaler und reverser Darstellung)

Während des Druckes ist auf den HiRes-Bildschirm umgeschaltet, so daß man die Abarbeitung verfolgen kann. Nach Fertigstellung des ersten Teiles unterbricht das Programm, um ein Neujustieren des Druckerpapiers zu ermöglichen. Danach wird der zweite Teil ausgedruckt. Die Bilder sollten sich im Speicher ab Adresse 8192 = $2000 befinden.

(Ralph Hoffmann/Christoph Bertog/rg)

# Hardcopy in doppelter Größe \[63-65\]

> Mit diesem Programm ist es jetzt auch MPS 801-Besitzern möglich, Hardcopies in doppelter Größe auszugeben.

»BIGCOPY 64« wurde abgefaßt, um auch mit dem Commodore MPS 801 eine Hardcopy in doppelter Größe anfertigen zu können.

Was uns besonders störte, war die Tatsache, daß es anscheinend keine Programme gab, die auf Siebennadeldruckern Hardcopies in doppelter Größe ermöglichten. Da wir jedoch unsere Grafiken zur Abwechslung einmal in akzeptabler Größe haben wollten, sahen wir uns gezwungen, ein eigenes Programm zu schreiben. Im folgenden wollen wir von den Schwierigkeiten, die sich uns in den Weg stellten und deren Beseitigung berichten.

Betrachtet man einmal die Speichernutzung des C 64 bei Grafiken, so ist ersichtlich, daß sich die Einteilung in horizontal liegende Bytes ideal für Hardcopies eignet, die auf Achtnadeldruckern ausgegeben werden sollen. Der Commodore MPS 801-Matrixdrucker hat aber die unangenehme Eigenschaft, die Grafiken mit lediglich sieben Nadeln auf das Papier zu bringen. Da man mit dem MPS 801 lediglich 480 Punkte in einer Zeile drucken kann, ist man bei der Erstellung von Programmen, die doppelt große Hardcopies ermöglichen sollen, darauf angewiesen, die Grafiken nicht wie üblich quer auszugeben, sondern sie müssen längs ausgedruckt werden. In dieser Richtung kann man die 400 x 640 Punkte problemlos auf das Papier bringen.

Jetzt aber stellt sich das oben angesprochene Problem: Wie die acht Bit eines Bytes mit sieben Nadeln ausdrucken? Die Antwort ist leider klar: Gar nicht, es geht nämlich nicht! Also muß ein Algorithmus her, der es gestattet, das bei ersten Versuchen unterschlagene achte Bit dennoch auszudrucken. Dieser Algorithmus muß aber, um eben dieses achte Bit zu berücksichtigen, Punkt für Punkt des zu druckenden Bildes abfragen, um so die gesamte Grafik in vertikale Siebenerscheibchen zu zerlegen, die der MPS 801 anstandslos verarbeitet. Durch diese, zugegebenermaßen recht unelegante, aber nötige Prozedur, geht jedoch der oben erwähnte positive Effekt verloren, den die interne Grafikspeicherung auf Berechnungen haben kann. Aus diesem Grund dauert eine Hardcopy mit der Basic-Version von »BIGCOPY« auch zirka 150 Minuten, eine nicht gerade berauschende Zeit für den Erhalt einer einzigen Grafik. Was liegt bei solcherart trödelnden Programmen näher, als sie in der um ein vielfaches schnelleren Maschinensprache zu verfassen.

Hier sei eine kurze Bemerkung über die Verträglichkeit des Programmes mit anderen Druckern als dem MPS 801 gesagt. Die Basic-Version läßt sich relativ leicht auf andere Drucker umschreiben, lediglich die OPEN-Anweisungen und die CHR$-Codes müssen geändert werden. Dies gilt selbstverständlich nur für die unglücklichen Besitzer von Siebennadeldruckern, die bisher gezwungen waren, ihre Grafiken in »Briefmarkenformat« ausdrucken zu lassen.

## Hardcopy in 13 Minuten

Die Maschinensprachversion des Programmes gibt sich auch schon viel freundlicher, was den Zeitbedarf angeht, sie liefert eine Hardcopy in einem Elftel der Zeit des Basic-Programmes, das heißt daß man jetzt nur noch 13 Minuten auf seine Grafik zu warten braucht. Wundert man sich jetzt, warum die als bis zu hundert Mal schnellere Maschinensprache lediglich eine Reduktion des Zeitbedarfs um 91% bringt, so sei man daran erinnert, daß der Drucker ja auch nicht gerade zu den schnellsten gehört, er ist also das bremsende Glied.

Da wir unser Programm als vollständiges Maschinenprogramm verfaßten, mußten aus Komfortgründen gewisse Änderungen vorgenommen werden. Daraus resultierte die vorliegende Fbrm in zwei einzutippenden Teilprogrammen, die ein drittes, funktionsfähiges »BIGCOPY« erzeugen.

Es folgt die Anleitung, wie die Programme eingegeben werden müssen. Zuerst werden beide Listing »BIGCOPY-DATAs« (Listing 1) und »BIGCOPY-Erzeuger« (Listing 2) eingetippt und ohne sie zu starten auf Diskette abgespeichert. Nach der Speicherung des DATA-Teiles sollte dieser Teil jedoch probehalber gestartet werden, um eventuelle Tippfehler durch die Prüfsummenbildung zu identifizieren und zu korrigieren. Diese verbesserte Version muß dann erneut abgespeichert werden. Bei dem Erzeugerprogramm dürfen die REM-Zeilen auf keinen Fall mit eingetippt werden! Zum Erzeugen von »BIGCOPY 64« lädt man zuerst das DATA-Programm, startet es und lädt danach den Erzeugerteil. Nachdem eine Diskette eingelegt wurde, auf der mindestens neun Blöcke Platz sein müssen, wird der Erzeuger mit RUN 1000 gestartet. Das erzeugte »BIGCOPY« kann dann einfach mit LOAD "BIGCOPY 64",8 geladen und mit RUN gestartet werden. Diese etwas umständliche Prozedur mußte gewählt werden, da der Maschinenteil des Programmes direkt hinter dem Basic-Teil liegen muß, um alle sieben Grafikspeicher ausdrucken zu können.

## Speicheraufteilung

Jetzt zum Programm an sich.

Um alle sieben Grafikspeicher ansprechen zu können, muß auf jeden Fall mit Maschinensprache gearbeitet werden, da ein Ausschalten des Basic-ROMs von Basic aus logischerweise Selbstmord wäre.

Im Maschinenteil ist deswegen eine Vertauschroutine, die das auszudruckende Bild in den Bereich $2000-$3FFF verschiebt. Diese Routine wird mit Basic angesprochen und wechselt den gewählten Grafikspeicher mit dem ab $2000 aus. Nachdem die Grafik eingeschaltet ist, wird die Druckroutine aufgerufen, die im Maschinensprachteil hinter der Tauschroutine liegt. Nach erfolgtem Ausdruck werden die beiden Bereiche (gewählter und $2000-$3FFF) wieder zurückgeschrieben, so daß kein Bild verlorengeht. Auf diese Weise können alle sieben Grafikspeicher hintereinander ausgedruckt werden. Die Maschinenroutine für den Ausdruck (Listing 3) wurde fast ohne Änderungen aus der Basic-Version der Druckroutine gebildet. Die Basic-Routine verdeutlicht den Algorithmus und vereinfacht die Anpassung an andere Siebennadeldrucker. Zusätzlich läßt sie sich als Unterprogramm in eigenen Programmen gebrauchen.

Da unser Maschinenprogramm bei $0D00 beginnt, und das im Januarheft des 64'er veröffentlichte Hi-Eddi zufälligerweise auch eine Druckroutine benötigt, die ab $0D00 liegt, kamen wir auf die Idee, »BIGCOPY« an Hi-Eddi anzupassen. Für die Anpassung an Hi-Eddi sind zwei Teilschritte notwendig. Zum ersten müssen im Hi-Eddi-Steuerprogramm (Listing 3 im 64'er, Ausgabe 1/85) die Zeilen 600-820 (Listing 4) durch die Änderungen ersetzt werden, zweitens muß ein Hi-Print-Programm (Listing 5) erzeugt werden, das aus unserer Maschinenroutine besteht. Zur Erzeugung von Hi-Print werden die Basic-Zeilen an den DATA-Teil des »BIGCOPY«-Listings angehängt, danach wird der DATA-Teil einfach mit RUN gestartet, dadurch wird Hi-Print auf Diskette geschrieben.

(M. Kowall/E. Wilde/rg)


# Hardcopy mit dem Seikosha GP-550 \[68-70\]

> Über den seriellen Bus des C 64 können mit dieser Routine durch einen SYS-Befehl Grafiken in einfacher und in doppelter Größe zu Papier gebracht werden.

Tippen Sie zunächst den Basic-Lader (Listing 1) ab und speichern ihn auf Diskette. Anschließend ist das Programm mit RUN <Return> zu starten. Es wird ein Maschinenprogramm ab Speicherzelle 49152 erzeugt und nach korrekter DATA-Summenkontrolle unter dem Namen »M/HCOPY GP-550A« abgespeichert. Tritt bei der DATA-Summenkontrolle kein Fehler auf, kann das Maschinenprogramm wie folgt aufgerufen werden:

Syntax der Hardcopyroutine:

SYS49152⟨(Pg)⟩⟨,M,(L-1)*4+Br,LM⟩⟨;⟩

Hierbei bedeuten:

TODO TABLE

⟨...⟩ Ein in spitzen Klammern stehender Ausdruck ist optional, kann also weggelassen werden.
Pg Grafikseitennummer 0 < Pg < = 7.
Durch die Angabe dieser Grafikspeicherkennziffer wird grundsätzlich der RAM-Bereich angesprochen!
Zum Beispiel:
(0): nicht erlaubt (illegal quantity error), da dieser Bereich die Zeropage beinhaltet.
(1): Standardgrafikspeicher (8192 bis 16383); wird auch angesprochen, wenn keine Angabe zu Pg gemacht worden ist.
(5): spricht das RAM unter dem Basic-ROM an.
(7): Hardcopy einer Simons-Basic-Grafik, die unter dem Kernal-ROM liegt.
M Moduskennzahl M = 0 (128) : 8-bit normal (revers)
M = 1 (129): 16-bit normal (revers)
L Länge	L = 1: einfache Länge / L = 2: doppelte Länge
Beachten Sie, daß die Zahl (L-1) einzugeben ist.
Br Breite	1 <=Br<=3
LM Linker Randabstand (siehe Druckeranleitung)
Der größtmögliche Wert des Randabstandes ist von der Breite abhängig. Eine Überschreitung des erlaubten Wertes ergibt jedoch »illegal quantity error«, so daß kein Fehlausdruck durch Zeilenüberlauf entstehen kann.
Zusätzlich stellt Ihnen die Routine eine Zentrierungsautomatik zur Verfügung, die Sie durch »LM=1« aktivieren können.
sperrt Blattvorschub nach erfolgtem Ausdruck, so daß Sie mehrere Hardcopies abstandsfrei koppeln können.


Beispiele:
(1) **SYS49152**
Ausdruck der Standard-Bitmap (8192-16383) mit Normalbelegung der Parameter. (8-Bit normale, doppelte Breite, einfache Länge, mittenzentriert, Seitenvorschub)
(2) **SYS49152(7)**;
Hardcopy einer Simons Basic-Grafik wie oben, aber ohne Seitenvorschub.
(3) **SYS49152,1,1,0**
Kleinstformat in 16-Bit-Auflösung ohne Randabstand.
(4) **SYS49152(3),128,6,5;**
Darstellung der Bitmap von 24576 bis 32767 im 8-Bit-Revers-Modus. Die Breite beträgt wie die Länge zwei, der linke Rand fünf Einheiten.

Um dem Anwender eine möglichst flexible Nutzungsmöglichkeit anbieten zu können, stehen neben derüblichen, oben dargestellten Parameterübergabe zusätzliche POKE-Optionen zur Verfügung, die zum Beispiel die Rahmenerstellung oder das Druckbild beeinflussen.

Alle Möglichkeiten sind inden Tabellen 1 und 2 aufgeführt.
Wichtig dabei ist:

Sämtliche in Tabelle 1 aufgelisteten POKE-Optionen sind nur für die aktuelle Hardcopy gültig und werden nach Beendigung des Druckvorganges automatisch abgeschaltet!

Hingegen sind die Programmeingriffe, die in Tabelle 2 stehen, dauerhaft, uhd müssen explizit zurückgesetzt werden.

Die Option **POKE49531,96** trägt wesentlich dazu bei, die Hardcopyroutine um interessante Aspekte zu bereichern. Sie sorgt dafür, daß jedesmal, wenn eine Grafikzeile abgearbeitet worden ist, die Kontrolle zwischenzeitlich an Basic zurückgegeben wird.

Dies eröffnet die Möglichkeit, vor oder hinter jeder Grafikzeile einen Text zu senden. Mit einem kleinen Trick sind zwei oder drei Grafikseiten nebeneinander zu erstellen, vorausgesetzt, die maximale Zeichenanzahl wird nicht überschritten.

Die prinzipielle Vorgehensweise dabei zeigen die Listings 2 und 3. Dort verwendete Adressen finden sich auch in Tabelle (1).

Listing 3 läßt sich noch effektvoll erweitern, indem geschickt der Elongation-Modus durch »PRINTCHR$(14);« zum Beispiel in Zeile 240 beziehungsweise »...CHR$(15);« in Zeile 210 ein- oder ausgeschaltet wird. Man erhält so zwei nebeneinander gedruckte Hardcopies mit einfacher und doppelter Breite.

In diesem Zusammenhang sei noch erwähnt, daß nach dem ersten Aufruf der Hardcopy-Routine alle Druckerbefehle nur noch mit einem normalen PRINT-Befehl gesendet werden dürfen, solange der Ausdruck nicht vollständig abgeschlossen ist.

(Frank Jörgens/ah)

# Ein Zeichengenerator für den FX-80 \[71-75\]

> Das Programm MAKE-CHR gestattet es auf einfache Weise, komplette Zeichensätze für Drucker wie den FX-80 selbst zu erstellen.

Es sind beliebige grafische Symbole und Schriftarten, insbesondere auch Zeichensätze mit doppelter Schrifthöhe (über zwei Druckzeilen) machbar.

Die gewünschten Zeichen werden einfach mit Hilfe des Joysticks (und/oder Tastatur) in ein Bildschirmfenster gezeichnet und dann in einer relativen Datei (CHR-Datei) abgespeichert. Weiterhin enthält das Programm Routinen zum teilweisen oder vollständigen Kopieren der CHR-Dateien sowie zum Übertragen der Zeichensätze in das Drucker-RAM. Ein Drucker-Handling-Menü erlaubt das Setzen verschiedener Druckerparameter und das Ausdrucken der Zeichen. Bei jeder Eingabe kann mit der Taste »Pfeil nach links« ins Menü zurückgesprungen werden.

Bei jeder Eingabe wird ein Default-Wert angezeigt, der bei leerer Eingabe erhalten bleibt. Eine neue Eingabe wird automatisch zum neuen Default-Wert.

Die ins Drucker-RAM übertragenen Zeichensätze können von Textprogrammen benutzt werden.

Zeichenerklärung für nachfolgende Beschreibung:

TODO

&	= Bildschirm	*	= Bemerkungen
**Fett** = Ihre Eingabe

### ERSTELLE ZEICHEN

&	Aus welcher Datei willst Du lesen? **Datei X**
&	In welche Datei willst Du schreiben? **Datei Y**
&	ASCII ? **ASCII X**

Die Zeichen werden aus der Datei X gelesen und in die Datei Y zurückgeschrieben.

Datei X und Datei Y können natürlich auch gleich sein. ASCII ist der ASCII-Code des zu bearbeitenden Zeichens.

\1.	Mit den CRSR-Tasten kann der Cursor im Bildschirmfenster plaziert werden. Die Taste »*« dient zum Setzen und Löschen von Punkten.

\2.	Zeichen können auch mit dem Joystick erstellt werden.

Wird der Feuerknopf gedrückt, wird ein Punkt gesetzt (gelöscht).

\* Es dürfen keine 2 Dots in horizontaler Linie nebeneinander liegen (Eigenheit des FX-80)!

Neun-DOT-Funktion:

Die Neun-DOT-Funktion bewirkt, daß das Zeichen um einen Dot versetzt nach unten ausgedruckt wird (für Unterlängen, Kommas und so weiter).

### SEND CHR TO PRINTER

& Welche Datei soll übertragen werden ? **Datei X**
& von ASCII? **ASCII X**
& bis ASCII? **ASCII Y**

Durch die Eingabe von ASCII X und ASCII Y kann man erreichen, daß nur ein bestimmter Teilbereich des Zeichensatzes ins Drucker-RAM übertragen wird.

ASCII X=0 und ASCII Y=254 (Default-Werte, das heißt voreingestellte Werte) überträgt den gesamten Zeichensatz.

\* Nach dem Übertragen eines Zeichensatzes wird ein automatischer Druckertest durchgeführt.

\* Wird ein leerer Zeichensatz beziehungsweise ein Zeichensatz mit Lücken übertragen, so wird das Drucker-RAM von den Lücken nicht überschrieben. Lücken werden vom Programm berücksichtigtund übersprungen!

### DRUCKER-HANDLING

1. COPY ROM TO RAM<br>Kopiert das Drucker-ROM ins Drucker-RAM.<br>Das Drucker-RAM hat dann den normalen Epson-Zeichensatz.
2. SELECT ROM/RAM<br>Wählt Drucker-ROM oder -RAM aus.
3. SETLINE-SPACE<br>Setzt den Drucker auf den gewählten Zeilenabstand. Bei doppelt hohem Zeichensatz wird automatisch der richtige Zeilenabstand eingestellt.
4. WÄHLE SCHRIFTART<br>Auswahl einer der 64 Schriftarten des FX-80.
5. TEST PRINTER<br>Druckt den gesamten ASCII-Code.

### ERSTELLE CHR-DATEI

Formatiert eine neue CHR-Datei. Der Name der CHR-Datei darf maximal 10 Zeichen lang sein.

### COPY SINGLE CHR

&	Aus welcher Datei wird gelesen? **DATEI X**
&	von ASCII? **ASCII X**
&	bis ASCII? **ASCII Y**
&	in welche Datei wird geschrieben? **DATEI Y**
&	ab ASCII? **ASCII Z**

Kopiert den Bereich ASCII X bis Y aus DATEI X in die DATEI Y ab ASCII Z.

\* DATEI X und DATEI Y müssen sich auf einer Diskette befinden.

### COPY CHR-DATEI

Kopiert die angegebene CHR-Datei vollständig — auch auf eine andere Diskette.

(Rainer Busch/ah)

# Grafik 2000 — Eine Basic-Erweiterung, die es in sich hat \[76-81\]

> Diese Befehlserweiterung für den C 64 stellt Ihnen 41 neue Basic-Befehle und zwei neue Funktionen zur komfortablen Handhabung der mehrfarbigen HiRes-Grafik zur Verfügung.

Die Befehle sind, wie die Befehle des Basic V2, abkürzbar, vollkommen in den Interpreter integriert und werden selbstverständlich als Tokens gespeichert. Selbst nach »THEN« ist kein Doppelpunkt notwendig.

Da die zwei unabhängigen Grafikschirme und das Programm selbst außerhalb des Basic-Speichers liegen, stehen dem Benutzer weiterhin 38911 Bytes für seine Programme zur Verfügung. Auch Sprites benötigen keinen Basic-Speicherplatz.

v Die Erweiterung selbst arbeitet außerordentlich schnell, da zum Beispiel das Programm zum Errechnen einer Punktadresse weniger als 1/15000 Sekunde benötigt. So dauert beispielsweise das AusFILLen des leeren Bildschirmes weniger als 50 Sekunden! Auch die weiteren Befehle arbeiten ähnlich schnell.

Diese Erweiterung ist zudem sehr sicher, denn selbst grobe Fehleingaben führen nicht zum Systemabsturz und somit Programmverlust (POKEs ausgenommen).

## Grundlagen

Grafik 2000 unterstützt die farbige HiRes-Grafik des C64. Diese Grafik ist aus 320 x 200 einzeln ansprechbaren Punkten aufgebaut. Dabei befindet sich der Punkt mit den Koordinaten 0/0 in der linken oberen und der Punkt mit den Koordinaten 319/199 in der rechten unteren Ecke des Bildschirmes.

Die Farbinformation fürje 8 x 8 Punkte liegt im sogenannten Video-RAM. Hier steht in den oberen vier Bits die Farbe für einen gesetzten, in den unteren vier Bits die Farbe für einen gelöschten Punkt. Für den Anwender bedeutet dies, daß in einem 8 x 8 Punkte-Kästchen nur zwei verschiedene Farben vorkommen können.

## Befehlsbesprechung

Anmerkung: Hinter dem Befehlsnamen steht die jeweilige Abkürzung, wobei»’« bedeutet, daß der folgende Buchstabe geSHIFTet eingegeben werden muß.

TODO

CLEAR	CL’E
Löscht den Grafikbildschirm. Die Farbe bleibt unverändert.
MODE n	M’O
Wenn n=1 ist, wird der Grafikmodus eingeschaltet; ist n=0, wird auf den Textbildschirm geschaltet. Dabei wird der Groß/Grafik-Modus eingeschaltet.
COLOR p,h	CO’L
Setzt die Farben im Video-RAM. Dabei steht p für die Punktfarbe und h für die Hintergrundfarbe. Es können Werte von 0 bis 15 für die Farben stehen.
CHANGE	CH’A
CHANGE wechselt zwischen den beiden Grafikschirmen, indem die jeweiligen Punkte ausgetauscht werden.
INVERS	IN’V
Invertiert die sichtbare Grafik. Das Video-RAM bleibt unverändert.
COMB n	CO’M
COMB führt eine logische Verknüpfung zwischen den beiden Grafikseiten aus. Das Ergebnis wird in die sichtbare Grafik geschrieben. Die Verknüpfungsart ist mit n wählbar:
n=1:	logisch OR
n=2:	logisch AND
n=3:	logisch EXOR
GSAVE a$,dv	G’S
GSAVE speichert die verdeckte Grafik mit dem Namen a$ an Gerät mit der Nummer dv ab. Die Parameter können entfallen.
Beispiel:
GASVE "BILD 1",8 Speichert die Grafik BILD 1 auf Diskette
GSAVE	Speichert die Grafik ohne Namen auf Kassette ab.
CSAVE a$,dv	C’S
Speichert das Video-RAM, die Farbe der Grafik, ab.
Die Parameter sind analog zu GSAVE.
GLOAD a$,dv	G’L
Mit GLOAD kann man die mit GSAVE abgespeicherte Grafik oder das mit CSAVE abgespeicherte Video-RAM laden.

Da dieser Befehl keine Basic-Zeiger verändert, eignet er sich auch zum Laden von Maschinenprogrammen, auch im Direktmodus.
SPOINT x,y	SP’O
Setzt einen Punkt an die Stelle x/y in der Grafik.
CPOINT x,y	C’P
Löscht den Punkt x/y.
IPOINT x,y	PS’C
Invertiert den Punkt x/y
PSCLINE x,y	PS’C
Setzt den Punkt x/y und löscht ab diesem Punkt eine Linie nach unten bis zum Grafikrand. Der Befehl ist besonders für 3D-Grafiken geeignet.
HMARK x,y	H’M
Setzt eine waagrechte »Markierung«an den Punktx/y, das heißt, es wird eine 5 Punkte lange Linie gezeichnet, deren Mittelpunkt der Punkt x/y ist.
VMARK x,y	V’M
Analog HMARK, jedoch wird eine senkrechte Markierung gezeichnet.
HLINE y	H’L
Zeichnet eine durchgehende Horizontale an y.
VLINE x	V’L
Zeichnet eine durchgehende Vertikale an x.
Mit den letzten vier Befehlen ist es möglich, schnell und einfach Koordinatensysteme zu zeichnen.
SLINE x0,y0,x1,y1	S’L
Zeichnet eine Linie von x0/y0 nach x1/y1. Die Richtung beziehungsweise Länge ist beliebig.
CLINE x0,y0,x1,y1	CLT
Wie SLINE, die Linie wird jedoch gelöscht.
ILINE x0,y0,x1,y1	l’L
Wie SLINE, die Linie wird jedoch invertiert.
SCIRCLE x,y,a,b	S’C
Zeichnet eine Ellipse mit dem Mittelpunkt x/y und den Radien a und b.
CCIRCLE x,y,a,b	C’C
Wie SCIRCLE, die Ellipse wird jedoch gelöscht.
ICIRCLE x,y,a,b	I’C
Wie SCIRCLE, die Ellipse wird jedoch invertiert.
SELLIPSE x,y,a,b,dw,sw,ew,s	S’E
Zeichnet einen Ellipsenbogen mit dem Mittelpunkt x/y und den Radien a und b.
Die weiteren Parameter bedeuten:

TOD TABLE

dw Drehwinkel der Hauptachse einer Ellipse um den Mittelpunkt. Die Ellipse wird mit dw im Uhrzeigersinn um den Mittelpunkt x/y gedreht.
sw, ew sw und ew geben den Start- und Endwinkel des Ellipsenbogens an.
s	gibt den Schrittwinkel an, mit dem die einzelnen Bogenpunkte errechnet werden.

Der Befehl errechnet einzelne Punkte des Ellipsenbogens, die mit einer Linie verbunden werden. Die Winkel müssen im Bogenmaß angegeben werden. Die Drehungen werden mit dem Uhrzeigersinn ausgeführt.
CELLIPSE x,y,a,b,dw,sw,ew,s	C’E
Wie SELLIPSE, der Bogen wird jedoch gelöscht.
IELLIPSE x,y,a,b,dw,sw,ew,s	I’E
Wie SELLIPSE, der Bogen wird jedoch invertiert.
STEXT r,b,h,v,a,x,y,a$	STE’X
Schreibt einen Text in den Grafikschirm.
Die einzelnen Parameter bedeuten:

TODO

r	Schreibrichtung
r = 1 von links nach rechts
r = 2 von rechts nach links
r = 3 von unten nach oben
r = 4 von oben nach unten
Die Schrift ist, der Richtung entsprechend, gekippt.
b	Breite eines einzelnen Zeichens; von 1 (normal)
bis 25 möglich.
h	Höhe eines Zeichens (von 1 bis 25).
v	Verschiebung (Kursivschrift)
v gibt die Verschiebung eines Zeichens von seiner Spitze zum Fuß an.
v kann Werte von 0 (normal) bis zum achtfachen (45 Grad Schräge) der Höhe h annehmen.
a	Abstand der Zeichen, a kann Werte von 0 bis 199
annehmen. Für Normalschrift ist a=8.
x und y Geben die Startkoordinaten an.
x/y ist die linke obere Ecke des ersten Zeichens eines Strings.
a$ String- oder numerischer Ausdruck, der gezeichnet werden soll.
Im String kann zwischen den Zeichensätzen umgeschaltet werden: ctrl/9	rvs on
ctrl/O	rvs off
ctrl/a	Groß/Klein
ctrl/b	Klein/Groß
Ohne	Umschaltung wird mit dem Groß/Grafik-
Zeichensatz in Normalschrift gearbeitet.
Hinweis: Wenn ein String außerhalb des Bildschirmes und mit großen Buchstaben gezeichnet wird, kann es vorkommen, daß der Computer bis zu zwei Minuten lang keine Meldung ausgibt. Er ist nicht abgestürzt, sondern fährt anschließend mit der Programmausführung fort.

CTEXT r,b,h,v,a,x,y,a$	C’T
Wie STEXT, der Text wird jedoch gelöscht.
ITEXT r,b,h,v,a,x,y,a$	I’T
Wie STEXT, jedoch wird der Text invertiert.
FILL x,y	F’I
Malt ein durch Linien oder den Bildschirmrand begrenztes Feld beliebiger Form aus.
x/y geben die Startkoordinaten an.
DUPLICATE x0,y0,x1,y1,x,y	D’U
Kopiert einen Grafikausschnitt.
Dabei geben x0/y0 und x1/y1 die Eckpunkte (links oben / rechts unten) eines Rechtecks an, das nun so kopiert wird, daß x/y die Koordinaten der linken oberen Ecke der Kopie angeben.
Der Ausschnitt wird so kopiert, daß die Kopie exakt dem Original entspricht. Das Original kann also überschrieben werden.
SCROLL r,x0,y0,x1,y1	SC’R
Rolliert einen Grafikausschnitt um einen Punkt.
Der Ausschnitt wird mit x0/y0 und x1/y1 analog zu DUPLICATE definiert.
r bestimmt die Richtung des Rollierens:
r1 = nach rechts
r2 = nach links
r3 = nach oben
r4 = nach unten
WINDOW y0,y1	W’I
WINDOW ermöglicht die gleichzeitige Anzeige von Text und Grafik. Die beiden Übergangszeilen dazu sind frei wählbar.
Die Parameter geben die erste (y0) und letzte (y1) Zeile im Grafikmodus an. Der restliche Bildschirm wird im Textmodus ausgegeben. In den Grenzzeilen sollten keine Textzeichen stehen; der VIC kann diese unter Umständen nicht von der Grafik unterscheiden und unsinnige Zeichen anzeigen.
WINDOW hat Vorrang vor MODE n.
WINDOW y0,y1 wird durch WINDOW ohne Parameter abgeschaltet. Der Groß/Grafik-Textmodus wird eingeschaltet.
LOWCOL x,y,p,h	LO’W
Mit LOWCOL kann man gezielt ein Byte des Video-RAMs ändern.
x/y geben die Koordinaten des entsprechenden Grafikpunktes an, p die Punkt- und h die Hintergrundfarbe.
SPRITE n,x,y	SP’R
Mit Sprite kann man die Form eines Sprites anhand der Grafik definieren.
n gibt die Nummer des Sprites an (0-7) und x/y die Koordinaten der linken oberen Ecke eines Grafikausschnittes, nach dem die Spriteform gebildet wird (siehe auch DUPLICATE). Diese Form wird jedoch nicht einem Sprite zugeordnet; die Nummer n zeigt vielmehr die Blocknummer an, in den die Spriteform abgelegt wird. Dies sind die Blöcke 120 (n=0) bis 127 (n=7).
Die Blockzeiger liegen in den Adressen 50168 bis 50175 und müssen mit POKE gesetzt werden.
Hinweis: Die Spriteformen gelten nur im Grafikmodus. Im Textmodus gelten die gewohnten Regeln zum Arbeiten mit Sprites von Basic aus.
Das bedeutet, daß man mit WINDOW »gemischte« Sprites erzeugen und zwischen den zwei Definitionssätzen umschalten kann.
SSAVE n,n$,dv	S’S
Speichert einen Spriteblock mit dem Namen n$ auf dv ab. Zur Nummer n (0-7) siehe auch SPRITE.
SLOAD n,n$,dv	SL’O
Lädt den Spriteblock n. Die Nummer, unter der der Block abgespeichert wurde, ist irrelevant. Siehe auch SPRITE und GLOAD.
Grafik 2000 besitzt vier weitere Befehle, die die meisten übrigen Befehle verändern und diese somit auf 140 verschiedene Funktionen erweitern.
PSCREEN n	PSC’R

TODO TABLE

n = 2 Alle Befehle, die die Grafik verändern, wirken nicht mehr auf die sichtbare, sondern auf die unsichtbare, zweite Grafik.
(CLEAR,COMBI,HLINE,INVERS,TEXT,LINE, CIRCLE,FILL, etc.)
n = 1 Die Befehle wirken wieder auf die sichtbare Grafik.

TSCREEN n	T’S

TODO TABLE

n = 2 Die Befehle SPRITE, SCROLL und DUPLICATE sowie die Funktionen TEST und CTEST testen nicht in der sichtbaren, sondern in der unsichtbaren Grafik.
Man kann also mit DUPLICATE Ausschnitte der einen in die andere Grafik übertragen.
n = 1 schaltet zurück in die sichtbare Grafik.

COLPLOT p,h	COL’P
COLPLOT ermöglicht das mehrfarbige Zeichnen in der HiRes-Grafik.

TODO TABLE

Parameter:
p	Punktfarbe (0-15)
h	Hintergrundfarbe (0-15)

COLPLOT p,h	bewirkt, daß	die Befehle
SPOINT	SUNE	SCIRCLE	SELLIPSE
STEXT	FILL	SCROLL	DUPLICATE
von nun an das Video-RAM mit der Punktfarbe p setzen. Jeder gesetzte Punkt erhält also die Farbe p; die Farbe der nicht gesetzten Punkte bleibt erhalten.
COLPLOT bewirkt außerdem, daß die Befehle

TODO TABLE

CPOINT	CLINE	CCIRCLE CELLIPSE
CTEXT	SCROLL	DUPLICATE

das Video-RAM mit der Hintergrundfarbe setzen.
Jeder gelöschte Punkt erhält die Farbe h; die Farbe der gesetzten Punkte wird nicht verändert.
Die Befehle SCROLL und DUPLICATE setzen sowohl Hintergrund- als auch Punktfarbe, je nachdem, ob ein Punkt gesetzt oder gelöscht wird.
Die Option kann mit COLPLOT ohne Parameter abgeschaltet werden.
PLOT n	P’L
n = 2
Die Befehle

TODO TABLE

SPOINT	SLINE	SCIRCLE SELLIPSE
STEXT	SCROLL	DUPLICATE

arbeiten nicht mehr mit der normalen Punkt-Setzroutine, sondern mit der PSCLINE-Routine.
Es wird also unter jedem gezeichnetem Punkt eine Linie bis zum Bildschirmrand gelöscht.
Es lassen sich auf einfachste Weise effektvolle 3D-Bilder auf den Bildschirm zaubern.
Dieser Befehl arbeitet unabhängig von COLPLOT.
Es wird nur die Farbe des gezeichneten Punktes gesetzt; die Löschlinie verändert keinesfalls das Video-RAM.

TODO TABLE

n = 1 Schaltet wieder die normale Punktsetzroutine ein.
Hinweis: Die invertierten Befehle werden weder von COLPLOT noch von PLOT beeinflußt.

### Testfunktionen

var = TEST (x,y)	T’E
Weist der Variablen var den Wert 1 zu, wenn der Punkt x/y gesetzt ist, ansonsten den Wert 0.
var = CTEST (x,y)	CTE’S
Weist der Variablen var die sichtbare Farbe des Punktes x/y zu (0 bis 15).
Siehe auch TSCREEN.

### Sonstiges

Grafik 2000 stellt dem Benutzer eine verbesserte SQR-Routine zur Verfügung. Sie wurde bereits in den Interpreter eingebunden.

Wenn eine Basic-Fehlermeldung ausgegeben wird, schaltet Grafik 2000 den Textmodus ein, und der Befehl WINDOW wird abgeschaltet.

Grafik 2000 verfügt über eine eigenen NMI/BREAK-Routine.

Diese schaltet den Textmodus ein, den Befehl WINDOW ab und setzt Rahmen/Hintergrund- und Schriftfarben.

Diese Farbe kann man durch POKE selbst bestimmen:

POKE 51071,Hintergrundfarbe

POKE 51079,Schriftfarbe

Die Farben werden bereits beim Drücken der RESTORE-Taste ohne die RUN/STOP-Taste gesetzt.

Das Programm wird hierbei nicht unterbrochen.

Während den Zeichenbefehlen (ausgenommen ELLIPSE) kann man den Computer durch nichts in seiner Arbeit stören.

Auch RUN/STOP-RESTORE ist erst nach dem Ausführen eines solchen Befehls möglich.

(Frank-Rüdiger Brendel/ah)

# Die 80-Zeichenkarte zum Abtippen \[81-84\]

> Verbreitern Sie den Bildschirm Ihres Monitors um das Doppelte: 80 Zeichen pro Zeile. Egal ob Sie nun Programme eingeben oder laufen lassen.

Scheuen Sie sich nicht, das etwas längere MSE-Programm abzutippen. Die Mühe wird mit einer professionellen Bildschirmdarstellung belohnt: 80 Zeichen, nicht nur bei der Ausgabe, sondern auch zur Eingabe. Natürlich entspricht die Bildqualität dieses Programms nicht der einer »richtigen« 80-Zeichenkarte auf Hardware-Basis, man kann aber dennoch gut damit arbeiten.

Die Software-80-Zeichenkarte wurde so im Speicher des C 64 untergebracht, daß kein Basic-Speicherplatz verlorengeht. Das Programm benutzt im einzelnen folgende Speicherbereiche:
$A000-$A7FF: Zeichensatz
$COOO-$CFFF: Color-RAM
$D800-$DFFF: Video-RAM
$02A8-$02A9: Kommunikationsadressen

Haben Sie die 80-Zeichenkarte mit dem MSE abgetippt und gespeichert, können Sie das Programm mit LOAD "80-ZEICHEN" ,8 laden und mit RUN starten. Das Programm verschiebt sich dann in die vorgesehenen Speicherbereiche und startet.

Mit dieser Routine können Sie Programme genauso bearbeiten wie mit dem normalen — 40spaltigen — Bildschirmeditor. Einige Kleinigkeiten, die im folgenden näher erläutert werden sollen, sind aber zu beachten. So ist es zum Beispiel nicht mehr möglich, mittels der Tastenkombination SHIFT und CBM zwischen Groß- und Kleinschrift umzuschalten. Man muß dazu auf die bekannten Steuercodes 14 und 142 ausweichen. PRINT CHR$(14) schaltet Klein-/Großschreibung ein, PRINT CHR$(142) entsprechend den Groß-/Grafikmodus. Den Klein-/Großschriftmodus kann man aber auch über die Tastenkombination CTRL-N anwählen. CTRL-N entspricht dem ASCII-Code 14. Für die Zurückschaltung gibt es leider keine Tastenkombination.

Auch das Anwählen der Hintergrundfarbe erfolgt etwas ungewohnt. Und zwar nicht über die bekannte Adresse 53281, sondern mit POKE 683,Farbcode. Gibt man diesen Befehl ein, so geschieht zunächst einmal nichts. Erst durch die Eingabe eines zusätzlichen Steuercodes (wiederum wahlweise mittels PRINT-Anweisung oder über eine Control-Tastenkombination) wird der Hintergrund entweder ganz oder teilweise eingefärbt. Gibt man CTRL-G ein, so nimmt der Bildschirmhintergrund die in Adresse 683 festgelegte Farbe an. Drückt man hingegen CTRL-P (für Paint), so wird nur die Fläche eingefärbt, die entweder vom Cursor überschrieben wird, oder durch Scrolling von unten ins Bildfeld tritt. Damit ist es möglich, auch verschiedene Hintergrundfarben darzustellen.

Um auch mit Programmen, die einen 40-Zeichen-Bildschirm verwenden, arbeiten zu können, ist es möglich, wahlweise zwischen den beiden Formaten hin und her zu schalten. Dies ist zum einen mit den Tastenkombinationen CTRL-B (um auf die normale 40-Zeichen-Darstellung zu schalten) und mit CTRL-A (Umschaltung von 40 auf 80 Zeichen je Zeile) möglich, wobei jedoch einfach nur zwischen den jeweiligen Bildschirmen hin und her geschaltet wird. Damit ist es dann aber nicht möglich, den 40spaltigen Bildschirm zu bearbeiten. Man kann auch mittels >SYS 685« die 80-Zeichenkarte zeitweise abschalten, um mit dem normalen Editor zu arbeiten (der Inhalt des Bildschirmspeichers bleibt übrigens, während die 80-Zeichenkarte aktiv ist, erhalten). Die analoge Rückschaltung erfolgt mittels »SYS 680«.

Um die 80-Zeichendarstellung zu inaktivieren und um alle verbogenen Zeiger wieder zu restaurieren, gibt man »SYS 49155« ein. Diesen Befehl sollte man immer einem STOP-RESTORE vorziehen, denn sonst stürzt der Computer ab. Der Neustart erfolgt dann mit »SYS 49152«.

Der Geräteadresse 6 (die zweite Zahl beim OPEN-Befehl) wurden Steueraufgaben zugewiesen. Dies ist dann nötig, wenn man im 40-Zeichenmodus Kommandos an das aktive Programm (nach der Umschaltung mit »SYS 685« bleibt das Programm aktiv) sendet. Dies ist vor allem dann recht praktisch, wenn man mit zwei Bildschirmen arbeitet. In dem folgenden Beispiel wird vom normalen Editor aus, auf die 80-Zeichen-Darstellung umgeschaltet, dessen Bildschirm gelöscht und wieder auf die 40 Zeichen geschaltet:

OPEN 6,6 : PRINT#6, CHR$(1);CHR$(147);CHR(2) : CLOSE 6

Abschließend möchte ich noch zwei Steuerzeichen anführen, die übrigens alle wahlweise mit dem CHR$-Befehl oder über die Control-Taste eingegeben werden können. Dies sind CHR$(8) und CHR$(9) — beziehungsweise CTRL-I und CTRL-H —, mit denen der Cursor ein- und ausgeschaltet werden kann. Dies ist besonders bei Eingaben mit GET sehr nützlich, da hier ja normalerweise kein Cursor zu sehen ist. Setzt man vor solch einer Eingabeschleife ein »PRINT CHR$(9)« (Cursor on), so erscheint der Zeiger auch während der Eingabe. Danach sollte man ihn mit CTRL-H (oder »PRINT CHR$(8)<<) wieder abschalten, da er sonst die Geschwindigkeit beim Listen verlangsamt.

(Matthias Eichholz/Christoph Sauer/hm)

# Charakter-Designer für den C 64 \[84-88\]

> Mit diesem Programm passen Sie komfortabel alle darstellbaren Bildschirmzeichen Ihren eigenen Vorstellungen an.

Der Charakter-Designer besteht aus drei Programmteilen. Einem Basic-Lader zum Laden des Hauptprogramms, dem Hauptprogramm selbst, das unbedingt unter dem Namen CHARAKTER-MAIN abgespeichert werden muß und einem Zeichensatz-Lader. Mit ihm können selbstdefinierte Zeichensätze außerhalb des Charakter-Designers geladen werden. Dazu muß der Name des Zeichensatzes eingegeben werden. Ist der Ladevorgang beendet, wird gefragt, ob die Zeichen im Multicolor-Modus ausgegeben werden sollen oder nicht. Wird der Multicolor-Modus gewählt, können nur die Farben, die über die Commodore-Taste erreichbar sind (8 bis 15) genutzt werden. Dadurch lassen sich Multicolor- und normale Zeichen gleichzeitig darstellen.

Der Charakter-Designer ist so aufgebaut, daß während des Programmablaufs eine Bildschirmmaske bestehen bleibt.

Der Bildschirm besteht aus folgenden Feldern:

- dem Sketch-Pad:<br>Zeichenfeld, in dem vier Zeichen auf einmal gezeichnet werden können;
- dem Farbfeld:<br>Anzeige der ausgewählten Farben und der aktuellen Farbe, mit der gezeichnet wird;
- einer Anzeige der vier in Arbeit stehenden Zeichen in Originalgröße;
- einer Anzeige der vier in Arbeit stehenden Zeichen in doppelter Größe;
- dem Charakterwahlfeld:<br>Anzeige des gesamten Zeichensatzes;
- der Statuszeile:<br>Ein- und Ausgabezeile für Disketteninhalt, Eingabe der Namen für LOAD und SAVE und zur Ausgabe von Fehlermeldungen;
— einer Anzeige der am häufigsten gebrauchten Funktionen. Die Steuerung des Cursorpfeils erfolgt mit dem Joystick (Port 2) oder mit den Cursortasten (Punkt setzen mit Space).

### Funktionen:

Zur Beschreibung der Funktionen einige Erklärungen im voraus:

Der »aktuelle Charakter« ist das Zeichen, über dem sich der Cursorpfeil auf dem Sketch-Pad gerade befindet.

Im »Normalmodus« besteht ein Zeichen aus 64 Grafikpunkten (8x8) und kann eine von 16 Farben annehmen.

Im »Multicolormodus« wird die halbe Auflösung des Charakters genommen (8x4 Punkte). In diesem Modus können vier Farben auf einmal in einem Zeichen verwendet werden, wobei die vierte Farbe der des Hintergrunds entspricht. Leider kann bei der Farbe »1« nur unter acht Farben ausgewählt werden.

TODO TABLE

M (Multi-/Normalcolorumschaltung)
Durch diese Funktion kann zwischen Normal- und Multicolormodus gewählt werden.
D (Drehen)
Durch diese Funktion ist es moglich,ein Zeichen um 90 Grad nach links zu drehen (nur im Normalmodus).
SHIFT-D (Drehen)
Wie bei D, jedoch wird das ganze Sketch-Pad gedreht.
F (Spiegeln)
Der aktuelle Charakter erscheint spiegelverkehrt auf dem Bildschirm.
SHIFT-F (Spiegeln)
Wie bei F, jedoch wird das ganze Sketch-Pad an der Y-Achse gespiegelt.
K (Kopfstellen)
Der aktuelle Charakter wird an der X-Achse gespiegelt.
SHIFT-K (Kopfstellen)
Wie bei F, jedoch wird das ganze Sketch-Pad an der X-Achse gespiegelt.
G (Groß/Klein)
Mit dieser Taste kann zwischen Groß- und Kleinschrift selektiert werden. Wenn der abgespeicherte Charaktersatz später, außerhalb des Programms, geladen wird, ist der Zeichensatz aktiv, der zuletzt im Designer bearbeitet wurde und kann mit SHIFT-Commodore umgeschaltet werden.
I (Invers)
Diese Funktion bewirkt, daß der aktuelle Charakter invertiert wird. Im Multicolormodus werden die Farben auch entsprechend geändert.
SHIFT-1
Wie bei I, jedoch wird das ganze Sketch-Pad invers gesetzt.
Commodore-Taste (Charakter auswählen)
Durch Drücken der Commodore-Taste kann ein neues Zeichen in das aktuelle Feld genommen werden. Der Pfeil springt in die obere linke Ecke des Charakter-Auswahlfeldes. Nun kann man mit dem Pfeil einen Charakter auswählen, der mit Return übernommen wird. C (Copy) — Kopieren eines Zeichens
lm Copy-Modus springt der Pfeil in die linke Ecke des Charakterauswahlfeldes. Nun kann das Zeichen ausgewählt werden, das man kopieren will. Nach dem Drücken der RETURN-Taste kann man entscheiden, wo das Zeichen hinkopiert werden soll.
L (Laden eines Zeichensatzes)
Es erscheint »Name:« in der Statuszeile. Nun kann man den Filenamen über die Tastatur eingeben. Nach Drücken der RETURN-Taste (Eingabe beendet) schaltet der Bildschirm ab und der Zeichensatz wird geladen. Falls ein Diskettenfehler auftritt, erscheint die Meldung »Diskerror« in der Statuszeile. Durch Drücken der SPACE-Taste kann im Programm fortgefahren werden (die ganze Fehlermeldung des Floppy-Laufwerks kann nicht ausgegeben werden, weil die Statuszeile dafür zu klein ist).
S (Save)
Wie bei L, jedoch wird der Zeichensatz abgelegt.
* (Directory lesen)
Mit dieser Funktion kann das Inhaltsverzeichnis angezeigt werden. Die einzelnen Namen werden in der Statuszeile angezeigt, wobei der erste Ausdruck der Diskettenname ist. Durch Drücken von SPACE (Leertaste) wird der nächste Filename angezeigt.
@ (Initialisieren)
Der Original-C 64-Zeichensatz wird aus dem ROM in das RAM übertragen. So können auch kleine Änderungen ohne große Komplikationen durchgeführt werden.
Z (Zurück)
Mit dieser Funktion kann der zuletzt geladene Zeichensatz zurückgeholt werden.
T (Testen)
Das Auswahlfeld wird gelöscht und der Pfeil verschwindet. Nun kann man mit dem Zeichensatz schreiben, um zu testen, wie er wirkt. Es können alle Tasten benutzt werden. Nach Drücken der RETURN-Taste erscheint der Zeichensatz wieder und man kann im Programm fortfahren.
Q (Quit)
Diese Taste muß (aus Sicherheitsgründen) dreimal gedrückt werden, um das Programm zu beenden. Nach erstmaligem Drücken der Taste erscheint der Ausdruck »ACHTUNG RESET« in der Statuszeile. Wenn man eine andere Taste drückt, verschwindet der Ausdruck wieder und man kann weiterzeichnen.
CLR/HOME (Löschen eines Zeichens)
Die CLR/HOME-Taste hat drei Funktionen:
1.	Alleiniges Drücken der Taste bewirkt, daß der Pfeil in die obere linke Ecke des Sketch-Pads springt.
2.	Zusammen mit der SHIFT-Taste wird der aktuelle Charakter gelöscht.
3.	Zusammen mit der CTRL-Taste wird das gesamte Sketch-Pad gelöscht.
Einfügen und Herausnehmen von Zeilen und Spalten:
Diese Funktion ist eine Besonderheit des Charakter-Designers. Sie ermöglicht es, Punkte in einer Zeile beziehungsweise Spalte einzufügen und herauszunehmen. Der Pfeil kann an einer beliebigen Stelle des Sketch-Pads positioniert werden.
Mit folgenden Tasten wird gearbeitet.
INS/DEL-Taste: für zeilenweises Herausnehmen. Durch zusätzliches Drücken der SHIFT-Taste wird eine Zeile eingefügt. Es werden bis zu 255 Zeilen gepuffert, die automatisch wieder ausgegeben werden.
Pfund-Taste: wie bei INS/DEL, jedoch wird der jeweils darunter liegende Charakter mit bewegt.
= -Taste: für das spaltenweise Herausnehmen von einzelnen Punkten. Mit SHIFT »=« wird ein Punkt eingefügt. Hierbei wird nichts gepuffert, weil es in den meisten Fällen, nur hinderlich wäre.
;-Taste: wie bei =, jedoch werden zwei nebeneinander liegende Charaktere bearbeitet.

### Farbgebung:

Die Farben werden mit den Tasten 1 bis 4 ausgewählt und können durch zusätzliches Drücken der SHIFT-Taste verändert werden.

Im Normalmodus kann man durch Drücken der Taste 1 die Farbe eins zum Zeichnen nehmen. Wenn man Punkte löschen will, muß man die Taste 4 drücken.

Im Multicolormodus sind die Tasten 1 bis 3 mit den verschiedenen Farben belegt, wobei mit der Taste 4 Punkte gelöscht werden können.

### Programmablauf:

Nach dem Starten (durch Reset oder Restore) werden die Initialisierungsroutinen aufgerufen. Danach werden die einzelnen Unterroutinen in den $COOO-Bereich verschoben und die Bildschirmmaske einschließlich Farbe übertragen. Nun werden die programminternen Initialisierungsroutinen aufgerufen (Rasterzeilen-Interrupt, Sprites für Charakteranzeige und so weiter) und der aktuelle Zeichensatz wird aktiviert. Anschließend befindet sich das Programm in der Tastatur- und Joystick-Abfrage (Hauptschleife).

(Matthias Meyer/ah)

# 3D-Supergrafik \[89-92,94-95\]

> Ein dreidimensionales Grafikprogramm, das sich auch vor professionellen 3D-Programmen nicht zu verstecken braucht. Bewiesen wurde das, indem dieses Programm im Rahmen des Wettbewerbs »Jugend forscht ’85« mit dem Sonderpreis Elektronik ausgezeichnet wurde.

Mit diesem Programm ist es möglich, beliebige dreidimensionale Körper zu drehen und in verschiedenen Perspektiven darzustellen. Die Besonderheit dieses Programms ist jedoch, daß es eine Routine zur Lösung des Hinterschneidungsproblems besitzt. Diese Routine ermöglicht es, Körper naturgetreu darzustellen, indem sie Kanten, die von dem Körper verdeckt werden, löscht. Außer der Darstellung von Körpern besitzt das Programm natürlich auch Routinen zum Eingeben, Laden, Speichern und Ausdrucken von Körpern sowie eine eigene Grafikerweiterung in Maschinensprache.

Insgesamt ist das Programm sehr übersichtlich und leicht zu bedienen. Nur die Routine zur Eingabe von Körpern erfordert eine kurze Einarbeitungszeit. Denn zuerst müssen die Eckpunkt-Koordinaten eingegeben werden, dann die Nummern der Punkte, aus denen die Fläche besteht, und zwar in der Reihenfolge, in der sie verbunden werden sollen.

Die Routine zur Berechnung des Bildes erlaubt keine Fehleingaben, so daß man durch Probieren die Auswirkungen der einzelnen Faktoren auf das Bild bestimmen kann. Außerdem braucht sich der Benutzer nicht um die Größe der Darstellung zu kümmern, da dies vom Computer erledigt wird.

### Die Speicherbelegung

Bei 3D-Supergrafik handelt es sich eigentlich um drei Programme: Einem Lader (Listing 1), eine Grafikerweiterung in Maschinensprache (Listing 3) und das Hauptprogramm in Basic (Listing 2). Diese Grafikerweiterung belegt den Speicherplatz von $C400 bis $CAFF. Außerdem benutzt sie zwei Grafikbildschirme unter den beiden ROM-Bereichen ($AOOO-$BFFF/$EOOO-$FFFF). Die dazugehörigen Farbspeicher liegen von $8C00 bis $8FFF und von $C000 bis $C3FF. Daraus folgt, daß das Hauptprogramm mit den Variablen im Bereich von $0800 bis $8BFF liegt. Soviel zur Speicherbelegung.

### Das Programm

Nach Laden und Starten des Laders gelangt man nach dreißig Sekunden ins Hauptmenü, das fünf Menüpunkte zur Verfügung stellt. Auf die Bedienung der einzelnen Punkte werde ich im folgenden eingehen.

### 1.	Daten eingeben

Bevor man einen dreidimensionalen Körper in den Computer eingeben kann, muß man ihn erst in mathematische Daten zerlegen. Das hört sich schwerer an als es eigentlich ist. Man zeichnet sich einfach eine Vorderansicht und eine Draufsicht des Körpers in Koordinatensysteme. Daraus kann man dann die Eckpunktkoordinaten und die Verbindungsvorschrift ablesen (siehe Bild 1). Nachdem Sie diese Arbeit erledigt haben, können Sie mit der Eingabe der Daten in den Computer beginnen.

Zuerst muß man die Anzahl der Eckpunkte (im Bild 1: 8 Punkte) und die Anzahl der Flächen (im Bild 1: 6 Flächen) des gewünschten Körpers eingeben. Danach sind die räumlichen Koordinaten der Eckpunkte an der Reihe. Nachdem man die Koordinaten des Punktes eingegeben hat, wird man vom Computer gefragt, ob die Eingabe richtig ist. Falls dies so ist, tippt man einfach weiter, falls nicht, drückt man die Taste »N«. Dann kann man die Werte noch einmal eingeben.

Nachdem man alle Eckpunkte definiert hat, muß man eingeben, in welcher Reihenfolge die Punkte zu jeder Fläche verbunden werden sollen. Ist man mit einer Fläche fertig, gibt man nur RETURN ein. Jetzt folgt wieder die Richtigkeitsabfrage des Computers, die analog zur vorherigen Frage beantwortet werden muß. Leider gibt es bei der Flächeneingabe noch eine Einschränkung. Eine Fläche darf nämlich nur aus vier Eckpunkten bestehen. Daraus folgt, daß große Flächen zerlegt, und auf mehrere kleine Flächen verteilt werden müssen (siehe Bild 2). Durch diese Maßnahme entstehen Linien, die die große Fläche teilen. Um so etwas zu vermeiden, kann der Anwender Linien eingeben, die später im Bild nicht gezeichnet werden. Das geht folgendermaßen:

Man schreibt hinter den Punkt, zu dem die nachher nicht sichtbare Linie führen soll, ein »I«.

So, das war das Schlimmste. Alles weitere ist einfach.

### 2.	Daten laden

Dieser Menüpunkt dient dazu, die Daten eines Körpers von Diskette zu laden. Er bietet noch zwei Sonderfunktionen: »$« druckt das Directory der Datenfiles auf der Disk »@« Rückkehr zum Hauptmenü

Bei der Angabe, welches Bild zu laden ist, darfdas »3D-« nicht mit eingegeben werden.

### 3.	Daten speichern

Diesen Menüpunkt sollte man sofort nach der Eingabe eines Körpers aufrufen, um die Daten zu sichern. Er speichert die Daten in einem platzsparendem Format auf Disk. Die Sonderfunktiorien sind analog zu Punkt 2. Dem Dateinamen wird automatisch ein »3D-« vorangestellt.

### 4.	Bild berechnen

Es handelt sich hierbei um den umfangreichsten Punkt des Programmes, der aber nicht schwer zu verstehen ist. Die Auswirkung der einzelnen Parameterauf das Bild läßt sich am besten durch folgende Methode herausfinden: Probieren, probieren, probieren ...

Für Interessierte möchte ich hier noch erwähnen, wie ich das Hinterschneidungsproblem in meinem Programm gelöst habe:

Der Computer zeichnet die hinterste Fläche zuerst und füllt sie im unsichtbaren Grafikschirm aus (zu sehen, wenn Sie »F2« drücken). Jeden Punkt, den er dort setzt, löscht er in der sichtbaren Grafik.Auf diese Weise verfährt er auch mit den anderen Flächen, die vorderste Fläche zeichnet er zuletzt. Diese Verfahrensweise läßt sich sehr gut beim Bildaufbau beobachten. Es sieht aus, als ob der Computer den Körper aus einzelnen Teilen zusammensetzt. Es lohnt sich auch, mit den Funktionstasten F1 und F2 beim Bildaufbau zwischen den beiden Grafikseiten hin- und herzuschalten.

Wenn das Bild .fertig gezeichnet ist, kommt man mit der Leertaste wieder in den Textbildschirm. Dort wird man gefragt, ob noch etwas an der Grafik zu ändern ist. Wenn diese Frage bejaht wird, gelangt man in einen kleinen Grafikeditor. Man bewegt das Kreuz mit dem Joystick (Port 2) über den Bildschirm. Bei gedrücktem Feuerknopf werden Punkte gesetzt oder gelöscht. Mit den Tasten »%« und »L« kann man zwischen Punkt setzen und Punkt löschen hin- und herschalten. Verlassen kann man den Editor mit »E«.

### 5.	Hardcopy

Dieser Menüpunkt sendet eine Hardcopy für einen Epson FX/RX-80 auf den seriellen Bus. Falls Sie über einen solchen Drucker verfügen, brauchen Sie nur noch die Sekundäradressen an Ihr Interface anpassen. In Zeile 395 setzen Sie die Sekundäradresse für Groß-/Klein-Schrift ein, in Zeile 407 die Sekundäradresse für den Epson-Direkt-Modus (ohne Auto-Linefeed !).

Sonstige Hinweise

- Falls Sie das Programm mit RUN/STOP unterbrochen haben und die Variablen noch vorhanden sind, können sie es mit »GOTO 115« wieder starten.
- Die Funktionstasten sind folgendermaßen belegt:
F1: Grafik 1
F3: Grafik 2
F5: Textbildschirm
F7: Textbildschirm
- Drücken Sie die Funktionstasten nie während Operationen auf dem seriellen Bus (Laden/Speichern/Hardcopy).
- Der Bereich von $9000 bis $9FFF ist aus Hardwaregründen unbenutzt (»Geisterbilder« des Zeichen-ROMs). Dort können eigene Hardcopyroutinen untergebracht werden.
- Man kann sich unter dem Menüpunkt »Bild berechnen« auch die Werte ausgeben lassen, um dann ein Bild von Hand zu zeichnen.

In Bild 3 bis Bild 6 sehen Sie noch einige Beispiele.

Zum Schluß möchte ich Ihnen noch viel Spaß bei der Arbeit mit meinem Programm wünschen.

(Oliver Günter/gk)

# Räumliche Grafik auf dem C 64 \[96-108\]

> Gerade auf dem Gebiet von Film- und Fernsehproduktionen werden Computergrafiken immer öfter eingesetzt, da es hiermit möglich ist, Dinge zu zeigen, die mit herkömmlichen Methoden nicht gefilmt werden konnten.

Ob nun Raumschiffe gezeigt werden, die eigentlich unmögliche Bewegungen durchführen oder der »Anflug« eines Logos (wie zum Beispiel die »1«bei der ARD), die Realisierung vereinfacht sich durch den Einsatz von Grafik-Computern enorm. Diese müssen jedoch — bedingt durch die anfallenden Datenmengen — enorm schnell sein, so daß zur Zeit nur »Supercomputer« Echtzeitsimulation erlauben.

Wenn man sich allerdings etwas mehr Zeit läßt, dann reicht auch ein Homecomputer wie der C 64 aus, um solche Grafiken (mit bestimmten Einschränkungen) zu erzeugen.

Das hier vorgestellte Grafikpaket geht über das übliche Punkte setzen und Linien ziehen weit hinaus. Es erlaubt die Erzeugung von plastischen Bildern ohne größeren Aufwand, wie zum Beispiel in Bild 1 und 2 dargestellt.

Das eigentliche Grafikpaket nimmt nur 3 KByte (I) des Speichers in Anspruch und steht im Bereich ab $C000. Damit bleibt der Basic-Speicher für die eigentlichen Programme frei. Auch das DOS 5.1 von Commodore kann parallel zu den Grafikroutinen verwendet werden. Aufgrund der Kompaktheit dieses Grafikpakets mußten allerdings bestimmte Dinge, wie zum Beispiel die Abfrage auf legale Koordinaten, in den Hintergrund treten; die Software fängt also solche Fehler nicht ab. Das macht das Schreiben eines eigenen Programms zwar etwas komplizierter, hat man aber erst einmal alle Fehler beseitigt, so würde eine Fehlerabfrage den Ablauf nur verlangsamen.

Beginnen wir mit den Grundlagen zur Erzeugung der Grafik. Da stellt sich zunächt einmal die Frage, wie man die verschiedenen Helligkeitswerte und Schattierungen eines darzustellenden Objektes berechnet. Danach müssen diese verschiedenen Grauwerte in einzelne Punkte umgesetzt werden, denn auf dem HiRes-Bildschirm können diese ja nur gesetzt und gelöscht werden. Dazu muß die gesamte Software selbst geschrieben werden, da der C 64 diese Art der Grafik vom Betriebssystem her nicht unterstützt.

## Schnelle Rechenroutinen

Das Maschinenprogramm, das für den Aufbau der Grafik zuständig ist, besteht aus mehreren Unterprogrammen. Beginnen wollen wir mit einem Unterprogrammpaket, das für schnelles Rechnen notwendig ist.

### Integer Arithmetik (Listing 1)

Diese Unterroutinen stellen schnelle Algorithmen für Multiplikation, Division, Wurzelziehen und Zufallszahlen zur Verfügung. Diese sind zwar schon im normalen Basic-Interpreter vorhanden, für unsere Anwendung sind sie jedoch aus Geschwindigkeitsgründen ungeeignet. Die Basic-Routinen sind nämlich nicht auf Geschwindigkeit, sondern auf Kürze optimiert worden, wie zum Beispiel die Funktion SQR. Die Wurzelberechnung in Basic teilt den Logarithmus durch 2 und potenziert das Ergebnis anschließend wieder. Das hat den Vorteil, daß der Interpreter auf bereits vorhandene Unterprogramme zugreifen kann, aber den Nachteil, daß diese Berechnungsweise relativ langsam ist. Wenn man für alle 64000 Bildschirmpunkte die Quadratwurzel mit den vorhandenen Routinen berechnen würde, ergäbe sich eine Zeichenzeit von mehr als einer Stunde (und dies trotz Maschinenspracheprogramm)! Man benötigt diese Berechnung zwar nicht für jeden Punkt, aber gerade bei der Berechnung der Schattierungswerte spielt die Quadratwurzel eine große Rolle. Eine Möglichkeit, die Wurzelberechnung zu beschleunigen bietet die Newton-Methode, mit der man Fließkommawurzeln in einem Bruchteil der sonst benötigten Zeit berechnen kann. Da wir, um die einzelnen Grafikpunkte zu adressieren, nur ganze Zahlen benötigen, beschleunigt sich die Abarbeitungszeit nochmals. Auch die Routine für die Erzeugung von Zufallszahlen, die später bei der »Random«-Schattierung erforderlich ist, wurde neu geschrieben.

### Grafik Utilities (Listing 2)

Die nächste Unterprogrammsammlung beinhaltet Basisroutinen für die Verwaltung der Bitmap wie zum Beispiel löschen, Farbe setzen und Punkte plotten. Diese Unterroutinen sind als einzige Commodore 64-spezifisch, so daß man — möchte man das Programm auf andere 6502-Computer übertragen — nur diese an das jeweilige Gerät anpassen muß.

Ferner wurden noch zwei Schattierungsroutinen »SHADE« und »RSHADE« implementiert. »SHADE« arbeitet im Prinzip ganz einfach: Man definiert eine 8 x 8 Graustufenmatrix, in der Werte von 0 bis 63 enthalten sind (Tabelle 1). Mit Hilfe dieser Daten wird nun ein — ebenfalls 8 x 8 Pixel großes — Feld erstellt, daß dann an einer bestimmten Stelle in den HiRes-Bildschirm kopiert wird. Um eine gleichmäßige Grauschattierung zu erreichen, müssen die Pixels auch möglichst einen gleichmäßigen Abstand voneinander haben. Wenn das Programm nun einen Grauwert in die Grafik setzen will, so übergibt es einfach einen Wert zwischen 0 und 63 an diese Unterroutine. Nun werden innerhalb dieser Matrix die einzelnen Punkte der Reihe nach gesetzt, also zuerst der Punkt mit der Nummer 0 (oben links), dann 1 (4. von links und 4. von oben) und so weiter. Also, je größer die Zahl ist, desto mehr Punkte werden gesetzt (und um so dunkler wird das Ganze). Durch diese festgelegte Reihenfolge wird sichergestellt, daß die Schattierung gleichmäßig ist. Die RSHADE-Unterroutine hat genau die gleiche Aufgabe, sorgt aber für etwas ungleichmäßigere — durch den Zufallsgenerator gesteuerte — Grauwerte.

Ein weiteres zu lösendes Problem ist das etwas merkwürdige rechteckige Bildschirmformat des C 64. Die Auflösung von 320 x 200 Punkten entspricht einem Teilungsverhältnis von 8:5, wodurch es bei einem normalen Bildschirm — mit einem Verhältnis von 4:3 — zu einer horizontalen Verzerrung kommen kann (eine Kugel würde dann etwa wie ein plattgedrückter Ball aussehen). Die Unterroutine »SCALE« (in Listing 2) sorgt für diese darstellungs- und maßstabsgerechte Aufbereitung der Koordinaten.

### Linien und Facettenzeichnen

Die Routinen in Listing 3 komplettieren die elementaren Grafik-Funktionen für das Ziehen von Linien und das Zeichnen von schattierten Polygonnetzen. Ein solches räumliches Polygonnetz ist in Bild 3 zu sehen; es besteht nur aus aneinander gesetzten und entsprechend schattierten Dreiecken. Diese Figuren können einfacher und schneller gezeichnet werden, da die Schattierung auf ebenen Flächen einfacher darzustellen ist als auf gekrümmten. Neben der üblichen Darstellungsweise (in der geschlossenen, schattierten Form) ist auch die Zeichnung von Grafiken ohne verdeckte Linien möglich.

Mit diesen Routinen gerüstet, können wir uns nun auf das eigentliche Shape-Unterprogramm konzentrieren, mit dem es möglich ist, gekrümmte, schattierte Figuren in kurzer Zeit zu erstellen.

Hier geht es wiederum als erstes um die Berechnung der verschiedenen Oberflächenreflexe, Brechungen, Streuungen und Absorptionen des Lichtes auf einer Oberfläche. Um diese, teilweise sehr komplizierten Berechnungenn, zu vereinfachen, geht man einen anderen Weg: Man beschränkt sich auf einige einfache symmetrische Figuren (Bild 4), aus denen alle zu zeichnenden Objekte zusammengesetzt werden. Weiterhin werden die Figuren nur in der Frontsicht, also von vorn, dargestellt; Drehungen sind nicht möglich. Durch diese Einschränkungen braucht man bei der Programmierung nicht auf komplizierte Vektorberechnungen zurückzugreifen.

Für die Berechnung des Lichteinfalls stelle man sich einfach eine Lampe vor, die an der rechten Schulter des Beobachters angebracht ist und das Objekt von dieser Position anleuchtet. Dementsprechend errechnet das Programm die Helligkeitswerte für jeden Punkt des Objektes. Ein Flag (Adresse 898) dient dazu, den Standort der »Lampe« (0= Frontbeleuchtung, 1 = Beleuchtung von hinten) festzulegen.

### Zeichenroutinen für Shapes

Listing 4 beinhaltet eine Sammlung von Routinen, die die acht Grundshapes (siehe Bild 4) zeichnen. Da dieses Unterprogramm auf die — an den C 64 angepaßten — Lower-Level-Routinen der Grafik-Utilities (Listing 2) zugreift, ist es selbst nicht vom jeweiligen Computer abhängig. Zusammen mit dem, in Listing 5 abgebildeten Programm, wird der Kontakt zum Basic hergestellt. Die Übergabe der Parameter geschieht mittels »SYS«-Befehl:
SYS <KOMMANDO>, <PARAM. 1,>, <PARAM. 2>, ..., wobei <KOMMANDO> die Adresse des jeweiligen Grafikbefehls ist (Tabelle 2 zeigt die komplette Befehlsübersicht dieses Grafikprogramms). Über <PARAMETER 1> und <PARAMETER 2> müssen die Koordinaten des Shapes angegeben werden, wobei zu beachten ist, daß der Ursprung (dort wo die X- und Y-Koordinate null ist) in der linken unteren Bildschirmecke liegt. Die einzusetzenden Werte gehen in der Horizontalen von 0 bis 255, in der Vertikalen von 0 bis 239.

Alle Shapes, mit Ausnahme der Kugel, können durch die Eingabe von insgesamt vier Parametern in ihrer Position und Form beeinflußt werden. Die ersten zwei bestimmen, wie oben erläutert, die Koordinaten des Figurmittelpunktes. Mit dem dritten und vierten Paramter kann man die Verzerrung in X- und Y-Richtung einstellen. Doch hier ist Vorsicht geboten, denn der X-Wert sollte hierbei immer größer als der Y-Wert sein, sonst zeichnet das Programm unerwünschte Figuren.

Eine weitere Besonderheit sind die Shape-Fenster. Damit ist es möglich, auch einzelne Teile eines Shapes auf dem Bildschirm zu bringen. Diese Funktion wurde zum Beispiel bei der Erstellung der Grafik in Bild 1 verwendet. Der Henkel dieser Kafffeetasse ist aus drei verschiedenen Shapes zusammengesetzt, die mit Hilfe des Fensters in ihrer Ausdehnung eingeschränkt wurden. Diesen Begrenzungsfenstern sind die Adressen 893 bis 896 zugeordnet, wobei sich die POKE-Werte auf den Mittelpunkt der Figur beziehen.

Die Kommandos, um die Bitmap zu löschen oder mit Punkten zu füllen, benötigen auch alle nur einen Parameter. So sieht zum Beispiel das Kommando zum Initialisieren des Farbspeichers so aus:

POKE 52001,16*DC + BC

wobei DC die Farbe der zu setzenden Punkte und BC die Hintergrundfarbe ist. Auch Texte können nach Wunsch auf dem Grafikbildschirm ausgegeben werden. Die dafür zuständigen Routinen sind in Listing 2 enthalten.

Die in Listing 10 und 11 abgedruckten Demonstrationsprogramme sollen helfen, die Arbeitsweise und die Kombinationsmöglichkeiten der einzelnen Shapes aufzuzeigen. Auch alle hier gezeigten Bilder stammen von diesem Programm. Die Bilder stehen im Speicher übrigens »unter« dem Basic-ROM im Bereich zwischen $A000 und $BFFF.

Um den Platz für das DOS 5.1 freizuhalten, wurde das Grafikpaket in zwei Teile aufgespalten. Der eine Teil mit dem Namen GRAPHICS (Listing 8) befindet sich im Bereich zwischen $C000 und $CBFC. Der zweite Teil, auf den im folgenden noch kurz eingegangen werden soll, muß nach Adresse $CF59 geladen werden. Dieser Programmteil enthält eine schnelle Sortierroutine (Listing 6) und ermöglicht die Darstellung von Text auf dem Grafikbildschirm (Listing 7). Die beiden Unterprogramme sind in dem MSE-Listing 9 zusammengefaßt worden und müssen gemeinsam mit »GRAPHICS« in den Speicher geladen werden.

### Hinweise zum Abtippen

Sie müssen als erstes die MSE-Listings 8 und 9 eingeben und anschließend natürlich auch abspeichern. Die Listings 1 bis 7 dienen nur zur Dokumentation und brauchen nicht eingegeben werden. Nachdem Sie auch die Demos abgetippt und auf Diskette oder Band gespeichert haben, müssen die einzelnen Programmteile nacheinander in den Speicher geladen werden. Begonnen wird mit GRAPHICS, das mit LOAD-"GRAPHICS",8,1 in den Speicher gelesen werden muß. Nachdem man anschließend NEW eingegeben hat, muß das zweite Maschinenprogramm, wie oben, geladen werden (auch hier das NEW nicht vergessen). Anschließend kann wahlweise eines der beiden Demonstrationsprogramme (Listing 10 oder11) geladen und ganz normal gestartet werden.

(Richard Rylander/Christoph Sauer/ev)

# Soft-Scrolling auf dem C 64 \[110-111\]

> Soft-Scrolling in eigene Programme einzubauen, kann oft zum Problem werden. Wie es gemacht wird, zeigt Ihnen dieser Beitrag.

Jeder kennt bestimmt Defender oder ähnliche Arcade-Games, bei denen die Hintergrundlandschaft über den Bildschirm zieht. Gemeint ist das sogenannte Smooth- oder Soft-Scrolling. Der Unterschied zwischen normalem und Soft-Scrolling ist, daß der Bildschirm beim Soft-Scrolling in Einerschritten (um ein Pixel) und beim normalen in Achterschritten (immer um acht Pixel gleichzeitig) verschoben wird.

Beim Achterscrolling werden einfach die Speicherstellen des Video-RAMs (ab 1024/$0800) um jeweils eine Stelle nach links, rechts, oben oder unten verschoben.

Zum Achterscrolling ein Beispiel in Basic:

TODO PRE

10 REM Beispiel Nr. 1
20 PRINT CHR$(147);TAB(14);
30 PRINT "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
40 FOR I=1064 T0 1024 STEP -1
50 POKE I,PEEK (I-1)
60 NEXT
70 G0T0 40

Dieses Programm arbeitet zwar noch relativ schnell, aber wir werden später diese Aufgabe einem Assemblerprogramm übergeben.

Das Alphabet wird nach dem Eintippen dieses Programms nach rechts herausgeschoben. Dieses Achterscrolling ist aber zu sprunghaft, und falls es schneller läuft, ist die gescrollte Schrift unleserlich.

Das Soft-Scrolling bewirkt, daß die Schrift gleichmäßig fließend und damit leserlich gemacht wird. Wie scrollt man denn nun aber den Bildschirm um nur ein Pixel?

Die Hauptrolle hierbei spielen die Speicherstellen 53248+17 (53248 = Basisadresse des Video-Chips +17 für das vertikale und 53248+22 für das horizontale Scrolling).

Befassen wir uns zunächst mit dem horizontalen Scrolling. Die Speicheradresse 53248+22 ist folgendermaßen aufgebaut:

Bit 7 bis 5 : Sind nicht benutzt

Bit 4 : Zur Umschaltung auf Multicolor
Wichtig sind für unsere Anwendung nur:

Bit 3 : Umschalten von 40 auf 38 Spalten

Bit 0 bis 2 : Horizontales Scrolling

Dazu ein Versuch:
POKE 53248+22,PEEK (53248+22) AND 248 OR 3

Nun müßte sich der Bildschirm um drei Pixels nach rechts verschoben haben.

Einige werden sich jetzt fragen, warum die ANDs und ORs?

Nehmen wir einmal an, im Register 22 des VIC würde die Zahl 107 stehen. Diese Zahl wird mit 248 AND-verknüpft. Beide Zahlen müssen binär aufgeschlüsselt werden:

TODO

107 = 01101011
AND 248 = 11111000
ergibt 01101000

Durch diese AND-Funktion werden also die Bits 0 bis 2 gelöscht. Die Bits 3 bis 7 ändern sich nie. Durch die OR-Funktion werden die entsprechenden Bits gesetzt:

TODO

01101000
OR 3 00000011
ergibt 01101011

Die Bits für das horizontale Scrolling enthalten jetzt den Wert 3. Der höchste mit den Bits 0 bis 2 zu erreichende Wert ist 7, der niedrigste ist 0. Je größer der Wert in diesen drei Bits, desto weiter wird der Bildschirm nach rechts verschoben! Mit dieser Erkenntnis können wir den Bildschirm um sieben Pixels nach rechts rollen!

TODO PRE

10 REM Beispiel Nr. 2
20 FOR 1=0 T0 7
30 POKE 53248+22,PEEK (53248+22) AND248 OR I
40 FOR T=0 T0 1000:NEXT T
50 NEXT I
60 RUN

Dieses Programm verschiebt den Bildschirm langsam von der normalen Position um sieben Pixel nach rechts. Dann wird er wieder auf die normale Position zurückgesetzt und rollt wieder nach rechts. Wie macht man es nun, daß der Bildschirm über das 7. Pixel hinausscrollt?

Dies ist ganz einfach: Nachdem das 7. Pixel erreicht wurde, machen wir ein Achterscrolling, das heißt wir verschieben einen Bildschirmcode um ein Zeichen nach rechts. Gleichzeitig setzen wir das Scrollregister wieder auf Null und haben jetzt das 8. Pixel erreicht.

Jetzt können wir die Prozedur wieder von vorne beginnen (dazu ein Flußdiagramm).

S = SCROLLREGISTER

Dieses Flußdiagramm muß nun noch in ein Programm umgesetzt werden. Würde das gesamte Programm in Basic geschrieben, wäre es ziemlich langsam. Deshalb wird im nachstehenden Listing das Achterscrolling in Assembler realisiert. Es scrollt die erste Zeile in Achterschritten nach rechts. Zuerst die Darstellung in Maschinensprache und dann in DATA-Zeilen:

TODO

LDA $0427	; STA $FB	Speicherstelle 1063 merken
LDX #38	;	Bei Spalte 38 anfangen
LDA $0400,X ;	Bildschirmcode laden
INX	;	Um 1 erhöhen
STA $0400,X ; DEX	Und abspeichern
DEX	;	Um 2 erhöhen
CPX #$FF ;	Schon fertig ?
BNEV
LDA $FB	; STA $0400	1063 wieder nach 1024
LDA $D016	;	Scrollregister laden
AND #248	;	Scrollbits löschen
STA $D016	; RTS	Zurückspeichern
110

Dieses Maschinenprogramm schiebt die Zeilen, die in der ersten Zeile des Bildschirms stehen, nicht nur nach rechts, sondern macht ein Rundum-Scrolling. Die rechts verschwundene Schrift erscheint also wieder am linken Bildschirmrand. Dies wird durch die ersten und letzten beiden Maschinenprogrammzeilen ermöglicht. Startet man dieses Programm, so ist ab und zu ein leichtes Zucken zu erkennen. Dies liegt daran, daß der Elektronenstrahl, der den Bildschirm 25mal in der Sekunde aufbaut, die erste Zeile schreibt, während sie gescrollt wird. Wie kann man das vermeiden?

Es ist das Register 53248+18, das benötigt wird. In ihm steht die Zeile, in der sich der Elektronenstrahl befindet (nähere Informationen siehe 64’er, Ausgabe 11/84).

Wir brauchen also nur dieses Register auszulesen und die erste Zeile erst dann zu scrollen, nachdem sie vollständig vom Elektronenstrahl aufgebaut wurde.

Die Abfrage muß in Assembler geschehen, da ein Basic-Programm im Verhältnis zur Geschwindigkeit des Elektronenstrahls zu langsam ist. Der richtige Zeitpunkt für den Beginn des Scrollings ist ungefähr dann gegeben, wenn der Strahl die Rasterzeile 100 erreicht hat.

Wir müssen das obige Maschinenprogramm also noch etwas erweitern. Ganz am Anfang muß stehen:

TODO

X LDA 53248+18 ; Rasterzeile auslesen
CMP #160 ; Vergleiche auf 160
BMI X ; Wenn kleiner dann nach X
CMP #190 ; Vergleiche auf 190
BPL X ; Wenn größer dann nach X
RTS

Und nun das gesamte 1-Zeilen-Soft-Scrolling in Basic: (Das dazugehörige Maschinenprogramm ist so geschrieben, daß es in jeden Bereich ge-POKEt werden kann!)

TODO PRE

10	REM Beispiel Nr. 3
20	PRINT CHR$(147);GOSUB 100
30 PRINT "Beliebiger Text kleiner als 40 Zeichen"
40	REM Farbe = schwarz
50	FOR I=55296 TO 55296+39:POKE I,0:NEXT
60	FOR I=1 TO 7
70	POKE 53248+22,PEEK (53248+22) AND 248 OR I
80	FOR T=0 TO 5:NEXT
90	NEXT I
100	FOR T=0 TO 3:NEXT
110	SYS32768:REM Achterscrolling
120	GOTO 60
130	REM Masch.PRG einlesen
140	FOR 1=32768 TO 32768+44:REM 44 DATAs
150	READ G:S=S+G:POKE I,G:NEXT
160	IF S=6044 THEN 180
170	PRINT"FEHLERINDATAS!":STOP
180	RETURN
190	DATA	173,18,208,201,160,48,249,201
200	DATA	190,16,245,173,39,4,141,255,207
210	DATA	162,38,189,0,4,232,157,0,4,202
220	DATA	202,224,255,208,243,173,255,207
230	DATA	141,0,4,173,22,208,41,248,9
240	DATA	0,141,22,208,96

Man stellt fest, daß die Zeichen am rechten Rand langsam herauswandern; aber am linken Rand plötzlich auftauchen. Dies läßt sich verhindern, indem man den Bildschirm seitlich verengt (Bit 3 des Registers 53248+22 löschen). Das kann man mit
POKE 53248+22,PEEK(53248+22)AND247 erreichen. Platz dafür wäre zum Beispiel in Zeile 45.

Basic reicht nicht aus, um eine angemessene Geschwindigkeit zu erreichen. Deshalb steigen wir nun ganz auf Assembler um! Schreiben wir zunächst die Zeilen 60 bis 90 des Beispiels Nummer 3 in Assembler:

M LDA 53248+22 ; Scrollregister laden
AND #7 ; Scrollbits ausfiltern
CMP #7 ; Schon 7 ?
BNE N ; Wenn nicht dann Einerscrolling
JSR ACHTSC ; Achterscrolling
JMP M ; Nächste Verschiebung
N INC 53248+22 ; Scrollreg. erhöhen
LDX #$FF ; Verzögerungsschleife
Q LDY #$30
A INY
BNE A
INX
BNE Q
JMP M ; Nächste Verschiebung

Diese Routine müssen wir nur noch in das obige Achterscrolling einbauen. Für die Basic-Fans haben wir einen Basic-Lader dieses Programms am Schluß abgedruckt. Kommen wir nun zum vertikalen Scrolling:

Im Prinzip funktioniert es wie das horizontale, es wird nur ein anderes Register benutzt.

Das Register für das vertikale Scrolling ist: 53248+17.

Für das Scrolling sind wie beim horizontalen Scrolling die Bits 0 bis 2 verantwortlich.

Einzeilen Soft-Scrolling (DATA-Lader):

TODO PRE

0	DATA173,22,208,41,7,201,7,208,6,32,34,128,76,0,
128,32,68,128,238,22,208
1	DATA162,255,160,160,200,208,253,232,208,248,76,0,	H
128,173,39,4,133,251
2	DATA162,38,189,0,4,232,157,0,4,202,202,224,255,	■
208,243,165,251,141,0
3	DATA4,173,22,208,41,248,141,22,208,96,173,18,208,
201,160,48,249,201,190
4	DATA16,245,96,255
10	FOR I=32768 TO 32768+5*16
20	READA:POKEI,A
30	NEXT
40	PRINT"(CLR}	HIER KOENNTE EIN TEXT STEHEN.
50	SYS32768
READY

(Frank Barcikowski + Holger Vocke/ah)

# Sprites ohne Streß \[112-114\]

> Es soll immer noch Leute geben, die sich nicht an die Programmierung von Sprites herantrauen, weil sie von den recht unverständlichen Ausführungen im Commodore-Handbuch ziemlich verunsichert sind. Deswegen wollen wir hier die Grundlagen der Sprites darstellen.

Spielefreaks haben sie lieben gelernt: die Sprites, frei auf dem Bildschirm bewegbare Objekte in hoher grafischer Auflösung, die sogar mehrfarbig sein können. Doch nicht nur in Videospielen haben sich die Sprites bewährt: Auch als Mini-Grafik, Erkennungszeichen oder verschnörkelter Schriftzug waren sie schon zu sehen, und jede Woche entdeckt irgendein findiger Kopf eine Anwendungsmöglichkeit mehr.

Wer Sprites als grafische »Auflockerung« seiner Programme verwenden will, der kann mit dem ganz normalen Commodore-Basic hervorragende Ergebnisse erzielen, obwohl man dabei nicht um den berühmtberüchtigten POKE-Befehl herumkommt Wer allerdings ein rasantes Actionspiel programmieren will, der verlege sich doch besser auf Maschinensprache, denn die Bearbeitung von Sprites durch Basic ist dafür nicht schnell genug, es sei denn, man hat eine Basic-Erweiterung, die Sprites direkt unterstüzt.

Drum also hier alles, was man wissen muß, um Sprites in den verschiedensten Variationen auf die heimische Mattscheibe zu bannen.

## Am Anfang ist die Idee

Wer mit Sprites arbeiten möchte, der kommt um eines nicht herum: Ein Sprite-Entwurf muß angefertigt werden. Und das bedeutet zuerst einmal, daß man kariertes Papier sowie Bunt-, Filz- oder Bleistift aus der Schublade hervorkramt. Dann malt man einen Rahmen, der genau 24 mal 21 Kästchen einschließt. Vor sich hat man nun ein sogenanntes Sprite-Entwurfsblatt liegen. Zugegeben, einige Details fehlen noch, aber zumindest können Sie damit schon einmal genau festlegen, wie Ihr Sprite später aussehen wird.

Ein vollständiges Sprite-Entwurfsblatt sehen Sie in Bild 1. Dies sollten Sie sich am besten mehrere Male fotokopieren. Für die ersten Entwürfe ist aber normales kariertes Papier empfehlenswert, weil die meistens in endlose Radiererei ausarten. Die vielen Zahlen auf dem Entwurfsblatt sollten Sie jetzt nicht verwirren: Zu deren Bedeutung kommen wir später.

Erst einmal wollen wir uns auf einfarbige Sprites beschränken. Sie können dann jedes der 504 Kästchen auf ihrem Sprite-Entwurfsblatt mit dem Stift einfärben oder auch freilassen. Jedes ausgemalte Kästchen wird später auf dem Bildschirm in der Spritefarbe zu sehen sein. Die leeren Kästchen sind später durchsichtig. Sie können also beispielsweise einen Buchstaben umrahmen, indem Sie einen Rahmen als Sprite zeichnen und dieses über den Buchstaben legen. In der Spritemitte, in der sich nur leere Kästchen befinden, ist' der Buchstabe zu sehen.

So, jetzt kommt gleich zum ersten Mal der POKE-Befehl ins Spiel. Denn die nächste Frage lautet natürlich: Wie erkläre ich meinem C 64, wie das Sprite auszusehen hat? Für den Nur-Basic-Anwender, der auch umfangreiche Programme schreiben will, gibt es da nicht viele Möglichkeiten. Dem Computer muß das Aussehen des Sprites in 63 Speicherstellen mitgeteilt werden, die an bestimmten Stellen im Arbeitsspeicher stehen müssen. Wieso gerade 63? Wir erinnern uns: Ein Punkt kann entweder eingeschaltet sein oder ausgeschaltet (durchsichtig).

In einer Speicherstelle lassen sich acht Ein-/Aus-Informationen speichern, es finden also acht Punkte eines Sprites Platz. Ein Sprite ist nun 24 Punkte breit. 24 ist 3 mal 8, also benötigen wir drei Speicherstellen, um eine Zeile eines Sprites zu definieren. Schließlich hat ein Sprite noch 21 Zeilen, so daß wir 3 mal 21, das sind 63 Speicherstellen, für die Punkte eines Sprites benötigen.

Wo liegen nun diese 63 Speicherstellen? Hier haben wir, wollen wir nicht mit Unmengen von Tricks und noch mehr POKEs arbeiten, nur vier Möglichkeiten. Diese sind in Tabelle 1 aufgeführt.

Und wie bekomme ich nun mein Sprite da rein, werden Sie jetzt vielleicht fragen? Nun, schauen wir uns nochmal das Entwurfsblatt an. Jetzt sollen die Zahlen entschlüsselt werden: Wie gesagt, es wird eine Zeilejeweils durch drei Zahlen verschlüsselt. Die drei dicken Striche geben an, welcher Zeilenbereich durch eine Zahl verschlüsselt wird.

Angenommen wir möchten in der ersten Reihe die Punkte 1, 3 und 5 setzen. Diese liegen alle in der ersten Spaltengruppe. Um den Zahlenwert zu errechnen, müssen Sie nun einfach die Zahlen addieren, die über den gesetzten Punkten stehen. In unserem Beispiel wären das die 128, die 32 und die 8. Das Ergebnis, 158, tragen Sie dann in das erste Kästchen mit der Überschrift »Zahlencodes« ein. Genauso verfahren Sie dann mit der zweiten und dritten Spaltengruppe und den weiteren 20 Zeilen. Schon haben Sie die 63 Zahlenwerte, die das Sprite codieren, ausgerechnet. Übrigens: Daß jede zweite Spaltentrennung gestrichelt gezeichnet ist, hat noch praktische Gründe, wie wir bei mehrfarbigen Sprites sehen werden.

## Ein Sprite erscheint

Jetzt besteht also unser Sprite aus 63 Zahlen. Diese können wir nun in die angeführten Speicherbereiche POKEn (Tabelle 1). |n einem Programm speichert man die 63 Zahlenwerte praktischerweise in DATAs und verwendet dann eine FOR-NEXT-Schleife, in der die Zahlenwerte in den Speicherbereich ge-POKEt werden. Jedem Speicherbereich ist dabei eine Codezahl zugeordnet, die nachher noch von entscheidender Bedeutung sein wird. Die letzten drei Bereiche werden allerdings jedesmal gelöscht, wenn Sie die Datasette benutzen.

Das war aber noch längst nicht alles. Esist noch einiges zu tun, bevor das Sprite auf dem Schirm zu sehen ist. Wir beschränken uns, bescheiden wie wir sind, auf ein einziges Sprite, das die Nummer 0 erhält.

Als erstes sollten wir dem Video-Chip mitteilen, wo wir das Sprite im Speicher plaziert haben. Dazu dient die Speicherstelle 2040. In diese Speicherstelle POKEn Sie bitte die Codezahl des Speicherbereiches.

Dann müssen Sie das Sprite noch wie eine Lampe einschalten. Dazu POKEn Sie in die Speicherstelle 53269 einfach eine 1. Nun dürfte ihr Sprite irgendwo auf dem Schirm zu sehen sein, wahrscheinlich aber nicht da, wo Sie es gern hätten. Dem kann Abhilfe geschaffen werden: In die Speicherstelle 53248 POKEn Sie die X-Koordinate, in 53249 die Y-Koordinate der gewünschten Position. In Bild 2 finden Sie dazu eine Orientierungshilfe. Sie werden sehen, daß das Koordinatensystem für die Sprites größer ist als der Bildschirm. Ein Sprite kann also hinter dem Bildschirmrand verschwinden und ist dann nicht mehr zu sehen, Obwohl es eingeschaltet ist. Eih weiteres Problem ergibt sich da: Die X-Koordinate kann laut Bild 2 bis 511 gehen. Will man aber Werte größer 255 in die Speicherstelle der X-Koordinate POKEn, erhält man einen ILLEGAL QUANTITY ERROR. Um das Sprite auch in die rechte Hälfte bewegen zu können benötigt man eine weitere Speicherstelle, 53264. Soll das Sprite auf eine Position größer als 255, dann POKEt man dort eine 1 hinein. Danach zieht man 256 von der X-Koordinate ab und POKEt das Ergebnis wieder in die Speicherstelle 53248.

Somit können wir also ein Sprite auf jede Stelle am Bildschirm und sogar über den Bildschirm hinaus positionieren.

Vielleicht gefällt ihnen die Farbe Ihres Sprites aber überhaupt nicht, vielleicht konnten Sie es bisher auch gar nicht sehen, weil es dieselbe Farbe wie der Hintergrund hatte. Nun, auch hier hilft ein POKE: Die Speicherstelle 53287 bestimmt die Farbe unseres Sprites. Dort können die 16 im Commodore-Handbuch angegebenen Farbcodes hineingeschrieben werden.

Ein Weiteres läßtsich bei Sprites kontrollieren: Die Priorität. Nehmen wir einmal an, ein Sprite und ein Buchstabe oder Grafikzeichen überschneiden sich. Dann gibt es zwei Möglichkeiten: Das Sprite ist »hinter« dem Buchstaben, wird also verdeckt, oder ist »davor«,verdeckt also den Buchstaben. Sie können einstellen, wie sich das Sprite verhalten soll: Steht in Speicherstelle 53275 eine 1, so ist das Sprite »hinten«, ist dort eine 0, ist das Sprite »vorne«.

Klein, aber fein sind diese Sprites, werden Sie jetzt wahrscheinlich sagen. Warten Sie’s ab, es geht auch größer. Ein Sprite läßt sich ».strecken« in X- und Y-Richtung. POKEn Sie mal eine 1 in 53277, und Sie verstehen, was damit gemeint ist. In die andere Richtung geht’s mit der Speicherstelle 53271. POKEt man in beide Speicherstellen eine 0, ist der Spuk vorbei, und das Sprite hat seine »normale« Größe wieder erreicht.

Ein kleines Problem, das sogar Profis ins Grübeln gebracht hat: Streckt man ein Sprite in X-Richtungund setzt es an die X-Position Null, verschwindet es nicht vom Schirm! Die rechte Hälfte ist immer noch zu sehen. Soll nun aber das Sprite einen eleganten Abgang nach links machen, ist dies natürlich absolut störend. Doch auch hier gibt es eine bestechend einfache Lösung. Stellen Sie sich das Sprite-Koordinatensystem als Zylinder vor. Wenn Sie unser gestrecktes Sprite an die Position 511 setzen, sehen Sie wiederum fast die Hälfte des Sprites am linken Bildschirmrand. Verringert man die X-Koordinate nun langsam auf 488, wird es nach links hin entschwinden, wie wir es uns wünschen. In Y-Richtung taucht dieses Problem nicht auf.

## Jetzt wird’s bunt

Bisher haben wir uns auf einfarbige Sprites beschränkt. Es geht aber auch dreifarbig! Eigentlich sind es sogar vier Farben, aber die vierte Farbe ist »durchsichtig«, und wir zählen sie deswegen nicht mit.

Bevor Siejetzt aberjubelnd die buntesten Sprites entwerfen, muß ich auf den Nachteil des »Multicolor«-Modus hinweisen: Sie haben nun nicht mehr 24, sondern nur noch 12 Punkte pro Zeile, diese sind allerdings auch doppelt so breit wie die eines tristen, einfarbigen Sprites.
Konkret bedeutet das, daß Sie schon beim Entwurf immer zwei nebeneinanderliegende Kästchen einfärben müssen, wenn Sie dort einen Punkt setzen sollen. Dabei dürfen Sie aber drei Farben benutzen. Die gestrichelten Linien in unserem Entwurfsblatt fallen also weg.

Beim Errechnen der 63 Zahlen für das Sprite geht man dann so vor: Anstelle einer 1 fürjeden gesetzten Punkt müssen Sie nun zwei Ziffern in das Sprite-Entwurfsblatt einsetzen, eine in das linke, eine in das rechte Kästchen eines Punktes. Welche Ziffern das sind, ist von der Farbe abhängig und steht in Tabelle 2. Ab dann verläuft das Ausrechnen der Zahlenwerte des Sprites genauso wie bei den einfarbigen Sprites. Allerdings kommen noch drei zusätzliche POKEs hinzu: In die Speicherstelle 53276 muß eine 1, damit der Video-Chip weiß, daß es sich jetzt um ein Multicolor-Sprite handelt. In die Speicherstelle 53285 kommt dann die Farbe 2, in die Speicherstelle 53286 die Farbe 3. Die Farbe 1 haben wir vorher schon in der Speicherstelle 53287 festgelegt. Schon schimmert uns ein schönes mehrfarbiges Sprite entgegen, das wir dann genauso wie ein einfarbiges behandeln können.

## Ein Sprite kommt selten allein

Schließlich steht ja im Commodore-Handbuch was von acht verschiedenen Sprites gleichzeitig. Also ohne viel Tricks kriegen wir nur vier_verschiedene Sprites auf den Bildschirm, denn wir können ja nur vier Sprites in die Speicherstellen aus Tabelle 1 POKEn. Dafür haben wir die Möglichkeit, ein Sprite doppelt, dreifach oder sogar achtfach gleichzeitig auf den Bildschirm zu bringen. Mit acht Sprites ist dann allerdings auch die Kapazität unseres Video-Chips erschöpft.

Wie kann man nun über die sieben zusätzlichen Sprites verfügen? Diese Sprites haben praktischerweise die Nummern 1 bis 7. Für ihre Position, Farbe und ihre Codezahl haben sie ihre eigenen Speicherstellen, die in Tabelle 3 aufgeführt sind.

Komplizierter wird es da schon bei den anderen Speicherstellen, die in Tabelle 4 aufgelistet wurden. Jede dieser Speicherstellen hat Kontrolle über alle acht Sprites. Wenn Sie genauer hinschauen, bemerken Sie, daß alle diese Speicherstellen nur An-/Aus-Funktion haben, sie sind sozusagen Schalter. Nun können aber in einer Speicherstelle, wie wir wissen, acht An-/Aus-Informationen gespeichert werden, also für jedes Sprite genau eine. Jetzt folgen zwei Routinen, deren Wirkung ich Ihnen gerne erkläre, nicht aber die Funktionsweise. Dazu müßte ich längere Vorträge über Binärarithmetik, logische Funktionen und ähnliches halten und damit den Rahmen dieses Artikels sprengen.

TODO PRE

POKE X, PEEK(X) OR 2 ↑ N

legt den Schalter in der Speicherstelle X für das Sprite N auf »An« um, ohne die anderen Schalter zu beeinflussen.

TODO PRE

POKE X, PEEK(X) AND (255 - 2 ↑ N)

stellt den entsprechenden Schalter wieder auf »Aus« um, ohne die anderen zu beinflussen.

Wichtig sind die beiden Adressen in der Tabelle 5: Sie sind uns schon bekannt, und legen die Farben 2 und 3 für **alle** Sprites verbindlich fest. Zwei Sprites im Multicolormodus, die gleichzeitig erscheinen, können sich also nur in der Farbe 1 unterscheiden.

Damit ist das Wichtigste über Sprites gesagt. In Basic sollte man sich auf stehende Sprites beschränken. Sich bewegende Sprites sind relativ langsam, wenn das Basic-Programm auch andere Funktionen nebenbei erfüllen muß.

Wer Sprites öfters benutzen will, für den lohnt es sich, die ebenfalls in diesem Heft abgedruckte Basic-Erweiterung »Sprite-Basic« abzutippen, und das soeben Gelernte dann nicht mit POKEs, sondern mit richtigen Befehlen auszuführen. Denn dann geht der Sprite-Spaß erst richtig los!

(Boris Schneider/ev)


# Hardcopy für Ihren Drucker \[115-122\]

> ... oder: von den Problemen, den Bildschirminhalt auf Papier zu bringen — und natürlich von den Lösungen dieser Probleme!

Das Problem dürfte sich jedem Benutzer des C 64 stellen, der einen Drucker hat: Auf dem Monitor oder Fernseher wird ein Bild dargestellt, doch leider ist es ganz unmöglich, dieses Bild auf dem Drucker auszugeben, denn es wird nicht der normale Bildschirm mit einer Auflösung von 25 Zeilen ä 40 Zeichen dargestellt, sondern ein Bild in hochauflösender Grafik. Wie Sie trotzdem auch mit diesem Problem fertig werden, soll im folgenden beschrieben werden.

## Aller Laster Anfang: Ihr Drucker

Schon beim Drucker stoßen wir auf schwerwiegende Probleme, denn manche Drucker sind wirklich nur sehr schwer oder gar nichtzum Drucken von Grafik zu bewegen. Folgende Kriterien sollten bei Ihrem Drucker erfüllt sein:

- der Drucker ist grafikfähig (natürlich die wichtigste Voraussetzung);
- der Drucker druckt mit mindestens acht Nadeln oder ähnlichem. Damit ist gemeint, daß der Druckkopf so konstruiert ist, daß er vertikal acht Punkte untereinander drucken kann;
- der Drucker beherrscht den sogenannten BI-Mode (Bit-Image-Mode). Das ist der Modus, in dem die hochauflösende Grafik ausgedruckt wird.

Wenn Ihr Drucker diese Voraussetzungen erfüllt, dann ist es Ihnen in jedem Fall möglich, Ihre Bildschirmgrafiken auf Papier zu bringen.

Aberauch Drucker, die keinen BI-Modus haben, sind mitunter grafikfähig. Da die Druckerpalette jedoch sehr groß ist, werden wir auf keinen speziellen Drucker eingehen, und es bleibt Ihnen letztlich überlassen, die Tauglichkeit Ihres Druckers zu überprüfen.

Auch bei Druckern der unteren Preisklasse findet man heute schon die sogenannten ESC-Sequenzen. Das sind Steuerbefehle für den Drucker, die ihn zum Beispiel dazu veranlassen, die Schriftart oder etwa den Zeilenvorschub zu verändern. Eine solche Steuersequenz erkennt der Drucker an einem speziellen Zeichencode, bei dem er nicht wie sonst üblich das empfangene Zeichen als solches ausgibt, sondern vielmehr auf weitere Zeichen wartet, die in ihrer Gesamtheit einen Steuerbefehl ergeben. Üblicherweise wird dabei als ESC-Code das Zeichen CHR$(27) an den Drucker gesendet.

## ESC — (von escape, engl. für entkommen, flüchten)

Die ESC-Sequenzen sind leider in keiner Norm vereinheitlicht. Deswegen darf normalerweise die Kompatibilität zwischen Druckern gleicher Leistungsklasse nicht ohne Einschränkungen angenommen werden.

Nach Senden von ESC an den Drucker werden immer Daten nachgeschoben, die die Grundeinstellung des Druckers ändern, so etwa den Drucker dazu veranlassen, Grafik anstatt Klartext zu drucken. Wenn Sie einmal Ihr Druckerhandbuch aufschlagen und eine der Sequenzen ESC-K, ESC-L oder ESC-Z finden, dann werden Sie (hoffentlich) feststellen, daß Sie in dem Teil des Handbuchs lesen, der Sie interessiert — der Ausgabe von Grafik.

Jetzt sind noch ein paar Berechnungen anzustellen und schon kann das Bild auf dem Drucker ausgegeben werden. Doch diese Berechnungen haben es in sich!

## Wie die Grafik im Computer steht

Der C 64 ist bekanntlich ein vielseitiger Computer. So hat er unter anderem in seinem Inneren einen kleinen Chip (6567 Video Interface Chip, kurz VIC II) eingebaut, der dafür verantwortlich ist, daß sich etwas auf Ihrem Bildschirm tut. Der VIC II ist sehr flexibel und hat vielseitige Verwendungsmöglichkeiten innerhalb des C 64; wir beschränken uns jedoch hier auf die Funktionen, die ausschließlich für die Erzeugung der Grafik verantwortlich sind.

Es können acht Grafikbildschirme vom VIC II verwaltet werden; ihre Basisadressen sind ein Vielfaches von 8192. So beginnt etwa der dritte Grafikbildschirm bei der Basisadresse 16384 (bei 0*8192 liegt der erste Grafikschirm, dieser wird aber im Regelfall nicht benutzt, da der Bereich anderweitig belegt ist, zum Beispiel durch Zero-Page und Stack.

Wenn Sie ein Bild drucken wollen, müssen Sie sich immer erst Klarheit darüber verschaffen, in welchem Bereich der Grafikbildschirm steht, den Sie ausgeben wollen. Zwar können Sie für die Berechnungen auch so lange zwischen den acht Basisadressen wechseln, bis Sie den richtigen Bildschirm erwischt haben, effektiver dürfte da aber das kleine Basic-Programm sein, das in Listing 1 dargestellt ist. Mit Hilfe dieses kurzen Programms werden die Grafikbildschirme 3 (Startadresse 16384) bis 8 (Startadresse 57344) durch ein kurzes Maschinenprogramm auf die Startadresse des zweiten Grafikschirms verschoben und dort dargestellt. Dadurch wird es Ihnen möglich, auch die Grafikbildschirme 5 und 7 yon Basic aus problemlos auszugeben, da diese Schirme normalerweise nicht erreichbar sind (sie liegen »unter« dem ROM). Weil sich dieser Artikel nur mit der Ausgabe von Grafik beschäftigt, verzichte ich an dieser Stelle auf Erläuterungen zu dem Programm, denn dabei würde zu stark auf die Besonderheiten des VIC II eingegangen werden müssen.

Nicht genug der acht Grafikschirme, verfügt der VIC II auch noch über zwei verschiedene Darstellungsarten: den sogenannten »High Resolution Mode« (HiRes, hochauflösende Grafik mit 64000 einzelnen Bildpunkten) und den »Multicolor-Mode«, in dem jeder Einzelpunkt in vier verschiedenen Farben dargestellt werden kann, bei dem aber dafür die Auflösung nur noch 32000 Bildpunkte beträgt. So mancher Anwender hat sich schon darüber gewundert, daß seine Hardcopy-Routine nur ein seltsames Strichmuster aufs Papier gebracht hat, aus dem man mit etwas Fantasie andeutungsweise das Originalbild entziffern konnte. Der Grund: im Multicolor-Modus werden in den Daten nicht nur die Bildinformation, sondern auch die Farbinformation verschlüsselt.

An dieser Stelle ein Tip: wenn Sie eine Grafik ausgeben wollen, jedoch keine Möglichkeiten haben, den Programmablauf zu unterbrechen, so können Sie durchaus einen Reset auslösen. Dabei wird das Bild normalerweise nicht gelöscht und Sie können dann fast immer von Basic aus weitere Schritte zur Ausgabe des Bildes einleiten.

## High Resolution Mode

ln Bild 1 ist zunächst einmal ein HiRes-Bild als solches dargestellt. In Bild 2 wurde über das Bild zusätzlich eine Schraffur gelegt, um die Struktur der Ablage des Bildes zu verdeutlichen. Durch das Rastermuster wird angedeutet, daß die Informationen nicht etwa Reihe für Reihe abgelegt werden, sondern in kleinen Blöcken, von denen in eine Zeile 40 passen, vertikal dagegen nur 25. Der Fachmann wird sich sofort an die Normaldarstellung von Zeichen erinnern. Tatsächlich ist diese Darstellung eng mit der normalen Zeichendarstellung verwandt.

Bild 3 zeigt eine Vergrößerung eines Blocks. Man erkennt, daß ein Block seinerseits aus einer Matrix von 8 x 8 Punkten besteht. Ergo besteht ein Block aus 64 Punkten, und wir wissen, daß 25 x 40 = 1000 dieser Blöcke auf dem Bildschirm Platz haben, wodurch also insgesamt eine Auflösung von 64000 Punkten erreicht wird. So weit, so gut. Aus Bild 3 geht aber noch weiter hervor, daß die Informationen innerhalb eines einzelnen Blocks zeilenweise abgelegt werden; ein Block setzt sich also aus 8 Bytes zusammen, die ihrerseits wieder in kleinste Informationseinheiten, die Bits, zerlegt werden können. Diese Blöcke werden bei der HiRes-Darstellung so lange aneinandergereiht, bis eine Zeile mit Blöcken (weiterhin auch als »Blockzeile« bezeichnet) gefüllt ist. Der nächste Block liegt dann naheliegenderweise unter dem ersten der vorangegangenen Zeile.

Damit es etwas anschaulicher wird, wollen wir uns an dieser Stelle mit einem kleinen Beispiel befassen.

Aus Bild 2 ist Block 27 in Zeile 13 vergrößert im Bild 4 wiedergegeben (Blockbereich 0-39, Zeilenbereich 0-24). Weiterhin wird für die Beispielrechnung angenommen, daß das Bild im Computer im Grafikschirm 2 (Basisadresse 8192) abgespeichert ist. Wenn Sie nun die Blöcke zeilenweise auszählen, werden Sie feststellen, daß der besagte Block die Nummer 547 (erster Block entspricht der Nummer 0) trägt.

Zunächst wollen wir klären, wie der Inhalt gerade dieses Blocks zu ermitteln ist. Dazö berechnen wir beispielsweise die Adresse von Byte 0 innerhalb dieses Blocks nach der Formel

TODO PRE

Byte 0 = Basisadresse+Blockzeilen*320+Blocknummer*8

Wie läßt sich die Formel erklären?

Zunächst einmal ist es verständlich, daß die Basisadresse des Grafikschirms der Positionsberechnung zugrunde liegen muß. Weiterhin faßt eine Blockzeile 40 Blöcke zu je 8 Byte; eine Blockzeile besteht also aus 320 Byte. Nun muß man sich noch innerhalb der aktuellen Zeile zu dem Block bewegen, dessen Inhalt untersucht werden soll. Hierzu multipliziert man einfach die Anzahl der Blöcke mit 8, da sich ein Blockaus 8 Byte zusammensetzt. Beachten Sie bitte bei der Berechnung, daß die Blockzeilen im Bereich 0 bis 24 liegen, die Blocknummern dagegen im Bereich 0 bis 39. So ergibt sich zum Beispiel als Startadresse für den 27. Block in der 13. Zeile:

TODO PRE

Byte 0 = 8192 + 13 * 320 + 27 * 8 = 12568

Bei dem Block in unserem Beispiel ergibt also der Basic-Befehl

TODO PRE

PRINT PEEK(12568)

den Inhalt von Byte 0 des Blocks 547. Wie groß wird nun dieser Wert sein?

Wie bereits erwähnt, besteht ein Byte aus kleinen Informationseinheiten (Bits). Das Bit kann entweder den Zustand »1« oder den Zustand »0« annehmen. Wenn Sie nun noch einmal Bild 3 betrachten, werden Sie erkennen, daß 8 solcher Bits ein Byte ergeben. Diese Bits werden mit Bit 0 bis Bit 7 von rechts nach links durchnumeriert. Da das Bit nur zwei Schaltzustände annehmen kann, wird zur Berechnung eines Bytes das Binärsystem zugrunde gelegt. Es ist
2<sup>7</sup>=128
2<sup>6</sup>= 64
2<sup>5</sup>= 32
2<sup>4</sup>= 16
2<sup>3</sup>=  8
2<sup>2</sup>=  4
2<sup>1</sup>=  2
und schließlich
2<sup>0</sup>=  1

Bereits mit diesen Vorüberlegungen läßt sich der Inhalt von Byte 0 berechnen. Wie Sie in Bild 4 sehen, ist nur Bit 5 gesetzt, also ergibt sich als Inhalt von Byte 0 der Wert 2s = 32. Diesen Wert würde auch die Abfrage »PRINT PEEK(12568)< ergeben.

Entsprechend ergeben sich zum Beispiel für Byte 2 als Inhalt

2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> = 8 + 2 + 1 = 11.

Damit lassen sich auch alle anderen Bytes eines Blocks berechnen. Das Verfahren verläuft analog zum gezeigten Beispiel. Die Inhalte aller Bytes des Beispiels sind vollständig in Bild 4 wiedergegeben.

## Der Drucker kommt ins Spiel

Zunächst muß der Drucker für die Datenausgabe vorbereitet werden. Hierfür müssen Sie sicherstellen, daß ein eventuell vorhandenes Interface keine falsche Interpretation von gesendeten Daten vornimmt. Dies geschieht im Normalfall durch Setzen einer bestimmten Sekundäradresse, bei einigen Herstellern auch als »Linearkanal« bezeichnet, weil gesendete Zeichen im Original an den Drucker weitergeleitet werden.

Ebenso muß der Zeilenvorschub korrigiert werden. Wenn man davon ausgeht, daß acht Punktreihen untereinander in einem Arbeitsgang gedruckt werden können, so ist der Zeilenvorschub so einzustellen, daß die nächste gedruckte Zeile sich nahtlos an die vorhergehende Zeile anschließt. Dazu ist der Zeilenvorschub im Regelfalle auf 24/216 Zoll zu stellen.

Damit sind die besonderen Voreinstellungen, die sowohl für den HiRes- als auch den Multicolor-Modus Gültigkeit besitzen, vorgenommen. Weitere Operationen beziehen sich nun auf den jeweiligen Modus, von dem ausgegangen wird.

Kommen wir schließlich zu dem schon anfangs erwähnten ESC-K und ESC-L. Mit diesen Sequenzen wird der BI-Mode eingeschaltet. Doch das reine Einschalten genügt nicht; man muß auch noch spezifizieren, wieviele Daten zum Drucker gesendet werden.

Schauen wir uns zunächst an, wie Grafik auf dem Drucker ausgegeben wird. Als Beispiel nehmen wir wieder Bezug auf Bild 4. Im ersteh Teil haben wir überlegt, wie ein Block innerhalb des Computers abgelegt wird: ein Block besteht aus 8 Bytes, die horizontal untereinander stehen.

Beim Drucker ist das nicht üblich. Da der Druckkopf im allgemeinen nur aus einer Reihe von vertikal untereinander liegenden Dots (Nadeln) besteht, werden die Daten vertikal aufbereitet erwartet. Wird deshalb im Grafikmodus des Druckers ein Byte gesendet, so werden maximal 8 Punkte vertikal untereinander gedruckt. Wir können vom Computer her jedoch immer nur horizontale Punktreihen per PEEK abfragen. Was benötigt wird, ist eine Routine, die jeweils einen Block aus 8 x 8 Punkten entsprechend umrechnet. Bei unserem Beispiel muß der Block aus Bild 4 entsprechend Bild 5 umgerechnet werden. Bei der Berechnung gehen wir in diesem Fall von der Tatsache aus, daß das höchstwertige Bit der Druckerkopfdots innerhalb der Druckkopfmatrix oben liegt. In Ihrem Handbuch kann aber auch nachzulesen sein, daß das höchstwertige Bit in der Druckmatrix nach unten weist. In diesem Fall würden sich die berechneten Werte gemäß Bild 6 ändern. Wie Sie sehen, ist es durchaus wichtig zu wissen, wie die Dotmatrix Ihres Druckers aufgebaut ist.

Wir gehen davon aus, daß der zuerst beschriebene Fall zutrifft. Wie man relativ einfach die Matrix yon Basic aus umrechnen kann, wird durch das Basic-Progfamm in Listing 2 illustriert. Mit diesem kleinen Programm können Sie jede beliebige Matrix umrechnen lassen. Dazu geben Sie nur die Startadresse Ihres Grafikschirms, die Zeile, in der sich der Block befindet und schließlich die Nummer des Blocks ähnlich wie oben in der Formel erwähnt an. Der Inhalt des betreffenden Blockswird in dem Basic-Programm in Listing 2 in den Zeilen 190 bis 210 in das Feld BYTEeingelesen. Nun müssen die Daten gewandelt werden. Dazu folgende Überlegungen:

Um das erste Bit links oben des ersten vertikalen Bytes zu erhalten, muß von Byte 0 Bit 7 betrachtet werden (siehe Bild 4). Wenn es gesetzt ist, so wird es mit 27 = 128 multipliziert; man erhält so einen ersten Wert. Dann wird von Byte 1 Bit 7 betrachtet und untersucht, ob das Bit gesetzt ist. Falls dies der Fall ist, wird es mit 2e = 64 multipliziert und zum ersten von Byte 2 bis 7 das 7. Bit untersucht und schließlich mit einer absteigenden Potenz von 2 multipliziert und zum jeweils schon erhaltenen Wert (im Listing 2 die Variable OUTPUT) hinzuaddiert. Hat man auf diese Art und Weise das erste vertikale Byte erhalten, kann selbiges an einen Drucker gesendet werden, denn jetzt ist die gewünschte Umwandlung vorgenommen worden, wovon Sie sich durch Nachrechnen überzeugen können.

Da der Block aber aus 8 Bytes besteht, wird dann mit der Aufbereitung des 2. vertikalen Bytes fortgefahren, also Bit 6 von Byte 0 untersucht. Ist es gesetzt, so muß es wieder mit 27 multipliziert werden, damit es an die korrekte Stelle innerhalb der Dotmatrix rutscht. Wieder erhält man einen ersten Zwischenwert. Dann wird Byte 1 auf Bit 6 hin untersucht. Ist es gesetzt, dann wird es mit 26 multipliziert, um dieses Bit an die korrekte Stelle der Dotmatrix des Druckers zu bringen. Nach diesem Verfahren wird fortgefahren, bis auch das letzte vertikale Byte berechnet worden ist.

Wenn Sie das Programm also starten und die Adresse eines Blocks eingeben, so erhalten Sie acht Werte, die jeweils (vergleiche hierzu nochmals den Zusammenhang zwischen den Bildern 4 und 5) die umgerechneten Werte wiedergeben.

Um die Effektivität und Berechnungszeit zu kürzen, wurde die Umrechnung in einen sehr kompakten Ausdruck eingebunden, über den Sie nicht gleich verzweifeln sollten (Zeile 240). Der Ausdruck kann nur verstanden werden, wenn Sie sich schon mal mit der »And/Or-Boolean-Wüste« des Computers beschäftigt haben, und ich möchte deswegen auch hier auf tiefergehende Erklärungen des Ausdrucks verzichten. Wenn Sie sich trotzdem für die Thematik interessieren, so empfehle ich Ihnen die im 64’er, Ausgabe 7/85 gestartete Serie »Logeleien«. Wichtig ist hier aber nur, daß Sie nachvollziehen können, wie die Umrechnung im Prinzip funktioniert.

## Block an Block — Reihe an Reihe — fertig ist das HiRes-Bild

Da nun ein Programm erstellt ist, das einzelne Blöcke gemäß unseren Anforderungen aufbereitet, sind wir fast an unserem Ziel angelangt. Die Drucker, bei denen es nicht möglich ist, mehr als einen Block auf einmal zu senden, haben praktisch damit das endgültige Programm, mit dem der Druck von Grafik möglich gemacht wird. Besser dran sind da schon die Besitzer von Druckern, die es erlauben, Grafik zeilenweise auszugeben. Was jetzt nur noch fehlt, sind Schleifen, die die Blöcke hintereinander berechnen und eine korrekte Aufbereitung vornehmen.

Doch bevor die eigentliche Ausgabe beginnt: der Drucker muß bereit sein! Haben Sie also den Zeilenvorschub korrigiert?

Nun, dann dürfte Ihr Programm dem Struktogramm in Bild 7 entsprechen.

Das Struktogramm enthält einen Punkt, über den man sich noch Klarheit verschaffen sollte:

»Sende Code zur Einschaltung von HiRes«.

Hier stellt sich die Frage, was man dem Drucker mitteilen soll. Da die Daten einer Blockzeile hintereinandergereiht auch einer Blockreihe auf dem Drucker entsprechen sollen, wird deutlich, was dem Drucker mitgeteilt werden muß:

- BI-Mode einschalten, dabei geeignete Punktdichte wählen
- Anzahl der Daten definieren

Da 40 Blöcke zu je 8 Byte gesendet werden sollen, muß dem Drucker mitgeteilt werden, daß 320 Zeichendaten folgen. Üblicherweise wird dazu zur Einschaltung des BI-Mode ESC-L beziehungsweise ESC-K verwendet. Da die Vorgehensweise bei beiden Steuerbefehlen gleich ist und sie sich nur bezüglich Ihrer Punktdichten unterscheiden, betrachten wir nur ESC-L. Sie werden in Ihrem Druckerhandbuch finden, daß nach dem Einschalten von ESC-L noch definiert werden muß, wieviele Zeichendaten gesendet werden, bevor der Drucker wieder in seinen normalen Modus zurückschaltet. Würde nämlich keine solche Definition vorhanden sein, so würde der Druckerjedes gesendete Byte nach Einschaltung des BI-Mode als Grafikzeichen interpretieren und dann wäre zum Beispiel ein kontrollierter Zeilenvorschub unmöglich zu realisieren. Da Sie inzwischen wissen, daß sich eine Blockzeile im Computer und deshalb entsprechend auch später aufdem Druckeraus 320 Byteszusammensetzt, müssen Sie vor der eigentlichen Ausgabe der Blockzeile dem Drucker die nachfolgende Anzahl von Zeichendaten mitteilen. Dazu werden üblicherweise zwei Zahlen n1 und n2 nach den Formeln

TODO PRE

n1 = Zahl der Daten - INT(Zahl der Daten/256) * 256

und

TODO PRE

n2 = INT(Zahl der Daten/256)

berechnet. In unserem Beispiel wären also n1 = 64 und n2 = 1. An den Drucker würde man also eine Steuersequenz senden, die folgendermaßen aussieht:

TODO PRE

CHR$(27);"K";CHR$(64);CHR$(1);

Danach ist dann der Drucker im BI-Mode und erwartet 320 Zeichendaten, um dann wieder auf Normalbetrieb zurückzuschalten.

Das entsprechende Basic-Programm für die Ausgabe eines ganzen Grafikschirms im HiRes-Modus ist in Listing 3 dargestellt. Beachten Sie aber Ihre druckerspezifischen Einschränkungen, bevor Sie das Programm ausprobieren. Überprüfen Sie bitte, wie bei Ihrem Drucker die einzelnen Funktionen angesprochen werden. Hilfestellung sollten Ihnen dabei das Struktogramm aus Bild 7 und das eigentliche Basic-Programm mit den reichlich eingefügten REM-Statements in Listing 3 bieten. Wenn Sie das Listing 2 mit Listing 3 vergleichen, werden Sie weiterhin feststellen, daß der Algorithmus zur Umrechnung eines Blocks übernommen wurde. Mit diesen Abschlußbemerkungen wenden wir uns jetzt dem zweiten Problem zu: dem Druck von Grafik im zweiten Grafikmodus.

## Der zweite Akt: Multicolor-Modus

Der Multicolor-Modus unterscheidet sich erheblich vom HiRes-Modus. Das liegt daran, daß mehrere Farben verwendet werden dürfen. Dabei werden immer zwei hintereinanderliegende Punkte zu einer Informationseinheit zusammengefaßt, aus der sich ableiten läßt, ob ein Punkt gesetzt ist, und wenn, in welcher Farbe. Dargestellt werden können in dieser Betriebsart des VIC II nur noch 32000 Bildpunkte.

Ein Punktpaar kann folgende Schaltzustände annehmen (1 = Bit gesetzt, 0 = Bit gelöscht):

00 Punkt nicht gesetzt, wird in Hintergrundfarbe dargestellt

01 Punkt gesetzt, Darstellung in Farbe 1

10 Punkt gesetzt, Darstellung in Farbe 2

11 Punkt gesetzt, Darstellung in Farbe 3

Wie man sich leicht selbst überlegt, muß eine Hardcopy einer Grafik dieses Modus also nicht nur zwischen gesetzten und nicht gesetzten Punkten differenzieren, sondern auch noch zusätzlich die Farbinformation weitergeben.

## Drei Farben auf dem Papier — ist das möglich?

Mit einem normalen Drucker wird es selbstverständlich nicht möglich sein, Farben darzustellen. Der Drucker ist nur in der Lage, schwarze Farbe auf das Papier zu bringen. Es drängt sich hier der Vergleich mit einem Schwarzweiß-Fernsehgerät auf. Dort werden die unterschiedlichen Farben durch entsprechende Grauschattierungen wiedergegeben, die aus Mischprodukten von Weiß und Schwarz entstehen. 

Das gleiche Prinzip läßt sich auch auf dem Drucker verwirklichen. Dabei wählt man unterschiedliche Punktdichten, um so den Eindruck zu vermitteln, daß das Bild aus unterschiedlichen Farben besteht. Für uns reicht es wegen der maximal vier darstellbaren Farben aus, anzunehmen, daß die Farben Weiß (Hintergrundfarbe), Schwarz, und zwei Graustufen bereits das ganze Bild darstellen können. Bild 8 zeigt verschiedene Rastermuster.

## So steht ein Multicolor-Bild im Speicher

Wieder wird über die Grafik ein Raster gelegt, welches das ganze Bild in einzelne Blöcke aufteilt. Eine Blockreihe besteht ebenfalls wieder aus 40 Blöcken. Ein Block ist in Bild 9 vergrößert. Zu erkennen ist die Struktur der Bitpaare, so daß im Prinzip eine Matrix vorliegt, mit der 4 Punkte in X-Richtung und 8 Punkte in Y-Richtung dargestellt werden können. Sie erhalten also eine 4 x 8-Matrix, die dann allerdings auch Informationen zur Farbe der einzelnen Punkte enthält. Zu finden ist nun ein Weg, der wieder Blöcke auswertet und zusätzlich noch Farbinformationen in Form eines Rastermusters mitliefert.

Wie kann man nun die Informationen, die der Block beinhaltet, verarbeiten?

Betrachten Sie zum Beispiel das fünfte Byte des Blocks in Bild 4. In Multicolor-Darstellung setzt sich das Byte aus 4 Bitpaaren zusammen, von denen das erste (Bitpaar 00) mit der Farbe des Hintergrundes, das zweite (Bitpaar 11) in Farbe 3, das dritte wieder in der Hintergrundfarbe und das vierte (Bitpaar 10) in Farbe 2 dargestellt werden würde. Ein Programm muß nun dem Inhalt eines Bitpaares verschiedene Punktdichten zuordnen, die dann als Graustufen auf dem Papier wiedergegeben werden.

## Graustufen mit dem Drucker

Wenn davon ausgegangen wird, daß jedes Byte eines Blocks getrennt für sich ausgewertet wird, stellt sich einerseits der Sachverhalt relativ einfach dar, andererseits muß aber mit entsprechender Berechnungszeit kalkuliert werden.

Um ein gutes, kontrastreiches Bild entstehen zu lassen, muß die Punktdichte möglichst groß gewählt werden. Grafikfähige Drucker bieten hierzu meist einen BI-Mode »vierfache Dichte« an, mit dem eine genügend hohe Auflösung erzielt werden kann. Um das Bild nun möglichst im Maßstab 1:1 auf j dem Drucker auszugeben, muß ein gesetzter Punkt auf dem Drucker durch ein kleines Quadrat wiedergegeben werden. Indem innerhalb eines solchen einzelnen Quadrates unterschiedliche Punkte gesetzt werden, erhält man unterschiedliche Grauwerte. Betrachten Sie hierzu einmal das Programm in Listing 4. Ähnlich wie im Fall einer HiRes-Grafik beschäftigen wir uns mit der Umwandlung eines einzelnen Blocks. Die Bestimmungsformeln zur Positionsbestimmung eines Blocks sind identisch mit denen zur Positionsbestimmung eines HiRes-Blocks, die Auswertung dagegen erfolgt anders. Die Rastermuster in den Zeilen 160 bis 190 erzeugen bei der gewählten vierfachen Punktdichte bei Ausgabe auf dem Drucker jeweils ein kleines Quadrat, das einen gesetzten Punkt in entsprechendem Grauwert wiedergibt (weiß wird hier auch mit einem Grauwert identifiziert). Diese Rastermuster werden zu Beginn des Programms in ein Feld DRUCKMATRIX eingelesen. Danach wird wie üblich definiert, welcher Block des Grafikbildschirms ausgegeben werden soll.

Während bei einer HiRes-Grafik die vertikalen Werte eines Blocks auf dem Bildschirm ausgegeben wurden, wird hier dagegen direkt der Drucker angesprochen, um das Prinzip der Umwandlung der Bitpaare in Rastermuster zu verdeutlichen. Da die Informationen innerhalb eines Blocks byteweise verarbeitet werden und da natürlich nach dem ersten berechneten Rastermuster für Byte 0 das zweite Rastermuster direkt unter dem ersten liegt, muß zusätzlich der Zeilenvorschub entsprechend korrigiert werden. Dazu wird der Zeilenvorschub auf zirka 6/216 Zoll gesetzt (siehe Zeile 270). Da weiterhin ein Byte des betrachteten Blocks aus vier Bitpaaren besteht, müssen selbstverständlich auch vier Rastermuster nebeneinander auf dem Drucker erzeugt werden.

## Das Bit-Rastermuster

Weil das Rastermuster eines Bits aber schon aus acht Daten (siehe DATA-Zeilen) zusammengesetzt wird, werden also 32 Daten pro Byte an den Drucker gesendet. Daher erklärt sich die Sequenz CHR$(32);CHR$(0) in Zeile 300, durch die der BI-Mode eingeschaltet wird und 32 Daten als reine Grafikdaten vom Drucker erwartet werden. Dann wird in den Zeilen 330 der Inhalt eines Bytes eines Blocks ermittelt und daraufhin in den Zeilen 340 bis 380 in seine Bitpaare zerlegt.

Entsprechend dieser Zerlegung erhält die Variable RASTER einen Wert zwischen null und drei (wegen logischer Verknüpfungsoperationen). Durch die so zustande kommenden 1nhalte der Variable RASTER kann an den Drucker die passende Druckmatrix gesendet werden. Mit Byte 1 bis 7 des gleichen Blocks wird genauso verfahren. Sie erhalten dadurch auf dem Drucker ein Rastermuster, dessen Aussehen von den Eingangsdaten abhängt.

## Der nächste Schritt: Ausgabe eines Multicolor-Bildes

Ein Block besteht aus 8 untereinanderliegenden Bytes. Von diesen Blöcken stehen in einer Zeile 40 und ergeben so eine Blockreihe. Wenn wir nach dem oben beschriebenen Prinzip weiter vorgehen wollen, dann muß zunächst Byte 0 von Block 1 berechnet werden. Daraufhin darf man jedoch nicht das zweite Byte des Blocks auswerten, sondern muß Byte 0 des Blocks 2 berechnen, da die nächste Information neben dem Byte 0 des Blocks 1 liegt. Man fährt nach diesem Auswertungsprinzip fort, bis Byte 0 des Blocks 40 einer Blockreihe berechnet ist und führt erst dann einen Zeilenvorschub aus, der aber so bemessen sein muß, daß die folgenden Punkte direkt an die vorhergehenden anschließen.

Genauso wird jeweils Byte 1 bis 7 für alle Blöcke einer Reihe ausgewertet und daraufhin mit der nächsten Blockzeile fortgefahren. Es ergibt sich ein Algorithmus, der vollständig durch das Struktogramm in Bild 10 beschrieben wird. Dieses Struktogramm wurde in Listing 5 in ein Basic-Programm umgesetzt. Wieder werden Sie in wesentlichen Teilen die Übereinstimmungen zum Programm zur Berechnung eines Blocks im Multicolor-Modus erkennen.

Als Ergebnis Ihrer Bemühungen dürften Sie eine Hardcopy Ihres im Computer befindlichen Bildes erhalten, das etwa so wie das Beispiel in Bild 1 aussieht.

## Auf ein Wort: Basic

Nun kennen Sie zwar die Geheimnisse, die es Ihnen ermöglichen, selbst hochauflösende Grafiken auf dem Drucker auszugeben, aber spätestens wenn Sie eines der beiden Programme aus Listing 3 oder 4 eintippen und anschließend starten, wird Ihre Freude gedämpft sein, denn der Computer macht seinem Namen alle Ehre: er rechnet. Die Berechnungen nehmen aber so viel Zeit in Anspruch, daß man mitunter die Geduld verliert. Was hier also wünschenswert erscheint, ist eine Programmiersprache, die die ganze Sache etwas beschleunigt. Das naheliegendste: Benutzung von Maschinensprache. Dadurch verkürzt sich zum Beispiel die Ausgabe einer HiRes-Grafik auf 30 Sekunden (etwa durch das in der 64’er-Ausgabe 8/84 auf Seite 83 veröffentlichte Listing). Das werden Sie zu schätzen wissen, wenn Sie einmal das entsprechende Basic-Programm haben laufen lassen und dann die Maschinenroutine dagegenhalten.

Wenn Sie also Maschinensprache beherrschen und nun das Prinzip der Grafikausgabe auf dem Drucker verstehen, empfehle ich Ihnen, eine Ihren Erfordernissen angepaßte Maschinenroutine zu schreiben, um Grafik auf dem Drucker auszugeben.

Deshalb gebe ich hier dem interessierten Maschinenspracheprogrammierer Informationen über eine möglichst einfache Ansteuerung des Druckers. Dazu zunächst eine Liste aller verwendbaren Systemroutinen und Zero-Page-Adressen:

TODO TABLE

BSOUT	$FFD2	Ausgabe eines Bytes auf aktivem Kanal
OPEN	$FFCO	Eröffnen eines Files auf dem Drucker
CKOUT	$FFC9	Ausgabe auf definiertem Kanal einleiten
CLRCH	$FFCC	Ausgabe wieder auf Standard zurücksetzen
CLOSE	$FFC3	Schließen eines Files auf dem Drucker
SETPAR	$FFBA	Setzen der Parameter für OPEN
LAENGE	$B7	für die Länge eines Strings bei OPEN

Bevor Sie ein File auf dem Drucker eröffnen, ist dem Computer erst mitzuteilen, welche Filenummer, welche Primäradresse und welche Sekundäradresse für das zu öffnende File zu verwenden sind. Da insbesondere beim Öffnen keine Zeichenkette an den Drucker zu senden ist, muß zunächst einmal das Flag LAENGE auf Null gesetzt werden:

TODO PRE

LDA #0
STA LAENGE

Daraufhin wird in den Akku die Filenummer, in das X--Register die Primäradresse des Druckers (normalerweise 4) und in das Y-Register die Sekundäradresse eines Files geladen, das dann später durch OPEN eröffnet wird. Zuerst müssen aber mit der Systemroutine SETPAR die Werte für einen OPEN-Befehl gesetzt werden, bevor die OPEN-Routine angesprungen werden darf.

TODO PRE

LDA #Filenummer
LDX #Primäradresse
LDY #Sekundäradresse
JSR SETPAR
JSR OPEN

Damit ist ein Kanal für die Ausgabe auf dem Drucker definiert. Die eigentliche Ausgabe auf dem Drucker wird durch das nochmalige Laden der Filenummer in das X-Register und das Anspringen der Systemroutine CHKOUT eingeleitet.

TODO PRE

LDX #Filenummer
JSR CHKOUT

Danach kann man Zeichen, die im Akku stehen, mittels der Routine BSOUT auf dem Drucker ausgeben.

TODO PRE

LDA #auszugebendes Zeichen
JSR BSOUT

Durch diese Routine wird die Ausgabe, die mittels der Routine BSOUT normalerweise auf dem Bildschirm erfolgen würde, auf den Drucker umgeleitet. Das heißt unter anderem, daß dann während dieser Umleitung keine Zeichenausgabe auf dem Bildschirm vorgenommen werden kann. Wollen Sie die Umleitung wieder aufheben, so können Sie dies mit Hilfe von CLRCH erreichen:

TODO PRE

JSR CLRCH

Diese Systemroutine setzt die Ausgabe auf den Bildschirm (und die Eingabe auf die Tastatur) zurück. Beachten Sie bitte, daß das Druckerfile noch nicht geschlossen ist und Sie jederzeit wieder mit der beschriebenen Syntax bei der Systemroutine CHKOUT die Ausgabe erneut umleiten können.

Das Druckerfile schließen können Sie mit der Routine CLOSE. Dazu laden Sie die Filenummer in den Akku:

TODO PRE

LDA #Filenummer
JSR CLOSE

Danach ist das Drucker-File ordnungsgemäß geschlossen. So, damit hätten wir unsere umfangreiche Expedition in das Gebiet der Grafikumsetzung für Druckausgaben abgeschlossen. Ich hoffe, daß Sie Ihnen ein wenig Spaß gemacht und Ihr Interesse an der Problematik geweckt hat. Ich wünsche Ihnen jedenfalls viel Erfolg bei der Programmierung einer eigenen Grafikroutine, sei es nun in Basic oder einer anderen Programmiersprache.

(Frank Lonczewski/ev)

# Funktionen auf Tastendruck \[123-125\]

> Mit diesem Beitrag zeigen wir Ihnen, wie auf Tastendruck beliebige Funktionen oder Programme auch während eines Programmlaufs gestartet werden können. Egal ob es sich nun um ein Basic- oder Maschinenprogramm handelt.

Dieser Artikel soll Ihnen das Thema »Funktionen« anhand eines Beispiels näherbringen. Das Beispielprogramm können Sie mit etwas Assemblerkenntnis auch für Ihre Programme verwenden. Vorschlag: Der F1-Taste wird eine Funktion zugeordnet. Durch Drücken der F1-Taste soll jederzeit das Directory einer Diskette am Bildschirm gezeigt werden, ohne daß ein im Speicher vorhandenes Programm gelöscht wird. Während das Directory geladen wird, soll der Bildschirmrahmen die Farbe des Hintergrundes annehmen.

Es wurden schon viele solcher Utilities veröffentlicht. Diese Programme werden aber im Regelfall durch Drücken der STOP/RESTORE-Tasten wieder abgeschaltet. Sollen diese Routinen dagegen gewappnet sein, so versagen sie spätestens nach einem Reset. Im Gegensatz zu diesen »Billigmethoden« soll aber unsere Directory-Funktion der F1-Taste auch nach einem Reset erhalten bleiben.

Um derartige Anforderungen zu realisieren, müssen einige Betriebssystemroutinen zumindest angeschnitten werden. Die Wichtigste ist die Interruptroutine des C 64. Die Interruptroutine ist ein computerinternes Programm, das sehr oft angesprochen wird. Befindet sich der Computer im »Ready«-Modus, wird die Interruptroutine beispielsweise alle 1/60 Sekunde durchlaufen. Wird der C 64 in Anspruch genommen, etwa durch Diskettenoperationen, wird dieses Programm jedoch seltener bearbeitet. Der Interrupt erfüllt viele Aufgaben. Er stellt beispielsweise die Uhrzeit (TI,TI$) nach, läßt den Cursor blinken und übernimmt die Tastaturabfrage. Das Interruptprogramm befindet sich ab Adresse $EA31 im Betriebssystem. Der Computer sucht sich diese Adresse über einen Wegweiser. Dieser Wegweiser steht bei Adresse $0314 und $0315 in der Zero-Page. Ein solcher Wegweiser wird im Fachjargon als Vektor bezeichnet. Da sich der Vektor im RAM befindet, kann dieser verändert werden. Das heißt, daß der Interrupt »umgeleitet« werden kann. Doch davon später.

## Wie funktioniert eine Modulerkennung?

Eine zweite gewichtige Betriebsroutine ist die Modulerkennung. Diese benötigt man, damit die geplante Funktion der F1-Taste »resetfest« wird und zugleich immun gegen die Tastenkombination STOP/RESTORE. Die Kennungs-Routine überprüft, ob sich ein Steckmodul im Expansion-Port befindet. Und zwar an der Codefolge »cbm80« ab Adresse $8004. Diese ASCII-Codefolge entspricht den Hex-Zahlen $C3,$C2,$CD,$38 und $30. Findet der Computer diese fünf Zahlen ab Adresse $8004, werden sowohl bei einem Reset als auch beim Drücken der Restore-Taste nicht mehr die Standardroutinen angesprochen. Der C 64 springt die Adressen an, deren Vektoren in $8000/8001 und $8002/8003 stehen. Der erste Vektor ist der Resetvektor. Der Resetvektor zeigt auf die Adresse, die nach einem Reset angesprungen wird. Nach STOP/RESTORE holt sich der C 64 die Sprungadresse des NMI-Vektors aus den Speicherzellen $8002 und 8003. Ist kein Modul eingesteckt, ist der Adreßbereich ab $8000 als RAM freigegeben. Wenn man nun ab Adresse $8004 die oben genannte Codefolge ablegt, nimmt der C 64 an, daß sich ein Modul im Expansion-Port befindet. Durch diesen Trick kann der Reset- und NMI-(RESTORE-) Vektor verändert werden.

Da unser Programm wegen dieses Tricks mitten im Basic-Speicher steht, muß es vor dem Überschreiben durch lange Basic-Programme oder Stringvariablen gesichert werden. Dies erreicht man, wenn man den Zeiger für den Stringspeicher $33-$34 und den Zeiger für die Speichergrenze auf $8000 setzt.

Doch nun zum Programm selbst. Nach dem Eingeben des Programmes mit Hilfe des MSE kann es mit SYS 32819 oder mit einem Reset (SYS 64738) initialisiert werden. Dabei wird der Interrupt auf die Adresse $8046 umgeleitet und das Programm vor dem Überschreiben geschützt. Solange der Interruptvektor verändert wird, muß der Interrupt gesperrt werden. Das heißt, daß während dieser Zeit die Interruptroutine nicht angesprungen werden darf. Ein Interrupt muß auch verhindert werden, wenn gerade ein Interruptprogramm stattfindet. Die Katze soll sich schließlich nicht in den eigenen Schwanz beißen. Um einen Interrupt zu sperren, gibt es einen speziellen Assemblerbefehl, den SEI (Set Interrupt Flag). Ist das IRQ-Flag (IRQ, Interrupt Request) gesetzt, läßt sich der 6502-Prozessor nicht mehr durch einen Interrupt unterbrechen, um ein anderes Programm auszuführen. Um den Interruptvektor auf unser Beispielprogramm zu richten, muß in Speicherzelle $0314 das Lowbyte ($46) und in $0315 das Highbyte ($80) unserer Programmadresse ($8046) geschrieben werden. Danach kann das Interruptflag wieder gelöscht werden. Der Assemblerbefehl dazu lautet CLI (Clear Interrupt Flag). Wird nun ein Interrupt ausgelöst (von den CIAs), springt der Prozessor zur Adresse $8046. In unserem Beispiel setzt dort die Abfrage der F1-Taste ein. Ist sie gedrückt oder nicht? Eine Antwort darauf liefert die Adresse $CB in der Zero-Page. Denn der Inhalt von $CB gibt Auskunft darüber, welche Taste zuletzt gedrückt wurde. War es die F1-Taste, steht dort eine »4«.

Den Code einer jeden Taste können Sie mit der folgenden Basic-Anweisung leicht ermitteln:
FOR 1=1 TO 10000 : PRINT PEEK(203) : NEXT I

Drücken Sie danach die gewünschte Taste, erscheint die zugehörige Zahl am Bildschirm.

Das Beispielprogramm reagiert nun folgendermaßen: Ist dieF1-TaSte nicht gedrückt, also der Inhalt der Speicherzelle ungleich 4, wird in Speicherzelle $8009 der Wert $FF geschrieben und die Adresse $EA31 angesprungen. Wie schon erwähnt, steht ab $EA31 die normale IRQ-Routine des C 64. Warum in Speicherzelle $FF geschrieben wird, soll später erklärt werden.

Wurde die F1-Taste gedrückt, wird das Beispielprogramm bearbeitet. Dabei verändert der Bildschirm seine Rahmenfarbe und das Unterprogramm »Directory« ab Adresse $8074 wird abgearbeitet. Ab Adresse $8074 kann jedes beliebige Unterprogramm stehen. Voraussetzung ist nur, daß dieses mit RTS abgeschlossen wird. In diesem Beispiel ist es eben das Zeigen eines Diskettendirectories.

Stellen Sie sich jetzt vor, es würde kein Directory gelesen, sondern irgendeine Funktion aufgerufen, die einen sehr kleinen Zeitbedarf hat. Eventuell eine Einstellung von Bildschirmfarben, wo verfügbare Farben durch Drücken der F1-Taste gezeigt werden. Alle 1/60 Sekunde würde dann die Farbe wechseln. Unmöglich! Deshalb ist in die Tastenabfrage noch ein Trick eingebaut, der das verhindert. Dazu wird nach dem Drücken von F1 ein Flag gesetzt (Speicherzelle $8009 auf $00) und erst dann die Funktion aufgerufen. Ist beim nächsten Interrupt $8009 immer noch »0«, so heißt das, daß die F1-Taste in der Zwischenzeit noch nicht losgelassen wurde. Die Funktion soll dann nicht nochmal ausgeführt, sondern mit der originalen IRQ-Routine fortgefahren werden.

Wäre die F1-Taste in der Zwischenzeit losgelassen worden, hätte in der Speicherzelle $CB eine Änderung stattgefunden. Unsere IRQ-Routine hätte das erkannt und in $8009 den Hex-Wert $FF geschrieben.

Damit die Funktions-Belegung derF1-Taste nicht durch einen Reset zerstört werden kann, wurde das Prinzip der Modulerkennung genutzt. Der Resetvektor zeigt auf die Adresse $800A. Ab dieser Adresse wurde einfach der Anfang des Originalresets nachgebildet. Nachdem der Arbeitsspeicher neu initialisiert und alle Vektoren (auch Interruptvektor) mit ihren Standardwerten belegt wurden, springt »unser« Reset nach $8033 und initialisiert wieder die F1-Taste. Anschließend wird der Prozessor wieder auf seinen gewohnten Weg geschickt ($FCFB).

## Unempfindlich gegen Reset

Der NMI-Vektor wurde auf die Adresse $801F »verbogen«. Ab dieser Adresse ist der Original-NMI nachgebaut Bis auf den Sprung an die Adresse $FD15, der weggelassen wurde. Dort wird nämlich die Interruptadresse korrigiert und die F1-Taste abgeschaltet, was die ganzen Anstrengungen zunichte machen würde.

Das Beispielprogramm kann natürlich beliebig erweitert oder geändert werden. Es wäre zum Beispiel möglich, die Buchstabentasten über die CTRL-Taste mit einer vierten Funktion zu belegen. Ähnlich SHIFT/CBM. Ein anderer Einsatz wäre der Aufruf einer Hardcopy. Versuchen Sie einfach mal, eine Hardcopyroutine über ????? aufzurufen, statt die Directory-Funktion. Sie müssen dazu nur den JSR $8074-Befehl ab Adresse $806A so ändern, daß die von Ihnen gewählte Routine abgearbeitet wird. Der Befehl lautet dann vielleicht JSR $C000. Haben Sie keine Angst vor Maschinensprache! Experimentieren Sie doch einfach mit diesem Programm. Eine einfache Übung: Stellen Sie mit der F1-Taste die Farben ein.

(Christian Quirin Spitzner/hm)

# Star SG-10 und Textomat \[125\]

> Haben Sie Probleme, den Star SG-10 mit Secus-Interface an Textomat anzupassen? Verzweifeln Sie nicht, hier kommt die Lösung.

Der erste und wichtigste Schritt ist die Eingabe folgender Basic-Kommandos:

OPEN 4,4,25 <Return>

PRINT#4

Die dabei verwendete Sekundäradresse »25« teilt dem Drucker mit, daß er den vollen Star-Zeichensatz fest einstellen soll. Die PRINT-Anweisung muß gegeben werden, damit der Drucker den Lock-Zustand ausführt. Um diesen Status wieder aufzuheben, muß der Drucker ausgeschaltet werden.

Als Zweites laden Sie Textomat wie gewohnt und nehmen im Menü-Punkt »Druckeranpassung« die entsprechenden Änderungen vor.

Beim Punkt »Drucker« wählen Sie die »1«. Die ASCII-Werte entnehmen Sie dem Interface-Handbuch auf Seite 14 oder dem Star-Handbuch auf den Seiten 217 bis 223. Für den Bereich »Steuerzeichen« empfehle ich folgende Befehlssequenzen:

TODO TABLE

Zeichenabstand: di10 1b4201 (Pica)
di12 1b4202 (Elite)
di15 1 b4203 (entspricht 17 Zeichen/ inch = Schmalschrift)
Zeilenabstand:	ab1 1b4106 (1zeiliger Abstand)
ab2 1b410c (2zeiliger Abstand)
ab3 1b4118 (3zeiliger Abstand)

Die anderen Steuerzeichen können Sie leicht selbst einsetzen, wobei Sie den Seitenwechsel nicht mit dem Wert 0c belegen sollten, da der Drucker dann immer zwei Seiten vorschiebt.

Sie sollten auch noch beachten, daß die DIP-Schalter am Drucker richtig eingestellt sind. Im Interface-Handbuch steht zwar, daß die Schalter 2-2,2-3 und 2-4 auf OFF-Stellung sein sollen, ich habe aber die Erfahrung gemacht, sie besser in ON-Stellung zu lassen. Wichtigstes Argument hierfür ist das nochmalige Vorschieben um eine Zeile. Des weiteren stelle ich den 1. und 7. Schalter auf OFF.

Ich hoffe, Sie freuen sich jetzt genauso wie ich an dem tollen Schriftbild Ihres SG-10 oder SG-15 in Verbindung mit dem Textverarbeitungsprogramm Textomat.

(Klaus Croll/gk)

# Zwei Quickies \[126\]

> Kopfstand für Sprites und ein kleiner Zeicheneditor sind zwei Einzeiler, die sich in Programme einbinden lassen.

Der folgende Einzeiler stellt ein Sprite auf den Kopf (beziehungsweise wieder auf die Füße):

### Kopfstand für Sprites

FOR A=958 TO 896 STEP-3:POKE A-2,PEEK(832 + L): POKE A-1,PEEK(833 + L):POKE A,PEEK (834 + L): L=L+3:NEXT

Der Einzeiler kann nur dann als solcher eingegeben werden, wenn von der Möglichkeit Gebrauch gemacht wird, die (Basic-)Kurzbefehle einzutippen (siehe Anhang D im C 64-Handbuch). Sie können jedoch auch zwei Zeilen daraus machen. Das Sprite, das verändert werden soll, muß im Bereich 13 (Adresse 832-895) abgelegt sein; im Bereich 14 (Adresse 896-958) steht nach Programmlauf das gedrehte Sprite beziehungsweise dessen Bitmuster.

TODO TABLE

A = Laufvariable für FOR...NEXT-Schleife
L = Zählvariable

Da L nicht auf Null gesetzt wird, muß vermieden werden, diese Variable anderweitig im (Gesamt-) Programm zu verwenden, da es sonst zu unliebsamen Überraschungen kommen kann.

(Hans Joachim Neumann/gk)

### Zeichendefinitionen

Folgendes kurze Programm wandelt ein am Bildschirm entworfenes Zeichen in Zahlen um und schreibt diese dann auf den Bildschirm. Im linken oberen Eck des Bildschirmes wird das Zeichen in einer 8 * 8-Matrix entworfen. Um einen gesetzten Punkt zu markieren, wird an die gewünschte Stelle ein Stern (»*«) geschrieben.

TODO TABLE

X(0-7)	=Zahl 0—7
T	Zähler der Reihe
Y	Zähler des Bits
1031	= linke obere Ecke des Zeichens + 7 (1024 + 7)
42 Bildschirmcode für »*« — es können auch andere verwendet werden.

Damit Sie nicht mit Abkürzungen arbeiten müssen, ist der Einzeiler auf zwei Zeilen aufgeteilt worden (Zeile 100 und 110).

Starten Sie das Programm mit RUN. In der oberen linken Ecke wird ein Raster von 8*8 Punkten gezeichnet und unter dem READY erscheint GOTO 100. Mit den Cursor-Tasten (nicht die RETURN-Taste verwenden) können Sie nun ein Zeichen definieren, indem Sie anstelle eines Punktes ein »*« setzen. Wenn das Zeichen fertig ist, gehen Sie mit dem Cursor auf »GOTO 100« und drücken RETURN. Auf dem Bildschirm werden jetzt die Daten dieses Zeichens angezeigt.

Diese Daten können zum Erstellen eines eigenen Zeichensatzes (auch für Spiele) verwendet werden. Ein manuelles Errechnen dieser Werte entfällt somit.

(Wolfgang Horak/gk)


# 3D-Darstellung in 19 Zeilen \[126-127\]

> Das Programm stellt ein frei wählbares, dreidimensionales Objekt auf dem Bildschirm dar, das durch Drücken der Funktionstasten gedreht werden kann. Simons Basic ist allerdings Voraussetzung.

Das Programm (Listing 1)wird nach Aktivierung von Simons Basic normal geladen und mit »RUN« gestartet. Danach muß die Datei angegeben werden, die die Daten für den darzustellenden Körper enthält. Bevor die Eingabe mit RETURN abgeschlossen werden kann, muß jedoch erst die Diskette mit der gewünschten Datei in das Laufwerk eingeführt werden. Sind alle Werte eingelesen, erscheint die Figur in Originalform auf dem Bildschirm. Sie kann nun durch Drücken der Funktionstasten (ohne SHIFT) beliebig gedreht werden. F1, F3 und F5 bestimmen die Rotationsachse, während F7 einen Richtungswechsel bewirkt.

### Die Erzeugung von Figuren

Die Daten für Figuren müssen in Form einer sequentiellen Datei (Typ SEQ) vorliegen. Eine Figur besteht dabei aus einer begrenzten Anzahl von Geradenstücken, die duch ihre Anfangs- und Endpunkte (x-, y- und z-Werte) gekennzeichnet sind. Jedes Geradenstück wird also durch sechs Zahlen bestimmt. Alle Geradenstücke werden unmittelbar hintereinander in die Datei geschrieben. Ein Endekennzeichen oder sonstige Zusatzangaben sind nicht erforderlich.

Das Demonstrationsprogramm (Listing 2) erzeugt eine Datei mit dem Namen »PYR«, welche die Daten für eine Pyramide enthält. Durch Veränderung der DATA-Zeilen können auch andere Körper definiert werden. Die Koordinaten müssen jedoch so gewählt werden, daß sie nicht außerhalb des Bildschirmbereichs liegen und diesen auch nicht durch die Rotation zu verlassen drohen. Es sei dabei darauf hingewiesen, daß die z-Achse in die Tiefe und die y-Achse nach oben zeigt. Als Orientierungshilfe kann die Demo-Pyramide verwendet werden.

### Darstellung eines Punktes

Um einen Raumpunkt auf dem Bildschirm darstellen zu können, muß er zunächst an das zweidimensionale Koordinatensystem angepaßt werden. Es wird hierzu die Fluchtpunktperspektive gewählt, die über die Strahlensätze herleitbar ist:

TODO TABLE

x’=xf—(zf—z) * (xf-x)/zf
y'=yf-(zf-z)*(yf-y)/zf
x’	horizontale Bildschirmkoordinate
y’	vertikale Bildschirmkoordinate
x,y,z	Koordinaten des Raumpunktes
xf,yf,zf	Koordinaten des Fluchtpunktes

### Anwendungsmöglichkeiten

Das Programm kann beispielsweise zur Darstellung und räumlichen Drehung von Computergrafiken (dreidimensionale Funktionen, Gegenstände, Flächen etc.) verwendet werden. Die Erzeugung der Gebilde erfolgt dabei von einem unabhängigen Programm. Nach Erstellung der sequentiellen Datei kann das Ergebnis mittels des Rotationsprogramms betrachtet werden. Dazu kann es sinnvoll sein, noch einige Erweiterungen in das Programm einzubauen. Zum Beispiel würden folgende zusätzlich eingegebenen Zeilen bei Überschreitung des Bildschirmbereiches einen Abbruch verhindern und statt dessen die betreffenden Geraden nur bis an den Rand zeichnen:

TODO PRE

22	gosub 60	
60	dx=x-v:dy=y-r:mm=0.01:if dx*dy<>0 then mm=dy/dx
62	if x<0 then y=y-mm*x:x=0
64	if x>320 then y=y-mm*(x-320):x=320
66	if v<0 then r=r-mm*v:v=0
68	if v>320 then r=r-mm*(v-320):v=320
70	if y<0 then x=x-y/mm:y=0
72	if y>200 then x=x-y/mm:y=200
74	if r<0 then v=v-r/mm:r=0
76	if r>200 then v=v-(r-200)/mm:r=200
78	if x<0 or x>320 or v>320 or v<0 then x=0:v=0
80	if y<0 or y>200 or r<0 or r>200 then y=0:r=0
82	return

Freilich nimmt ein derart ergänztes Programm beim LISTen mehr als eine Bildschirmseite ein, bietet aber bessere Anwendungsmöglichkeiten.

Ein völlig anderer Aspekt wäre die bloße Verwendung der mathematischen Formeln zum Einbau in eigene Programme (beispielsweise Spiele). Dazu kann es unter Umständen erforderlich sein, sie in Maschinensprache zu übersetzen. Da aber dies bereits mit einfachen 16-Bit-Rechenroutinen und wenigen Tabellen bewerkstelligt werden kann, dürfte das für den erfahrenen Programmierer kein allzu großes Hindernis darstellen.

### Mathematisch gesehen: Das Problem der Rotation

Um einen Körper von allen nur erdenklichen Perspektiven darzustellen, muß er im Raum gedreht werden. Die dazu notwendigen Berechnungen sind allerdings recht kompliziert und auch nicht im Rahmen eines extrem kurzen Programms realisierbar, will man den Körper — das heißt alle seine Eckpunkte — um eine beliebig im Raum schwebende Achse rotieren lassen.

Verzichtet man jedoch auf eine beliebige Rotationsachse und beschränkt man sich auf den Sonderfall, daß diese zu einer der Achsen des Koordinatensystems (x-,y- oder z-Achse) parallel liegt, ergibt sich eine erhebliche Vereinfachung, die daraus resultiert, daß — bedingt durch die Parallelität — immer nur zwei Koordinatenangaben eines zu rotierenden Punktes verändert werden und somit das Problem in der Ebene betrachtet werden kann. Konstant bleibt immer diejenige Koordinatenangabe, die sich auf jene Koordinatenachse bezieht, zu welcher die Rotationsachse parallel ist.

Für die Drehung eines Punktes P um einen Punkt R ergeben sich folgende Rechenschritte:
A... Abszisse
O... Ordinate
Koordinaten von R und P : R (ar, or); P (ap,op)
Koordinate von P’ : P’ (ap’, op’)
W... Winkel, der den Grad der Rotation bestimmt
A, B, d, e, h, d’, h’ : siehe Bild 1
A = ABS (ATN((or-op)/(ar-ap)))
if ar-ap >0 then A=-Aπ
if or-op >0 then A=-A
e = SQR((d)(d) + (h)(h))
d = ap—ar; h=op-or
B = W+A; d’ = COS(B)*e; h’ = SIN(B)*e
ap’ = ar+d’; op’=or+h’

(Der Absolutbetrag und die IF-Anweisungen sind nötig, um die durch Quotientenbildung verlorengegangene Vorzeicheninformation wiederzugewinnen.)

Diese mathematischen Ausführungen waren nur für den an den Grundlagen Interessierten gedacht. Natürlich kann man auch mathematisch unbelastet mit dem Programm experimentieren.

(Achim Vowe/ev)

# Zeicheneditor für C 64 \[129\]

> In der Kürze liegt hier die Würze. Statt seitenlanger Listings brauchen Sie nur eine einzige Bildschirmseite abzutippen, um den Zeichensatz Ihres C 64 ganz nach Belieben ändern zu können.

Das Programm »Character Change« (Listing 1) ist ein Hilfsprogramm, um den Zeichensatz des C 64 beliebig zu verändern und anschließend auf Diskette abzuspeichern. Das ganze Listing wirkt zwar auf den ersten Blick etwas unübersichtlich, aber dafür sind es halt auch bloß 24 Zeilen.

Der Vollständigkeit halber ist auch noch ein Demo-Programm dabei, das es ermöglicht, mit diesem veränderten Zeichensatz in eigenen Programmen zu arbeiten. Einsatzmöglichkeiten gibt es genug, etwa Spiele.

Ein paar Erläuterungen zum Programm:

Nach dem Starten mit »RUN«, fragt der Computer »KEY ?«. Hier kann ein beliebiges Zeichen über die Tastatur eingegeben werden. Allerdings muß es an der Stelle stehen, an der der Cursor blinkt, da aus dieser Speicherzelle des Video-RAMs der Bildschirmcode geholt wird.

Nachdem die Eingabe mit RETURN abgeschlossen wurde, erscheint die Matrix des Zeichens vergrößert auf dem Bildschirm. Dabei steht ein Sternchen für gesetztes, ein Punkt für ein nicht gesetztes Pixel.

Jetzt kann die Zeichenmatrix verändert werden, und zwar zeilenweise. Wieder durch Punkte und Sternchen kennzeichnen, wo ein Punkt gesetzt beziehungsweise nicht gesetzt werden soll. Danach RETURN drücken und die nächste Zeile ändern.

Sind alle acht Zeilen neu eingegeben, so kann man sich für »W« wie »weiter« und »S« wie »save« entscheiden. Drückt man »W«, so geht das Spielchen von vorne los, mit »S« wird der «Zeichensatz auf Diskette abgespeichert. Drückt man eine andere Taste, so erfolgt ein Programmabbruch.

Das File des Zeichensatzes nennt sich »character ram«. Das Demo-Programm (Listing 2) lädt einen bereits veränderten Zeichensatz von Diskette und stellt dann alle 256 Zeichen auf dem Bildschirm dar.

## So arbeitet das Programm

Noch ein paar Worte zur Arbeitsweise des Programms.

Zuerst wird von einem in DATAs abgelegten Maschinenprogramm mit Hilfe der Blockverschieberoutine des Betriebssystems der Zeichensatz zweimal in verschiedene RAM-Bereiche kopiert. Einmal nach $E000, einmal nach $9000. Dies ist erforderlich, um die Zeichenmatrix mit PEEK auslesen zu können, was im unter dem Betriebssystem liegenden RAM bekanntlich nicht geht Die zweite Kopie ist die, aus der der Computer jetzt die Zeichen ausliest. Danach werden von Basic aus die Zeiger für den Beginn des Video-RAMs, den Zeichengenerator und die damit zusammenhängenden 16 KByte für den Video-Controller neu gesetzt. Das Video-RAM wird also zwangsweise mit verschoben, und zwar nach dezimal 49152.

Aus dem Bildschirmcode des eingegebenen Zeichens wird die Startadresse in der ersten Kopie des Zeichensatzes ermittelt und 8 Bytes ausgelesen. Aus diesen 8 Bytes werden dann die Strings für die Bildschirmdarstellung gebildet. Umgekehrt werden aus den eingegebenen Strings die Bytes für den Zeichensatz gebildet und anschließend in beide Kopien ge-POKEt.

Ein zweites Maschinenprogramm ruft dann die SAVE-Routine auf und speichert die 4 KByte der ersten Kopie auf Diskette. Eine erste Kopie deshalb, um sie nach dem Laden in andere Programme nochmals lesen oder verändern zu können.

Das Demo-Programm enthält im wesentlichen eine weitere Maschinenspracheroutine, die den Zeichensatz nach $9000 lädt und dann nach $E000 verschiebt. Die Umschaltung der Zeiger geschieht auch hier von Basic aus, um dem Anwender zu überlassen, wann er den neuen Zeichensatz verwenden will.

(Marc Ritter/ev)

# Impressum \[130\]

Herausgeber: Carl-Franz von Quadt, Otmar Weber

Redaktion: Albert Absmeier, Volker Everts, Georg Klinge, Harald Meyer, Achim Hübner, Christian Rogge.
Fremdautoren:
Lonczewski, Mann, Weineck, Wippgen, Riethmüller, Zinner, Meierhofer, Eyssele, Del Pino, Schäfer, Amblank, Schmidt, Schwarz, Arndt, Klenz, Hohenberger, Ziesche, Paetzold, Hoffmann, Bertog, Kowall, Wilde, Jörgens, Büsch, Brendel, Eichholz, Sauer, Meyer, Günter, Rylander, Barcikowski, Vocke, Schneider, Spitzner, Croll, Neumann, Vowe, Ritter, Horak

Layout: Leo Eder (Ltg.)

Herstellung: Klaus Buck

Auslandsrepräsentation:
Schweiz: Markt & Technik Vertriebs AG, Kollerstr. 3, CH-6300 Zug, Tel. 042-22 31 55, Telex: 862 329
USA:	M&T Publishing Inc.; 2464 Embarcadero Way, Palo Alto, CA 94303

Manuskripteinsendungen: Manuskripte und Programmlistings werden gerne von der Redaktion angenommen. Sie müssen frei sein von Rechten Dritter. Sollten sie auch an anderer Stelle zur Veröffentlichung oder gewerblichen Nutzung angeboten werden, so muß dies angegeben werden. Mit der Einsendung von Manuskripten und Listings gibt der Verfasser die Zustimmung zum Abdruck in von der Markt & Technik Verlags AG herausgegebenen Publikationen und zur Vervielfältigung der Programmlistings auf Datenträger. Honorare nach Vereinbarung. Für unverlangt eingesandte Manuskripte und Listings wird keine Haftung übernommen.

Vertriebsleitung: Hans Hörl

Anzeigenverwaltung und Disposition: Michaela Hörl

Verlagsleiter M&T-Buchverlag: Günther Frank

Druck: E. Schwend GmbH, Schmollerstr. 31, Schwäbisch Hall.
Auch Anschrift für Beihefter und Beilagen.

Preis: Das Einzelheft kostet DM 14,—

Vertrieb Handelsauflage: Inland (Groß-, Einzel- und Bahnhofsbuchhandel) sowie Österreich und Schweiz: Pegasus Buch- und Zeitschriften-Vertriebs GmbH, Hauptstätter Straße 96, 7000 Stuttgart 1, Telefon (0711) 7 6 48 30

Urheberrecht: Alle in diesem Heft erschienenen Beiträge sind urheberrechtlich geschützt. Alle Rechte, auch Übersetzungen, vorbehalten. Reproduktionen gleich welcher Art, ob Fotokopie, Mikrofilm oder Erfassung in Datenverarbeitungsanlagen, nur mit schriftlicher Genehmigung des Verlages. Anfragen sind an die Redaktion zu richten. Für Schaltungen und Programme, die als Beispiele veröffentlicht werden, können wir weder Gewähr noch irgendwelche Haftung übernehmen. Aus der Veröffentlichung kann nicht geschlossen werden, daß die beschriebenen Lösungen oder verwendeten Bezeichnungen frei von gewerblichen Schutzrechten sind. Anfragen für Sonderdrucke sind an Peter Wagstyl (185) zu richten.

© 1985 Markt & Technik Verlag Aktiengesellschaft

Verantwortlich:
Für redaktionellen Teil: Albert Absmeier
Für Anzeigen: Brigitte Fiebig

Vorstand: Carl-Franz von Quadt, Otmar Weber

Anschrift für Verlag, Redaktion, Vertrieb, Anzeigenverwaltung und alle Verantwortlichen:
Markt & Technik Verlag Aktiengesellschaft, Hans-Pinsel-Straße 2, 8013 Haar bei München, Telefon (0 89) 4613-0, Telex 5-22 052

Aktionäre, die mehr als 25% des Kapitals halten: Otmar Weber, Ingenieur, München; Carl-Franz von Quadt, Betriebswirt, München. Aufsichtsrat: Dr. Robert Dissmann (Vorsitzender), Karl-Heinz Fanselow, Eduard Heilmayr
