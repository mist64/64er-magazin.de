<!DOCTYPE html>
<html lang="de">

<head>
    <title>Mathematical-Basic: Das Super-Basic für den VC 20</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Wolfgang W. Wirth, ev">
    <meta name="64er.issue" content="12/84">
    <meta name="64er.pages" content="50,55-60">
    <meta name="64er.head1" content="Listing des Monats">
    <meta name="64er.head2" content="VC 20 + 8 KByte">
    <meta name="64er.toc_category" content="Wettbewerbe|Listing des Monats">
    <meta name="64er.toc_title" content="<b>Super-Basic für den VC 20</b>">
    <meta name="64er.index_title" content="Mathematical-Basic: Das Super-Basic für den VC 20 (LdM)">
    <meta name="64er.index_category" content="Listings zum Abtippen|Anwendung|Mathematik">
    <meta name="64er.id" content="mathe_basic">
</head>

<body>
    <article>

        <h1>Mathematical-Basic: Das Super-Basic für den VC 20</h1>

        <p class="intro">Einen echten Knüller für alle Besitzer eines VC 20 mit 8 KByte Erweiterung haben wir zum »Listing des Monats« gewählt. Mathematical Basic steift über 50 neue Befehle und Funktionen zur Verfügung und setzt damit einen Standard, an dem andere Toolkits künftig gemessen werden müssen.</p>

        <p>Das Programm ist vollständig in Assembler geschrieben und liegt zum Eintippen als Basic-Lader vor. Nach dem Starten des Laders wird das eigentliche Maschinenprogramm ab Adresse 29211, also am oberen Ende von Speicherblock 3 abgelegt und gleichzeitig vor dem Überschreiben durch Basic-Programme oder Variable geschützt. Bei einem voll ausgebauten VC 20 (+ 24 KByte) kann das Programm ohne weitere Veränderungen benutzt werden. Aber auch Besitzer einer 8-KByte-Erweiterung können diese Basic-Erweiterung nutzen. Allerdings muß dann diese 8-KByte-Erweiterung hardwaremäßig auf den Adreßbereich von $6000 bis $7FFF, also auf Speicherblock 3 umgeschaltet werden. Schlagen Sie bitte die erforderliche Vorgehensweise im Handbuch für die 8-KByte-Erweiterung nach. Es ist die gleiche Umstellung, die auch nötig wird, wenn Sie das 8-KByte-Modul zusammen mit einer 16-KByte-Erweiterung als 24 KByte RAM nutzen wollen.</p>

        <p>Haben Sie allerdings keine zusätzliche 16-KByte-Erweiterung, dann steht Ihnen für das Arbeiten mit Mathematical-Basic nur der Grundversionsspeicher zur Verfügung. Leider ist es nicht möglich, nur das 16-KByte-Modul zu verwenden, da dieses immer auf Speicherblock 1 und 2 eingestellt ist. Doch nun zum Programm selbst: Mathematical-Basic erweitert den Wortschatz des Basic-Interpreters um zusätzliche Befehle und Funktionen. Insbesondere wurde die Handhabung der trigonometrischen Funktionen verbessert (man kann zwischen Altgrad, Neugrad und Bogenmaß wählen). Daneben wurden Spezialbefehle für Diskettenbetrieb wie CATALOG, DLOAD, DSAVE etc. eingebaut. Strukturierte Programmierung wird durch DO&hellip;UNTIL-Schleifen unterstützt. Viele weitere Befehle und Funktionen vereinfachen die Programmierung zum Teil ganz erheblich.</p>

        <p>Auf jeden Fall braucht »Mathematical-Basic« den Vergleich auch mit kommerziellen Softwareprodukten dieser Art nicht zu scheuen.</p>

        <address class="author">(ev)</address>

        <aside>
            <h2>Der Autor des »Mathematical Basic« stellt sich vor</h2>

            <img class="inline" src="50-1.png" alt="">

            <p>Ich bin am 9.7.1963 geboren und zur Zeit Praktikant in einem Softwarehaus in Bad Kreuznach.</p>

            <p>Für die Entwicklung des Programms ist hauptsächlich der Ärger über das permanente Fehlen der gebräuchlichsten naturwissenschaftlichen Funktionen in jedem Basic-Interpreter von Commodore verantwortlich.</p>

            <p>Um mehrere Funktionen über den USR-Vektor zu implementieren, müßte man vor jedem Aufruf auch lästigerweise die jeweilige Adresse in diesen Vektor schreiben. Das ist sehr umständlich; also müssen mehrere USR-Funktionen her. Wenn nun aber schon eine Routine für das Selektieren der Adressen geschrieben wird, so kann man auch gleich das Ganze etwas komfortabler gestalten und eine Interpreter-Erweiterung basteln. Das waren meine anfänglichen Überlegungen und heraus kam »Mathematical Basic«. Das Programm wurde so gehalten, daß es jederzeit weitere Befehle und Funktionen aufnehmen kann. 6502-Freunde mit Kenntnissen über das VC 20-Betriebssystem werden sich schnell mit »Mathematical Basic« zurechtfinden und auch eigene Änderungen durchführen können.</p>

            <address class="author">(Wolfgang W. Wirth)</address>
        </aside>

        <p>Eine gute Nachricht für alle Freunde des VC 20: Unser »Listing des Monats« macht mit über 50 neuen Befehlen das Programmieren zum Vergnügen.</p>

        <p>Leider gibt es aber auch eine schlechte Nachricht. Sie müssen gut und gerne 150 DATA-Zeilen eintippen. Lassen Sie sich aber davon nicht entmutigen. Der Aufwand lohnt sich ganz bestimmt. Das Programm hilft Ihnen bei der wohl unvermeidlichen Suche nach Tippfehlern durch das blockweise Bilden von Prüfsummen.</p>

        <h3>Befehle des Mathematical Basic</h3>

        <ul class="plain">
            <li><strong>':</strong><br>
                erlaubt eine REM-Anweisung innerhalb einer Zeile ohne sofortige Programmfortsetzung ab folgender Zeile.
            </li>
            <li><strong>BEEP</strong> h, l:<br>
                gibt einen Ton variabler Höhe (h) und Länge (l) aus. h ist im Bereich von 0 bis 126 und l von 0 bis 255 definiert. Beträgt l=0, so wird kein Ton ausgegeben.            
            </li>
            <li><strong>CATALOG:</strong><br>
                bringt das Inhaltsverzeichnis der Diskette auf den Bildschirm. Dieser Befehl ist nur für das Gerät mit der Nummer 8 definiert. Wird während der Ausgabe die STOP-Taste betätigt, so wird die Ausgabe sofort abgebrochen. Wird die Leertaste gedrückt, so wird die Ausgabe nur unterbrochen und kann mit einer weiteren Betätigung dieser Taste fortgesetzt werden.                
            </li>
            <li><strong>COLOR</strong><br>
                c,h,r: setzt die Farben für Cursor (c), Hintergrund (h) und Rahmen (r). r und c erstrecken sich von 0 bis 7 und h von 0 bis 15. Die einzelnen Farben bezüglich der Nummercodes können dem VC 20-Handbuch entnommen werden.                
            </li>
            <li><strong>CLS:</strong><br>
                löscht den Bildschirmspeicher.                
            </li>
            <li><strong>DEFUSRn TO x:</strong><br>
                definiert einen der neun möglichen USR-Vektoren. Die einzelnen USR-Funktionen werden durch das Zeichen n unterschieden. n kann dabei A, B, C, D, E, F, G oder H sein. Die neunte USR-Funktion ist die, welche über den Vektor in den Adressen 1 und 2 angesprungen wird. Soll dieser Vektor definiert werden, so muß n weggelassen werden. Die Variable x steht für den Vektor selbst, also der Adresse, ab der die U8R-Funktion starten soll. Beispiel: DEFUSRA TO 30000. Die USR-Funktion USRA erhält die Einsprungadresse 30000.                
            </li>
            <li><strong>DEGREE:</strong><br>
                stellt die Routinen für trigonometrische Funktionen auf Normalgrad (0 bis 360) ein.                
            </li>
            <li><strong>DELETE a-b</strong>:<br>
                löscht Zeilen eines Basic-Programms von Zeile a bis Zeile b. Für a und b sind nur Konstanten erlaubt.                
            </li>
            <li><strong>DIRECTORY:</strong><br>
                siehe CATALOG                
            </li>
            <li><strong>DLOAD</strong> pn$:<br>
                lädt ein Programm mit dem Namen pn$ vom Floppy-Laufwerk mit der Nummer 8. Außer dem Namen sind keine weiteren Parameter erlaubt.                
            </li>
            <li><strong>DO:</strong><br>
                erlaubt zusammen mit UNTIL eine Schleife. Der zwischen diesen beiden Schlüsselwörtern liegende Programmteil wird so oft wiederholt, bis der Ausdruck, der UNTIL folgt, nicht mehr auf logisch 0 ist. Dazu ein Beispiel: DO GET a$: UNTIL a$=" ". Das Programm verläßt die Schleife nicht eher, bis die Leertaste gedrückt wird. DO-UNTIL-Schleifen können acht Ebenen tief geschachtelt werden. Eine neunte DO-Anweisung würde die Meldung »out of memory« zur Folge haben. Sollte UNTIL einmal ohne einen vorangegangenen DO-Befehl aufgerufen werden, so gibt der VC 20 »until without do« aus.                
            </li>
            <li><strong>DSAVE</strong> pn$:<br>
                sichert ein Programm mit dem Namen pn$ auf dem Floppy-Laufwerk mit der Nummer 8. Außer dem Namen sind keine weiteren Parameter zulässig. Sollte dem Befehl DSAVE, DLOAD oder DVERIFY kein Parameter folgen, so wird automatisch »*« als Parameter gesetzt.                
            </li>
            <li><strong>DVERIFY</strong> pn$:<br>
                vergleicht das Programm mit dem Namen pn$ im Speicher mit dem gleichen auf der Diskette. Als Parameter ist nur der Name erlaubt.                
            </li>
            <li><strong>EXECUTE</strong> a$:<br>
                wandelt den String a$ in Interpretercode und führt die darin enthaltenen Anweisungen aus. Beispiel: a$="a=22":EXECUTE a$. Der Variablen a wird der Wert 22 zugewiesen. Der Befehl darf nicht im Direkt-Modus gegeben werden und der Befehlsstring (a$) darf eine Länge von 88 Zeichen nicht überschreiten.                
            </li>
            <li><strong>GRAD:</strong><br>
                stellt die trigonometrischen Routinen auf Neugrad (0 bis 400).                
            </li>
            <li><strong> IF:</strong><br>
                Die IF&hellip;THEN-Anweisung ist in ihren Aufbaumöglichkeiten erweitert worden. Es ist nicht mehr zwingend erforderlich, den THEN-Dummy zu schreiben. Beispiel: IF A=4 THEN PRINT B$ läßt sich auch als IF A=4 PRINT B$ eingeben.                
            </li>
            <li><strong>INITIALIZE:</strong><br>
                initialisiert die Floppy mit der Nummer 8.                
            </li>
            <li><strong>LOCATE</strong> z,s:<br>
                setzt den Cursor in Zeile z und Spalte s. z liegt im Bereich von 1 bis 23 und s von 1 bis 22. Folgende Variationsmöglichkeiten sind gegeben: LOCATE z definiert nur eine neue Zeilenposition. LOCATE ,s setzt den Cursor innerhalb einer Zeile nur an eine neue Spaltenposition.                
            </li>
            <li><strong>LPRINT:</strong><br>
                verhält sich wie PRINT. Die Zeichen werden aber nicht auf den Bildschirm, sondern auf den Drucker (Nummer 4) ausgegeben. LPRINT und PPRINT sollten nur bei angeschlossenen Geräten benutzt werden, da sonst der IEC-Bus blockiert wird.                
            </li>
            <li><strong>RADIAN:</strong><br>
                stellt die trigonometrischen Routinen auf Bogenmaß ein.                
            </li>
            <li><strong>RENUMBER</strong> z,s:<br>
                reorganisiert die Zeilennummern eines Basic-Programms. z ist dabei die Startzeile und s die Schrittweite, z und s dürfen nur Konstanten sein. Sollten dem Befehl keine Parameter folgen, so gilt z = 100 und s = 10.                
            </li>
            <li><strong>RESTORE TO</strong> z:<br>
                positioniert den DATA-Pointer auf die Zeile z. Das Wort TO kann dabei wegfallen. RESTORE allein setzt den Pointer wie gewohnt auf den Programmstart.                
            </li>
            <li><strong>RETURN TO</strong> z:<br>
                ermöglicht es, aus einem Unterprogramm in eine bestimmte Zeile z zurückzukehren.                
            </li>
            <li><strong>RUN</strong> "name":<br>
                hat die gleiche Funktion wie DLOAD. Zusätzlich wird aber noch der String RUN +CHR$(13) in den Tastaturpuffer geschrieben. Das hat zur Folge, daß das gerade geladene Programm sofort gestartet wird.                
            </li>
            <li><strong>PPRINT</strong>:<br>
                verhält sich wie PRINT. Die Zeichen werden aber, anstatt auf den Bildschirm, auf den Plotter (Nummer 6) ausgegeben.                
            </li>
            <li><strong>QUIT</strong>:<br>
                führt ein Total-Reset aus. Mathematical Basic wird dabei gelöscht.                
            </li>
            <li><strong>UNITL</strong> a: siehe DO.<br>                
            </li>
        </ul>

        <h2>Die Funktionen des Mathematical Basic</h2>

        <ul class="plain">
            <li><strong>! a</strong>:<br>
                ist ein Äquivalent zur CHR$(a)-Funktion. Hierbei sind aber keine Klammern nötig, a ist nur als Konstante erlaubt.                
            </li>
            <li><strong>&amp;</strong>:<br>
                ist das »Hexadezimal-Vorzeichen« für Hex-Konstanten. Beispiel: &amp;aO2b ist das Äquivalent für 41003. Die Anzahl der Hex-Ziffern ist beliebig, es wird maximal eine 16-Bit-Zahl errechnet.                
            </li>
            <li><strong>←</strong>:<br>
                entspricht dem Ausdruck CHR$(13) und kann auch genauso gehandhabt werden.                
            </li>
            <li><strong>[a]</strong>:<br>
                hat die gleiche Wirkung wie die ABS-Funktion. Unterscheidet sich aber durch die bessere Selbstdokumentation.                
            </li>
            <li><strong>ACS</strong>(a):<br>
                berechnet abhängig von der jeweiligen Einstellung durch RADIAN, DEGREE oder GRAD den Arcus-Cosinus von a. Die hier angesprochene Abhängigkeit gilt für alle trigonometrischen Funktionen.                
            </li>
            <li><strong>ACT</strong>(a):<br>
                bestimmt den Arcus-Cotangens von a.                
            </li>
            <li><strong>ASN</strong>(a):<br>
                ergibt den Arcus-Sinus von a.                
            </li>
            <li><strong>CHR$</strong>(z,l).<br>
                ist eine Variante von CHR$(z). z entspricht dabei dem Zeichen des normalerweise nur 1 Byte langen Strings. Mit l läßt sich nun aber zusätzlich auch die Länge variieren. l ist dabei von 0 bis 255 definiert.                
            </li>
            <li><strong>COT</strong>(a):<br>
                berechnet den Cotangens von a.                
            </li>
            <li><strong>CRSCOL</strong>:<br>
                holt die momentane Spaltenposition des Cursors.                
            </li>
            <li><strong>CRSLIN</strong>:<br>
                holt die momentane Zeilenposition des Cursors.                
            </li>
            <li><strong>CVF</strong>(a$):<br>
                wandelt den fünf Zeichen langen String a$ in eine Fließkommazahl um.                
            </li>
            <li><strong>CVI</strong>(a$):<br>
                wandelt den zwei Zeichen langen String a$ in eine Integerzahl um.                
            </li>
            <li><strong>DEC</strong>(a$):<br>
                berechnet aus dem 4-Byte-String a$, der sich aus Hex-Ziffern aufbaut, eine dezimale 16-Bit-Zahl.                
            </li>
            <li><strong>DIV</strong>(a,b,):<br>
                ist gleichwertig mit dem Ausdruck INT(a/b).                
            </li>
            <li><strong>FRC</strong>(a):<br>
                holt die Nachkommazahl von a.                
            </li>
            <li><strong>FUNCTION</strong>(a$).<br>
                wandelt den maximal 88 Zeichen langen String a$ in Interpretercode und berechnet ihn. Beispiel: y=FUNCTION("5+2"). y wird der Wert 7 zugewiesen. Diese Funktion darf nicht im Direktmodus stehen.                
            </li>
            <li><strong>HEX$</strong>(a):<br>
                wandelt die 16-Bit-Zahl a in einen 4-Byte-Hex. String.                
            </li>
            <li><strong>INSTR</strong>(a$,b$):<br>
                testet, an welcher Stelle a$ sich in b$ befindet. Ist a$ nicht in b$ enthalten, so ist das Ergebnis 0, ansonsten entspricht es der Position von a$ in b$. a$ und b$ müssen mindestens 1 Zeichen lang sein und a$ darf nicht länger als b$ sein. INSTR darf nicht im Direktmodus stehen.                
            </li>
            <li><strong>LGD</strong> (a):<br>
                berechnet den dekadischen Logarithmus von a.                
            </li>
            <li><strong>LGU</strong>(a,b):<br>
                bestimmt den Logarithmus von a zur Basis b.                
            </li>
            <li><strong>MKF$</strong>(a):<br>
                wandelt die Zahl a in einen fünf Zeichen langen String.                
            </li>
            <li><strong>MKI$</strong>(a):<br>
                wandelt die Integerzahl a in einen zwei Zeichen langen String.               
            </li>
            <li><strong>MOD</strong>(a,b):<br>
                bestimmt den ganzzahligen Rest aus der Division von a durch b.                          
            </li>
            <li><strong>RANDOM</strong>:<br>
                entspricht dem Ausdruck RND(1).                
            </li>
            <li><strong>RANDOM</strong>(a,b):<br>
                entspricht dem Ausdruck RND(1)*b+a.                
            </li>
            <li><strong>TIME$</strong>:<br>
                ist eine modifizierte Form von Tl$. Der Unterschied liegt darin, daß bei TIME$ noch zwei Trennzeichen eingefügt werden.                
            </li>
            <li><strong>USR</strong>n:<br>
                entspricht im Prinzip der USR(a)-Funktion. Unterschiede liegen darin, daß n (was der Kennung A, B, C, D, E, F, G oder H entspricht) folgen muß, aber keine »Klammer-auf-Klammer-zu«-Sequenz. Diese Routine (Aufruf durch JSR$cef1) muß zusätzlich an USR-Routinen, die für die Standard-USR-Funktion ausgelegt sind, angehängt werden. Der Vorteil bei den USRn-Funktionen liegt nun darin, daß man den USR-String mit mehreren Parametern übergeben kann. Die dazu nötigen Routinen sind:                
                <table class="plain">
                    <tr>
                        <td>cefa</td>
                        <td>Test auf Klammer auf und nächstes Zeichen holen.</td>
                    </tr>
                    <tr>
                        <td>cd9e</td>
                        <td>Ausdruck holen und String- und Integer-Flag setzen.</td>
                    </tr>
                    <tr>
                        <td>cd8d</td>
                        <td>Test auf numerischen Ausdruck.</td>
                    </tr>
                    <tr>
                        <td>cd8f</td>
                        <td>Test auf String.</td>
                    </tr>
                    <tr>
                        <td>cef7</td>
                        <td>Test auf Klammer zu und nächstes Zeichen holen.</td>
                    </tr>
                    <tr>
                        <td>cefd</td>
                        <td>Test auf Komma und nächstes Zeichen holen.</td>
                    </tr>
                </table>
            </li>
        </ul>

        <p>Damit sind alle neuen Befehle und Funktionen vorgestellt. Bleibt nur noch, Ihnen viel Spaß beim Programmieren mit »Mathematical Basic« zu wünschen.</p>

        <address class="author">(Wolfgang W. Wirth/ev)</address>

        <figure>
            <pre data-filename="mathe basic vc20" data-name="Mathematical Basic"></pre>
            <figcaption>Listing »Mathematical Basic«</figcaption>
        </figure>

    </article>

</body>

</html>
