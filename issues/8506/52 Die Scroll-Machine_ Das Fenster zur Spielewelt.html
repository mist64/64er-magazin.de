<!DOCTYPE html>
<html lang="de">

<head>
    <title>Die Scroll-Machine: Das Fenster zur Spielewelt</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Thilo Herrmann, ah, ak">
    <meta name="64er.issue" content="6/85">
    <meta name="64er.pages" content="52,56-67">
    <meta name="64er.head1" content="Listing des Monats">
    <meta name="64er.head2" content="C 64">
    <meta name="64er.toc_title" content="Listing des Monats<br>Die Scroll-Machine: Das Fenster zur Spielewelt">
    <meta name="64er.toc_category" content="Wettbewerbe">
    <meta name="64er.index_title" content="Die Scroll-Maschine – D. Fenster zur Spielewelt (LdM)">
    <meta name="64er.index_category" content="Listings zum Abtippen|Spielehilfe">
    <meta name="64er.id" content="scroll-machine">
</head>

<body>
    <article>
        <h1>Die Scroll-Machine: Das Fenster zur Spielewelt</h1>
        <p class="intro">Dieses außergewöhnliche Programm verschiebt den Bildschirm flimmerfrei in jede Richtung, wie es sonst nur von professionellen Spielen her bekannt ist — und das mit Basic.</p>

        <figure>
            <img src="52-1.png" alt="">
            <img src="52-2.png" alt="">
            <figcaption>Bild 1 und 2. Ausschnitte aus dem Pseudoschirm eines Demos</figcaption>
        </figure>

        <p>Bildschirmscrolling in eine beliebige Richtung ist im Commodore Basic V2.0 nicht realisierbar. Wer es dennoch versucht, wird mit dem Ergebnis nicht zufrieden sein. Dieses Programm macht es auch dem Anfänger leicht, Soft-Scrolling, ein Synonym für ruckfreies Verschieben des Bildschirms in alle Richtungen, in seine eigene Programme einzubauen. Besonders gut eignet es sich dazu mit dem Pseudoschirm-Editor Spielfelder zu konstruieren, die die Größe des normalen Bildschirms überschreiten. Durch eine große Anzahl von Befehlen ist jeder in der Lage, mittels Soft-Scroll immer den Teil des Feldes darzustellen, in dem sich die Spielfigur befindet. Die Spielfiguren werden ähnlich wie in professionellen Programmen durch Basic-Befehle, die die Beschleunigung, Reibung oder Höchstgeschwindigkeit festlegen, beliebig auf dem sichtbaren Pseudoschirm bewegt, einem Schirm, der in x- und y-Richtung größer ist als der normale Textbildschirm (x&gt;40, y&gt;25). Jeder kann maximal zwei Textfenster realisieren, die beliebige Spielinformationen enthalten. Das Programm stellt zum Laden und Abspeichern von SEQ- und PRG-Files einige sehr leistungsfähige Befehle zur Verfügung.</p>

        <p>Aber nicht nur für die Gestaltung von Spielen ist dieses Programm geeignet. Der Anwender kann zum Beispiel von Basic aus Textverarbeitungsprogramme gestalten, die durch horizontales Scrollen mehr als 40 Zeichen pro Zeile darstellen können, wie es bei fast allen kommerziellen Programmen der Fall ist.</p>

        <p>Bei dem Pseudoschirm-Editor handelt es sich um ein in Basic geschriebenes Programm, das durch einfache Befehle und einen geeigneten Zeichensatz beliebige Landschaften auf dem Bildschirm entstehen läßt. Die Konstruktion von Gängen und Höhlen wird im Kontur- und Micromodus zum Kinderspiel. Das Programm arbeitet sowohl mit einfarbigen wie aber auch mehrfarbigen Zeichensätzen. Die beiden Bilder sind ein ausgezeichnetes Beispiel für die Leistungsfähigkeit dieses Programms.</p>

        <address class="author">(Thilo Herrmann/ah)</address>

        <aside>
            <h2>Lebenslauf</h2>

            <img src="52-0.png" alt="" class="inline">

            <p>Ich wurde am 20.12.1968 in Göppingen geboren und ging nach erfolgreichem Besuch der Grundschule 1979 auf das Gymnasium, wo ich nun wenig begeistert die 10te Klasse besuche. Bis zum 14ten Lebensjahr stieg mein Interesse an Computern langsam an. Im Göppinger Computershop entdeckte ich einen TI99 4/A. Nach kurzer Zeit wurde mir das Herumexperimentieren mit diesem Computer zu wenig und ich entschloß mich, von meinen Ersparnissen einen VC 20 mit Datasette zu kaufen. Mit ihm war es mir möglich, das Commodore Basic zu erlernen. Ein halbes Jahr später stieß ich im Kaufhaus auf einen C 64 und war von seinen Fähigkeiten begeistert. So wurde der VC 20 kurzerhand zu Weihnachten gegen seinen größeren Bruder eingetauscht. Vom Rest meiner Ersparnisse schaffte ich mir ein 1541-Diskettenlaufwerk an. Nun konnte ich endlich richtig programmieren. Zuerst noch viel in Basic, doch dann immer mehr in Maschinensprache. Das Ergebnis meiner Bemühungen ist die Scroll-Machine, die mein bisher größtes Maschinenprogramm ist. Ohne Zweifel werden ihr noch größere Programme folgen. Es war nicht immer einfach, sämtliche Hürden zu überwinden, denn beim Programmieren des Videoprozessors sind viele Besonderheiten zu beachten, die nicht leicht zu verstehen und in keinem Buch zu finden sind.</p>

            <address class="author">(Thilo Herrmann/ak)</address>
        </aside>

        <p class="intro">Bringen Sie Bewegung in Ihre Grafik. Nutzen Sie einen Bildschirm, der bis zu 30 mal größer ist als der normale Textbildschirm. Scrolling wie bei dem Spiel Zeppelin wird dadurch möglich.</p>

        <p>Das Programm besteht aus 3 KByte Maschinensprache, die im Bereich von $C000 (49152) bis fast $CBFF (52223) liegen. Die Variablen stehen von 828 bis 959 im Kassettenpuffer. Das Video-RAM, das vom Programm benutzt wird, liegt im Bereich von 52224 bis 53223. Da die Spritepointer immer dem Video-RAM folgen, stehen sie nun von 53240 bis 53247 (normal: 2040 bis 2047). Im Bereich von $D000 (53248) bis $D7FF (55295) steht der Zeichensatz, der leicht verändert werden kann. Dabei ist zu beachten, daß der Bereich von $D000 bis $DFFF dreimal belegt ist, einmal durch die Ein-/ Ausgabe (VIC, SID, CIA 1 und 2), den C 64-Zeichensatz und das RAM, in das der Zeichensatz kopiert oder ein neuer geladen wird.</p>

        <p>Außerdem benötigt die Scroll-Machine noch eine Multiplikationstabelle, die von $DE00 (56832) bis $DFFF (57343) steht. Der Rest von $D800 bis $DDFF (55296 bis 56831) kann von Sprites genutzt werden. Ebenfalls für Sprites frei ist das RAM unter dem Kernal von $E000 bis $FFFF (57344 bis 65535). Dort kann auch ein 8-KByte-Pseudoschirm stehen, der eine größere X/Y-Ausdehnung hat als der normale Textbildschirm. Wenn dieser Bereich jedoch frei ist, kann man insgesamt 152 verschiedene Sprites im Speicher halten. Es muß aufgrund einer Besonderheit des VICs darauf geachtet werden, daß die Speicherstelle 65535 den Wert Null enthält. Die Sprites müssen nach wie vor vom Basic-Programm bewegt werden.</p>

        <p>Es sei nicht unerwähnt, daß ich die Restore-Taste geändert habe. Sie funktioniert nun auch ohne daß man RUN-STOP drückt. Die NMI-Vektoren $0318/$0319 (792/793) und $FFFA/$FFFB (65530/65531) im RAM enthalten immer die Adresse der neuen Restore-Routine. Soll die Restore-Taste gesperrt werden, so hilft POKE 51692,64. Die RUN/STOP-Taste kann mit POKE 49710,52 außer Kraft gesetzt werden (Tl wird damit auch unbrauchbar).</p>

        <h2>Die Funktionsweise</h2>

        <p>Das Programm arbeitet mit drei Rasterzeileninterrupts, zwei für den oberen Text/Soft-Scroll-Übergang und einer für den unteren. Alle Interrupts können mit dem RZ-Befehl verschoben werden, so daß die Bildschirmfenster beliebig groß werden können.</p>

        <p>Jede der drei Interruptroutinen setzt erst die Parameter des Videoprozessors: Hintergrundfarbe, Rahmenfarbe und so weiter. Die erste Interruptroutine hat damit ihre Aufgabe erfüllt. Sie setzt die Hintergrundfarbe auf die Zeichenfarbe, damit ein sauberer Übergang zwischen Soft-Scroll und normalem Text entsteht.</p>

        <p>Die zweite Routine berechnet die Werte für Bewegung und Steuerung. Dann springt sie zum normalen Systeminterrupt, der die Tastatur abfragt und die Zeit erhöht.</p>

        <p>Der dritte Interrupt ruft die Scroll-Routine auf, die den Pseudobildschirm abtastet und am meisten Zeit verschlingt.</p>

        <p>Dieser Teil des Programms muß sehr schnell sein, da er seine Aufgabe erledigt haben muß, bevor der nächste Interrupt ausgelöst wird.</p>

        <p>Die neuen Basic-Befehle werden mit Hilfe des Pointers $0308/$0309 eingebunden.</p>

        <p>TI$ wird unbrauchbar, da der Systeminterrupt nun nicht mehr jede 60stel Sekunde, sondern jede 50stel Sekunde ausgeführt wird. Die Sekunde errechnet sich während des Betriebs des Soft-Scrolls nun mit TI/50.</p>

        <h2>Joysticksteuerung</h2>

        <p>Wie sich aus der Befehlsliste ersehen läßt, besitzt das Programm vier Befehle zur Steuerung des Joysticks.</p>

        <p>Es gibt mehrere Möglichkeiten, ein Objekt zu steuern. Zum einen gibt es die »lineare« Steuerung. Sie wird wohl am häufigsten verwendet, zum Beispiel bei Fort Apocalypse und den meisten selbstgeschriebenen Spielen. Das funktioniert so: Man drückt den Steuerknüppel in eine bestimmte Richtung und das Objekt setzt sich in Bewegung. Es bewegt sich so lange, bis man den Knüppel wieder losläßt. Diese Steuerung ist jedoch wenig wirklichkeitsnah, man denke nur an eine Raumkapsel, die durch Raketenschübe gesteuert wird. Sie setzt sich nicht sprunghaft in Bewegung, sondern langsam. Wenn der Antrieb dann abgeschaltet wird, stoppt unser Flugkörper nicht plötzlich, sondern fliegt mit der gleichen Geschwindigkeit weiter. Diese träge Steuerung und die lineare Steuerung lassen sich mit der Scroll-Machine verwirklichen.</p>

        <p>Da die lineare Steuerung besonders einfach ist, werden ihre Werte im JS-Befehl mit angegeben. Nämlich so:</p>

        <p class="noindent"><strong>← JS m,x,y,p</strong> (m = Joystickmodus, p = Port)<br>
            x und y stellen die Geschwindigkeiten der linearen Steuerung dar. Bei x = 8 und y = 0 hat man in etwa die Space-Invader-Einstellung.

        <p>Die träge Steuerung benötigt drei Befehle, was schon andeutet, daß sie etwas kompliziert ist. Hier bestimmt man nicht die Geschwindigkeit, sondern die Beschleunigung. Da vor jedem Trägheitsbefehl ein T steht, lautet der Befehl:</p>

        <p class="noindent"><strong>← TB x,y</strong></p>

        <p>x und y geben die X-Y-Beschleunigung an. Sie können Werte zwischen Null und 255 annehmen.</p>

        <p>Wenn man nun den Steuerknüppel in eine Richtung drückt, wird die Geschwindigkeit immer größer. Die größtmögliche Geschwindigkeit kann man mit dem TG-Befehl festlegen.</p>

        <p class="noindent"><strong>← TG x, y</strong></p>

        <p>Dies kann man sehr genau regeln, weil x und y Werte zwischen Null und 32767 annehmen können.</p>

        <p>Wenn man einen Gegenstand auf einer waagrechten Fläche beschleunigt, so hält dieser Gegenstand irgendwann auch wieder an. Daran ist die Reibung schuld. Das kann man auch simulieren, der Befehl lautet:</p>

        <p class="noindent"><strong>← TR x,y</strong><br>
            x und y müssen kleiner sein als die entsprechenden Werte beim TB-Befehl. Die Routine zieht x und y einfach von der Geschwindigkeit ab.</p>

        <p>Natürlich kann man die lineare und die träge Steuerung auch mischen. (Es muß vor jedem Befehl ein Pfeil stehen.)</p>

        <p>Zum Beispiel: Defender:←RS:←CP:←ZF 1:←US 1.</p>

        <p class="noindent">Diese Befehle setzen die Standardeinstellung.</p>

        <table class="plain">
            <tbody>
                <tr>
                    <td>← JS 2,0,8,2</td>
                    <td>m=2</td>
                    <td>mischen</td>
                </tr>
                <tr>
                    <td><br></td>
                    <td>x=0</td>
                    <td>keine lineare X-Steuerung</td>
                </tr>
                <tr>
                    <td><br></td>
                    <td>y=8</td>
                    <td>lineare Y-Steuerung, Geschwindigkeit 8</td>
                </tr>
                <tr>
                    <td><br></td>
                    <td>P=2</td>
                    <td>Port 2</td>
                </tr>
                <tr>
                    <td>←TB 16,0</td>
                    <td>x=16</td>
                    <td>X-Beschleunigung 16</td>
                </tr>
                <tr>
                    <td><br></td>
                    <td>y=0</td>
                    <td>keine Y-Beschleunigung</td>
                </tr>
                <tr>
                    <td>←TG 2000,0</td>
                    <td>x=2000</td>
                    <td>X-Geschwindigkeit höchstens 2000</td>
                </tr>
                <tr>
                    <td><br></td>
                    <td>y=0</td>
                    <td>Y-Geschwindigkeit 0 (hier unwichtig)</td>
                </tr>
                <tr>
                    <td>←TR 6,0</td>
                    <td>x=6</td>
                    <td>X-Reibung 6</td>
                </tr>
                <tr>
                    <td><br></td>
                    <td>V=0</td>
                    <td>Y-Reibunq 0 (auch unwichtig)</td>
                </tr>
                <tr><td colspan="3"><p>In diese Steuerung kann man auch noch Bewegung einmischen mit:</p></td></tr>
                <tr>
                    <td>←BW 0—8</td>
                    <td>x=0</td>
                    <td>keine X-Bewegung</td>
                </tr>
                <tr>
                    <td><br></td>
                    <td>y=-8</td>
                    <td>Mit Geschwindigkeit 8 nach oben.</td>
                </tr>
            </tbody>
        </table>

        <p>Ergebnis: Der Bildschirm bewegt sich kontinuierlich nach oben. Mit dem Joystick kann man die Y-Geschwindigkeit erhöhen oder vermindern.</p>

        <h2>Die Befehle</h2>

        <p>Vor jedem Befehl steht der Pfeil nach links. Die folgenden zwei Buchstaben stellen das Befehlswort dar. Danach muß man teilweise einige Parameter angeben, wie zum Beispiel beim normalen POKE-Befehl. Nach einer IF&hellip;THEN-Entscheidung muß nach dem THEN ein Doppelpunkt stehen, wenn ein Scroll-Machine-Befehl folgt, zum Beispiel IF A=1 THEN: ← RS. Wem der Pfeil nicht paßt, der kann mit POKE 50550,ASC(X$) ein anderes Zeichen auswählen. So wird nach POKE 50550,ASC("!") nur noch das Ausrufezeichen angenommen. Folgende Zeichen lassen sich verwenden: !";#$%&amp;'(),.:; sowie Klammeraffe, die eckigen Klammern, Pfund, PI, Pfeil links sowie fast alle Buchstaben:</p>

        <p>Damit man das Programm auch von Maschinensprache aus verwenden kann, habe ich jeweils die entsprechenden Adressen und gegebenenfalls auch die Einsprungadressen mit angegeben.</p>

        <p>Die Befehle:</p>

        <h3>RS</h3>

        <p>Reset. Dieser Befehl sollte am Anfang jedes Programms stehen. Er löscht alle Einstellungen und schaltet auf den Normalzustand, das heißt, er führt unter anderem folgende Befehle aus:
            <code>MT 40960,40,0: VI 52224,21
                ML: JSR $C5C0
            </code>
        </p>

        <h3>MT aa,xd,yd</h3>

        <p>Erstellt die Multiplikationstabelle, das heißt, man legt mit diesem Befehl die Anfangsadresse und die X- und Y-Ausdehnung des Pseudoschirms fest.</p>

        <p>aa = Anfangsadresse, xd = Ausdehnung des Schirms in X-Richtung, yd = Ausdehnung in Y-Richtung.</p>

        <p>Der normale Videoschirm hätte zum Beispiel die X- und Y-Werte 40 und 25. Die des Pseudoschirms können theoretisch zwischen Null und 8191 liegen.</p>

        <p>Die Y-Ausdehnung ist völlig unwichtig. Sie gehört jedoch der Vollständigkeit halber dazu, wird mitgespeichert und -geladen und kann über USR(12) abgefragt werden.</p>

        <p>Wenn der Schirm im Basic-RAM liegt (aa &lt; 40960), sollte man das Basic-Ende so herabsetzen:</p>

        <p><code>AA = Startadresse aa: H = INT(AA/256): L=AA-H*256: POKE 55,L: POKE 56,H: CLR
            ML: aa:$CBFA/CBFB, xd:$CBFC/CBFD, yd:$CBFE/CBFF, JSR $C6AC</code></p>

        <h3>CP</h3>

        <p>Kopiert den Zeichensatz vom ROM in das darunterliegende RAM. Erführt UT 53248, 55295, 53248,51,48 aus. Dieser Befehl sollte ebenfalls am Anfang eines Programms stehen, falls nicht ein neu definierter Zeichensatz mit dem LD-Befehl geladen wurde.
           <code> ML: JSR $C8BC</code>
        </p>

        <h3>US n</h3>

        <p>Umschalten zwischen Soft-Scroll (n=1) und Text (n=0). Bei n=0 werden alle Einstellungen des Textfensters gesetzt.
            <code>ML:LDX#n:JSR$C5F8</code>
        </p>

        <h3>ZFf</h3>

        <p>Dient zum Setzen der Zeichenfarbe f. Wenn man im Multicolormodus arbeitet, kann man nur die Farben Null bis Sieben nutzen und muß jeweils Acht dazuzählen (Bit 3 setzen).
            <code>ML : LDA #n: JSR $C8EB</code>
        </p>

        <h3>HF f1,f2,f3</h3>

        <p>Wählt die Hintergrundfarben der drei Bereiche.</p>

        <ul class="plain">
            <li>f1 = Hintergrundfarbe des Textfensters,</li>
            <li>f2 = Hintergrundfarbe des Streifens, f2 muß gleich der Zeichenfarbe sein, damit ein sauberer Übergang entsteht.</li>
            <li>f3 = Hintergrundfarbe des Soft-Scroll-Bereiches.</li>
        </ul>

        <p><code>ML: $C568/$C569/$C56A</code></p>

        <h3>RF f1,f2,f3</h3>

        <p>Die Randfarben können beliebig gewählt werden.
            <code>ML: $C56B/$C56C/$C56D</code>
        </p>

        <h3>PO x,y</h3>

        <p>Positioniert den Bildschirm innerhalb des Pseudoschirms, x und y können negativ und positiv sein.</p>

        <p>Sinnvoll sind jedoch nur 0 &lt; x &lt; xd*8 und 0 &lt; y &lt; yd*8.
            <code>ML: x:$0358/$0359, y:$035A/$035B</code>
        </p>

        <h3>BWx,y</h3>

        <p>Bewegt den Bildschirm in der angegebenen X- und Y-Geschwindigkeit. x und y können zwischen -127 und 128 liegen.
            <code>ML: x:$0385, y:$0386</code>
        </p>

        <h3>JS m,x,y,p</h3>

        <p>Bestimmt die Werte für den Joystick.</p>

        <ul class="plain">
            <li>m = Modus.
            <ul class="plain">
                <li>Bei m=0 keine Steuerung.</li>
                <li>Bei m=1 lineare Steuerung.</li>
                <li>Bei m=2 lineare und träge Steuerung.</li>
            </ul></li>
            <li>x und y geben die Geschwindigkeit der linearen Steuerung an. Sie kann zwischen 0 und 255 liegen.</li>
            <li>p steht für den Joystickport.</li>
        </ul>

        <p class="noindent">Die letzten drei Angaben können weggelassen werden.</p>

        <p><code>ML: n:$033E, x:$0374, y:$0375, p:$03A5</code></p>

        <p>Zur trägen Steuerung gibt es drei Befehle. Sie bewirken nur etwas, wenn der Joystickmodus zwei gewählt wurde. Der erste Buchstabe lautet immer »T«.</p>

        <h3>TB x,y</h3>

        <p>Regelt die Beschleunigung, x und y kann zwischen 0 und 255 liegen.
            <code>ML: x:$034A, y:$034B</code>
        </p>

        <h3>TR x,y</h3>

        <p>Bestimmt die Reibung, x und y sind auch hier 1-Byte-Werte.
            <code>ML: x:$0392, y:$0393</code>
        </p>

        <h3>TG x,y</h3>

        <p>Legt die Höchstgeschwindigkeit fest, x und y sind hier 2-Byte-Werte, sie können also Werte zwischen 0 und 65535 annehmen.
            <code>ML: x:$038E/$038F, y:$0390/$0391</code>
        </p>

        <p>Die nachfolgenden Befehle sind allgemeingültig:</p>

        <h3>GR x,x2,y,y2</h3>

        <p>Die hier festgelegten Grenzen können nicht überschritten werden. Die Werte können wie beim PO-Befehl zwischen 0 und 65535 liegen.
            <code>ML x:$0396/$0397, x2:$0398/$0399, y:$039A/$039B, y2:$039C/$039D</code>
        </p>

        <h3>GM m</h3>

        <p>Der Grenzmodus wird gewählt: Bei m=O bestehen keine Grenzen. Bei m=1 wird bei den Grenzen abgestoppt. Bei m=2 wird der Bildschirm an die gegenüberliegende Grenze gesetzt.
            <code>ML: m:$039E</code>
        </p>

        <h3>AS n</h3>

        <p>Läßt den Interrupt n mal aussetzen, bevor er wieder ausgeführt wird. Das ist besonders nützlich, wenn man Rechenzeit sparen will.</p>

        <p>Nachteil: Je größer n ist, desto stärker ruckt das Bild.
            <code>ML: LDX #n: JSR $C78D</code>
        </p>

        <h3>TM m</h3>

        <p>Wählt den »Tastmodus«. Bei m=0 wird der Pseudoschirm nur abgetastet, wenn es nötig ist.</p>

        <p>Bei m=1 wird er immer abgetastet (= jede 50stel Sekunde), was natürlich Rechenzeit kostet.</p>

        <p>Nützlich, wenn im Pseudoschirm laufend etwas verändert wird. Ein Beispiel: RS:CP:ZF 1:MT 1024,40,25:PO O,O:TM 1:US 1
            <code>PRINT "&lt;HO&gt;"</code>
        </p>

        <p>Ergebnis: Der blinkende Cursor erscheint doppelt auf dem Schirm. Der zweite Cursor macht alle Bewegungen mit. Wenn man TM 0 eingibt, ändert sich das.
            <code>ML: m:$03A2</code>
        </p>

        <h3>SY n</h3>

        <p>Synchronisiert die Scroll-Machine mit dem laufenden Programm, das heißt, der Interrupt wird nicht mehr im 50stel-Sekunden-Takt ausgeführt, sondern im Programmtakt.</p>

        <ul class="plain">
            <li>n=1 schaltet Sync-Modus ein und führt den nächsten Interrupt aus.</li>
            <li>n=0 schaltet den Sync-Modus aus.</li>
        </ul>

        <p>Diese Funktion ist wichtig bei langsamen Basic-Programmen wie dem Editor. Achtung: Die X/Y-Position wird erst beim darauffolgenden SY 1-Befehl gesetzt.
            <code>ML: LDX #n: JSR $C88C</code>
        </p>

        <h3>VI aa,z</h3>

        <p>Verlegt das Video-RAM, in das geschrieben wird.<br>
            aa = neue Anfangsadresse, z = Anzahl der Zeilen (z &lt; = 21). Normal: aa= 52224, z=21. Je kleiner z ist, desto schneller wird das Programm.</p>

        <p>ML: aa:$C4D9/$C4DA, LDX #z: JSR $C7AE</p>

        <h3>1R n1,n2,n3</h3>

        <p>Inhalt des 1. Steuerregisters (VIC+17) in den drei Bereichen. Normal: 27,23,16
            <code>ML: $C55C/$C55D/$C55E</code>
        </p>

        <h3>2R n1,n2,n3</h3>

        <p>Der entsprechende Befehl für das 2. Steuerregister (VIC+22). Normal: 200,200,192
            <code>ML: $C55F/$C560/$C561</code>
        </p>

        <h3>MC n1,n2,n3</h3>

        <p>Dasselbe für das Memory-Control-Register (VIC+24). Normal: 21,52,52
            <code>ML: $C562/$C563/$C564</code>
        </p>

        <h3>CI n1,n2,n3</h3>

        <p>Das Gleiche gilt für die Basisadresse der CIA 2 (56576). Normal: 151,148,148
            <code>ML: $C565/$C566/$C567</code>
        </p>

        <h3>RZ z1,z2,z3</h3>

        <p>Legt die Rasterzeilen für die drei Interrupts fest. Normal: 81,88,248 andere Möglichkeit: 106,115,232 + SU 4
            <code>ML: $C56E/$C56F/$C570</code>
        </p>

        <h3>SU n</h3>

        <p>Behebt Fehler, die bei der Änderung der Rasterzeilen entstehen können. Das erkennt man am Rucken des Scrollings, n kann Werte von 0 bis 7 annehmen.</p>

        <p class="noindent">Den richtigen Wert kann man nur durch Ausprobieren feststellen.</p>

        <p class="noindent">Wenig Probleme wird man haben, wenn man die RZ-Werte in Achterschritten verändert. Normal: n=5</p>

        <p><code>ML: n:$C571</code></p>

        <p>Die folgenden zwei Befehle sind als allgemeine Hilfe gedacht:</p>

        <h3>FU a,e,n,w</h3>

        <p>Dieser Befehl füllt den Speicher von a bis e mit n, während in der Speicherstelle 1 w steht, w kann weggelassen werden.
            <code>ML: a:$FB/$FC, e:$FD/$FE, n:$03B0, LDX #w: JSR $C842</code>
        </p>

        <h3>UT a,e,a2,r,w</h3>

        <p>Es wird der Block von a bis e nach a2 übertragen. Dabei steht in 1 während des Lesens r und während des Schreibens w.
            <code>ML: a:$FB/$FC, e:$03A6/$03A7, a2:$FD/$FE,
            LDA #r : LDX #w : JSR $C725</code>
        </p>

        <p>Natürlich kann man die Erweiterung auch ausschalten:</p>

        <h3>OF</h3>

        <p>Schaltet die Erweiterung vollständig ab. Sie muß mit SYS49152 wieder gestartet werden. Die Wirkung ähnelt der der Run-Stop/Restore-Funktion.</p>

        <p>Dieser Befehl wird zum Beispiel dann benötigt, wenn man etwas von der Datasette laden will.
            <code>ML: JSR $C65E</code>
        </p>

        <h2>Die Diskettenbefehle</h2>

        <h3>LD "Name"</h3>

        <p>Lädt den Pseudoschirm mit der Bezeichnung Name von der Diskette. Die Anfangsadresse, die X-Ausdehnung und die Y-Ausdehnung werden mitgeladen und gesetzt.</p>

        <table class="plain">
            <tr>
                <td>ML:</td>
                <td><code>LDA #0 : STA $CBF8
                        LDX # &lt; Namenadr. : LDY # &gt; Namenadr. : LDA # Namenlänge
                        JSR $FFBD (Setnam-Routine)
                        JSR $CAC8
                    </code>
                </td>
            </tr>
        </table>

        <h3>LD "Name",aa</h3>

        <p>Lädt ein beliebiges Datenfile absolut an die Adresse aa von der Diskette. Achtung: Das File wird vollständig geladen, inklusive den beiden Adreßbytes am Anfang jedes Programms. Man sollte deshalb von aa zwei abziehen.</p>

        <p>Wenn man sequentielle Files oder Userfiles laden will, dann hängt man an den Namen einfach noch ,S oder ,U an.
            <code>ML: aa:$FB/$FC, LDA #1 : STA $CBF8</code>
        </p>

        <p>Ansonsten weiter wie oben.</p>

        <h3>SV "Name",ea</h3>

        <p>Speichert einen Pseudoschirm mit der Bezeichnung »Name« auf Diskette. Die Endadresse ea errechnet sich aus Anfangsadresse + X-Ausdehnung * Y-Ausdehnung.
            <code>ML: ea:$FD/$FE</code>
        </p>

        <p>LDX # &lt; Namenadr. LDY # &gt; Namenadr. LDA # Namenlänge</p>

        <p>JSR $FFBD (Setnam-Routine)</p>

        <p>JSR $CB3E</p>

        <h2>Die USR(x)-Funktion</h2>

        <p>Mit ihrer Hilfe kann sich der Benutzer einige wichtige Werte holen. Je nachdem, welchen Wert x annimmt, wird zu verschiedenen Routinen verzweigt.</p>

        <table class="plain">
            <tr><td><b>x=0</b></td><td>Jedesmal, wenn eine Grenze berührt wird, die mit dem GR-Befehl gesetzt wurde, setzt das Programm ein Flag auf eins. Mit dieser Funktion wird das Flag abgefragt und gelöscht.<code>ML: $03AD</code></td></tr>
            <tr><td><b>x=1</b></td><td>Liefert die momentane X-Position.<code>ML $0358/$0359</code></td></tr>
            <tr><td><b>x=2</b></td><td>Liefert die Y-Position.<code>ML: $035A/$035B</code></td></tr>
            <tr><td><b>x=3</b></td><td>Gibt die Adresse im Pseudoschirm an, die der Bildmitte entspricht.<code>ML: $C50C/$C50D</code></td></tr>
            <tr><td><b>x=4</b></td><td>Ergibt eins, wenn der Feuerknopf des Joysticks in Port 2 gedrückt ist.<br>ML: Es empfiehlt sich der normale Joystickport $DC00.</td></tr>
            <tr><td><b>x=5</b></td><td>Dasselbe für Port 1.<code>ML: $DC01</code></td></tr>
            <tr><td><b>x=10</b></td><td>Übermittelt die Anfangsadresse des Pseudoschirms (die möglicherweise nicht bekannt ist, weil der Schirm eben geladen wurde).<code>ML: $CBFA/$CBFB</code></td></tr>
            <tr><td><b>x=11</b></td><td>Liefert die X-Ausdehnung.<code>ML: $CBFC/$CBFD</code></td></tr>
            <tr><td><b>x=12</b></td><td>Liefert die Y-Ausdehnung.<code>ML: $CBFE/$CBFF</code></td></tr>
            <tr><td><b>x>255</b></td><td>Übermittelt den Inhalt der Speicherstelle x. Es wird immer der Inhalt des RAMs gelesen. Man hat damit also die Möglichkeit, das versteckte RAM zu lesen.<br>ML: Die allgemeine Methode funktioniert so:<code>SEI: LDX #48:STX 1:LDA x:LDX #55:STX 1:CLI</code></td></tr>
        </table>

        <p>Übrigens: In $036A/$036B (874/875) und $036C/$036D (876/877) stehen die X- und Y-Werte für die Trägheitsgeschwindigkeit.</p>

        <h2>Der Pseudoschirmeditor</h2>

        <p>Der Editor ist ein Basic-Programm, das mit den wichtigsten Funktionen zur komfortablen Erstellung eines Pseudoschirms ausgestattet ist.</p>

        <p>Er benötigt die Scroll-Machine, um arbeiten zu können. Man muß sie also von Datasette oder Diskette laden. Dann lädt man den Editor und startet ihn mit RUN.</p>

        <p>Zuerst wird man nach der X/Y-Ausdehnung und der Anfangsadresse gefragt. Die Werte XD=128, YD=64 und AA=40960 sind vorgegeben, so daß der Pseudoschirm das RAM unter dem Basic-ROM voll belegt ($A000 — $BFFF). In diesem Fall ist RETURN zu drücken. Dann will das Programm wissen, ob der Zeichensatz vom ROM ins RAM kopiert werden soll. Wenn man das Programm eben erst geladen hat, sollte man mit »J« antworten. Steht jedoch schon ein neuer Zeichensatz, der erhalten werden soll, im Speicher, so gibt man »N« ein. Anschließend erscheint die Frage »MULTICOLOR (J/N)« auf dem Bildschirm. Wenn der normale Commodore-Zeichensatz benutzt wird, lautet die Antwort immer »N«, ansonsten hängt das vom Zeichensatz ab. Natürlich muß man auch noch die Farben eingeben, wenn man nur Return drückt, erhält man die Standardeinstellung. Schließlich kann man entscheiden, ob der Pseudoschirm gelöscht werden soll. Normalerweise antwortet man mit »J« und der Pseudoschirm wird nach einer Rückversicherung mit dem Zeichen 32 (Space) gefüllt.</p>

        <p>Nach diesen Eingaben hat man endlich das normale Bild des Editors vor sich, das folgendermaßen aufgebaut ist:</p>

        <p>Der Bildschirm ist in zwei Bereiche unterteilt. Oben wird immer der Teil des Pseudoschirms gezeigt, der gerade bearbeitet wird. In der Mitte dieses Bereiches befindet sich ein Sprite, der als Cursor fungiert. Der Bildschirm läßt sich mit Hilfe eines Joysticks in Port zwei bewegen. Unten kann man den kompletten C 64-Zeichensatz erkennen. Er ist in acht Zeilen à 32 Zeichen unterteilt, wie bei vielen Zeichengeneratorprogrammen. Es wird der große Zeichensatz benützt, weil er mehr Grafikzeichen zur Verfügung stellt. Auch hier wird ein Sprite als Cursor benutzt, der sich mit den Cursortasten auf der Zeichenpalette bewegen läßt.</p>

        <p>Im Normalmodus wird durch einen Druck auf den Joystickknopf jeweils das Zeichen von der Palette auf den Pseudoschirm übertragen, auf das der Zeichencursor zeigt.</p>

        <p>Das ist die einfachste Funktion des Programms, mit ihr allein ist es jedoch fast unmöglich, einen Pseudoschirm zu erstellen. Deshalb bietet es noch einige andere Möglichkeiten wie Rechteck füllen, Rechteck übertragen und so weiter, die man von Programmen wie Paint Magic oder Koalapainter her kennt. Sie bedürfen keiner langen Erklärung, da die Bedienung einfach und logisch aufgebaut ist.</p>

        <p>Auch der Mikromodus ist schnell erklärt. Er benutzt die Zeichen 32, 97, 98, 108, 123, 124, 126, 127 und ihre reversen Entsprechungen, um eine vierfache Auflösung zu erreichen. Mit dem Klammeraffen kann man zwischen Punkt löschen und Punkt setzen umschalten. Mit Shift-M kann man die Zeichenfolge neu definieren. Wenn man einen selbstdefinierten Zeichensatz benutzt, stimmen die Codes 97, 98, 108 etc. nicht mehr. Der Einfachheit halber müssen die neuen Zeichen aufeinanderfolgen, mit Leerraum (=Space) beginnen und mit einem vollständig gefüllten Zeichen enden. Eine nicht ganz einfache Funktion ist der Konturmodus, der im folgenden näher erläutert wird.</p>

        <p>Mit den Zeichen 100, 111, 121, 98 und so weiter, kann man eine sanft aufsteigende Linie bilden. Das wird im Konturmodus ausgenutzt. Wenn man F7 betätigt, wird dieser Modus gesetzt. Jetzt kann man Landschaften formen, die sanft auf- und absteigen. Jedoch kann man keine Höhlendecken oder ähnliches bilden, auch senkrechte Wände bleiben einem versagt. Das kann man mit einem Druck auf »K« ändern. Man wird nach X+, X—, Y+, Y— gefragt. Mit den Tasten 1-4 kann man die gewünschte Einstellung wählen. X bedeutet senkrechte Wände, Y steht für waagrechte Wände. Plus und Minus geben jeweils an, welche Seite Freiraum und welche Wand ist. Anschließend muß man noch die Geschwindigkeit angeben, die regelt, ob der Berg sanft oder steil ansteigt.</p>

        <p>Wenn man senkrechte Wände bearbeitet, wird man feststellen, daß die Kontur fehlerhaft ist. Das liegt am Zeichensatz des C 64. Die Zeichen 101 und 116 sind identisch, was von Commodore so geregelt wurde, damit das Zeichen auf einem Fernsehschirm besser sichtbar ist. Mit einem VC 20-Zeichensatz hätten wir diese Probleme nicht. Wenn man einen eigenen Zeichensatz benutzt, ist das Problem auch gelöst. Denn wie beim Mikromodus gibt es hier ebenfalls die Möglichkeit, das Programm an den eigenen Zeichensatz anzupassen.</p>

        <p>Mit SHIFT-K ruft man die entsprechende Routine auf. Man benötigt vier Zeichenfolgen. Jeweils eine für X+, X—, Y+, Y— Mit 1-4 kann man wählen, welche man neu definieren will. Jede Zeichenfolge muß aus acht Zeichen bestehen, von denen das erste Space (32) oder das letzte Revers-Space (160) ist. Man steuert mit den Cursortasten auf das erste Zeichen und drückt dann RETURN. Nun muß man sich für +1 oder —1 entscheiden. Hier hilft nur ausprobieren. Dann gibt man nur noch die Geschwindigkeit an und die neue Zeichenfolge ist im Speicher.</p>

        <p>Ein Pseudoschirm muß auch abgespeichert und geladen werden können, was man mit F1 und F3 erreichen kann. Die Scroll-Machine enthält bereits Routinen, um einen Pseudoschirm aus irgendeinem Speicherbereich auf Diskette Gerätenummer 8 abzuspeichern und in den gleichen Bereich wieder zu laden. Für die Datasette existiert jedoch kein Befehl, so daß man dafür die ROM-Routinen verwenden muß. Deshalb kann man mit der Datasette nur das Basic-RAM benutzen, da sich die Bereiche von 40960 bis 49151 und 57344 bis 65535 von den ROM-Routinen nicht auslesen lassen. Man kann jedoch einen Pseudoschirm in das Basic-RAM laden, um ihn dann mit dem UT-Befehl in das versteckte RAM zu schieben. Wenn man einen Pseudoschirm mit dem eigenen Programm von Kassette laden will, muß man das Unterprogramm des Editors verwenden (<a href="#fehlerteufelchen" class="fehlerteufelchen_link">ab Zeile 17&thinsp;500)</a>. Der Wechselmodus wird mit »W« aktiviert und mit SHIFT-W definiert. Man kann einen Bereich von Zeichen festlegen, die dann zyklisch wiederholt verwendet werden. Nützlich ist dies für flächige Felsstrukturen oder ähnliches. Denn wenn man den ganzen Bereich mit dem gleichen Zeichen gestaltet, wird die Struktur regelmäßig und sieht nicht echt aus.</p>

        <p>Aus allen Modi kommt man wieder heraus, indem man den Pfeil nach links drückt. Dadurch wird der Editor wieder in den Normalzustand zurückgesetzt.</p>

        <p>Zum Editor ist damit alles Wichtige gesagt. Abtippen muß man ihn wie jedes andere Programm, die REM- und Doppelpunkt-Zeilen werden jedoch nicht angesprungen, deshalb können sie weggelassen werden.</p>

        <p>Die Befehlsliste gibt Auskunft über die restlichen Funktionen und deren Handhabung.</p>

        <p>Ich hoffe, daß das Programm möglichst fehlerlos ist und wünsche Ihnen viel Spaß damit.</p>

        <p>Um die Fähigkeiten von »Scroll-Machine« aufzuzeigen, soll auch gleich ein kleines Beispielprogramm angeführt werden. Da man es niemandem zumuten kann, einen Pseudoschirm von 8 KByte oder mehr abzutippen, muß sich das Spiel den Schirm selbst aufbauen. Daß darunter die Qualität der Grafik leidet ist klar. Außerdem habe ich keinen neudefinierten Zeichensatz verwendet, sondern nur die Commodore-Zeichen Space (32), lnvers-Space (160) und lnvers-Shift-0 (207). Der Pseudoschirm besitzt nur eine Auflösung von 128 x 64, was genau 8 KByte entspricht. Eigene Schirme sollte man größer machen — etwa 20 bis 30 KByte — und wenn möglich mit einem eigenen Zeichensatz versehen.</p>

        <h2>Atomdepot, ein Demoprogramm zur Scroll-Machine</h2>

        <p>Doch dieses Spiel ist trotzdem ein gutes Beispiel dafür, wie man die Scroll-Machine benutzt.</p>

        <p>Der Handlungsort ist ein Bergwerksstollen in nicht allzu ferner Zukunft, in dem noch drei Atommüllfässer lagern. Sinn des Spiels ist es, die drei Fässer von der hinteren Kammer in die vordere zu bringen, von wo sie abtransportiert werden können. Der Greifer des Transporters wird mit dem Feuerknopf des Joysticks (Port 2) bedient, doch erst dann, wenn Greifarme punktgenau am Faß anliegen. Ebenso vorsichtig muß man es auf den Boden stellen. In einem engen Stollen ist der Transport nicht einfach, doch mit genügend Geduld und etwas Übung ist auch das kein Problem.</p>

        <address class="author">(Thilo Herrmann/ah)</address>

        <figure>
            <table class="plain nobreak0">
                <tbody>
                    <tr>
                        <td><b>Ziffern 1 bis 9</b></td>
                        <td>Regeln die Geschwindigkeit des Cursors. Die Geschwindigkeit Eins ist normal.</td>
                    </tr>
                    <tr>
                        <td><b>Space</b></td>
                        <td>Auf den Schnellgang schalten.</td>
                    </tr>
                    <tr>
                        <td><b>Pfeil links</b></td>
                        <td>Den Editor auf den Normalmodus setzen.</td>
                    </tr>
                    <tr>
                        <td><b>CRSR-Tasten</b></td>
                        <td>Mit ihnen kann man den Zeichencursor auf der Palette bewegen, um ein Zeichen auszuwählen.</td>
                    </tr>
                    <tr>
                        <td><b>DEL</b></td>
                        <td>Loschen des Zeichens unter dem Cursor.</td>
                    </tr>
                    <tr>
                        <td><b>HOME</b></td>
                        <td>Setzen des Zeichencursors auf das Leerzeichen.</td>
                    </tr>
                    <tr>
                        <td><b>L</b></td>
                        <td>Löschen des Pseudoschirms.</td>
                    </tr>
                    <tr>
                        <td><b>F</b></td>
                        <td>Farben neu bestimmen.</td>
                    </tr>
                    <tr>
                        <td><b>C</b></td>
                        <td>Zeichensatz kopieren.</td>
                    </tr>
                    <tr>
                        <td><b>Z</b></td>
                        <td>Zeichensatz laden.</td>
                    </tr>
                    <tr>
                        <td><b>F1</b></td>
                        <td>Abspeichern eines Pseudoschirms auf Disk oder Datasette.</td>
                    </tr>
                    <tr>
                        <td><b>F3</b></td>
                        <td>Laden eines Pseudoschirms von Disk oder Datasette.</td>
                    </tr>
                    <tr>
                        <td><b>M</b></td>
                        <td>Mikromodus einschalten.</td>
                    </tr>
                    <tr>
                        <td><b>SHIFT-M</b></td>
                        <td>Mikromodus neu definieren.</td>
                    </tr>
                    <tr>
                        <td><b>Klammeraffe</b></td>
                        <td>Umschalten des Mikromodes zwischen Punkt setzen und Punkt löschen.</td>
                    </tr>
                    <tr>
                        <td><b>F7</b></td>
                        <td>Konturmodus einschalten.</td>
                    </tr>
                    <tr>
                        <td><b>K</b></td>
                        <td>Kontur und Geschwindigkeit wählen.</td>
                    </tr>
                    <tr>
                        <td><b>SHIFT-K</b></td>
                        <td>Kontur neu definieren. Das erste Zeichen wird mit den Cursortasten ausgewählt und mit Return festge- legt</td>
                    </tr>
                    <tr>
                        <td><b>Pfeil oben</b></td>
                        <td>Kontur- und Mikromodus zurücksetzen.</td>
                    </tr>
                    <tr>
                        <td><b>W</b></td>
                        <td>Wechselmodus einschalten.</td>
                    </tr>
                    <tr>
                        <td><b>SHIFT-W</b></td>
                        <td>Wechselnde Zeichen neu definieren.<br>
                            Die Zeichen kann man mit den Cursortasten auswählen und mit Return festlegen.</td>
                    </tr>
                    <tr>
                        <td><b>U</b></td>
                        <td>Mehrere zusammenhängende Zeichen von der Palette übertragen. Exit mit Return.</td>
                    </tr>
                    <tr>
                        <td><b>S</b></td>
                        <td>Mit der Tastatur direkt auf den Schirm nach Art einer Schreibmaschine schreiben.<br>
                            Steuertasten: RVS ON, RVS OFF, DEL, Cursortasten, RETURN. Exit mit F7.</td>
                    </tr>
                    <tr>
                        <td><b>R</b></td>
                        <td>Rechteck mit einem beliebigen Zeichen füllen. Der Punkt an dem sich der Cursor gerade befindet, wird nun als Eckpunkt betrachtet. Den gegenüberliegenden Eckpunkt wählt man mit dem Joystick und abschließendem Knopfdruck. Das Zeichen, mit dem das Rechteck ausgefüllt wird, ist durch den Zeichencursor auf der Palette festgelegt. Benutzung des Schnellgangs ist möglich. Abbruch mit Pfeil links.</td>
                    </tr>
                    <tr>
                        <td><b>T</b></td>
                        <td>Rechteck übertragen. Der momentane Ort des Cursors wird als Ecke des Rechtecks angesehen. Die diagonal gegenüberliegende Ecke wird durch Bewegung des Cursors mit dem Joystick an die entsprechende Stelle festgelegt.<br>
                            Anschließend legt man auf die gleiche Weise die linke obere Ecke der Kopie fest.<br>
                            Eine Benutzung des Schnellgangs ist ebenfalls möglich. Abbruch mit Pfeil links.</td>
                    </tr>
                    <tr>
                        <td><b>A</b></td>
                        <td>Ändern der X/Y-Ausdehnung und der Anfangsadresse. Wenn man auf die der Eingabe folgende Frage mit »J« antwortet, wird der komplette Pseudoschirm an die neue Anfangsadresse kopiert und vollständig umformatiert. Die dafür benötigte Zeit hängt maßgeblich von der Y-Ausdehnung ab.</td>
                    </tr>
                    <tr>
                        <td><b>CTRL-X</b></td>
                        <td>Verlassen des Programms.</td>
                    </tr>
                </tbody>
            </table>
            <figcaption>Tabelle 1. Zusammenfassung der Editorbefehle</figcaption>
        </figure>

        <figure>
            <pre data-filename="scroll-machine.prg" data-name="Scroll-Machine" data-mse=mse1></pre>
            <figcaption>Listing 1. Hauptprogramm »Scroll-Machine«. Das Programm ist mit dem MSE einzugeben.</figcaption>
        </figure>
        <figure>
            <pre data-filename="scroll-editor" data-name="Scroll-Machine Editor"></pre>
            <figcaption>Listing 2. Editor »Scroll-Machine«. Zur sicheren Eingabe verwenden Sie bitte den Checksummer.</figcaption>
        </figure>

        <!-- Von der Programmservicediskette, nicht im Heft -->
        <pre style="display: none;" data-filename="demo i" data-name="Demo I"></pre>
        <div class="binary_download" data-filename="pseudo i.prg" data-name="Pseudo I"></div>
        <div class="binary_download" data-filename="zeichensatz.prg" data-name="Zeichensatz"></div>
        <div class="binary_download" data-filename="sprites.prg" data-name="Sprites"></div>
        <pre style="display: none;" data-filename="demo ii" data-name="Demo II"></pre>
        <div class="binary_download" data-filename="pseudo ii.prg" data-name="Pseudo II"></div>

        <figure>
            <pre data-filename="spiel" data-name="Spiel als Demoprogramm"></pre>
            <figcaption>Listing 3. Ein kleines Spiel als Demoprogramm</figcaption>
        </figure>

        <aside class="fehlerteufelchen" id="fehlerteufelchen">
            <h2>Fehlerteufelchen</h2>
        
            <p>Um Pseudoschirme auf Kassette zu speichern beziehungsweise von der Kassette zu laden ist nicht die Zeile 17500 sondern die Zeile 3940 beziehungsweise 4170 anzuspringen.</p>
        
            <!-- 64'er 11/1985 -->
        </aside>

    </article>
</body>

</html>
